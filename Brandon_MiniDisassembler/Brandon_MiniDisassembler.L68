00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 2/26/2014 5:07:00 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :Brandon's Mini Disassembler
00000000                             3  * Written by :Brandon Roth
00000000                             4  * Date       :2/23/2014
00000000                             5  * Description:Disassembles and stuff!
00000000                             6  *-----------------------------------------------------------
00001000                             7  START   ORG     $1000
00001000                             8  
00001000  43F9 0000103C              9          LEA     MESSAGE,A1      Loads MESSAGE into address register A1
00001006  103C 000E                 10          MOVE.B  #14,D0          Moves the number 14 into data register D0
0000100A  4E4F                      11          TRAP    #15             Displays Message
0000100C                            12          
0000100C                            13  *-----------------------------------------------------------        
0000100C                            14  * Start of Mini Disassembler
0000100C                            15  *-----------------------------------------------------------        
0000100C                            16  
0000100C  =00007FC0                 17  START2  EQU $00007FC0
0000100C  =00000004                 18  NOPOP   EQU $04   *Store as byte, but I really only care about first 4 bits
0000100C                            19  *MOVEOP  EQU %00 *First two bits of move are always 00
0000100C                            20          
0000100C                            21          *Load starting location of test input file into A0
0000100C  207C 00007FC0             22          MOVEA.L #START2,A0  
00001012                            23          *Move byte data at (A0) into D0. D0 is now the first 8 bits of the first
00001012                            24          *OP instruction from the test input file
00001012  1010                      25          MOVE.B  (A0),D0
00001014                            26          *Clear the first 4 bits from 8 bit value in D0. I am doing this so we retain
00001014                            27          *just the last 4 bits. These LAST 4 bits are FIRST 4 bits the of the first OP
00001014                            28          *CODE. By using only the first 4 bits of an instruction, we can begin to
00001014                            29          *narrow down which particular OP code the instruction actually is!
00001014  0880 0000                 30          BCLR.L  #$00,D0 
00001018  0880 0001                 31          BCLR.L  #$01,D0
0000101C  0880 0002                 32          BCLR.L  #$02,D0
00001020  0880 0003                 33          BCLR.L  #$03,D0
00001024                            34          *Now I need to shift these 4 bit values right by 4 bits, so that these 4 bits
00001024                            35          *are in the LSB position. Then I can begin to compare this value with others 
00001024                            36          *and start decoding this OP CODE.
00001024  E848                      37          LSR.W   #$04,D0
00001026                            38          *Now I know the order in which the opcodes will appear, but later I will
00001026                            39          *need to keep loading opcode data into some register and testing until we
00001026                            40          *find a hit with the first four bits. then JSR into some subroutine.   
00001026                            41  
00001026                            42  *Decode a NOP OP--------------------------------------------
00001026  123C 0004                 43          MOVE.B  #NOPOP,D1  *Load the first 4 bits (really a byte) of NOP into D1
0000102A                            44          *Compare the first 4 bits of the first OP CODE with first 4 of NOP. 
0000102A                            45          *If equal we have a NOP instruction. branch to 'ISNOP' and decode the rest
0000102A  B200                      46          CMP.B   D0,D1
0000102C  6700 0002                 47          BEQ     ISNOP
00001030                            48          
00001030                            49  *Decode a MOVE OP-------------------------------------------
00001030                            50          *MOVE.B  (A0),D0     *Move the byte data at A0 into D0 (**i really want only 4 bits...)
00001030                            51          
00001030                            52  *Branch to correct OP-------------------------------------------        
00001030                            53  ISNOP   
00001030  =00000E71                 54  NOPBODY EQU $0E71   *The rest of the NOP instruction equals this hex value
00001030  3010                      55          MOVE.W  (A0),D0
00001032  323C 0E71                 56          MOVE.W  #NOPBODY,D1
00001036                            57          
00001036                            58  *ISMOVE  *is a move instruction, try to decode rest. need a jsr or something to get here?
00001036                            59          
00001036                            60  *-----------------------------------------------------------        
00001036                            61  * End of Mini Disassembler
00001036                            62  *-----------------------------------------------------------    
00001036                            63          
00001036  103C 0009                 64  THEEND  MOVE.B  #9,D0
0000103A  4E4F                      65          TRAP    #15             Halt Simulator        
0000103C                            66          
0000103C  =0000000D                 67  CR      EQU     $0D             ASCII code for Carriage Return
0000103C  =0000000A                 68  LF      EQU     $0A             ASCII code for Line Feed
0000103C= 48 65 79 2C 20 67 ...     69  MESSAGE DC.B    'Hey, going to try to disassemble MOVE.B',CR,LF,0
00001066                            70          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
CR                  D
ISNOP               1030
LF                  A
MESSAGE             103C
NOPBODY             E71
NOPOP               4
START               1000
START2              7FC0
THEEND              1036
