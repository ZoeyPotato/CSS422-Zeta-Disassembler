00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 2/27/2014 1:40:22 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :Brandon's Mini Disassembler
00000000                             3  * Written by :Brandon Roth
00000000                             4  * Date       :2/23/2014
00000000                             5  * Description:Disassembles and stuff!
00000000                             6  *-----------------------------------------------------------
00001000                             7  START   ORG $1000   *Start program at provided location
00001000  =00007FC0                  8  ST_ADDR EQU $7FC0   *Starting address of input test file
00001000  =00007000                  9  STACK   EQU $7000   *Stack location
00001000                            10  
00001000  307C 7FC0                 11          MOVEA.W #ST_ADDR,A0 *Load starting location of test input file into A0
00001004  43F9 00001068             12          LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100A  103C 000E                 13          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000100E  4E4F                      14          TRAP    #15         *Displays Message
00001010                            15          
00001010                            16  *-----------------------------------------------------------        
00001010                            17  * Start of Mini Disassembler
00001010                            18  *-----------------------------------------------------------        
00001010                            19  
00001010                            20  GRAB_NEXT_OP
00001010                            21          *Move byte data at (A0) into D0. D0 is now the first 8 bits of the first
00001010                            22          *OP instruction from the test input file
00001010  4280                      23          CLR.L   D0
00001012  1010                      24          MOVE.B  (A0),D0
00001014                            25          *Clear the first 4 bits from 8 bit value in D0. I am doing this so we retain
00001014                            26          *just the last 4 bits. These LAST 4 bits are FIRST 4 bits the of the first OP
00001014                            27          *CODE. By using only the first 4 bits of an instruction, we can begin to
00001014                            28          *narrow down which particular OP code the instruction actually is!
00001014  0880 0000                 29          BCLR.L  #$00,D0 
00001018  0880 0001                 30          BCLR.L  #$01,D0
0000101C  0880 0002                 31          BCLR.L  #$02,D0
00001020  0880 0003                 32          BCLR.L  #$03,D0
00001024                            33          *Now I need to shift these 4 bit values right by 4 bits, so that these 4 bits
00001024                            34          *are in the LSB position. Then I can begin to compare this value with others 
00001024                            35          *and start decoding this OP CODE.
00001024  E848                      36          LSR.W   #$04,D0
00001026                            37          *Now try to figure out what OP CODE this is using these 4 bits.        
00001026                            38          *Later I will not try to go directly to op codes, but to a 'category' of
00001026                            39          *potential codes it could be (since many share the same first 4 bits).
00001026                            40  
00001026                            41  *Decode a NOP OP--------------------------------------------
00001026  =00000004                 42  NOP_OP  EQU $04 *Store as byte, but I really only care about first 4 bits
00001026                            43  
00001026  123C 0004                 44          MOVE.B  #NOP_OP,D1  *Load the first 4 bits (really a byte) of NOP into D1
0000102A                            45          *Compare the first 4 bits of the first OP CODE with first 4 of NOP. 
0000102A                            46          *If equal we have a NOP instruction. Branch to 'ISNOP' and decode the rest.
0000102A  B200                      47          CMP.B   D0,D1
0000102C  6700 0006                 48          BEQ     ISNOP
00001030                            49          
00001030                            50  *Decode a MOVE OP-------------------------------------------
00001030                            51  *MOVEOP EQU %00 *First two bits of move are always 00
00001030                            52          *MOVE.B  (A0),D0     *Move the byte data at A0 into D0 (**i really want only 4 bits...)
00001030                            53          
00001030                            54          
00001030                            55          *We didn't find a valid OP CODE from given instruction, go to next OP in mem
00001030  4EF8 1010                 56          JMP     GRAB_NEXT_OP
00001034                            57          
00001034                            58  *Verify valid NOP syntax------------------------------------
00001034                            59  ISNOP   
00001034  =00004E71                 60  NOPALL  EQU $4E71   *The entire NOP instruction equals this constant hex value
00001034  3010                      61          MOVE.W  (A0),D0 *Move the WHOLE instruction from mem into D0
00001036  323C 4E71                 62          MOVE.W  #NOPALL,D1 *Move the entire NOP instruction into D1
0000103A                            63          *Compare D0 to D1, if equal we found a match, print some message.
0000103A                            64          *If not equal, there was some syntax error, print error message.
0000103A  B240                      65          CMP.W   D0,D1
0000103C  6700 0004                 66          BEQ     CORRECTNOP
00001040  6010                      67          BRA.S   ERRORNOP
00001042                            68  CORRECTNOP
00001042                            69          *Output some message, hey we found a NOP or something...
00001042  43F9 00001092             70          LEA     FOUNDNOP,A1 *Loads FOUNDNOP into address register A1
00001048  103C 000E                 71          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000104C  4E4F                      72          TRAP    #15         *Displays Message
0000104E  4EF8 1010                 73          JMP     GRAB_NEXT_OP    *Jump and go to the next instruction
00001052                            74  ERRORNOP
00001052                            75          *Output some error message, hey incorrect NOP syntax or something...
00001052  43F9 000010A6             76          LEA     BADNOP,A1   *Loads BADNOP into address register A1
00001058  103C 000E                 77          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000105C  4E4F                      78          TRAP    #15         *Displays Message
0000105E  4EF8 1010                 79          JMP     GRAB_NEXT_OP    *Jump and go to the next instruction
00001062                            80          
00001062                            81  *Verify valid MOVE syntax-----------------------------------
00001062                            82  *ISMOVE  *is a move instruction, try to decode rest.
00001062                            83          
00001062                            84  *-----------------------------------------------------------        
00001062                            85  * End of Mini Disassembler
00001062                            86  *-----------------------------------------------------------    
00001062                            87          
00001062  103C 0009                 88  THEEND  MOVE.B  #9,D0
00001066  4E4F                      89          TRAP    #15             Halt Simulator        
00001068                            90          
00001068  =0000000D                 91  CR      EQU     $0D             ASCII code for Carriage Return
00001068  =0000000A                 92  LF      EQU     $0A             ASCII code for Line Feed
00001068= 48 65 79 2C 20 67 ...     93  MESSAGE DC.B    'Hey, going to try to disassemble MOVE.B',CR,LF,0
00001092= 48 65 79 2C 20 66 ...     94  FOUNDNOP    DC.B    'Hey, found a NOP!',CR,LF,0
000010A6= 48 65 79 2C 20 73 ...     95  BADNOP  DC.B    'Hey, something is wrong with this NOP!',CR,LF,0
000010CF                            96          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BADNOP              10A6
CORRECTNOP          1042
CR                  D
ERRORNOP            1052
FOUNDNOP            1092
GRAB_NEXT_OP        1010
ISNOP               1034
LF                  A
MESSAGE             1068
NOPALL              4E71
NOP_OP              4
STACK               7000
START               1000
ST_ADDR             7FC0
THEEND              1062
