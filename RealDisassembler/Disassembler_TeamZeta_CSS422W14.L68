00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.0
Created On: 3/11/2014 8:04:19 PM

00001000                             1  START       ORG $1000   *Start program at provided location
00001000  =00007FC0                  2  ST_ADDR     EQU $7FC0   *Starting address of input test file
00001000  =00007000                  3  STACK       EQU $7000   *Stack location
00001000                             4  
00001000                             5  *-----------------------------------------------------------
00001000                             6  * Start of I/O
00001000                             7  *-----------------------------------------------------------
00001000  307C 7FC0                  8              MOVEA.W #ST_ADDR,A0 *Load starting location of test input file into A0
00001004                             9              
00001004  43F9 00001210             10              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100A  103C 000E                 11              MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000100E  4E4F                      12              TRAP    #15         *Displays Message
00001010                            13          
00001010  303C 0000                 14  loop_1      MOVE    #0,D0       
00001014  43F9 0000161F             15              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101A  103C 000E                 16              MOVE.B  #14,D0
0000101E  4E4F                      17              TRAP    #15    
00001020  303C 0002                 18              MOVE    #2,D0
00001024  43F9 000016D4             19              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102A  4E4F                      20              TRAP    #15
0000102C  4EB9 00001052             21              JSR     CHECK_UPY
00001032  0C07 0001                 22              CMPI.B  #01,D7
00001036  67D8                      23              BEQ     loop_1
00001038  43F9 00001650             24  NXT_CMD     LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
0000103E  103C 000E                 25              MOVE.B  #14,D0
00001042  4E4F                      26              TRAP    #15
00001044  303C 0002                 27              MOVE    #2,D0       
00001048  43F9 000016D4             28              LEA     CMD_HLD,A1  *Need to change where it can hold the start/end address
0000104E  4E4F                      29              TRAP    #15
00001050  2811                      30              MOVE.L  (A1),D4
00001052                            31          
00001052                            32  *-----------------------------------------------------------
00001052                            33  * I/O: Input check for Y, y, N, n
00001052                            34  *-----------------------------------------------------------
00001052  0C11 0059                 35  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001056  6600 0004                 36              BNE     CHECK_LOWy
0000105A  4E75                      37              RTS
0000105C  0C11 0079                 38  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
00001060  6600 0004                 39              BNE     CHECK_UPN
00001064  4E75                      40              RTS
00001066  0C11 004E                 41  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
0000106A  6700 019A                 42              BEQ     DONE
0000106E  6600 0004                 43              BNE     CHECK_LOWn
00001072  4E75                      44              RTS
00001074  0C11 006E                 45  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001078  6600 0008                 46              BNE     INVALID
0000107C  6700 0188                 47              BEQ     DONE
00001080  4E75                      48              RTS
00001082  303C 0000                 49  INVALID     MOVE    #0,D0       *Prints invalid command msg if not found
00001086  43F9 000017D7             50              LEA     INV_MSG,A1
0000108C  303C 000E                 51              MOVE    #14,D0
00001090  4E4F                      52              TRAP    #15
00001092  5207                      53              ADDI.B  #1,D7
00001094  6000 FF7A                 54              BRA     loop_1      *Prompts the user again
00001098                            55              
00001098                            56  *-----------------------------------------------------------
00001098                            57  *
00001098                            58  * I/O: Check Start Address
00001098                            59  *
00001098                            60  * Make sure that start address starts after allocated 
00001098                            61  * memory addresses. Else, it will print out a message 
00001098                            62  * saying that requested address is invalid & prompts the
00001098                            63  * user again for the starting address.
00001098                            64  *-----------------------------------------------------------
00001098                            65  *CHECKSTRT1 MOVE.B  
00001098                            66              
00001098                            67  *-----------------------------------------------------------        
00001098                            68  * Start of Disassembler
00001098                            69  *-----------------------------------------------------------
00001098                            70  GRAB_NEXT_OP
00001098                            71          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
00001098                            72          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
00001098                            73          *data that may be associated with the instruction.
00001098                            74          *Post increment addr, A0 will point to the start of next instruction or will 
00001098                            75          *point to the start of any immed/abso data with this current instruction
00001098  4280                      76          CLR.L   D0
0000109A  3018                      77          MOVE.W  (A0)+,D0
0000109C                            78          *Copy the word data we just moved into D0 into D7. We are copying this data
0000109C                            79          *So we always have a copy of the WHOLE instruction somewhere
0000109C  4287                      80          CLR.L   D7
0000109E  3E00                      81          MOVE.W  D0,D7
000010A0                            82          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000010A0                            83          *four bits of the instruction. Once we have just the first four bits, we can
000010A0                            84          *begin to see which 'bucket'/category this instruction falls into. 
000010A0  E048                      85          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000010A2  E848                      86          LSR.W   #$04,D0
000010A4                            87          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000010A4                            88          *list of buckets until we find which one this instruction falls into.
000010A4                            89  
000010A4                            90  
000010A4                            91  *-----------------------------------------------------------        
000010A4                            92  * Bucket 0000:
000010A4                            93  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
000010A4                            94  *                   BCHG(dynamic) | BCHG (static) | CMPI----
000010A4                            95  *-----------------------------------------------------------
000010A4                            96  BUCKET_0000
000010A4  =00000000                 97  BUCKET0000_BITS EQU $0
000010A4  4281                      98          CLR.L   D1
000010A6                            99          *Load the first 4 bits (really a byte) of BUCKET0 into D1
000010A6  123C 0000                100          MOVE.B  #BUCKET0000_BITS,D1
000010AA                           101          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
000010AA                           102          *If equal, continue decoding. If not, branch to next bucket.
000010AA  B200                     103          CMP.B   D0,D1
000010AC  6600 0132                104          BNE     BUCKET_0001
000010B0                           105  
000010B0                           106          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
000010B0                           107          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
000010B0  3007                     108          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
000010B2  0800 0008                109          BTST.L  #$08,D0
000010B6  6600 00C2                110          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
000010BA                           111          
000010BA                           112          *Now we can check bits 11-8 in the instruction and branch to different op-codes
000010BA                           113          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
000010BA  E048                     114          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
000010BC  0880 0004                115          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
000010C0  0880 0005                116          BCLR.L  #$05,D0
000010C4  0880 0006                117          BCLR.L  #$06,D0
000010C8  0880 0007                118          BCLR.L  #$07,D0
000010CC                           119          
000010CC                           120          *Perform compares with these 4 bits to see which specific instruction it is.
000010CC  B03C 0006                121          CMP.B   #$06,D0 *Is this an ADDI?
000010D0  6700 0028                122          BEQ     IS_ADDI
000010D4  B03C 0002                123          CMP.B   #$02,D0 *Is this an ANDI?
000010D8  6700 0068                124          BEQ     IS_ANDI
000010DC  B03C 000A                125          CMP.B   #$0A,D0 *Is this an EORI?
000010E0  6700 007C                126          BEQ     IS_EORI
000010E4  B03C 0008                127          CMP.B   #$08,D0 *Is this a BCHG(static)?
000010E8  6700 00BE                128          BEQ     IS_BCHG_S
000010EC  B03C 000C                129          CMP.B   #$0C,D0 *Is this a CMPI?
000010F0  6700 00D2                130          BEQ     IS_CMPI
000010F4                           131          
000010F4                           132          *If we get through all of the compares without finding the specific instruction,
000010F4                           133          *then this instruction is either not in our list of OP CODES to decode, or is an
000010F4                           134          *invalid instruction/syntax.
000010F4  4EF9 000011E6            135          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000010FA                           136  
000010FA                           137  
000010FA                           138  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
000010FA                           139  IS_ADDI
000010FA                           140          *Don't need to verify anymore bits for this particular op code (all important
000010FA                           141          *opcode bits were 'verified' by getting here...)
000010FA                           142  
000010FA                           143          *Output some message, hey we found an ADDI instruction...
000010FA  43F9 0000171A            144          LEA     FNDADDI,A1  *Loads FNDADDI into address register A1
00001100  103C 000E                145          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001104  4E4F                     146          TRAP    #15         *Displays Message
00001106                           147          
00001106                           148          *Should have a valid IS_ADDI op code. Set data up for EA.
00001106                           149                 
00001106                           150          *Set D0 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001106  3007                     151          MOVE.W  D7,D0   *Move the WHOLE instruction to D0
00001108  EC48                     152          LSR.W   #$06,D0 *Shift the first 10 bits into LSB position
0000110A  0880 0008                153          BCLR.L  #$08,D0 *Set first 8 bits to 0, leaving only bits 7-6 of the instruction
0000110E  0880 0009                154          BCLR.L  #$09,D0 *This should be a func (jsr) since a lot of instructions will do this...
00001112  0880 000A                155          BCLR.L  #$0A,D0 *SEE BFCLR
00001116  0880 000B                156          BCLR.L  #$0B,D0        
0000111A  0880 000C                157          BCLR.L  #$0C,D0        
0000111E  0880 000D                158          BCLR.L  #$0D,D0        
00001122  0880 000E                159          BCLR.L  #$0E,D0        
00001126  0880 000F                160          BCLR.L  #$0F,D0
0000112A                           161          
0000112A                           162          *Set D1 to the EA mode of the operation located in bits 5-3 of the instruction        
0000112A  3207                     163          MOVE.W  D7,D1   *Move the WHOLE instruction to D1
0000112C                           164          *Okay! So I thought of something weird to do... I am going to shift the instruction
0000112C                           165          *to the LEFT by 10 bits, putting bits 5-0 of the original instruction into MSB position.
0000112C  E149                     166          LSL.W   #$08,D1
0000112E  E549                     167          LSL.W   #$02,D1
00001130                           168          *Now! I am going to shift the register to the RIGHT by 13 bits, leaving only bits 5-3
00001130                           169          *in LSB position, and the rest of the bits will be zero in the register.
00001130  E049                     170          LSR.W   #$08,D1
00001132  EA49                     171          LSR.W   #$05,D1
00001134                           172          *Now is this a better way than just shifting once and clearing like I did above with 'size'?
00001134                           173          
00001134                           174          *Set D2 to the EA register of the operation located in bits 2-0 of the instruction
00001134  3407                     175          MOVE.W  D7,D2   *Move the WHOLE instruction to D2
00001136                           176          *TODO, REMEMBER LOOK INTO BFCLR
00001136                           177          
00001136  4EF9 0000113C            178          JMP     EA_ADDI
0000113C                           179  
0000113C                           180  EA_ADDI
0000113C                           181          *some code verifiying the integrity/syntax of the EA bits of the instruction
0000113C                           182          *if bad EA, jump to BADEACODE, where i/o will take care of it
0000113C                           183          
0000113C                           184          *make sure when you leave an EA func that you also read in and either use
0000113C                           185          *or ignore immediate/absoluate data, so that we can we ready to start reading
0000113C                           186          *in the next instruction.
0000113C  4EF9 0000120A            187          JMP     THEEND  *For now just end
00001142                           188  
00001142                           189  
00001142                           190  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
00001142                           191  IS_ANDI
00001142                           192          *TODO:Verify bits
00001142                           193  
00001142                           194          *Output some message, hey we found an ANDI instruction...
00001142  43F9 00001731            195          LEA     FNDANDI,A1  *Loads FNDANDI into address register A1
00001148  103C 000E                196          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000114C  4E4F                     197          TRAP    #15         *Displays Message
0000114E                           198          
0000114E                           199          *Should have a valid IS_ANDI op code. Set data up for EA.
0000114E                           200          *TODO:
0000114E  163C 000E                201          MOVE.B  #14,D3
00001152  4EF9 00001158            202          JMP     EA_ANDI
00001158                           203  
00001158                           204  EA_ANDI
00001158  4EF9 0000120A            205          JMP     THEEND  *For now just end
0000115E                           206  
0000115E                           207  
0000115E                           208  *Now we know this instruction is exactly EORI, lets set everything up for EA.
0000115E                           209  IS_EORI
0000115E                           210          *TODO:Verify bits
0000115E                           211  
0000115E                           212          *Output some message, hey we found an EORI instruction...
0000115E  43F9 00001748            213          LEA     FNDEORI,A1  *Loads FNDEORI into address register A1
00001164  103C 000E                214          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001168  4E4F                     215          TRAP    #15         *Displays Message
0000116A                           216          
0000116A                           217          *Should have a valid IS_EORI op code. Set data up for EA.
0000116A                           218          *TODO:
0000116A  163C 000E                219          MOVE.B  #14,D3
0000116E  4EF9 00001174            220          JMP     EA_EORI
00001174                           221  
00001174                           222  EA_EORI
00001174  4EF9 0000120A            223          JMP     THEEND  *For now just end
0000117A                           224  
0000117A                           225  
0000117A                           226  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
0000117A                           227  * everything up for EA if is a legit instruction. Assuming D0 holds full instruction.
0000117A                           228  IS_BCHG_D
0000117A  3007                     229          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
0000117C                           230          
0000117C                           231          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
0000117C                           232          *invalid, branch to BADOPCODE
0000117C  0800 0007                233          BTST.L  #$07,D0
00001180  6600 0064                234          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
00001184  0800 0006                235          BTST.L  #$06,D0
00001188  6700 005C                236          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
0000118C                           237          
0000118C                           238          *Output a message, hey we found a BCHG(dynamic) instruction...
0000118C  43F9 0000175F            239          LEA     FNDBCHG_D,A1    *Loads FNDBCHG_D into address register A1
00001192  103C 000E                240          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001196  4E4F                     241          TRAP    #15             *Displays Message
00001198                           242                  
00001198                           243          *Should have a valid BCHG(dynamic) op code. Set data up for EA.
00001198                           244          *TODO:
00001198  163C 000E                245          MOVE.B  #14,D3
0000119C  4EF9 000011A2            246          JMP     EA_BCHG_D
000011A2                           247  
000011A2                           248  EA_BCHG_D
000011A2  4EF9 0000120A            249          JMP     THEEND  *For now just end
000011A8                           250  
000011A8                           251  
000011A8                           252  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
000011A8                           253  IS_BCHG_S
000011A8                           254          *TODO:Verify bits
000011A8                           255  
000011A8                           256          *Output some message, hey we found an BCHG_S instruction...
000011A8  43F9 0000177E            257          LEA     FNDBCHG_S,A1    *Loads FNDBCHG_S into address register A1
000011AE  103C 000E                258          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000011B2  4E4F                     259          TRAP    #15             *Displays Message
000011B4                           260          
000011B4                           261          *Should have a valid IS_BCHG_S op code. Set data up for EA.
000011B4                           262          *TODO:
000011B4  163C 000E                263          MOVE.B  #14,D3
000011B8  4EF9 000011BE            264          JMP     EA_BCHG_S
000011BE                           265  
000011BE                           266  EA_BCHG_S
000011BE  4EF9 0000120A            267          JMP     THEEND  *For now just end
000011C4                           268  
000011C4                           269  
000011C4                           270  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000011C4                           271  IS_CMPI
000011C4                           272          *TODO:Verify bits
000011C4                           273  
000011C4                           274          *Output some message, hey we found an CMPI instruction...
000011C4  43F9 0000179C            275          LEA     FNDCMPI,A1  *Loads FNDCMPI into address register A1
000011CA  103C 000E                276          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000011CE  4E4F                     277          TRAP    #15         *Displays Message
000011D0                           278          
000011D0                           279          *Should have a valid IS_CMPI op code. Set data up for EA.
000011D0                           280          *TODO:
000011D0  163C 000E                281          MOVE.B  #14,D3
000011D4  4EF9 000011DA            282          JMP     EA_CMPI
000011DA                           283  
000011DA                           284  EA_CMPI
000011DA  4EF9 0000120A            285          JMP     THEEND  *For now just end
000011E0                           286  
000011E0                           287  
000011E0                           288  *STARTS WITH 0001, MOVE.B-----------------------------------
000011E0                           289  BUCKET_0001
000011E0  =00000001                290  BUCKET0001_BITS EQU $1
000011E0                           291          
000011E0                           292          *some code...
000011E0                           293  
000011E0                           294  
000011E0                           295  *STARTS WITH 0010, MOVE.L-----------------------------------
000011E0                           296  BUCKET_0010
000011E0  =00000002                297  BUCKET0010_BITS EQU $2
000011E0                           298  
000011E0                           299          *some code...
000011E0                           300  
000011E0                           301  
000011E0                           302  *STARTS WITH 0011, MOVE.W-----------------------------------
000011E0                           303  BUCKET_0011
000011E0  =00000003                304  BUCKET0011_BITS EQU $3
000011E0                           305  
000011E0                           306          *some code...
000011E0                           307  
000011E0                           308  
000011E0                           309  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
000011E0                           310  BUCKET_0100
000011E0  =00000004                311  BUCKET0100_BITS EQU $4
000011E0                           312  
000011E0                           313          *some code...
000011E0                           314  
000011E0                           315  
000011E0                           316  *STARTS WITH 0101, SUBQ-------------------------------------
000011E0                           317  BUCKET_0101
000011E0  =00000005                318  BUCKET0101_BITS EQU $5
000011E0                           319  
000011E0                           320          *some code...
000011E0                           321  
000011E0                           322  
000011E0                           323  *STARTS WITH 0110, BCC--------------------------------------
000011E0                           324  BUCKET_0110
000011E0  =00000006                325  BUCKET0110_BITS EQU $6
000011E0                           326  
000011E0                           327          *some code...
000011E0                           328  
000011E0                           329  
000011E0                           330  *STARTS WITH 1000, DIVU-------------------------------------
000011E0                           331  BUCKET_1000
000011E0  =00000008                332  BUCKET1000_BITS EQU $8
000011E0                           333  
000011E0                           334          *some code...
000011E0                           335  
000011E0                           336  
000011E0                           337  *STARTS WITH 1001, SUBA-------------------------------------
000011E0                           338  BUCKET_1001
000011E0  =00000009                339  BUCKET1001_BITS EQU $9
000011E0                           340  
000011E0                           341          *some code...
000011E0                           342  
000011E0                           343  
000011E0                           344  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000011E0                           345  BUCKET_1011
000011E0  =0000000B                346  BUCKET1011_BITS EQU $B
000011E0                           347  
000011E0                           348          *some code...
000011E0                           349  
000011E0                           350  
000011E0                           351  *STARTS WITH 1100, MULS(W) | AND----------------------------
000011E0                           352  BUCKET_1100
000011E0  =0000000C                353  BUCKET1100_BITS EQU $C
000011E0                           354  
000011E0                           355          *some code...
000011E0                           356  
000011E0                           357  
000011E0                           358  *STARTS WITH 1101, ADD | ADDA-------------------------------
000011E0                           359  BUCKET_1101
000011E0  =0000000D                360  BUCKET1101_BITS EQU $D
000011E0                           361  
000011E0                           362          *some code...
000011E0                           363  
000011E0                           364  
000011E0                           365  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000011E0                           366  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000011E0                           367  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000011E0                           368  BUCKET_1110
000011E0  =0000000E                369  BUCKET1110_BITS EQU $E     
000011E0                           370  
000011E0                           371          *some code...
000011E0                           372  
000011E0                           373  
000011E0                           374  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000011E0                           375  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000011E0  4EF9 000011E6            376          JMP     BADOPCODE  
000011E6                           377          
000011E6                           378          
000011E6                           379  BADOPCODE
000011E6                           380          *We found a bad op code, output some error to the screen, jump to the 
000011E6                           381          *next instruction in memory.
000011E6                           382          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
000011E6                           383          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
000011E6                           384          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
000011E6                           385          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
000011E6                           386          *i/o and error message code...
000011E6  43F9 000017C2            387          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
000011EC  103C 000E                388          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000011F0  4E4F                     389          TRAP    #15         *Displays Message
000011F2  4EF8 1098                390          JMP     GRAB_NEXT_OP
000011F6                           391          
000011F6                           392          
000011F6                           393  BADEACODE
000011F6                           394          *We found a bad ea code, output some error to the screen, jump to the
000011F6                           395          *next instruction in memory.
000011F6                           396          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
000011F6                           397          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
000011F6  43F9 000017B2            398          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
000011FC  103C 000E                399          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001200  4E4F                     400          TRAP    #15         *Displays Message
00001202  4EF8 1098                401          JMP     GRAB_NEXT_OP
00001206                           402          
00001206                           403  *-----------------------------------------------------------        
00001206                           404  * End of Disassembler
00001206                           405  *-----------------------------------------------------------    
00001206                           406  
00001206  4E72 2700                407  DONE    STOP    #$2700  *What does this do? Why was it added?
0000120A                           408  
0000120A  103C 0009                409  THEEND  MOVE.B  #9,D0
0000120E  4E4F                     410          TRAP    #15             Halt Simulator        
00001210                           411          
00001210  =0000000D                412  CR      EQU     $0D             ASCII code for Carriage Return
00001210  =0000000A                413  LF      EQU     $0A             ASCII code for Line Feed
00001210= 2D 2D 2D 2D 2D 2D ...    414  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
0000124F= 7C 7C 20 20 20 20 ...    415              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
0000128E= 2D 2D 2D 2D 2D 2D ...    416              DC.B    '-------------------------------------------------------------',CR,LF
000012CD= 2A 2A 2A 2A 2A 2A ...    417              DC.B    '*************************************************************',CR,LF
0000130C= 2A 2A 2A 2A 2A 2A ...    418              DC.B    '*************************************************************',CR,LF
0000134B= 2A 2A 2A 2A 2A 2A ...    419              DC.B    '******           ***        ***           ****    ***********',CR,LF
0000138A= 2A 2A 2A 2A 2A 2A ...    420              DC.B    '************    ****   ************   *******  **  **********',CR,LF
000013C9= 2A 2A 2A 2A 2A 2A ...    421              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001408= 2A 2A 2A 2A 2A 2A ...    422              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001447= 2A 2A 2A 2A 2A 2A ...    423              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001486= 2A 2A 2A 2A 2A 2A ...    424              DC.B    '*************************************************************',CR,LF
000014C5= 2A 2A 2A 2A 2A 2A ...    425              DC.B    '*************************************************************',CR,LF
00001504= 2A 20 20 20 20 20 ...    426              DC.B    '*                                                           *',CR,LF
00001543= 2A 20 41 75 74 68 ...    427              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001582= 2A 20 20 20 20 20 ...    428              DC.B    '*                                                           *',CR,LF
000015C1= 2A 2A 2A 2A 2A 2A ...    429              DC.B    '*************************************************************',CR,LF,CR,LF
00001602= 53 74 61 72 74 69 ...    430              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
0000161F                           431              
0000161F= 57 6F 75 6C 64 20 ...    432  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001650                           433  
00001650= 20 0D 0A                 434  GETSTRTADDR DC.B    ' ',CR,LF
00001653= 50 6C 65 61 73 65 ...    435              DC.B    'Please type in your starting address request: ',0
00001682                           436              
00001682= 20 0D 0A                 437  GETENDADDR  DC.B    ' ',CR,LF
00001685= 50 6C 65 61 73 65 ...    438              DC.B    'Please type in your ending address request: ',0
000016B2                           439              
000016B2= 20 0D 0A                 440  QUIT_MSG    DC.B    ' ',CR,LF
000016B5= 57 6F 75 6C 64 20 ...    441              DC.B    'Would you like to quit (Y/N)? ',0
000016D4                           442  
000016D4                           443  *****************************************************
000016D4                           444  * I/O storages - assuming users knows what to do.
000016D4                           445  *****************************************************
000016D4                           446  CMD_HLD     DS.B    30
000016F2                           447  STADDR      DS.B    10
000016FC                           448  STADDRSZ    DS.B    10
00001706                           449  ENDADDR     DS.B    10
00001710                           450  ENDADDRSZ   DS.B    10
0000171A                           451  *****************************************************
0000171A                           452  
0000171A                           453  *for now, i guess every OPCODE will have a corresponding 'found it' msg...
0000171A= 46 6F 75 6E 64 20 ...    454  FNDADDI     DC.B    'Found an ADDI opcode',CR,LF,0
00001731= 46 6F 75 6E 64 20 ...    455  FNDANDI     DC.B    'Found an ANDI opcode',CR,LF,0
00001748= 46 6F 75 6E 64 20 ...    456  FNDEORI     DC.B    'Found an EORI opcode',CR,LF,0
0000175F= 46 6F 75 6E 64 20 ...    457  FNDBCHG_D   DC.B    'Found a BCHG(dynamic) opcode',CR,LF,0
0000177E= 46 6F 75 6E 64 20 ...    458  FNDBCHG_S   DC.B    'Found a BCHG(static) opcode',CR,LF,0
0000179C= 46 6F 75 6E 64 20 ...    459  FNDCMPI     DC.B    'Found a CMPI opcode',CR,LF,0
000017B2                           460  
000017B2= 42 41 44 20 45 41 ...    461  BADEAMSG    DC.B    'BAD EA, WHY?!',CR,LF,0
000017C2= 42 41 44 20 4F 50 ...    462  BADOPMSG    DC.B    'BAD OP CODE, WHY?!',CR,LF,0
000017D7= 49 6D 70 72 6F 70 ...    463  INV_MSG     DC.B    'Improper command.',CR,LF,0
000017EB                           464          
000017EB                           465          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BADEACODE           11F6
BADEAMSG            17B2
BADOPCODE           11E6
BADOPMSG            17C2
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         10A4
BUCKET_0001         11E0
BUCKET_0010         11E0
BUCKET_0011         11E0
BUCKET_0100         11E0
BUCKET_0101         11E0
BUCKET_0110         11E0
BUCKET_1000         11E0
BUCKET_1001         11E0
BUCKET_1011         11E0
BUCKET_1100         11E0
BUCKET_1101         11E0
BUCKET_1110         11E0
CHECK_LOWN          1074
CHECK_LOWY          105C
CHECK_UPN           1066
CHECK_UPY           1052
CMD_HLD             16D4
CR                  D
DONE                1206
EA_ADDI             113C
EA_ANDI             1158
EA_BCHG_D           11A2
EA_BCHG_S           11BE
EA_CMPI             11DA
EA_EORI             1174
ENDADDR             1706
ENDADDRSZ           1710
FNDADDI             171A
FNDANDI             1731
FNDBCHG_D           175F
FNDBCHG_S           177E
FNDCMPI             179C
FNDEORI             1748
GETENDADDR          1682
GETSTRTADDR         1650
GRAB_NEXT_OP        1098
INVALID             1082
INV_MSG             17D7
IS_ADDI             10FA
IS_ANDI             1142
IS_BCHG_D           117A
IS_BCHG_S           11A8
IS_CMPI             11C4
IS_EORI             115E
LF                  A
LOOP_1              1010
MESSAGE             1210
NXT_CMD             1038
QUIT_MSG            16B2
STACK               7000
STADDR              16F2
STADDRSZ            16FC
START               1000
STARTASSEM          161F
ST_ADDR             7FC0
THEEND              120A
