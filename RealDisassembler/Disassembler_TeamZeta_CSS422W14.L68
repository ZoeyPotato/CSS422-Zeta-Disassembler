00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.0
Created On: 3/14/2014 4:19:54 AM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/11/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC6                  9  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00000000  =0000000F                 11  MAX_LINE    EQU     15      *Maximum number of instructions that can be 
00001000                            12  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 13              LEA stack,SP
00001004  3C3C 000F                 14              MOVE    #MAX_LINE,D6
00001008                            15  
00001008                            16  
00001008                            17  *-----------------------------------------------------------
00001008                            18  * Start of I/O
00001008                            19  *-----------------------------------------------------------            
00001008  43F9 00001B3C             20              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 21              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      22              TRAP    #15         *Displays Message
00001014                            23          
00001014  303C 0000                 24  loop_1      MOVE    #0,D0       
00001018  43F9 00001F4B             25              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 26              MOVE.B  #14,D0
00001022  4E4F                      27              TRAP    #15    
00001024  303C 0002                 28              MOVE    #2,D0
00001028  43F9 00002026             29              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      30              TRAP    #15
00001030  0C01 0001                 31              CMPI.B  #01,D1
00001034  6600 00F8                 32              BNE     INVALID1
00001038  4EB9 0000110A             33              JSR     CHECK_UPY
0000103E                            34  *-----------------------------------------------------------
0000103E                            35  *
0000103E                            36  * I/O: Check Start Address
0000103E                            37  *
0000103E                            38  * Make sure that start address starts after allocated 
0000103E                            39  * memory addresses. Else, it will print out a message 
0000103E                            40  * saying that requested address is invalid & prompts the
0000103E                            41  * user again for the starting address.
0000103E                            42  *-----------------------------------------------------------
0000103E  43F9 00001F7C             43  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001044  103C 000E                 44              MOVE.B  #14,D0
00001048  4E4F                      45              TRAP    #15
0000104A  43F9 00002062             46              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001050  3239 0000206C             47              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001056  303C 0002                 48              MOVE    #2,D0           *Get start address
0000105A  4E4F                      49              TRAP    #15
0000105C  4EB9 000010DE             50              JSR     CHECKSTRT1
00001062  4287                      51              CLR.L   D7
00001064  4EB9 0000116E             52              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106A  0C03 0001                 53              CMPI.B  #01,D3      *Check if there was a bad start
0000106E  6700 00D6                 54              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001072  0C87 00007FC6             55              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001078  6D00 00CC                 56              BLT     INV_STRT1   *Asks for another start address if invalid
0000107C  0C87 00FFFFFE             57              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001082  6C00 00C2                 58              BGE     INV_STRT1
00001086  23C7 00002076             59              MOVE.L  D7,PROGST
0000108C                            60  
0000108C  43F9 00001FAE             61  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001092  103C 000E                 62              MOVE.B  #14,D0
00001096  4E4F                      63              TRAP    #15
00001098  43F9 0000207A             64              LEA     ENDADDR,A1      *Buffer to hold end address
0000109E  3239 00002084             65              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A4  303C 0002                 66              MOVE    #2,D0
000010A8  4E4F                      67              TRAP    #15
000010AA  4EB9 000010F4             68              JSR     CHECKEND1
000010B0  4287                      69              CLR.L   D7
000010B2  4EB9 0000116E             70              JSR     ASCIIHEX
000010B8  0C03 0001                 71              CMPI.B  #01,D3
000010BC  6700 009C                 72              BEQ     INV_END1
000010C0  0C87 00002076             73              CMPI.L  #PROGST,D7
000010C6  6D00 0092                 74              BLT     INV_END1
000010CA  0C87 00FFFFFF             75              CMPI.L  #$00FFFFFF,D7
000010D0  6C00 0088                 76              BGE     INV_END1
000010D4  23C7 0000208E             77              MOVE.L  D7,PROGEND
000010DA  6000 0284                 78              BRA     PL_STADDR           
000010DE                            79                          
000010DE  0C81 00000008             80  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010E4  6E00 0060                 81              BGT     INV_STRT1
000010E8  0C81 00000000             82              CMPI.L  #00,D1
000010EE  6300 0056                 83              BLS     INV_STRT1
000010F2  4E75                      84              RTS         
000010F4                            85              
000010F4  0C81 00000008             86  CHECKEND1   CMPI.L  #08,D1
000010FA  6E00 005E                 87              BGT     INV_END1
000010FE  0C81 00000000             88              CMPI.L  #00,D1
00001104  6300 0054                 89              BLS     INV_END1
00001108  4E75                      90              RTS
0000110A                            91  
0000110A                            92  *-----------------------------------------------------------
0000110A                            93  * I/O: Input check for Y, y, N, n
0000110A                            94  *-----------------------------------------------------------
0000110A  0C11 0059                 95  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
0000110E  6600 0004                 96              BNE     CHECK_LOWY
00001112  4E75                      97              RTS
00001114  0C11 0079                 98  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
00001118  6600 0004                 99              BNE     CHECK_UPN
0000111C  4E75                     100              RTS
0000111E  0C11 004E                101  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001122  6700 0A0E                102              BEQ     DONE
00001126                           103              
00001126  0C11 006E                104  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
0000112A  6700 0A06                105              BEQ     DONE
0000112E                           106              
0000112E  163C 0000                107  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001132  303C 0000                108              MOVE    #0,D0       *Prints invalid command msg if not found
00001136  43F9 000021FF            109              LEA     INV_MSG,A1
0000113C  303C 000E                110              MOVE    #14,D0
00001140  4E4F                     111              TRAP    #15
00001142  6000 FED0                112              BRA     loop_1
00001146                           113              
00001146  43F9 00002213            114  INV_STRT1   LEA     INVSTRTMSG,A1
0000114C  103C 000E                115              MOVE.B  #14,D0
00001150  4E4F                     116              TRAP    #15
00001152  163C 0000                117              MOVE.B  #00,D3      *Reset flag
00001156  6000 FEE6                118              BRA     GET_STRT        
0000115A                           119              
0000115A  43F9 0000222C            120  INV_END1    LEA     INVENDMSG,A1
00001160  103C 000E                121              MOVE.B  #14,D0
00001164  4E4F                     122              TRAP    #15
00001166  163C 0000                123              MOVE.B  #00,D3      *Reset flag
0000116A  6000 FF20                124              BRA     GET_END
0000116E                           125              
0000116E                           126  *-----------------------------------------------------------
0000116E                           127  * ASCII to Hex converter
0000116E                           128  *
0000116E                           129  * Checks and converts the ASCII value to the hex equivalent
0000116E                           130  *-----------------------------------------------------------
0000116E  48E7 6000                131  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001172  0C01 0000                132  ASCIIHEX1   CMPI.B  #00,D1      *See if done
00001176  6700 0062                133              BEQ     exitSub     *Exit subroutine 
0000117A  5301                     134              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
0000117C  E99F                     135              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
0000117E  1419                     136              MOVE.B  (A1)+,D2    *Takes the first char
00001180  0C02 0024                137              CMPI.B  #$24,D2     *See if the first char is $
00001184  67EC                     138              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
00001186  0C02 0030                139              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
0000118A  6D00 004C                140              BLT     st_bad      *Put error message
0000118E  0C02 0039                141              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001192  6F00 0026                142              BLE     CONV_NUM    *Convert to number, if so
00001196  0C02 0041                143              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
0000119A  6D00 003C                144              BLT     st_bad      *Put error message
0000119E  0C02 0046                145              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011A2  6F00 0020                146              BLE     CONV_UpL    *Convert to hex
000011A6  0C02 0061                147              CMPI.B  #$61,D2     *Checks for non-valid chars
000011AA  6D00 002C                148              BLT     st_bad
000011AE  0C02 0066                149              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011B2  6F00 001A                150              BLE     CONV_LoL    
000011B6  6E00 0020                151              BGT     st_bad      *Puts error message for anything greater than f value
000011BA                           152              
000011BA  0402 0030                153  CONV_NUM    SUBI.B  #$30,D2
000011BE  8E02                     154              OR.B    D2,D7
000011C0  4EF8 1172                155              JMP     ASCIIHEX1
000011C4  0402 0037                156  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011C8  8E02                     157              OR.B    D2,D7
000011CA  4EF8 1172                158              JMP     ASCIIHEX1
000011CE  0402 0057                159  CONV_LoL    SUBI.B  #$57,D2
000011D2  8E02                     160              OR.B    D2,D7
000011D4  4EF8 1172                161              JMP     ASCIIHEX1   
000011D8                           162  
000011D8  5203                     163  st_bad      ADDI.B  #01,D3
000011DA  4CDF 0006                164  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011DE  4E75                     165              RTS
000011E0                           166              
000011E0                           167  *-----------------------------------------------------------
000011E0                           168  * Hex to ASCII converter
000011E0                           169  *-----------------------------------------------------------
000011E0  48E7 4C00                170  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011E4  0C01 0000                171  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011E8  6700 002C                172              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011EC  B27C 0001                173              CMP.W   #01,D1          
000011F0  6700 003E                174              BEQ     CHNG_SZW
000011F4  6000 0006                175              BRA     CHNG_SZL        
000011F8                           176  
000011F8  48E7 4C00                177  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011FC  123C 0008                178  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
00001200  0C01 0000                179  LOOP_L      CMPI.B  #00,D1
00001204  6700 00CA                180              BEQ     EXIT_CONV
00001208  5301                     181              SUBI.B  #01,D1
0000120A  E99C                     182              ROL.L   #4,D4           * Shift it for next bit
0000120C  2A04                     183              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000120E  4EB9 0000124A            184              JSR     CONV_LOOP
00001214  60EA                     185              BRA     LOOP_L      
00001216                           186  
00001216  123C 0002                187  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
0000121A  0C01 0000                188  LOOP_B      CMPI.B  #00,D1
0000121E  6700 00B0                189              BEQ     EXIT_CONV
00001222  5301                     190              SUBI.B  #01,D1
00001224  E91C                     191              ROL.B   #4,D4           * Shift it for next bit
00001226  2A04                     192              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001228  4EB9 0000124A            193              JSR     CONV_LOOP
0000122E  60EA                     194              BRA     LOOP_B
00001230                           195              
00001230  123C 0004                196  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
00001234  0C01 0000                197  LOOP_W      CMPI.B  #00,D1
00001238  6700 0096                198              BEQ     EXIT_CONV
0000123C  5301                     199              SUBI.B  #01,D1
0000123E  E95C                     200              ROL.W   #4,D4           * Shift it for next bit
00001240  2A04                     201              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001242  4EB9 0000124A            202              JSR     CONV_LOOP
00001248  60EA                     203              BRA     LOOP_W
0000124A                           204  
0000124A  0285 0000000F            205  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001250  0C05 0000                206              CMPI.B  #$0,D5
00001254  6700 0088                207              BEQ     NUM_0
00001258  0C05 0001                208              CMPI.B  #$1,D5
0000125C  6700 0088                209              BEQ     NUM_1
00001260  0C05 0002                210              CMPI.B  #$2,D5
00001264  6700 0088                211              BEQ     NUM_2
00001268  0C05 0003                212              CMPI.B  #$3,D5
0000126C  6700 0088                213              BEQ     NUM_3
00001270  0C05 0004                214              CMPI.B  #$4,D5
00001274  6700 0088                215              BEQ     NUM_4
00001278  0C05 0005                216              CMPI.B  #$5,D5
0000127C  6700 0088                217              BEQ     NUM_5
00001280  0C05 0006                218              CMPI.B  #$6,D5
00001284  6700 0088                219              BEQ     NUM_6
00001288  0C05 0007                220              CMPI.B  #$7,D5
0000128C  6700 0088                221              BEQ     NUM_7
00001290  0C05 0008                222              CMPI.B  #$8,D5
00001294  6700 0088                223              BEQ     NUM_8
00001298  0C05 0009                224              CMPI.B  #$9,D5
0000129C  6700 0088                225              BEQ     NUM_9
000012A0  0C05 000A                226              CMPI.B  #$A,D5
000012A4  6700 0088                227              BEQ     NUM_A
000012A8  0C05 000B                228              CMPI.B  #$B,D5
000012AC  6700 0088                229              BEQ     NUM_B
000012B0  0C05 000C                230              CMPI.B  #$C,D5
000012B4  6700 0088                231              BEQ     NUM_C
000012B8  0C05 000D                232              CMPI.B  #$D,D5
000012BC  6700 0088                233              BEQ     NUM_D
000012C0  0C05 000E                234              CMPI.B  #$E,D5
000012C4  6700 0088                235              BEQ     NUM_E
000012C8  0C05 000F                236              CMPI.B  #$F,D5
000012CC  6700 0088                237              BEQ     NUM_F
000012D0                           238              
000012D0  4CDF 0032                239  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012D4  4E75                     240              RTS
000012D6                           241              
000012D6  303C 000E                242  PRINT_NUM   MOVE    #14,D0
000012DA  4E4F                     243              TRAP    #15
000012DC  4E75                     244              RTS
000012DE  43F9 000020B0            245  NUM_0       LEA     PRNT0,A1
000012E4  60F0                     246              BRA     PRINT_NUM
000012E6  43F9 000020B2            247  NUM_1       LEA     PRNT1,A1
000012EC  60E8                     248              BRA     PRINT_NUM
000012EE  43F9 000020B4            249  NUM_2       LEA     PRNT2,A1
000012F4  60E0                     250              BRA     PRINT_NUM
000012F6  43F9 000020B6            251  NUM_3       LEA     PRNT3,A1
000012FC  60D8                     252              BRA     PRINT_NUM
000012FE  43F9 000020B8            253  NUM_4       LEA     PRNT4,A1
00001304  60D0                     254              BRA     PRINT_NUM
00001306  43F9 000020BA            255  NUM_5       LEA     PRNT5,A1
0000130C  60C8                     256              BRA     PRINT_NUM
0000130E  43F9 000020BC            257  NUM_6       LEA     PRNT6,A1
00001314  60C0                     258              BRA     PRINT_NUM
00001316  43F9 000020BE            259  NUM_7       LEA     PRNT7,A1
0000131C  60B8                     260              BRA     PRINT_NUM
0000131E  43F9 000020C0            261  NUM_8       LEA     PRNT8,A1
00001324  60B0                     262              BRA     PRINT_NUM
00001326  43F9 000020C2            263  NUM_9       LEA     PRNT9,A1
0000132C  60A8                     264              BRA     PRINT_NUM
0000132E  43F9 000020C4            265  NUM_A       LEA     PRNTA,A1
00001334  60A0                     266              BRA     PRINT_NUM
00001336  43F9 000020C6            267  NUM_B       LEA     PRNTB,A1
0000133C  6098                     268              BRA     PRINT_NUM
0000133E  43F9 000020C8            269  NUM_C       LEA     PRNTC,A1
00001344  6090                     270              BRA     PRINT_NUM
00001346  43F9 000020CA            271  NUM_D       LEA     PRNTD,A1
0000134C  6088                     272              BRA     PRINT_NUM
0000134E  43F9 000020CC            273  NUM_E       LEA     PRNTE,A1
00001354  6080                     274              BRA     PRINT_NUM
00001356  43F9 000020CE            275  NUM_F       LEA     PRNTF,A1
0000135C  6000 FF78                276              BRA     PRINT_NUM
00001360                           277  
00001360                           278  *-----------------------------------------------------------        
00001360                           279  * Start of Disassembler
00001360                           280  *-----------------------------------------------------------
00001360                           281          *FOR DEBUGGING ONLY!!!
00001360                           282  *        MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
00001360  2079 00002076            283  PL_STADDR   MOVEA.L PROGST,A0
00001366                           284          
00001366                           285  GRAB_NEXT_OP
00001366  2E08                     286          MOVE.L  A0,D7
00001368  2479 0000208E            287          MOVEA.L PROGEND,A2
0000136E  BE8A                     288          CMP.L   A2,D7  *Check and see if A0 == end of test address. 
00001370  6E00 FCA2                289          BGT     loop_1      * Ask user if they want to do the disassembler again
00001374  0C86 00000000            290          CMPI.L  #00,D6      * Check if max line of instructions output on console is reached
0000137A  6700 0026                291          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
0000137E  5306                     292          SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
00001380                           293          *Output the address of this instruction to console...
00001380  2808                     294          MOVE.L  A0,D4
00001382  4EB8 11F8                295          JSR     HEXASCIIREG
00001386                           296          
00001386                           297          *Output a tab (4 spaces) to console, just after the address...
00001386  43F9 000021DE            298          LEA     Tab,A1  *Loads Tab into address register A1
0000138C  103C 000E                299          MOVE.B  #14,D0  *Moves the number 14 into data register D0
00001390  4E4F                     300          TRAP    #15     *Displays Message
00001392                           301          
00001392                           302          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
00001392                           303          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
00001392                           304          *data that may be associated with the instruction.
00001392                           305          *Post increment addr, A0 will point to the start of next instruction or will 
00001392                           306          *point to the start of any immed/abso data with this current instruction
00001392  4280                     307          CLR.L   D0
00001394  3018                     308          MOVE.W  (A0)+,D0
00001396                           309          *Copy the word data we just moved into D0 into D7. We are copying this data
00001396                           310          *So we always have a copy of the WHOLE instruction somewhere
00001396  4287                     311          CLR.L   D7
00001398  3E00                     312          MOVE.W  D0,D7
0000139A                           313          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
0000139A                           314          *four bits of the instruction. Once we have just the first four bits, we can
0000139A                           315          *begin to see which 'bucket'/category this instruction falls into. 
0000139A  E048                     316          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
0000139C  E848                     317          LSR.W   #$04,D0
0000139E                           318          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
0000139E                           319          *list of buckets until we find which one this instruction falls into.
0000139E  6000 0068                320          BRA     BUCKET_0000     * Start with 0000
000013A2                           321  
000013A2                           322  *-----------------------------------------------------------        
000013A2                           323  * Question Prompts
000013A2                           324  *-----------------------------------------------------------        
000013A2  43F9 00001FDE            325  CONT_Q      LEA     QUES_CONT,A1
000013A8  303C 000E                326              MOVE    #14,D0
000013AC  4E4F                     327              TRAP    #15
000013AE  43F9 00002092            328              LEA     CONT,A1     *Need to store Y/N
000013B4  303C 0002                329              MOVE    #2,D0
000013B8  4E4F                     330              TRAP    #15
000013BA  0C01 0001                331              CMPI.B  #01,D1
000013BE  6600 FD6E                332              BNE     INVALID1
000013C2  0C39 0059 00002092       333              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013CA  6600 0008                334              BNE     CHECK_Y
000013CE  3C3C 000F                335              MOVE    #MAX_LINE,D6    *Resets counter
000013D2  4E75                     336              RTS
000013D4  0C11 0079                337  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
000013D8  6600 0008                338              BNE     CHECK_N
000013DC  3C3C 000F                339              MOVE    #MAX_LINE,D6    *Resets counter
000013E0  4E75                     340              RTS
000013E2  0C11 004E                341  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
000013E6  6700 FC2C                342              BEQ     loop_1
000013EA  0C11 006E                343              CMPI.B  #$6E,(A1)   *Checks for lowercase n
000013EE  6700 FC24                344              BEQ     loop_1      
000013F2                           345  
000013F2  163C 0000                346  INV2        MOVE.B  #0,D3       *Reset bad flag
000013F6  303C 0000                347              MOVE    #0,D0       *Prints invalid command msg if not found
000013FA  43F9 000021FF            348              LEA     INV_MSG,A1
00001400  303C 000E                349              MOVE    #14,D0
00001404  4E4F                     350              TRAP    #15
00001406  609A                     351              BRA     CONT_Q
00001408                           352  
00001408                           353  *-----------------------------------------------------------        
00001408                           354  * Bucket 0000:
00001408                           355  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
00001408                           356  *                   BCHG(dynamic) | BCHG (static) | CMPI----
00001408                           357  *-----------------------------------------------------------
00001408                           358  BUCKET_0000
00001408  =00000000                359  BUCKET0000_BITS EQU $0
00001408  4281                     360          CLR.L   D1
0000140A                           361          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000140A  123C 0000                362          MOVE.B  #BUCKET0000_BITS,D1
0000140E                           363          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
0000140E                           364          *If equal, continue decoding. If not, branch to next bucket.
0000140E  B200                     365          CMP.B   D0,D1
00001410  6600 02CE                366          BNE     BUCKET_0001
00001414                           367  
00001414                           368          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001414                           369          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001414  3007                     370          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001416  0800 0008                371          BTST.L  #$08,D0
0000141A  6600 01A4                372          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
0000141E                           373          
0000141E                           374          *Now we can check bits 11-8 in the instruction and branch to different op-codes
0000141E                           375          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
0000141E  E048                     376          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001420  0880 0004                377          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001424  0880 0005                378          BCLR.L  #$05,D0
00001428  0880 0006                379          BCLR.L  #$06,D0
0000142C  0880 0007                380          BCLR.L  #$07,D0
00001430                           381          
00001430                           382          *Perform compares with these 4 bits to see which specific instruction it is.
00001430  B03C 0006                383          CMP.B   #$06,D0 *Is this an ADDI?
00001434  6700 0028                384          BEQ     IS_ADDI
00001438  B03C 0002                385          CMP.B   #$02,D0 *Is this an ANDI?
0000143C  6700 0096                386          BEQ     IS_ANDI
00001440  B03C 000A                387          CMP.B   #$0A,D0 *Is this an EORI?
00001444  6700 0104                388          BEQ     IS_EORI
00001448  B03C 0008                389          CMP.B   #$08,D0 *Is this a BCHG(static)?
0000144C  6700 0200                390          BEQ     IS_BCHG_S
00001450  B03C 000C                391          CMP.B   #$0C,D0 *Is this a CMPI?
00001454  6700 0214                392          BEQ     IS_CMPI
00001458                           393          
00001458                           394          *If we get through all of the compares without finding the specific instruction,
00001458                           395          *then this instruction is either not in our list of OP CODES to decode, or is an
00001458                           396          *invalid instruction/syntax.
00001458  4EF9 00001B12            397          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
0000145E                           398          
0000145E                           399          
0000145E                           400  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
0000145E                           401  IS_ADDI
0000145E                           402          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000145E                           403          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000145E  4281                     404          CLR.L   D1
00001460  3207                     405          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001462  C27C 00C0                406          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001466  EC09                     407          LSR.B   #$06,D1     *Shift the size bits into LSB
00001468                           408          
00001468  B23C 0003                409          CMP.B   #$03,D1     *Compare the size bits to $3
0000146C  6700 06A4                410          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001470                           411          
00001470                           412          *Output 'ADDI' to console...
00001470  43F9 000020D0            413          LEA     ADDI,A1     *Loads ADDI into address register A1
00001476  103C 000E                414          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000147A  4E4F                     415          TRAP    #15         *Displays Message
0000147C                           416          
0000147C                           417          
0000147C                           418          *Should have a valid ADDI op code. Set data up for EA.
0000147C                           419          
0000147C                           420          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000147C  4282                     421          CLR.L   D2
0000147E  3407                     422          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001480  C47C 003C                423          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001484  E60A                     424          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001486                           425                  
00001486                           426          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001486  4283                     427          CLR.L   D3
00001488  3607                     428          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000148A  C67C 0007                429          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000148E                           430          
0000148E  4EF9 00001494            431          JMP     EA_ADDI
00001494                           432  
00001494                           433  EA_ADDI
00001494                           434          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
00001494                           435          *and D3 holds the EA register.
00001494                           436          
00001494                           437          *Determine how much data to read in, depending on the size of the operation
00001494                           438          *output the size of the operation and the immediate data to console
00001494  4EB9 000016E6            439          JSR     WrapperSizeImmediate
0000149A                           440          
0000149A                           441          *manually output a comma here...
0000149A  43F9 000021E3            442          LEA     Comma,A1        *Loads Comma into address register A1
000014A0  103C 000E                443          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014A4  4E4F                     444          TRAP    #15             *Displays Message        
000014A6                           445          
000014A6                           446          *Determine which EA mode and thus Register/Mem Address this instruction used
000014A6  B43C 0000                447          CMP.B   #$00,D2
000014AA  6700 02BC                448          BEQ     DataRegMode *If EA mode is a data register, output that
000014AE                           449          
000014AE  B43C 0002                450          CMP.B   #$02,D2
000014B2  6700 02C4                451          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014B6                           452          
000014B6  B43C 0003                453          CMP.B   #$03,D2
000014BA  6700 02CC                454          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014BE                           455          
000014BE  B43C 0004                456          CMP.B   #$04,D2
000014C2  6700 02CE                457          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014C6                           458          
000014C6  B43C 0007                459          CMP.B   #$07,D2
000014CA  6700 02D0                460          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014CE                           461          
000014CE                           462          *If the ea mode isn't equal to any of these, it is an invalid EA
000014CE  4EF9 00001B22            463          JMP     BADEACODE                               
000014D4                           464          
000014D4                           465  
000014D4                           466  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000014D4                           467  IS_ANDI
000014D4                           468          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014D4                           469          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014D4  4281                     470          CLR.L   D1
000014D6  3207                     471          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014D8  C27C 00C0                472          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014DC  EC09                     473          LSR.B   #$06,D1     *Shift the size bits into LSB
000014DE                           474          
000014DE  B23C 0003                475          CMP.B   #$03,D1     *Compare the size bits to $3
000014E2  6700 062E                476          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014E6                           477          
000014E6                           478          *Output 'ANDI' to console...
000014E6  43F9 000020D5            479          LEA     ANDI,A1     *Loads ANDI into address register A1
000014EC  103C 000E                480          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014F0  4E4F                     481          TRAP    #15         *Displays Message
000014F2                           482          
000014F2                           483          
000014F2                           484          *Should have a valid ANDI op code. Set data up for EA.
000014F2                           485          
000014F2                           486          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014F2  4282                     487          CLR.L   D2
000014F4  3407                     488          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014F6  C47C 003C                489          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000014FA  E60A                     490          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000014FC                           491                  
000014FC                           492          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000014FC  4283                     493          CLR.L   D3
000014FE  3607                     494          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001500  C67C 0007                495          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001504                           496          
00001504  4EF9 0000150A            497          JMP     EA_ANDI
0000150A                           498  
0000150A                           499  EA_ANDI
0000150A                           500          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
0000150A                           501          *and D3 holds the EA register.
0000150A                           502          
0000150A                           503          *Determine how much data to read in, depending on the size of the operation
0000150A                           504          *output the size of the operation and the immediate data to console
0000150A  4EB9 000016E6            505          JSR     WrapperSizeImmediate
00001510                           506          
00001510                           507          *manually output a comma here...
00001510  43F9 000021E3            508          LEA     Comma,A1        *Loads Comma into address register A1
00001516  103C 000E                509          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000151A  4E4F                     510          TRAP    #15             *Displays Message        
0000151C                           511          
0000151C                           512          *Determine which EA mode and thus Register/Mem Address this instruction used
0000151C  B43C 0000                513          CMP.B   #$00,D2
00001520  6700 0246                514          BEQ     DataRegMode *If EA mode is a data register, output that
00001524                           515          
00001524  B43C 0002                516          CMP.B   #$02,D2
00001528  6700 024E                517          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000152C                           518          
0000152C  B43C 0003                519          CMP.B   #$03,D2
00001530  6700 0256                520          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001534                           521          
00001534  B43C 0004                522          CMP.B   #$04,D2
00001538  6700 0258                523          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000153C                           524          
0000153C  B43C 0007                525          CMP.B   #$07,D2
00001540  6700 025A                526          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001544                           527          
00001544                           528          *If the ea mode isn't equal to any of these, it is an invalid EA
00001544  4EF9 00001B22            529          JMP     BADEACODE
0000154A                           530          
0000154A                           531  
0000154A                           532  *Now we know this instruction is exactly EORI, lets set everything up for EA.
0000154A                           533  IS_EORI
0000154A                           534          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000154A                           535          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000154A  4281                     536          CLR.L   D1
0000154C  3207                     537          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000154E  C27C 00C0                538          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001552  EC09                     539          LSR.B   #$06,D1     *Shift the size bits into LSB
00001554                           540          
00001554  B23C 0003                541          CMP.B   #$03,D1     *Compare the size bits to $3
00001558  6700 05B8                542          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000155C                           543          
0000155C                           544          *Output 'EORI' to console...
0000155C  43F9 000020DA            545          LEA     EORI,A1     *Loads EORI into address register A1
00001562  103C 000E                546          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001566  4E4F                     547          TRAP    #15         *Displays Message
00001568                           548          
00001568                           549          
00001568                           550          *Should have a valid EORI op code. Set data up for EA.
00001568                           551          
00001568                           552          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001568  4282                     553          CLR.L   D2
0000156A  3407                     554          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000156C  C47C 003C                555          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001570  E60A                     556          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001572                           557                  
00001572                           558          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001572  4283                     559          CLR.L   D3
00001574  3607                     560          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001576  C67C 0007                561          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000157A                           562          
0000157A  4EF9 00001580            563          JMP     EA_EORI
00001580                           564  
00001580                           565  EA_EORI
00001580                           566          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
00001580                           567          *and D3 holds the EA register.
00001580                           568          
00001580                           569          *Determine how much data to read in, depending on the size of the operation
00001580                           570          *output the size of the operation and the immediate data to console
00001580  4EB9 000016E6            571          JSR     WrapperSizeImmediate
00001586                           572          
00001586                           573          *manually output a comma here...
00001586  43F9 000021E3            574          LEA     Comma,A1        *Loads Comma into address register A1
0000158C  103C 000E                575          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001590  4E4F                     576          TRAP    #15             *Displays Message        
00001592                           577          
00001592                           578          *Determine which EA mode and thus Register/Mem Address this instruction used
00001592  B43C 0000                579          CMP.B   #$00,D2
00001596  6700 01D0                580          BEQ     DataRegMode *If EA mode is a data register, output that
0000159A                           581          
0000159A  B43C 0002                582          CMP.B   #$02,D2
0000159E  6700 01D8                583          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015A2                           584          
000015A2  B43C 0003                585          CMP.B   #$03,D2
000015A6  6700 01E0                586          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015AA                           587          
000015AA  B43C 0004                588          CMP.B   #$04,D2
000015AE  6700 01E2                589          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015B2                           590          
000015B2  B43C 0007                591          CMP.B   #$07,D2
000015B6  6700 01E4                592          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015BA                           593          
000015BA                           594          *If the ea mode isn't equal to any of these, it is an invalid EA
000015BA  4EF9 00001B22            595          JMP     BADEACODE
000015C0                           596  
000015C0                           597  
000015C0                           598  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015C0                           599  * everything up for EA if is a legit instruction.
000015C0                           600  IS_BCHG_D
000015C0                           601          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015C0                           602          *invalid, branch to BADOPCODE
000015C0  3007                     603          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015C2  0800 0007                604          BTST.L  #$07,D0
000015C6  6600 054A                605          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015CA  0800 0006                606          BTST.L  #$06,D0
000015CE  6700 0542                607          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000015D2                           608          
000015D2                           609          *Output 'BCHG' to console...
000015D2  43F9 000020DF            610          LEA     BCHG,A1         *Loads BCHG into address register A1
000015D8  103C 000E                611          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015DC  4E4F                     612          TRAP    #15             *Displays Message
000015DE                           613                  
000015DE                           614                  
000015DE                           615          *Should have a valid BCHG op code. Set data up for EA.
000015DE                           616  
000015DE                           617          *Set D1 to the EA source register located in bits 11-9 of the instruction
000015DE  4281                     618          CLR.L   D1
000015E0  3207                     619          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015E2  C27C 0E00                620          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
000015E6  E009                     621          LSR.B   #$08,D1     *Shift the EA source register bits into LSB
000015E8  E209                     622          LSR.B   #$01,D1
000015EA                           623  
000015EA                           624          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015EA  4282                     625          CLR.L   D2
000015EC  3407                     626          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000015EE  C47C 003C                627          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000015F2  E60A                     628          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000015F4                           629                  
000015F4                           630          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000015F4  4283                     631          CLR.L   D3
000015F6  3607                     632          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000015F8  C67C 0007                633          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000015FC                           634  
000015FC  4EF9 00001602            635          JMP     EA_BCHG_D
00001602                           636  
00001602                           637  EA_BCHG_D
00001602                           638          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001602                           639          *D2 holds the EA mode, and D3 holds the EA register.
00001602                           640          
00001602                           641          *output the source register to console, flag D6 with a 1 so we come back...
00001602  48E7 0200                642          MOVEM.L  D6,-(SP)   *Push current contents of D6 into stack (line counter)
00001606  1C3C 0001                643          MOVE.B  #$01,D6
0000160A  4EB9 00001768            644          JSR     DataRegMode
00001610  4CDF 0040                645          MOVEM.L (SP)+,D6    *Pull current contents of stack back into D6
00001614                           646          
00001614                           647          *manually output a comma here...
00001614  43F9 000021E3            648          LEA     Comma,A1        *Loads Comma into address register A1
0000161A  103C 000E                649          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000161E  4E4F                     650          TRAP    #15             *Displays Message
00001620                           651          
00001620                           652          *Determine which EA mode and thus Register/Mem Address this instruction used
00001620  B43C 0000                653          CMP.B   #$00,D2
00001624  6700 0142                654          BEQ     DataRegMode *If EA mode is a data register, output that
00001628                           655          
00001628  B43C 0002                656          CMP.B   #$02,D2
0000162C  6700 014A                657          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001630                           658          
00001630  B43C 0003                659          CMP.B   #$03,D2
00001634  6700 0152                660          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001638                           661          
00001638  B43C 0004                662          CMP.B   #$04,D2
0000163C  6700 0154                663          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001640                           664          
00001640  B43C 0007                665          CMP.B   #$07,D2
00001644  6700 0156                666          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001648                           667          
00001648                           668          *If the ea mode isn't equal to any of these, it is an invalid EA
00001648  4EF9 00001B22            669          JMP     BADEACODE
0000164E                           670  
0000164E                           671  
0000164E                           672  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
0000164E                           673  IS_BCHG_S
0000164E                           674          *TODO:Verify bits
0000164E                           675  
0000164E                           676          *Output 'BCHG' to console...
0000164E  43F9 000020DF            677          LEA     BCHG,A1 *Loads FNDBCHG_S into address register A1
00001654  103C 000E                678          MOVE.B  #14,D0  *Moves the number 14 into data register D0
00001658  4E4F                     679          TRAP    #15     *Displays Message
0000165A                           680          
0000165A                           681          *Should have a valid BCHG_S op code. Set data up for EA.
0000165A                           682          *TODO:
0000165A  163C 000E                683          MOVE.B  #14,D3
0000165E  4EF9 00001664            684          JMP     EA_BCHG_S
00001664                           685  
00001664                           686  EA_BCHG_S
00001664  4EF9 00001B36            687          JMP     THEEND  *For now just end
0000166A                           688  
0000166A                           689  
0000166A                           690  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
0000166A                           691  IS_CMPI
0000166A                           692          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000166A                           693          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000166A  4281                     694          CLR.L   D1
0000166C  3207                     695          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000166E  C27C 00C0                696          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001672  EC09                     697          LSR.B   #$06,D1     *Shift the size bits into LSB
00001674                           698          
00001674  B23C 0003                699          CMP.B   #$03,D1     *Compare the size bits to $3
00001678  6700 0498                700          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000167C                           701          
0000167C                           702          *Output 'CMPI' to console...
0000167C  43F9 000020E4            703          LEA     CMPI,A1     *Loads CMPI into address register A1
00001682  103C 000E                704          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001686  4E4F                     705          TRAP    #15         *Displays Message
00001688                           706          
00001688                           707          
00001688                           708          *Should have a valid CMPI op code. Set data up for EA.
00001688                           709          
00001688                           710          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001688  4282                     711          CLR.L   D2
0000168A  3407                     712          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000168C  C47C 003C                713          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001690  E60A                     714          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001692                           715                  
00001692                           716          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001692  4283                     717          CLR.L   D3
00001694  3607                     718          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001696  C67C 0007                719          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000169A                           720          
0000169A  4EF9 000016A0            721          JMP     EA_CMPI
000016A0                           722  
000016A0                           723  EA_CMPI
000016A0                           724          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
000016A0                           725          *and D3 holds the EA register.
000016A0                           726          
000016A0                           727          *Determine how much data to read in, depending on the size of the operation
000016A0                           728          *output the size of the operation and the immediate data to console
000016A0  4EB9 000016E6            729          JSR     WrapperSizeImmediate
000016A6                           730          
000016A6                           731          *manually output a comma here...
000016A6  43F9 000021E3            732          LEA     Comma,A1        *Loads Comma into address register A1
000016AC  103C 000E                733          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016B0  4E4F                     734          TRAP    #15             *Displays Message
000016B2                           735          
000016B2                           736          *Determine which EA mode and thus Register/Mem Address this instruction used
000016B2  B43C 0000                737          CMP.B   #$00,D2
000016B6  6700 00B0                738          BEQ     DataRegMode *If EA mode is a data register, output that
000016BA                           739          
000016BA  B43C 0002                740          CMP.B   #$02,D2
000016BE  6700 00B8                741          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016C2                           742          
000016C2  B43C 0003                743          CMP.B   #$03,D2
000016C6  6700 00C0                744          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016CA                           745          
000016CA  B43C 0004                746          CMP.B   #$04,D2
000016CE  6700 00C2                747          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000016D2                           748          
000016D2  B43C 0007                749          CMP.B   #$07,D2
000016D6  6700 00C4                750          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000016DA                           751          
000016DA                           752          *If the ea mode isn't equal to any of these, it is an invalid EA
000016DA  4EF9 00001B22            753          JMP     BADEACODE
000016E0                           754  
000016E0                           755          
000016E0                           756  *STARTS WITH 0001, MOVE.B-----------------------------------
000016E0                           757  BUCKET_0001
000016E0  =00000001                758  BUCKET0001_BITS EQU $1
000016E0                           759          
000016E0                           760          *some code...
000016E0                           761  
000016E0                           762  
000016E0                           763  *STARTS WITH 0010, MOVE.L-----------------------------------
000016E0                           764  BUCKET_0010
000016E0  =00000002                765  BUCKET0010_BITS EQU $2
000016E0                           766  
000016E0                           767          *some code...
000016E0                           768  
000016E0                           769  
000016E0                           770  *STARTS WITH 0011, MOVE.W-----------------------------------
000016E0                           771  BUCKET_0011
000016E0  =00000003                772  BUCKET0011_BITS EQU $3
000016E0                           773  
000016E0                           774          *some code...
000016E0                           775  
000016E0                           776  
000016E0                           777  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
000016E0                           778  BUCKET_0100
000016E0  =00000004                779  BUCKET0100_BITS EQU $4
000016E0                           780  
000016E0                           781          *some code...
000016E0                           782  
000016E0                           783  
000016E0                           784  *STARTS WITH 0101, SUBQ-------------------------------------
000016E0                           785  BUCKET_0101
000016E0  =00000005                786  BUCKET0101_BITS EQU $5
000016E0                           787  
000016E0                           788          *some code...
000016E0                           789  
000016E0                           790  
000016E0                           791  *STARTS WITH 0110, BCC--------------------------------------
000016E0                           792  BUCKET_0110
000016E0  =00000006                793  BUCKET0110_BITS EQU $6
000016E0                           794  
000016E0                           795          *some code...
000016E0                           796  
000016E0                           797  
000016E0                           798  *STARTS WITH 1000, DIVU-------------------------------------
000016E0                           799  BUCKET_1000
000016E0  =00000008                800  BUCKET1000_BITS EQU $8
000016E0                           801  
000016E0                           802          *some code...
000016E0                           803  
000016E0                           804  
000016E0                           805  *STARTS WITH 1001, SUBA-------------------------------------
000016E0                           806  BUCKET_1001
000016E0  =00000009                807  BUCKET1001_BITS EQU $9
000016E0                           808  
000016E0                           809          *some code...
000016E0                           810  
000016E0                           811  
000016E0                           812  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000016E0                           813  BUCKET_1011
000016E0  =0000000B                814  BUCKET1011_BITS EQU $B
000016E0                           815  
000016E0                           816          *some code...
000016E0                           817  
000016E0                           818  
000016E0                           819  *STARTS WITH 1100, MULS(W) | AND----------------------------
000016E0                           820  BUCKET_1100
000016E0  =0000000C                821  BUCKET1100_BITS EQU $C
000016E0                           822  
000016E0                           823          *some code...
000016E0                           824  
000016E0                           825  
000016E0                           826  *STARTS WITH 1101, ADD | ADDA-------------------------------
000016E0                           827  BUCKET_1101
000016E0  =0000000D                828  BUCKET1101_BITS EQU $D
000016E0                           829  
000016E0                           830          *some code...
000016E0                           831  
000016E0                           832  
000016E0                           833  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000016E0                           834  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000016E0                           835  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000016E0                           836  BUCKET_1110
000016E0  =0000000E                837  BUCKET1110_BITS EQU $E     
000016E0                           838  
000016E0                           839          *some code...
000016E0                           840  
000016E0                           841  
000016E0                           842  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000016E0                           843  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000016E0  4EF9 00001B12            844          JMP     BADOPCODE  
000016E6                           845          
000016E6                           846  
000016E6                           847  *-----------------------------------------------------------        
000016E6                           848  * EA operation size decoding functionality
000016E6                           849  *-----------------------------------------------------------   
000016E6                           850  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
000016E6                           851  WrapperSizeImmediate
000016E6  4284                     852          CLR.L   D4
000016E8                           853          *Depending on the EA Register, choose which size to decode
000016E8  B23C 0000                854          CMP.B   #$00,D1
000016EC  6700 0014                855          BEQ     ByteSizeImmediate
000016F0                           856          
000016F0  B23C 0001                857          CMP.B   #$01,D1
000016F4  6700 002E                858          BEQ     WordSizeImmediate
000016F8                           859  
000016F8  B23C 0002                860          CMP.B   #$02,D1
000016FC  6700 0048                861          BEQ     LongSizeImmediate
00001700                           862          
00001700                           863  *Used to get back to what we were doing, after dealing with the specific size
00001700                           864  WrapperSizeImmediateEnd
00001700  4E75                     865          RTS
00001702                           866          
00001702                           867  ByteSizeImmediate
00001702  3818                     868          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
00001704                           869          
00001704                           870          *Output '.B' to console...
00001704  43F9 000020E9            871          LEA     ByteSize,A1 *Loads ByteSize into address register A1
0000170A  103C 000E                872          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000170E  4E4F                     873          TRAP    #15         *Displays Message
00001710                           874          
00001710                           875          *Output '#$' just before the immediate data
00001710  43F9 000021E8            876          LEA     ShaBang,A1
00001716  103C 000E                877          MOVE.B  #14,D0
0000171A  4E4F                     878          TRAP    #15  
0000171C                           879          
0000171C                           880          *output the immediate data to console with the hex-ascii converter
0000171C  4EB8 11E0                881          JSR     HEXASCII
00001720                           882                  
00001720  4EF8 1700                883          JMP     WrapperSizeImmediateEnd
00001724                           884                  
00001724                           885  WordSizeImmediate
00001724  3818                     886          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001726                           887          
00001726                           888          *Output '.W' to console...
00001726  43F9 000020F0            889          LEA     WordSize,A1 *Loads WordSize into address register A1
0000172C  103C 000E                890          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001730  4E4F                     891          TRAP    #15         *Displays Message
00001732                           892          
00001732                           893          *Output '#$' just before the immediate data
00001732  43F9 000021E8            894          LEA     ShaBang,A1
00001738  103C 000E                895          MOVE.B  #14,D0
0000173C  4E4F                     896          TRAP    #15  
0000173E                           897          
0000173E                           898          *output the immediate data to console with the hex-ascii converter
0000173E  4EB8 11E0                899          JSR     HEXASCII
00001742                           900          
00001742  4EF8 1700                901          JMP     WrapperSizeImmediateEnd
00001746                           902                  
00001746                           903  LongSizeImmediate
00001746  2818                     904          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
00001748                           905          
00001748                           906          *Output '.L' to console...
00001748  43F9 000020F7            907          LEA     LongSize,A1 *Loads LongSize into address register A1
0000174E  103C 000E                908          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001752  4E4F                     909          TRAP    #15         *Displays Message
00001754                           910          
00001754                           911          *Output '#$' just before the immediate data
00001754  43F9 000021E8            912          LEA     ShaBang,A1
0000175A  103C 000E                913          MOVE.B  #14,D0
0000175E  4E4F                     914          TRAP    #15  
00001760                           915          
00001760                           916          *output the immediate data to console with the hex-ascii converter
00001760  4EB8 11E0                917          JSR     HEXASCII
00001764                           918          
00001764  4EF8 1700                919          JMP     WrapperSizeImmediateEnd
00001768                           920  
00001768                           921  
00001768                           922  *-----------------------------------------------------------        
00001768                           923  * EA Mode/EA Register decoding functionality
00001768                           924  *-----------------------------------------------------------        
00001768                           925  DataRegMode
00001768                           926          *Depending on the EA Register, output a different register number
00001768  4EB9 000017A6            927          JSR     WrapperDataReg        
0000176E                           928          
0000176E                           929          *if this was called for a destination decoding then we are done decoding this        
0000176E                           930          *instruction, go get the next instruction
0000176E  BC3C 0001                931          CMP.B   #$01,D6
00001772  6600 FBF2                932          BNE     GRAB_NEXT_OP
00001776                           933          
00001776                           934          *else this was a source decoding, rts back to we can keep decoding
00001776  4E75                     935          RTS
00001778                           936  
00001778                           937  AddrDirectMode
00001778                           938          *some code...
00001778                           939  
00001778                           940  AddrIndirectMode
00001778                           941          *Depending on the EA Register, output a different register number
00001778  4EB9 00001868            942          JSR     WrapperAddrIndirect
0000177E                           943                          
0000177E                           944          *if this was called for a destination decoding then we are done decoding this        
0000177E                           945          *instruction, go get the next instruction
0000177E  BC3C 0001                946          CMP.B   #$01,D6
00001782  6600 FBE2                947          BNE     GRAB_NEXT_OP
00001786                           948          
00001786                           949          *else this was a source decoding, rts back to we can keep decoding
00001786  4E75                     950          RTS
00001788                           951  
00001788                           952  AddrIndirectPostMode
00001788                           953          *Depending on the EA Register, output a different register number
00001788  4EB9 0000192A            954          JSR     WrapperAddrIndirectPost
0000178E                           955  
0000178E                           956          *need to read some flag, if this was called from a source EA decoding then jmp to 
0000178E                           957          *some wrapper (i'll define later)
0000178E                           958          
0000178E                           959          *else this was a destination EA decoding, we can just go get the next instruction
0000178E                           960          *since there is no more decoding to do for the current instruction
0000178E  4EF8 1366                961          JMP     GRAB_NEXT_OP
00001792                           962  
00001792                           963  AddrIndirectPreMode
00001792                           964          *Depending on the EA Register, output a different register number
00001792  4EB9 000019EC            965          JSR     WrapperAddrIndirectPre
00001798                           966  
00001798                           967          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001798                           968          *some wrapper (i'll define later)
00001798                           969          
00001798                           970          *else this was a destination EA decoding, we can just go get the next instruction
00001798                           971          *since there is no more decoding to do for the current instruction
00001798  4EF8 1366                972          JMP     GRAB_NEXT_OP
0000179C                           973  
0000179C                           974  AddrAbsoluteMode
0000179C                           975          *Depending on the EA Register, output a different register number
0000179C  4EB9 00001AAE            976          JSR     WrapperAddrAbsolute        
000017A2                           977  
000017A2                           978          *need to read some flag, if this was called from a source EA decoding then jmp to 
000017A2                           979          *some wrapper (i'll define later)
000017A2                           980          
000017A2                           981          *else this was a destination EA decoding, we can just go get the next instruction
000017A2                           982          *since there is no more decoding to do for the current instruction
000017A2  4EF8 1366                983          JMP     GRAB_NEXT_OP
000017A6                           984          
000017A6                           985  ImmediateDataMode
000017A6                           986          *some code        
000017A6                           987          
000017A6                           988          
000017A6                           989  *-----------------------------------------------------------        
000017A6                           990  * Output logic for all Data Registers (0-7)
000017A6                           991  *-----------------------------------------------------------
000017A6                           992  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000017A6                           993  WrapperDataReg
000017A6                           994          *Depending on the EA destination register, output a different register number
000017A6  B63C 0000                995          CMP.B   #$00,D3
000017AA  6700 003C                996          BEQ     DataReg0
000017AE                           997          
000017AE  B63C 0001                998          CMP.B   #$01,D3
000017B2  6700 0044                999          BEQ     DataReg1
000017B6                          1000          
000017B6  B63C 0002               1001          CMP.B   #$02,D3
000017BA  6700 004C               1002          BEQ     DataReg2
000017BE                          1003          
000017BE  B63C 0003               1004          CMP.B   #$03,D3
000017C2  6700 0054               1005          BEQ     DataReg3
000017C6                          1006          
000017C6  B63C 0004               1007          CMP.B   #$04,D3
000017CA  6700 005C               1008          BEQ     DataReg4
000017CE                          1009          
000017CE  B63C 0005               1010          CMP.B   #$05,D3
000017D2  6700 0064               1011          BEQ     DataReg5
000017D6                          1012          
000017D6  B63C 0006               1013          CMP.B   #$06,D3
000017DA  6700 006C               1014          BEQ     DataReg6
000017DE                          1015          
000017DE  B63C 0007               1016          CMP.B   #$07,D3
000017E2  6700 0074               1017          BEQ     DataReg7        
000017E6                          1018  
000017E6                          1019  *Used to get back to 'DataRegMode', after dealing with the specific register
000017E6                          1020  WrapperDataRegEnd
000017E6  4E75                    1021          RTS
000017E8                          1022  
000017E8                          1023  DataReg0
000017E8                          1024          *Output the specific data register...
000017E8  43F9 000020FE           1025          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
000017EE  103C 000E               1026          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000017F2  4E4F                    1027          TRAP    #15             *Displays Message   
000017F4                          1028          
000017F4  4EF8 17E6               1029          JMP     WrapperDataRegEnd
000017F8                          1030  
000017F8                          1031  DataReg1
000017F8  43F9 00002103           1032          LEA     OutDataReg1,A1
000017FE  103C 000E               1033          MOVE.B  #14,D0
00001802  4E4F                    1034          TRAP    #15
00001804                          1035          
00001804  4EF8 17E6               1036          JMP     WrapperDataRegEnd
00001808                          1037  
00001808                          1038  DataReg2
00001808  43F9 00002108           1039          LEA     OutDataReg2,A1
0000180E  103C 000E               1040          MOVE.B  #14,D0
00001812  4E4F                    1041          TRAP    #15
00001814                          1042  
00001814  4EF8 17E6               1043          JMP     WrapperDataRegEnd
00001818                          1044      
00001818                          1045  DataReg3
00001818  43F9 0000210D           1046          LEA     OutDataReg3,A1
0000181E  103C 000E               1047          MOVE.B  #14,D0
00001822  4E4F                    1048          TRAP    #15
00001824                          1049  
00001824  4EF8 17E6               1050          JMP     WrapperDataRegEnd
00001828                          1051          
00001828                          1052  DataReg4
00001828  43F9 00002112           1053          LEA     OutDataReg4,A1
0000182E  103C 000E               1054          MOVE.B  #14,D0
00001832  4E4F                    1055          TRAP    #15
00001834                          1056  
00001834  4EF8 17E6               1057          JMP     WrapperDataRegEnd
00001838                          1058                 
00001838                          1059  DataReg5
00001838  43F9 00002117           1060          LEA     OutDataReg5,A1
0000183E  103C 000E               1061          MOVE.B  #14,D0
00001842  4E4F                    1062          TRAP    #15
00001844                          1063  
00001844  4EF8 17E6               1064          JMP     WrapperDataRegEnd
00001848                          1065          
00001848                          1066  DataReg6
00001848  43F9 0000211C           1067          LEA     OutDataReg6,A1 A1
0000184E  103C 000E               1068          MOVE.B  #14,D0
00001852  4E4F                    1069          TRAP    #15
00001854                          1070  
00001854  4EF8 17E6               1071          JMP     WrapperDataRegEnd
00001858                          1072          
00001858                          1073  DataReg7
00001858  43F9 00002121           1074          LEA     OutDataReg7,A1
0000185E  103C 000E               1075          MOVE.B  #14,D0
00001862  4E4F                    1076          TRAP    #15
00001864                          1077          
00001864  4EF8 17E6               1078          JMP     WrapperDataRegEnd
00001868                          1079  
00001868                          1080  
00001868                          1081  *-----------------------------------------------------------        
00001868                          1082  * Output logic for all Address Indirect Registers (0-7)
00001868                          1083  *-----------------------------------------------------------     
00001868                          1084  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001868                          1085  WrapperAddrIndirect
00001868                          1086          *Depending on the EA Register, output a different register number
00001868  B63C 0000               1087          CMP.B   #$00,D3
0000186C  6700 003C               1088          BEQ     AddrIndReg0
00001870                          1089          
00001870  B63C 0001               1090          CMP.B   #$01,D3
00001874  6700 0044               1091          BEQ     AddrIndReg1
00001878                          1092          
00001878  B63C 0002               1093          CMP.B   #$02,D3
0000187C  6700 004C               1094          BEQ     AddrIndReg2
00001880                          1095          
00001880  B63C 0003               1096          CMP.B   #$03,D3
00001884  6700 0054               1097          BEQ     AddrIndReg3
00001888                          1098          
00001888  B63C 0004               1099          CMP.B   #$04,D3
0000188C  6700 005C               1100          BEQ     AddrIndReg4
00001890                          1101          
00001890  B63C 0005               1102          CMP.B   #$05,D3
00001894  6700 0064               1103          BEQ     AddrIndReg5
00001898                          1104          
00001898  B63C 0006               1105          CMP.B   #$06,D3
0000189C  6700 006C               1106          BEQ     AddrIndReg6
000018A0                          1107          
000018A0  B63C 0007               1108          CMP.B   #$07,D3
000018A4  6700 0074               1109          BEQ     AddrIndReg7
000018A8                          1110  
000018A8                          1111  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
000018A8                          1112  WrapperAddrIndirectEnd
000018A8  4E75                    1113          RTS        
000018AA                          1114  
000018AA                          1115  AddrIndReg0
000018AA                          1116          *Output the specific address indirect register...
000018AA  43F9 00002126           1117          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
000018B0  103C 000E               1118          MOVE.B  #14,D0              *Moves the number 14 into data register D0
000018B4  4E4F                    1119          TRAP    #15                 *Displays Message        
000018B6                          1120          
000018B6  4EF8 18A8               1121          JMP     WrapperAddrIndirectEnd
000018BA                          1122  
000018BA                          1123  AddrIndReg1
000018BA  43F9 0000212D           1124          LEA     OutAddrIndReg1,A1
000018C0  103C 000E               1125          MOVE.B  #14,D0
000018C4  4E4F                    1126          TRAP    #15
000018C6                          1127          
000018C6  4EF8 18A8               1128          JMP     WrapperAddrIndirectEnd
000018CA                          1129  
000018CA                          1130  AddrIndReg2
000018CA  43F9 00002134           1131          LEA     OutAddrIndReg2,A1
000018D0  103C 000E               1132          MOVE.B  #14,D0
000018D4  4E4F                    1133          TRAP    #15
000018D6                          1134          
000018D6  4EF8 18A8               1135          JMP     WrapperAddrIndirectEnd
000018DA                          1136  
000018DA                          1137  AddrIndReg3
000018DA  43F9 0000213B           1138          LEA     OutAddrIndReg3,A1
000018E0  103C 000E               1139          MOVE.B  #14,D0
000018E4  4E4F                    1140          TRAP    #15
000018E6                          1141          
000018E6  4EF8 18A8               1142          JMP     WrapperAddrIndirectEnd
000018EA                          1143  
000018EA                          1144  AddrIndReg4
000018EA  43F9 00002142           1145          LEA     OutAddrIndReg4,A1
000018F0  103C 000E               1146          MOVE.B  #14,D0
000018F4  4E4F                    1147          TRAP    #15
000018F6                          1148          
000018F6  4EF8 18A8               1149          JMP     WrapperAddrIndirectEnd
000018FA                          1150  
000018FA                          1151  AddrIndReg5
000018FA  43F9 00002149           1152          LEA     OutAddrIndReg5,A1
00001900  103C 000E               1153          MOVE.B  #14,D0
00001904  4E4F                    1154          TRAP    #15
00001906                          1155          
00001906  4EF8 18A8               1156          JMP     WrapperAddrIndirectEnd
0000190A                          1157  
0000190A                          1158  AddrIndReg6
0000190A  43F9 00002150           1159          LEA     OutAddrIndReg6,A1
00001910  103C 000E               1160          MOVE.B  #14,D0
00001914  4E4F                    1161          TRAP    #15
00001916                          1162          
00001916  4EF8 18A8               1163          JMP     WrapperAddrIndirectEnd
0000191A                          1164  
0000191A                          1165  AddrIndReg7
0000191A  43F9 00002157           1166          LEA     OutAddrIndReg7,A1
00001920  103C 000E               1167          MOVE.B  #14,D0
00001924  4E4F                    1168          TRAP    #15
00001926                          1169          
00001926  4EF8 18A8               1170          JMP     WrapperAddrIndirectEnd
0000192A                          1171          
0000192A                          1172          
0000192A                          1173  *-----------------------------------------------------------        
0000192A                          1174  * Output logic for all Address Indirect Post Increment Registers (0-7)
0000192A                          1175  *-----------------------------------------------------------     
0000192A                          1176  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
0000192A                          1177  WrapperAddrIndirectPost
0000192A                          1178          *Depending on the EA Register, output a different register number
0000192A  B63C 0000               1179          CMP.B   #$00,D3
0000192E  6700 003C               1180          BEQ     AddrIndPoReg0
00001932                          1181          
00001932  B63C 0001               1182          CMP.B   #$01,D3
00001936  6700 0044               1183          BEQ     AddrIndPoReg1
0000193A                          1184          
0000193A  B63C 0002               1185          CMP.B   #$02,D3
0000193E  6700 004C               1186          BEQ     AddrIndPoReg2
00001942                          1187          
00001942  B63C 0003               1188          CMP.B   #$03,D3
00001946  6700 0054               1189          BEQ     AddrIndPoReg3
0000194A                          1190          
0000194A  B63C 0004               1191          CMP.B   #$04,D3
0000194E  6700 005C               1192          BEQ     AddrIndPoReg4
00001952                          1193          
00001952  B63C 0005               1194          CMP.B   #$05,D3
00001956  6700 0064               1195          BEQ     AddrIndPoReg5
0000195A                          1196          
0000195A  B63C 0006               1197          CMP.B   #$06,D3
0000195E  6700 006C               1198          BEQ     AddrIndPoReg6
00001962                          1199          
00001962  B63C 0007               1200          CMP.B   #$07,D3
00001966  6700 0074               1201          BEQ     AddrIndPoReg7
0000196A                          1202  
0000196A                          1203  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
0000196A                          1204  WrapperAddrIndirectPostEnd
0000196A  4E75                    1205          RTS        
0000196C                          1206  
0000196C                          1207  AddrIndPoReg0
0000196C                          1208          *Output the specific address indirect post register...
0000196C  43F9 0000215E           1209          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001972  103C 000E               1210          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001976  4E4F                    1211          TRAP    #15                 *Displays Message        
00001978                          1212          
00001978  4EF8 196A               1213          JMP     WrapperAddrIndirectPostEnd
0000197C                          1214  
0000197C                          1215  AddrIndPoReg1
0000197C  43F9 00002166           1216          LEA     OutAddrIndPoReg1,A1
00001982  103C 000E               1217          MOVE.B  #14,D0
00001986  4E4F                    1218          TRAP    #15
00001988                          1219          
00001988  4EF8 196A               1220          JMP     WrapperAddrIndirectPostEnd
0000198C                          1221  
0000198C                          1222  AddrIndPoReg2
0000198C  43F9 0000216E           1223          LEA     OutAddrIndPoReg2,A1
00001992  103C 000E               1224          MOVE.B  #14,D0
00001996  4E4F                    1225          TRAP    #15
00001998                          1226          
00001998  4EF8 196A               1227          JMP     WrapperAddrIndirectPostEnd
0000199C                          1228  
0000199C                          1229  AddrIndPoReg3
0000199C  43F9 00002176           1230          LEA     OutAddrIndPoReg3,A1
000019A2  103C 000E               1231          MOVE.B  #14,D0
000019A6  4E4F                    1232          TRAP    #15
000019A8                          1233          
000019A8  4EF8 196A               1234          JMP     WrapperAddrIndirectPostEnd
000019AC                          1235  
000019AC                          1236  AddrIndPoReg4
000019AC  43F9 0000217E           1237          LEA     OutAddrIndPoReg4,A1
000019B2  103C 000E               1238          MOVE.B  #14,D0
000019B6  4E4F                    1239          TRAP    #15
000019B8                          1240          
000019B8  4EF8 196A               1241          JMP     WrapperAddrIndirectPostEnd
000019BC                          1242  
000019BC                          1243  AddrIndPoReg5
000019BC  43F9 00002186           1244          LEA     OutAddrIndPoReg5,A1
000019C2  103C 000E               1245          MOVE.B  #14,D0
000019C6  4E4F                    1246          TRAP    #15
000019C8                          1247          
000019C8  4EF8 196A               1248          JMP     WrapperAddrIndirectPostEnd
000019CC                          1249  
000019CC                          1250  AddrIndPoReg6
000019CC  43F9 0000218E           1251          LEA     OutAddrIndPoReg6,A1
000019D2  103C 000E               1252          MOVE.B  #14,D0
000019D6  4E4F                    1253          TRAP    #15
000019D8                          1254          
000019D8  4EF8 196A               1255          JMP     WrapperAddrIndirectPostEnd
000019DC                          1256  
000019DC                          1257  AddrIndPoReg7
000019DC  43F9 00002196           1258          LEA     OutAddrIndPoReg7,A1
000019E2  103C 000E               1259          MOVE.B  #14,D0
000019E6  4E4F                    1260          TRAP    #15
000019E8                          1261          
000019E8  4EF8 196A               1262          JMP     WrapperAddrIndirectPostEnd
000019EC                          1263  
000019EC                          1264  
000019EC                          1265  *-----------------------------------------------------------        
000019EC                          1266  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
000019EC                          1267  *-----------------------------------------------------------     
000019EC                          1268  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000019EC                          1269  WrapperAddrIndirectPre
000019EC                          1270          *Depending on the EA Register, output a different register number
000019EC  B63C 0000               1271          CMP.B   #$00,D3
000019F0  6700 003C               1272          BEQ     AddrIndPrReg0
000019F4                          1273          
000019F4  B63C 0001               1274          CMP.B   #$01,D3
000019F8  6700 0044               1275          BEQ     AddrIndPrReg1
000019FC                          1276          
000019FC  B63C 0002               1277          CMP.B   #$02,D3
00001A00  6700 004C               1278          BEQ     AddrIndPrReg2
00001A04                          1279          
00001A04  B63C 0003               1280          CMP.B   #$03,D3
00001A08  6700 0054               1281          BEQ     AddrIndPrReg3
00001A0C                          1282          
00001A0C  B63C 0004               1283          CMP.B   #$04,D3
00001A10  6700 005C               1284          BEQ     AddrIndPrReg4
00001A14                          1285          
00001A14  B63C 0005               1286          CMP.B   #$05,D3
00001A18  6700 0064               1287          BEQ     AddrIndPrReg5
00001A1C                          1288          
00001A1C  B63C 0006               1289          CMP.B   #$06,D3
00001A20  6700 006C               1290          BEQ     AddrIndPrReg6
00001A24                          1291          
00001A24  B63C 0007               1292          CMP.B   #$07,D3
00001A28  6700 0074               1293          BEQ     AddrIndPrReg7
00001A2C                          1294  
00001A2C                          1295  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001A2C                          1296  WrapperAddrIndirectPreEnd
00001A2C  4E75                    1297          RTS        
00001A2E                          1298  
00001A2E                          1299  AddrIndPrReg0
00001A2E                          1300          *Output the specific address indirect post register...
00001A2E  43F9 0000219E           1301          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001A34  103C 000E               1302          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001A38  4E4F                    1303          TRAP    #15                 *Displays Message        
00001A3A                          1304          
00001A3A  4EF8 1A2C               1305          JMP     WrapperAddrIndirectPreEnd
00001A3E                          1306  
00001A3E                          1307  AddrIndPrReg1
00001A3E  43F9 000021A6           1308          LEA     OutAddrIndPrReg1,A1
00001A44  103C 000E               1309          MOVE.B  #14,D0
00001A48  4E4F                    1310          TRAP    #15
00001A4A                          1311          
00001A4A  4EF8 1A2C               1312          JMP     WrapperAddrIndirectPreEnd
00001A4E                          1313  
00001A4E                          1314  AddrIndPrReg2
00001A4E  43F9 000021AE           1315          LEA     OutAddrIndPrReg2,A1
00001A54  103C 000E               1316          MOVE.B  #14,D0
00001A58  4E4F                    1317          TRAP    #15
00001A5A                          1318          
00001A5A  4EF8 1A2C               1319          JMP     WrapperAddrIndirectPreEnd
00001A5E                          1320  
00001A5E                          1321  AddrIndPrReg3
00001A5E  43F9 000021B6           1322          LEA     OutAddrIndPrReg3,A1
00001A64  103C 000E               1323          MOVE.B  #14,D0
00001A68  4E4F                    1324          TRAP    #15
00001A6A                          1325          
00001A6A  4EF8 1A2C               1326          JMP     WrapperAddrIndirectPreEnd
00001A6E                          1327  
00001A6E                          1328  AddrIndPrReg4
00001A6E  43F9 000021BE           1329          LEA     OutAddrIndPrReg4,A1
00001A74  103C 000E               1330          MOVE.B  #14,D0
00001A78  4E4F                    1331          TRAP    #15
00001A7A                          1332          
00001A7A  4EF8 1A2C               1333          JMP     WrapperAddrIndirectPreEnd
00001A7E                          1334  
00001A7E                          1335  AddrIndPrReg5
00001A7E  43F9 000021C6           1336          LEA     OutAddrIndPrReg5,A1
00001A84  103C 000E               1337          MOVE.B  #14,D0
00001A88  4E4F                    1338          TRAP    #15
00001A8A                          1339          
00001A8A  4EF8 1A2C               1340          JMP     WrapperAddrIndirectPreEnd
00001A8E                          1341  
00001A8E                          1342  AddrIndPrReg6
00001A8E  43F9 000021CE           1343          LEA     OutAddrIndPrReg6,A1
00001A94  103C 000E               1344          MOVE.B  #14,D0
00001A98  4E4F                    1345          TRAP    #15
00001A9A                          1346          
00001A9A  4EF8 1A2C               1347          JMP     WrapperAddrIndirectPreEnd
00001A9E                          1348  
00001A9E                          1349  AddrIndPrReg7
00001A9E  43F9 000021D6           1350          LEA     OutAddrIndPrReg7,A1
00001AA4  103C 000E               1351          MOVE.B  #14,D0
00001AA8  4E4F                    1352          TRAP    #15
00001AAA                          1353          
00001AAA  4EF8 1A2C               1354          JMP     WrapperAddrIndirectPreEnd
00001AAE                          1355  
00001AAE                          1356  
00001AAE                          1357  *-----------------------------------------------------------        
00001AAE                          1358  * Output logic for absolute memory addressing (0-7)
00001AAE                          1359  *-----------------------------------------------------------     
00001AAE                          1360  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001AAE                          1361  WrapperAddrAbsolute
00001AAE  4284                    1362          CLR.L   D4
00001AB0                          1363          *Depending on the EA Register, choose which size to decode
00001AB0  B63C 0000               1364          CMP.B   #$00,D3
00001AB4  6700 000C               1365          BEQ     WordSizeAbsolute
00001AB8                          1366  
00001AB8  B63C 0001               1367          CMP.B   #$01,D3
00001ABC  6700 002C               1368          BEQ     LongSizeAbsolute
00001AC0                          1369          
00001AC0                          1370  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001AC0                          1371  WrapperAddrAbsoluteEnd
00001AC0  4E75                    1372          RTS
00001AC2                          1373  
00001AC2                          1374  WordSizeAbsolute        
00001AC2  3818                    1375          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001AC4                          1376          
00001AC4                          1377          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001AC4  4281                    1378          CLR.L   D1
00001AC6  123C 0001               1379          MOVE.B  #$01,D1     
00001ACA                          1380              
00001ACA                          1381          *Output ',$' just after source operand
00001ACA  43F9 000021EB           1382          LEA     Bang,A1
00001AD0  103C 000E               1383          MOVE.B  #14,D0
00001AD4  4E4F                    1384          TRAP    #15
00001AD6                          1385              
00001AD6                          1386          *output the absolute mem address to console with the hex-ascii converter
00001AD6  4EB8 11E0               1387          JSR     HEXASCII
00001ADA                          1388          
00001ADA                          1389          *Print a new line, since this should be the last piece of data for an instruction
00001ADA  43F9 000021E5           1390          LEA     NewLine,A1
00001AE0  103C 000E               1391          MOVE.B  #14,D0
00001AE4  4E4F                    1392          TRAP    #15
00001AE6                          1393          
00001AE6  4EF8 1AC0               1394          JMP     WrapperAddrAbsoluteEnd
00001AEA                          1395  
00001AEA                          1396  LongSizeAbsolute
00001AEA  2818                    1397          MOVE.L  (A0)+,D4    *read in next long, data is that long
00001AEC                          1398                  
00001AEC                          1399          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001AEC  4281                    1400          CLR.L   D1
00001AEE  123C 0010               1401          MOVE.B  #$10,D1
00001AF2                          1402                  
00001AF2                          1403          *Output ',$' just after source operand
00001AF2  43F9 000021EB           1404          LEA     Bang,A1
00001AF8  103C 000E               1405          MOVE.B  #14,D0
00001AFC  4E4F                    1406          TRAP    #15  
00001AFE                          1407          
00001AFE                          1408          *output the absolute mem address to console with the hex-ascii converter
00001AFE  4EB8 11E0               1409          JSR     HEXASCII
00001B02                          1410          
00001B02                          1411          *Print a new line, since this should be the last piece of data for an instruction
00001B02  43F9 000021E5           1412          LEA     NewLine,A1
00001B08  103C 000E               1413          MOVE.B  #14,D0
00001B0C  4E4F                    1414          TRAP    #15
00001B0E                          1415  
00001B0E  4EF8 1AC0               1416          JMP     WrapperAddrAbsoluteEnd
00001B12                          1417          
00001B12                          1418  
00001B12                          1419  *-----------------------------------------------------------        
00001B12                          1420  * Current handling of bad op/ea codes. Should be revisited.
00001B12                          1421  *----------------------------------------------------------- 
00001B12                          1422  BADOPCODE
00001B12                          1423          *We found a bad op code, output some error to the screen, jump to the 
00001B12                          1424          *next instruction in memory.
00001B12                          1425          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001B12                          1426          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001B12                          1427          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001B12                          1428          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001B12                          1429          *i/o and error message code...
00001B12  43F9 000021F6           1430          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001B18  103C 000E               1431          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001B1C  4E4F                    1432          TRAP    #15         *Displays Message
00001B1E  4EF8 1366               1433          JMP     GRAB_NEXT_OP
00001B22                          1434                  
00001B22                          1435  BADEACODE
00001B22                          1436          *We found a bad ea code, output some error to the screen, jump to the
00001B22                          1437          *next instruction in memory.
00001B22                          1438          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001B22                          1439          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001B22  43F9 000021ED           1440          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001B28  103C 000E               1441          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001B2C  4E4F                    1442          TRAP    #15         *Displays Message
00001B2E  4EF8 1366               1443          JMP     GRAB_NEXT_OP
00001B32                          1444          
00001B32                          1445          
00001B32                          1446  *-----------------------------------------------------------        
00001B32                          1447  * End of Disassembler
00001B32                          1448  *-----------------------------------------------------------    
00001B32                          1449  
00001B32  4E72 2700               1450  DONE    STOP    #$2700  *What does this do? Why was it added?
00001B36                          1451  
00001B36  103C 0009               1452  THEEND  MOVE.B  #9,D0
00001B3A  4E4F                    1453          TRAP    #15             Halt Simulator        
00001B3C                          1454          
00001B3C                          1455       
00001B3C                          1456  *-----------------------------------------------------------        
00001B3C                          1457  * Output stuff
00001B3C                          1458  *-----------------------------------------------------------     
00001B3C  =0000000D               1459  CR      EQU     $0D             ASCII code for Carriage Return
00001B3C  =0000000A               1460  LF      EQU     $0A             ASCII code for Line Feed
00001B3C= 2D 2D 2D 2D 2D 2D ...   1461  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001B7B= 7C 7C 20 20 20 20 ...   1462              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001BBA= 2D 2D 2D 2D 2D 2D ...   1463              DC.B    '-------------------------------------------------------------',CR,LF
00001BF9= 2A 2A 2A 2A 2A 2A ...   1464              DC.B    '*************************************************************',CR,LF
00001C38= 2A 2A 2A 2A 2A 2A ...   1465              DC.B    '*************************************************************',CR,LF
00001C77= 2A 2A 2A 2A 2A 2A ...   1466              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001CB6= 2A 2A 2A 2A 2A 2A ...   1467              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001CF5= 2A 2A 2A 2A 2A 2A ...   1468              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001D34= 2A 2A 2A 2A 2A 2A ...   1469              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001D73= 2A 2A 2A 2A 2A 2A ...   1470              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001DB2= 2A 2A 2A 2A 2A 2A ...   1471              DC.B    '*************************************************************',CR,LF
00001DF1= 2A 2A 2A 2A 2A 2A ...   1472              DC.B    '*************************************************************',CR,LF
00001E30= 2A 20 20 20 20 20 ...   1473              DC.B    '*                                                           *',CR,LF
00001E6F= 2A 20 41 75 74 68 ...   1474              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001EAE= 2A 20 20 20 20 20 ...   1475              DC.B    '*                                                           *',CR,LF
00001EED= 2A 2A 2A 2A 2A 2A ...   1476              DC.B    '*************************************************************',CR,LF,CR,LF
00001F2E= 53 74 61 72 74 69 ...   1477              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001F4B                          1478              
00001F4B= 57 6F 75 6C 64 20 ...   1479  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001F7C                          1480  
00001F7C= 20 0D 0A                1481  GETSTRTADDR DC.B    ' ',CR,LF
00001F7F= 50 6C 65 61 73 65 ...   1482              DC.B    'Please type in your starting address request: ',0
00001FAE                          1483              
00001FAE= 20 0D 0A                1484  GETENDADDR  DC.B    ' ',CR,LF
00001FB1= 50 6C 65 61 73 65 ...   1485              DC.B    'Please type in your ending address request: ',0
00001FDE                          1486              
00001FDE= 20 0D 0A                1487  QUES_CONT   DC.B    ' ',CR,LF
00001FE1= 57 6F 75 6C 64 20 ...   1488              DC.B    'Would you like to continue (Y/N)? ',0
00002004                          1489              
00002004= 20 0D 0A                1490  QUIT_MSG    DC.B    ' ',CR,LF
00002007= 57 6F 75 6C 64 20 ...   1491              DC.B    'Would you like to quit (Y/N)? ',0
00002026                          1492  
00002026                          1493  *****************************************************
00002026                          1494  * I/O storages - assuming users knows what to do.
00002026                          1495  *****************************************************
00002026                          1496  CMD_HLD     DS.B    30
00002044                          1497  CMD_SZ      DS.B    30
00002062                          1498  STADDR      DS.B    10
0000206C                          1499  STADDRSZ    DS.B    10
00002076                          1500  PROGST      DS.L    1
0000207A                          1501  ENDADDR     DS.B    10
00002084                          1502  ENDADDRSZ   DS.B    10
0000208E                          1503  PROGEND     DS.L    1
00002092                          1504  CONT        DS.B    30
000020B0                          1505  *****************************************************
000020B0                          1506  
000020B0                          1507  *Table for 0-9 && A-F
000020B0= 30 00                   1508  PRNT0   DC.B    '0',0
000020B2= 31 00                   1509  PRNT1   DC.B    '1',0
000020B4= 32 00                   1510  PRNT2   DC.B    '2',0
000020B6= 33 00                   1511  PRNT3   DC.B    '3',0
000020B8= 34 00                   1512  PRNT4   DC.B    '4',0
000020BA= 35 00                   1513  PRNT5   DC.B    '5',0
000020BC= 36 00                   1514  PRNT6   DC.B    '6',0
000020BE= 37 00                   1515  PRNT7   DC.B    '7',0
000020C0= 38 00                   1516  PRNT8   DC.B    '8',0
000020C2= 39 00                   1517  PRNT9   DC.B    '9',0
000020C4= 41 00                   1518  PRNTA   DC.B    'A',0
000020C6= 42 00                   1519  PRNTB   DC.B    'B',0
000020C8= 43 00                   1520  PRNTC   DC.B    'C',0
000020CA= 44 00                   1521  PRNTD   DC.B    'D',0
000020CC= 45 00                   1522  PRNTE   DC.B    'E',0
000020CE= 46 00                   1523  PRNTF   DC.B    'F',0
000020D0                          1524  
000020D0                          1525  *output for all OPCODEs
000020D0= 41 44 44 49 00          1526  ADDI    DC.B    'ADDI',0
000020D5= 41 4E 44 49 00          1527  ANDI    DC.B    'ANDI',0
000020DA= 45 4F 52 49 00          1528  EORI    DC.B    'EORI',0
000020DF= 42 43 48 47 00          1529  BCHG    DC.B    'BCHG',0
000020E4= 43 4D 50 49 00          1530  CMPI    DC.B    'CMPI',0
000020E9                          1531  
000020E9                          1532  *output for the size of the operation
000020E9= 2E 42 20 20 20 20 00    1533  ByteSize    DC.B    '.B    ',0
000020F0= 2E 57 20 20 20 20 00    1534  WordSize    DC.B    '.W    ',0
000020F7= 2E 4C 20 20 20 20 00    1535  LongSize    DC.B    '.L    ',0
000020FE                          1536  
000020FE                          1537  *output for all destination data registers (0-7)
000020FE= 44 30 0D 0A 00          1538  OutDataReg0 DC.B    'D0',CR,LF,0
00002103= 44 31 0D 0A 00          1539  OutDataReg1 DC.B    'D1',CR,LF,0
00002108= 44 32 0D 0A 00          1540  OutDataReg2 DC.B    'D2',CR,LF,0
0000210D= 44 33 0D 0A 00          1541  OutDataReg3 DC.B    'D3',CR,LF,0
00002112= 44 34 0D 0A 00          1542  OutDataReg4 DC.B    'D4',CR,LF,0
00002117= 44 35 0D 0A 00          1543  OutDataReg5 DC.B    'D5',CR,LF,0
0000211C= 44 36 0D 0A 00          1544  OutDataReg6 DC.B    'D6',CR,LF,0
00002121= 44 37 0D 0A 00          1545  OutDataReg7 DC.B    'D7',CR,LF,0
00002126                          1546  
00002126                          1547  *output for all address indirect registers (0-7)
00002126= 28 41 30 29 0D 0A 00    1548  OutAddrIndReg0  DC.B    '(A0)',CR,LF,0
0000212D= 28 41 31 29 0D 0A 00    1549  OutAddrIndReg1  DC.B    '(A1)',CR,LF,0
00002134= 28 41 32 29 0D 0A 00    1550  OutAddrIndReg2  DC.B    '(A2)',CR,LF,0
0000213B= 28 41 33 29 0D 0A 00    1551  OutAddrIndReg3  DC.B    '(A3)',CR,LF,0
00002142= 28 41 34 29 0D 0A 00    1552  OutAddrIndReg4  DC.B    '(A4)',CR,LF,0
00002149= 28 41 35 29 0D 0A 00    1553  OutAddrIndReg5  DC.B    '(A5)',CR,LF,0
00002150= 28 41 36 29 0D 0A 00    1554  OutAddrIndReg6  DC.B    '(A6)',CR,LF,0
00002157= 28 41 37 29 0D 0A 00    1555  OutAddrIndReg7  DC.B    '(A7)',CR,LF,0
0000215E                          1556  
0000215E                          1557  *output for all address indirect post registers (0-7)
0000215E= 28 41 30 29 2B 0D ...   1558  OutAddrIndPoReg0    DC.B    '(A0)+',CR,LF,0
00002166= 28 41 31 29 2B 0D ...   1559  OutAddrIndPoReg1    DC.B    '(A1)+',CR,LF,0
0000216E= 28 41 32 29 2B 0D ...   1560  OutAddrIndPoReg2    DC.B    '(A2)+',CR,LF,0
00002176= 28 41 33 29 2B 0D ...   1561  OutAddrIndPoReg3    DC.B    '(A3)+',CR,LF,0
0000217E= 28 41 34 29 2B 0D ...   1562  OutAddrIndPoReg4    DC.B    '(A4)+',CR,LF,0
00002186= 28 41 35 29 2B 0D ...   1563  OutAddrIndPoReg5    DC.B    '(A5)+',CR,LF,0
0000218E= 28 41 36 29 2B 0D ...   1564  OutAddrIndPoReg6    DC.B    '(A6)+',CR,LF,0
00002196= 28 41 37 29 2B 0D ...   1565  OutAddrIndPoReg7    DC.B    '(A7)+',CR,LF,0
0000219E                          1566  
0000219E                          1567  *output for all address indirect pre registers (0-7)
0000219E= 2D 28 41 30 29 0D ...   1568  OutAddrIndPrReg0    DC.B    '-(A0)',CR,LF,0
000021A6= 2D 28 41 31 29 0D ...   1569  OutAddrIndPrReg1    DC.B    '-(A1)',CR,LF,0
000021AE= 2D 28 41 32 29 0D ...   1570  OutAddrIndPrReg2    DC.B    '-(A2)',CR,LF,0
000021B6= 2D 28 41 33 29 0D ...   1571  OutAddrIndPrReg3    DC.B    '-(A3)',CR,LF,0
000021BE= 2D 28 41 34 29 0D ...   1572  OutAddrIndPrReg4    DC.B    '-(A4)',CR,LF,0
000021C6= 2D 28 41 35 29 0D ...   1573  OutAddrIndPrReg5    DC.B    '-(A5)',CR,LF,0
000021CE= 2D 28 41 36 29 0D ...   1574  OutAddrIndPrReg6    DC.B    '-(A6)',CR,LF,0
000021D6= 2D 28 41 37 29 0D ...   1575  OutAddrIndPrReg7    DC.B    '-(A7)',CR,LF,0
000021DE                          1576  
000021DE                          1577  *output for a tab only (4 spaces)
000021DE= 20 20 20 20 00          1578  Tab DC.B    '    ',0
000021E3                          1579  
000021E3                          1580  *output for a comma only
000021E3= 2C 00                   1581  Comma   DC.B    ',',0
000021E5                          1582  
000021E5                          1583  *output for a new line only
000021E5= 0D 0A 00                1584  NewLine DC.B    CR,LF,0
000021E8                          1585  
000021E8                          1586  *output for a '#$' and '$' only
000021E8= 23 24 00                1587  ShaBang DC.B    '#$',0
000021EB= 24 00                   1588  Bang    DC.B    '$',0
000021ED                          1589  
000021ED                          1590  *current output for error messages
000021ED= 42 41 44 20 45 41 ...   1591  BADEAMSG    DC.B    'BAD EA',CR,LF,0
000021F6= 42 41 44 20 4F 50 ...   1592  BADOPMSG    DC.B    'BAD OP',CR,LF,0
000021FF= 49 6D 70 72 6F 70 ...   1593  INV_MSG     DC.B    'Improper command.',CR,LF,0
00002213= 49 6E 76 61 6C 69 ...   1594  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
0000222C= 49 6E 76 61 6C 69 ...   1595  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
00002243                          1596  
00002243                          1597          
00002243                          1598          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                20D0
ADDRABSOLUTEMODE    179C
ADDRDIRECTMODE      1778
ADDRINDIRECTMODE    1778
ADDRINDIRECTPOSTMODE  1788
ADDRINDIRECTPREMODE  1792
ADDRINDPOREG0       196C
ADDRINDPOREG1       197C
ADDRINDPOREG2       198C
ADDRINDPOREG3       199C
ADDRINDPOREG4       19AC
ADDRINDPOREG5       19BC
ADDRINDPOREG6       19CC
ADDRINDPOREG7       19DC
ADDRINDPRREG0       1A2E
ADDRINDPRREG1       1A3E
ADDRINDPRREG2       1A4E
ADDRINDPRREG3       1A5E
ADDRINDPRREG4       1A6E
ADDRINDPRREG5       1A7E
ADDRINDPRREG6       1A8E
ADDRINDPRREG7       1A9E
ADDRINDREG0         18AA
ADDRINDREG1         18BA
ADDRINDREG2         18CA
ADDRINDREG3         18DA
ADDRINDREG4         18EA
ADDRINDREG5         18FA
ADDRINDREG6         190A
ADDRINDREG7         191A
ANDI                20D5
ASCIIHEX            116E
ASCIIHEX1           1172
BADEACODE           1B22
BADEAMSG            21ED
BADOPCODE           1B12
BADOPMSG            21F6
BANG                21EB
BCHG                20DF
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         1408
BUCKET_0001         16E0
BUCKET_0010         16E0
BUCKET_0011         16E0
BUCKET_0100         16E0
BUCKET_0101         16E0
BUCKET_0110         16E0
BUCKET_1000         16E0
BUCKET_1001         16E0
BUCKET_1011         16E0
BUCKET_1100         16E0
BUCKET_1101         16E0
BUCKET_1110         16E0
BYTESIZE            20E9
BYTESIZEIMMEDIATE   1702
CHECK               11E4
CHECKEND1           10F4
CHECKSTRT1          10DE
CHECK_LOWN          1126
CHECK_LOWY          1114
CHECK_N             13E2
CHECK_UPN           111E
CHECK_UPY           110A
CHECK_Y             13D4
CHNG_SZB            1216
CHNG_SZL            11FC
CHNG_SZW            1230
CMD_HLD             2026
CMD_SZ              2044
CMPI                20E4
COMMA               21E3
CONT                2092
CONT_Q              13A2
CONV_LOL            11CE
CONV_LOOP           124A
CONV_NUM            11BA
CONV_UPL            11C4
CR                  D
DATAREG0            17E8
DATAREG1            17F8
DATAREG2            1808
DATAREG3            1818
DATAREG4            1828
DATAREG5            1838
DATAREG6            1848
DATAREG7            1858
DATAREGMODE         1768
DONE                1B32
EA_ADDI             1494
EA_ANDI             150A
EA_BCHG_D           1602
EA_BCHG_S           1664
EA_CMPI             16A0
EA_EORI             1580
ENDADDR             207A
ENDADDRSZ           2084
EORI                20DA
EXITSUB             11DA
EXIT_CONV           12D0
GETENDADDR          1FAE
GETSTRTADDR         1F7C
GET_END             108C
GET_STRT            103E
GRAB_NEXT_OP        1366
HEXASCII            11E0
HEXASCIIREG         11F8
IMMEDIATEDATAMODE   17A6
INV2                13F2
INVALID1            112E
INVENDMSG           222C
INVSTRTMSG          2213
INV_END1            115A
INV_MSG             21FF
INV_STRT1           1146
IS_ADDI             145E
IS_ANDI             14D4
IS_BCHG_D           15C0
IS_BCHG_S           164E
IS_CMPI             166A
IS_EORI             154A
LF                  A
LONGSIZE            20F7
LONGSIZEABSOLUTE    1AEA
LONGSIZEIMMEDIATE   1746
LOOP_1              1014
LOOP_B              121A
LOOP_L              1200
LOOP_W              1234
MAX_LINE            F
MESSAGE             1B3C
NEWLINE             21E5
NUM_0               12DE
NUM_1               12E6
NUM_2               12EE
NUM_3               12F6
NUM_4               12FE
NUM_5               1306
NUM_6               130E
NUM_7               1316
NUM_8               131E
NUM_9               1326
NUM_A               132E
NUM_B               1336
NUM_C               133E
NUM_D               1346
NUM_E               134E
NUM_F               1356
OUTADDRINDPOREG0    215E
OUTADDRINDPOREG1    2166
OUTADDRINDPOREG2    216E
OUTADDRINDPOREG3    2176
OUTADDRINDPOREG4    217E
OUTADDRINDPOREG5    2186
OUTADDRINDPOREG6    218E
OUTADDRINDPOREG7    2196
OUTADDRINDPRREG0    219E
OUTADDRINDPRREG1    21A6
OUTADDRINDPRREG2    21AE
OUTADDRINDPRREG3    21B6
OUTADDRINDPRREG4    21BE
OUTADDRINDPRREG5    21C6
OUTADDRINDPRREG6    21CE
OUTADDRINDPRREG7    21D6
OUTADDRINDREG0      2126
OUTADDRINDREG1      212D
OUTADDRINDREG2      2134
OUTADDRINDREG3      213B
OUTADDRINDREG4      2142
OUTADDRINDREG5      2149
OUTADDRINDREG6      2150
OUTADDRINDREG7      2157
OUTDATAREG0         20FE
OUTDATAREG1         2103
OUTDATAREG2         2108
OUTDATAREG3         210D
OUTDATAREG4         2112
OUTDATAREG5         2117
OUTDATAREG6         211C
OUTDATAREG7         2121
PL_STADDR           1360
PRINT_NUM           12D6
PRNT0               20B0
PRNT1               20B2
PRNT2               20B4
PRNT3               20B6
PRNT4               20B8
PRNT5               20BA
PRNT6               20BC
PRNT7               20BE
PRNT8               20C0
PRNT9               20C2
PRNTA               20C4
PRNTB               20C6
PRNTC               20C8
PRNTD               20CA
PRNTE               20CC
PRNTF               20CE
PROGEND             208E
PROGST              2076
QUES_CONT           1FDE
QUIT_MSG            2004
SHABANG             21E8
STACK               7000
STADDR              2062
STADDRSZ            206C
START               1000
STARTASSEM          1F4B
ST_ADDR             7FC6
ST_BAD              11D8
TAB                 21DE
THEEND              1B36
WORDSIZE            20F0
WORDSIZEABSOLUTE    1AC2
WORDSIZEIMMEDIATE   1724
WRAPPERADDRABSOLUTE  1AAE
WRAPPERADDRABSOLUTEEND  1AC0
WRAPPERADDRINDIRECT  1868
WRAPPERADDRINDIRECTEND  18A8
WRAPPERADDRINDIRECTPOST  192A
WRAPPERADDRINDIRECTPOSTEND  196A
WRAPPERADDRINDIRECTPRE  19EC
WRAPPERADDRINDIRECTPREEND  1A2C
WRAPPERDATAREG      17A6
WRAPPERDATAREGEND   17E6
WRAPPERSIZEIMMEDIATE  16E6
WRAPPERSIZEIMMEDIATEEND  1700
