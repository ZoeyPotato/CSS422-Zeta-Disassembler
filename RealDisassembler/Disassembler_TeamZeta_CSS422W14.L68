00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 8:53:59 PM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/14/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. After specifying
00000000                             7  * where the program to be disassembled is located, this program will disassemble
00000000                             8  * instructions of that program, and output the contents to console.
00000000                             9  *
00000000                            10  * For use with the EASy68K Emulator. To run, open this program in the emulator.
00000000                            11  * Hit 'F9' to execute. In the execution window, open the test input file, and press
00000000                            12  * 'F9' to run the program.
00000000                            13  *
00000000                            14  * This program will not disassemble every 68k instruction, only a subset of instructions
00000000                            15  * that we have currently implemented. See corresponding documentation for more details.
00000000                            16  *-------------------------------------------------------------
00000000  =00007FC6                 17  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 18  STACK       EQU $7000   *Stack location
00000000  =0000000F                 19  MAX_LINE    EQU 15      *Maximum number of instructions that can be displayed
00001000                            20  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 21              LEA stack,SP
00001004  3C3C 000F                 22              MOVE    #MAX_LINE,D6
00001008                            23  
00001008                            24  
00001008                            25  *-----------------------------------------------------------
00001008                            26  * Start of I/O
00001008                            27  *-----------------------------------------------------------            
00001008  43F9 00001E72             28              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 29              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      30              TRAP    #15         *Displays Message
00001014                            31          
00001014  303C 0000                 32  loop_1      MOVE    #0,D0       
00001018  43F9 00002281             33              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 34              MOVE.B  #14,D0
00001022  4E4F                      35              TRAP    #15    
00001024  303C 0002                 36              MOVE    #2,D0
00001028  43F9 0000235C             37              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      38              TRAP    #15
00001030  0C01 0001                 39              CMPI.B  #01,D1
00001034  6600 00FE                 40              BNE     INVALID1
00001038  4EB9 00001110             41              JSR     CHECK_UPY
0000103E                            42              
0000103E                            43              
0000103E                            44  *-----------------------------------------------------------
0000103E                            45  * I/O: Check Start Address
0000103E                            46  *
0000103E                            47  * Make sure that start address starts after allocated 
0000103E                            48  * memory addresses. Else, it will print out a message 
0000103E                            49  * saying that requested address is invalid & prompts the
0000103E                            50  * user again for the starting address.
0000103E                            51  *-----------------------------------------------------------
0000103E  43F9 000022B2             52  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001044  103C 000E                 53              MOVE.B  #14,D0
00001048  4E4F                      54              TRAP    #15
0000104A  43F9 00002398             55              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001050  3239 000023A2             56              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001056  303C 0002                 57              MOVE    #2,D0           *Get start address
0000105A  4E4F                      58              TRAP    #15
0000105C  4EB9 000010E4             59              JSR     CHECKSTRT1
00001062  4287                      60              CLR.L   D7
00001064  4EB9 00001174             61              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106A  0C03 0001                 62              CMPI.B  #01,D3      *Check if there was a bad start
0000106E  6700 00DC                 63              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001072  0C87 00007FC6             64              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001078  6D00 00D2                 65              BLT     INV_STRT1   *Asks for another start address if invalid
0000107C  0C87 00FFFFFE             66              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001082  6C00 00C8                 67              BGE     INV_STRT1
00001086  23C7 000023AC             68              MOVE.L  D7,PROGST
0000108C                            69  
0000108C  43F9 000022E4             70  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001092  103C 000E                 71              MOVE.B  #14,D0
00001096  4E4F                      72              TRAP    #15
00001098  43F9 000023B0             73              LEA     ENDADDR,A1      *Buffer to hold end address
0000109E  3239 000023BA             74              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A4  303C 0002                 75              MOVE    #2,D0
000010A8  4E4F                      76              TRAP    #15
000010AA  4EB9 000010FA             77              JSR     CHECKEND1
000010B0  4287                      78              CLR.L   D7
000010B2  4EB9 00001174             79              JSR     ASCIIHEX
000010B8  0C03 0001                 80              CMPI.B  #01,D3
000010BC  6700 00A2                 81              BEQ     INV_END1
000010C0  0C87 000023AC             82              CMPI.L  #PROGST,D7
000010C6  6D00 0098                 83              BLT     INV_END1
000010CA  0C87 00FFFFFF             84              CMPI.L  #$00FFFFFF,D7
000010D0  6C00 008E                 85              BGE     INV_END1
000010D4  23C7 000023C4             86              MOVE.L  D7,PROGEND
000010DA  2079 000023AC             87              MOVEA.L PROGST,A0
000010E0  6000 028A                 88              BRA     GRAB_NEXT_OP            
000010E4                            89                          
000010E4  0C81 00000008             90  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EA  6E00 0060                 91              BGT     INV_STRT1
000010EE  0C81 00000000             92              CMPI.L  #00,D1
000010F4  6300 0056                 93              BLS     INV_STRT1
000010F8  4E75                      94              RTS         
000010FA                            95              
000010FA  0C81 00000008             96  CHECKEND1   CMPI.L  #08,D1
00001100  6E00 005E                 97              BGT     INV_END1
00001104  0C81 00000000             98              CMPI.L  #00,D1
0000110A  6300 0054                 99              BLS     INV_END1
0000110E  4E75                     100              RTS
00001110                           101  
00001110                           102  
00001110                           103  *-----------------------------------------------------------
00001110                           104  * I/O: Input check for Y, y, N, n
00001110                           105  *-----------------------------------------------------------
00001110  0C11 0059                106  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001114  6600 0004                107              BNE     CHECK_LOWY
00001118  4E75                     108              RTS
0000111A  0C11 0079                109  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
0000111E  6600 0004                110              BNE     CHECK_UPN
00001122  4E75                     111              RTS
00001124  0C11 004E                112  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001128  6700 0D3E                113              BEQ     DONE
0000112C                           114              
0000112C  0C11 006E                115  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001130  6700 0D36                116              BEQ     DONE
00001134                           117              
00001134  163C 0000                118  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001138  303C 0000                119              MOVE    #0,D0       *Prints invalid command msg if not found
0000113C  43F9 00002536            120              LEA     INV_MSG,A1
00001142  303C 000E                121              MOVE    #14,D0
00001146  4E4F                     122              TRAP    #15
00001148  6000 FECA                123              BRA     loop_1
0000114C                           124              
0000114C  43F9 0000254A            125  INV_STRT1   LEA     INVSTRTMSG,A1
00001152  103C 000E                126              MOVE.B  #14,D0
00001156  4E4F                     127              TRAP    #15
00001158  163C 0000                128              MOVE.B  #00,D3      *Reset flag
0000115C  6000 FEE0                129              BRA     GET_STRT        
00001160                           130              
00001160  43F9 00002563            131  INV_END1    LEA     INVENDMSG,A1
00001166  103C 000E                132              MOVE.B  #14,D0
0000116A  4E4F                     133              TRAP    #15
0000116C  163C 0000                134              MOVE.B  #00,D3      *Reset flag
00001170  6000 FF1A                135              BRA     GET_END
00001174                           136              
00001174                           137              
00001174                           138  *-----------------------------------------------------------
00001174                           139  * ASCII to Hex converter
00001174                           140  *
00001174                           141  * Checks and converts the ASCII value to the hex equivalent
00001174                           142  *-----------------------------------------------------------
00001174  48E7 6000                143  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001178  0C01 0000                144  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000117C  6700 0062                145              BEQ     exitSub     *Exit subroutine 
00001180  5301                     146              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001182  E99F                     147              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001184  1419                     148              MOVE.B  (A1)+,D2    *Takes the first char
00001186  0C02 0024                149              CMPI.B  #$24,D2     *See if the first char is $
0000118A  67EC                     150              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000118C  0C02 0030                151              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001190  6D00 004C                152              BLT     st_bad      *Put error message
00001194  0C02 0039                153              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001198  6F00 0026                154              BLE     CONV_NUM    *Convert to number, if so
0000119C  0C02 0041                155              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A0  6D00 003C                156              BLT     st_bad      *Put error message
000011A4  0C02 0046                157              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011A8  6F00 0020                158              BLE     CONV_UpL    *Convert to hex
000011AC  0C02 0061                159              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B0  6D00 002C                160              BLT     st_bad
000011B4  0C02 0066                161              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011B8  6F00 001A                162              BLE     CONV_LoL    
000011BC  6E00 0020                163              BGT     st_bad      *Puts error message for anything greater than f value
000011C0                           164              
000011C0  0402 0030                165  CONV_NUM    SUBI.B  #$30,D2
000011C4  8E02                     166              OR.B    D2,D7
000011C6  4EF8 1178                167              JMP     ASCIIHEX1
000011CA  0402 0037                168  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011CE  8E02                     169              OR.B    D2,D7
000011D0  4EF8 1178                170              JMP     ASCIIHEX1
000011D4  0402 0057                171  CONV_LoL    SUBI.B  #$57,D2
000011D8  8E02                     172              OR.B    D2,D7
000011DA  4EF8 1178                173              JMP     ASCIIHEX1   
000011DE                           174  
000011DE  5203                     175  st_bad      ADDI.B  #01,D3
000011E0  4CDF 0006                176  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E4  4E75                     177              RTS
000011E6                           178              
000011E6                           179              
000011E6                           180  *-----------------------------------------------------------
000011E6                           181  * Hex to ASCII converter
000011E6                           182  *-----------------------------------------------------------
000011E6  48E7 4C00                183  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EA  0C01 0000                184  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011EE  6700 002C                185              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F2  B27C 0001                186              CMP.W   #01,D1          
000011F6  6700 003E                187              BEQ     CHNG_SZW
000011FA  6000 0006                188              BRA     CHNG_SZL        
000011FE                           189  
000011FE  48E7 4C00                190  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001202  123C 0008                191  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
00001206  0C01 0000                192  LOOP_L      CMPI.B  #00,D1
0000120A  6700 00CA                193              BEQ     EXIT_CONV
0000120E  5301                     194              SUBI.B  #01,D1
00001210  E99C                     195              ROL.L   #4,D4           * Shift it for next bit
00001212  2A04                     196              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001214  4EB9 00001250            197              JSR     CONV_LOOP
0000121A  60EA                     198              BRA     LOOP_L      
0000121C                           199  
0000121C  123C 0002                200  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001220  0C01 0000                201  LOOP_B      CMPI.B  #00,D1
00001224  6700 00B0                202              BEQ     EXIT_CONV
00001228  5301                     203              SUBI.B  #01,D1
0000122A  E91C                     204              ROL.B   #4,D4           * Shift it for next bit
0000122C  2A04                     205              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000122E  4EB9 00001250            206              JSR     CONV_LOOP
00001234  60EA                     207              BRA     LOOP_B
00001236                           208              
00001236  123C 0004                209  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123A  0C01 0000                210  LOOP_W      CMPI.B  #00,D1
0000123E  6700 0096                211              BEQ     EXIT_CONV
00001242  5301                     212              SUBI.B  #01,D1
00001244  E95C                     213              ROL.W   #4,D4           * Shift it for next bit
00001246  2A04                     214              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001248  4EB9 00001250            215              JSR     CONV_LOOP
0000124E  60EA                     216              BRA     LOOP_W
00001250                           217  
00001250  0285 0000000F            218  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001256  0C05 0000                219              CMPI.B  #$0,D5
0000125A  6700 0088                220              BEQ     NUM_0
0000125E  0C05 0001                221              CMPI.B  #$1,D5
00001262  6700 0088                222              BEQ     NUM_1
00001266  0C05 0002                223              CMPI.B  #$2,D5
0000126A  6700 0088                224              BEQ     NUM_2
0000126E  0C05 0003                225              CMPI.B  #$3,D5
00001272  6700 0088                226              BEQ     NUM_3
00001276  0C05 0004                227              CMPI.B  #$4,D5
0000127A  6700 0088                228              BEQ     NUM_4
0000127E  0C05 0005                229              CMPI.B  #$5,D5
00001282  6700 0088                230              BEQ     NUM_5
00001286  0C05 0006                231              CMPI.B  #$6,D5
0000128A  6700 0088                232              BEQ     NUM_6
0000128E  0C05 0007                233              CMPI.B  #$7,D5
00001292  6700 0088                234              BEQ     NUM_7
00001296  0C05 0008                235              CMPI.B  #$8,D5
0000129A  6700 0088                236              BEQ     NUM_8
0000129E  0C05 0009                237              CMPI.B  #$9,D5
000012A2  6700 0088                238              BEQ     NUM_9
000012A6  0C05 000A                239              CMPI.B  #$A,D5
000012AA  6700 0088                240              BEQ     NUM_A
000012AE  0C05 000B                241              CMPI.B  #$B,D5
000012B2  6700 0088                242              BEQ     NUM_B
000012B6  0C05 000C                243              CMPI.B  #$C,D5
000012BA  6700 0088                244              BEQ     NUM_C
000012BE  0C05 000D                245              CMPI.B  #$D,D5
000012C2  6700 0088                246              BEQ     NUM_D
000012C6  0C05 000E                247              CMPI.B  #$E,D5
000012CA  6700 0088                248              BEQ     NUM_E
000012CE  0C05 000F                249              CMPI.B  #$F,D5
000012D2  6700 0088                250              BEQ     NUM_F
000012D6                           251              
000012D6  4CDF 0032                252  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DA  4E75                     253              RTS
000012DC                           254              
000012DC  303C 000E                255  PRINT_NUM   MOVE    #14,D0
000012E0  4E4F                     256              TRAP    #15
000012E2  4E75                     257              RTS
000012E4  43F9 000023E6            258  NUM_0       LEA     PRNT0,A1
000012EA  60F0                     259              BRA     PRINT_NUM
000012EC  43F9 000023E8            260  NUM_1       LEA     PRNT1,A1
000012F2  60E8                     261              BRA     PRINT_NUM
000012F4  43F9 000023EA            262  NUM_2       LEA     PRNT2,A1
000012FA  60E0                     263              BRA     PRINT_NUM
000012FC  43F9 000023EC            264  NUM_3       LEA     PRNT3,A1
00001302  60D8                     265              BRA     PRINT_NUM
00001304  43F9 000023EE            266  NUM_4       LEA     PRNT4,A1
0000130A  60D0                     267              BRA     PRINT_NUM
0000130C  43F9 000023F0            268  NUM_5       LEA     PRNT5,A1
00001312  60C8                     269              BRA     PRINT_NUM
00001314  43F9 000023F2            270  NUM_6       LEA     PRNT6,A1
0000131A  60C0                     271              BRA     PRINT_NUM
0000131C  43F9 000023F4            272  NUM_7       LEA     PRNT7,A1
00001322  60B8                     273              BRA     PRINT_NUM
00001324  43F9 000023F6            274  NUM_8       LEA     PRNT8,A1
0000132A  60B0                     275              BRA     PRINT_NUM
0000132C  43F9 000023F8            276  NUM_9       LEA     PRNT9,A1
00001332  60A8                     277              BRA     PRINT_NUM
00001334  43F9 000023FA            278  NUM_A       LEA     PRNTA,A1
0000133A  60A0                     279              BRA     PRINT_NUM
0000133C  43F9 000023FC            280  NUM_B       LEA     PRNTB,A1
00001342  6098                     281              BRA     PRINT_NUM
00001344  43F9 000023FE            282  NUM_C       LEA     PRNTC,A1
0000134A  6090                     283              BRA     PRINT_NUM
0000134C  43F9 00002400            284  NUM_D       LEA     PRNTD,A1
00001352  6088                     285              BRA     PRINT_NUM
00001354  43F9 00002402            286  NUM_E       LEA     PRNTE,A1
0000135A  6080                     287              BRA     PRINT_NUM
0000135C  43F9 00002404            288  NUM_F       LEA     PRNTF,A1
00001362  6000 FF78                289              BRA     PRINT_NUM
00001366                           290  
00001366                           291  
00001366                           292  *-----------------------------------------------------------        
00001366                           293  * Start of Disassembler
00001366                           294  *-----------------------------------------------------------
00001366                           295          *FOR DEBUGGING ONLY!!!
00001366  207C 00007FC6            296          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000136C                           297          
0000136C                           298  GRAB_NEXT_OP
0000136C                           299          *Check and see if A0 == end of test address. If so, we need to end.
0000136C  2E08                     300          MOVE.L  A0,D7
0000136E  2479 000023C4            301          MOVEA.L PROGEND,A2
00001374  BE8A                     302          CMP.L   A2,D7       * Check and see if A0 == end of test address. 
00001376  6C00 FC9C                303          BGE     loop_1      * Ask user if they want to do the disassembler again
0000137A  0C86 00000000            304          CMPI.L  #00,D6      * Check if max line of instructions output on console is reached
00001380  6700 0032                305          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
00001384  5306                     306          SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
00001386                           307  
00001386                           308          *Output a newline to console...        
00001386  43F9 00002520            309          LEA     NewLine,A1  *Loads NewLine into address register A1
0000138C  103C 000E                310          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001390  4E4F                     311          TRAP    #15         *Displays Message
00001392                           312  
00001392                           313          *Output the address of this instruction to console...
00001392  2808                     314          MOVE.L  A0,D4
00001394  4EB8 11FE                315          JSR     HEXASCIIREG
00001398                           316          
00001398                           317          *Output a tab (4 spaces) to console, just after the address...
00001398  43F9 00002519            318          LEA     Tab,A1  *Loads Tab into address register A1
0000139E  103C 000E                319          MOVE.B  #14,D0  *Moves the number 14 into data register D0
000013A2  4E4F                     320          TRAP    #15     *Displays Message
000013A4                           321          
000013A4                           322          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
000013A4                           323          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
000013A4                           324          *data that may be associated with the instruction.
000013A4                           325          *Post increment addr, A0 will point to the start of next instruction or will 
000013A4                           326          *point to the start of any immed/abso data with this current instruction
000013A4  4280                     327          CLR.L   D0
000013A6  3018                     328          MOVE.W  (A0)+,D0
000013A8                           329          *Copy the word data we just moved into D0 into D7. We are copying this data
000013A8                           330          *So we always have a copy of the WHOLE instruction somewhere
000013A8  4287                     331          CLR.L   D7
000013AA  3E00                     332          MOVE.W  D0,D7
000013AC                           333          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000013AC                           334          *four bits of the instruction. Once we have just the first four bits, we can
000013AC                           335          *begin to see which 'bucket'/category this instruction falls into. 
000013AC  E048                     336          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013AE  E848                     337          LSR.W   #$04,D0
000013B0                           338          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013B0                           339          *list of buckets until we find which one this instruction falls into.
000013B0  6000 0068                340          BRA     BUCKET_0000     * Start with 0000
000013B4                           341  
000013B4                           342  
000013B4                           343  *-----------------------------------------------------------        
000013B4                           344  * Question Prompts
000013B4                           345  *-----------------------------------------------------------        
000013B4  43F9 00002314            346  CONT_Q      LEA     QUES_CONT,A1
000013BA  303C 000E                347              MOVE    #14,D0
000013BE  4E4F                     348              TRAP    #15
000013C0  43F9 000023C8            349              LEA     CONT,A1     *Need to store Y/N
000013C6  303C 0002                350              MOVE    #2,D0
000013CA  4E4F                     351              TRAP    #15
000013CC  0C01 0001                352              CMPI.B  #01,D1
000013D0  6600 FD62                353              BNE     INVALID1
000013D4  0C39 0059 000023C8       354              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013DC  6600 0008                355              BNE     CHECK_Y
000013E0  3C3C 000F                356              MOVE    #MAX_LINE,D6    *Resets counter
000013E4  4E75                     357              RTS
000013E6  0C11 0079                358  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
000013EA  6600 0008                359              BNE     CHECK_N
000013EE  3C3C 000F                360              MOVE    #MAX_LINE,D6    *Resets counter
000013F2  4E75                     361              RTS
000013F4  0C11 004E                362  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
000013F8  6700 FC1A                363              BEQ     loop_1
000013FC  0C11 006E                364              CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001400  6700 FC12                365              BEQ     loop_1      
00001404                           366  
00001404  163C 0000                367  INV2        MOVE.B  #0,D3       *Reset bad flag
00001408  303C 0000                368              MOVE    #0,D0       *Prints invalid command msg if not found
0000140C  43F9 00002536            369              LEA     INV_MSG,A1
00001412  303C 000E                370              MOVE    #14,D0
00001416  4E4F                     371              TRAP    #15
00001418  609A                     372              BRA     CONT_Q
0000141A                           373  
0000141A                           374  *-----------------------------------------------------------        
0000141A                           375  * Bucket 0000:
0000141A                           376  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
0000141A                           377  *                   BCHG(dynamic) | BCHG (static) | CMPI----
0000141A                           378  *-----------------------------------------------------------
0000141A                           379  BUCKET_0000
0000141A  =00000000                380  BUCKET0000_BITS EQU $0
0000141A  4281                     381          CLR.L   D1
0000141C                           382          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000141C  123C 0000                383          MOVE.B  #BUCKET0000_BITS,D1
00001420                           384          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0000. 
00001420                           385          *If equal, continue decoding. If not, branch to next bucket.
00001420  B200                     386          CMP.B   D0,D1
00001422  6600 0344                387          BNE     BUCKET_0001
00001426                           388  
00001426                           389          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001426                           390          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001426  3007                     391          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001428  0800 0008                392          BTST.L  #$08,D0
0000142C  6600 01A4                393          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to IS_BCHG_D
00001430                           394          
00001430                           395          *Now we can check bits 11-8 in the instruction and branch to different op-codes
00001430                           396          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
00001430  E048                     397          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001432  0880 0004                398          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001436  0880 0005                399          BCLR.L  #$05,D0
0000143A  0880 0006                400          BCLR.L  #$06,D0
0000143E  0880 0007                401          BCLR.L  #$07,D0
00001442                           402          
00001442                           403          *Perform compares with these 4 bits to see which specific instruction it is.
00001442  B03C 0006                404          CMP.B   #$06,D0 *Is this an ADDI?
00001446  6700 0028                405          BEQ     IS_ADDI
0000144A  B03C 0002                406          CMP.B   #$02,D0 *Is this an ANDI?
0000144E  6700 0096                407          BEQ     IS_ANDI
00001452  B03C 000A                408          CMP.B   #$0A,D0 *Is this an EORI?
00001456  6700 0104                409          BEQ     IS_EORI
0000145A  B03C 0008                410          CMP.B   #$08,D0 *Is this a BCHG(static)?
0000145E  6700 0210                411          BEQ     IS_BCHG_S
00001462  B03C 000C                412          CMP.B   #$0C,D0 *Is this a CMPI?
00001466  6700 028A                413          BEQ     IS_CMPI
0000146A                           414          
0000146A                           415          *If we get through all of the compares without finding the specific instruction,
0000146A                           416          *then this instruction is either not in our list of OP CODES to decode, or is an
0000146A                           417          *invalid instruction/syntax.
0000146A  4EF9 00001E48            418          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
00001470                           419          
00001470                           420          
00001470                           421  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
00001470                           422  IS_ADDI
00001470                           423          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001470                           424          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001470  4281                     425          CLR.L   D1
00001472  3207                     426          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001474  C27C 00C0                427          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001478  EC09                     428          LSR.B   #$06,D1     *Shift the size bits into LSB
0000147A                           429          
0000147A  B23C 0003                430          CMP.B   #$03,D1     *Compare the size bits to $3
0000147E  6700 09C8                431          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001482                           432          
00001482                           433          *Output 'ADDI' to console...
00001482  43F9 00002406            434          LEA     ADDI,A1     *Loads ADDI into address register A1
00001488  103C 000E                435          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000148C  4E4F                     436          TRAP    #15         *Displays Message
0000148E                           437          
0000148E                           438          
0000148E                           439          *Should have a valid ADDI op code. Set data up for EA.
0000148E                           440          
0000148E                           441          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000148E  4282                     442          CLR.L   D2
00001490  3407                     443          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001492  C47C 0038                444          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001496  E60A                     445          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001498                           446                  
00001498                           447          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001498  4283                     448          CLR.L   D3
0000149A  3607                     449          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000149C  C67C 0007                450          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000014A0                           451          
000014A0  4EF9 000014A6            452          JMP     EA_ADDI
000014A6                           453  
000014A6                           454  EA_ADDI
000014A6                           455          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
000014A6                           456          *and D3 holds the EA register.
000014A6                           457          
000014A6                           458          *Determine how much data to read in, depending on the size of the operation
000014A6                           459          *output the size of the operation and the immediate data to console
000014A6  4EB9 0000189C            460          JSR     WrapperSizeImmediate
000014AC                           461          
000014AC                           462          *manually output a comma here...
000014AC  43F9 0000251E            463          LEA     Comma,A1        *Loads Comma into address register A1
000014B2  103C 000E                464          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014B6  4E4F                     465          TRAP    #15             *Displays Message        
000014B8                           466          
000014B8                           467          *Determine which EA mode and thus Register/Mem Address this instruction used
000014B8  B43C 0000                468          CMP.B   #$00,D2
000014BC  6700 0504                469          BEQ     DataRegMode *If EA mode is a data register, output that
000014C0                           470          
000014C0  B43C 0002                471          CMP.B   #$02,D2
000014C4  6700 051C                472          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014C8                           473          
000014C8  B43C 0003                474          CMP.B   #$03,D2
000014CC  6700 0524                475          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014D0                           476          
000014D0  B43C 0004                477          CMP.B   #$04,D2
000014D4  6700 052C                478          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014D8                           479          
000014D8  B43C 0007                480          CMP.B   #$07,D2
000014DC  6700 0534                481          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014E0                           482          
000014E0                           483          *If the ea mode isn't equal to any of these, it is an invalid EA
000014E0  4EF9 00001E58            484          JMP     BADEACODE                               
000014E6                           485          
000014E6                           486  
000014E6                           487  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000014E6                           488  IS_ANDI
000014E6                           489          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014E6                           490          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014E6  4281                     491          CLR.L   D1
000014E8  3207                     492          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014EA  C27C 00C0                493          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014EE  EC09                     494          LSR.B   #$06,D1     *Shift the size bits into LSB
000014F0                           495          
000014F0  B23C 0003                496          CMP.B   #$03,D1     *Compare the size bits to $3
000014F4  6700 0952                497          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014F8                           498          
000014F8                           499          *Output 'ANDI' to console...
000014F8  43F9 0000240B            500          LEA     ANDI,A1     *Loads ANDI into address register A1
000014FE  103C 000E                501          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001502  4E4F                     502          TRAP    #15         *Displays Message
00001504                           503          
00001504                           504          
00001504                           505          *Should have a valid ANDI op code. Set data up for EA.
00001504                           506          
00001504                           507          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001504  4282                     508          CLR.L   D2
00001506  3407                     509          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001508  C47C 0038                510          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000150C  E60A                     511          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000150E                           512                  
0000150E                           513          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000150E  4283                     514          CLR.L   D3
00001510  3607                     515          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001512  C67C 0007                516          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001516                           517          
00001516  4EF9 0000151C            518          JMP     EA_ANDI
0000151C                           519  
0000151C                           520  EA_ANDI
0000151C                           521          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
0000151C                           522          *and D3 holds the EA register.
0000151C                           523          
0000151C                           524          *Determine how much data to read in, depending on the size of the operation
0000151C                           525          *output the size of the operation and the immediate data to console
0000151C  4EB9 0000189C            526          JSR     WrapperSizeImmediate
00001522                           527          
00001522                           528          *manually output a comma here...
00001522  43F9 0000251E            529          LEA     Comma,A1        *Loads Comma into address register A1
00001528  103C 000E                530          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000152C  4E4F                     531          TRAP    #15             *Displays Message        
0000152E                           532          
0000152E                           533          *Determine which EA mode and thus Register/Mem Address this instruction used
0000152E  B43C 0000                534          CMP.B   #$00,D2
00001532  6700 048E                535          BEQ     DataRegMode *If EA mode is a data register, output that
00001536                           536          
00001536  B43C 0002                537          CMP.B   #$02,D2
0000153A  6700 04A6                538          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000153E                           539          
0000153E  B43C 0003                540          CMP.B   #$03,D2
00001542  6700 04AE                541          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001546                           542          
00001546  B43C 0004                543          CMP.B   #$04,D2
0000154A  6700 04B6                544          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000154E                           545          
0000154E  B43C 0007                546          CMP.B   #$07,D2
00001552  6700 04BE                547          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001556                           548          
00001556                           549          *If the ea mode isn't equal to any of these, it is an invalid EA
00001556  4EF9 00001E58            550          JMP     BADEACODE
0000155C                           551          
0000155C                           552  
0000155C                           553  *Now we know this instruction is exactly EORI, lets set everything up for EA.
0000155C                           554  IS_EORI
0000155C                           555          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000155C                           556          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000155C  4281                     557          CLR.L   D1
0000155E  3207                     558          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001560  C27C 00C0                559          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001564  EC09                     560          LSR.B   #$06,D1     *Shift the size bits into LSB
00001566                           561          
00001566  B23C 0003                562          CMP.B   #$03,D1     *Compare the size bits to $3
0000156A  6700 08DC                563          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000156E                           564          
0000156E                           565          *Output 'EORI' to console...
0000156E  43F9 00002410            566          LEA     EORI,A1     *Loads EORI into address register A1
00001574  103C 000E                567          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001578  4E4F                     568          TRAP    #15         *Displays Message
0000157A                           569          
0000157A                           570          
0000157A                           571          *Should have a valid EORI op code. Set data up for EA.
0000157A                           572          
0000157A                           573          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000157A  4282                     574          CLR.L   D2
0000157C  3407                     575          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000157E  C47C 0038                576          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001582  E60A                     577          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001584                           578                  
00001584                           579          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001584  4283                     580          CLR.L   D3
00001586  3607                     581          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001588  C67C 0007                582          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000158C                           583          
0000158C  4EF9 00001592            584          JMP     EA_EORI
00001592                           585  
00001592                           586  EA_EORI
00001592                           587          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
00001592                           588          *and D3 holds the EA register.
00001592                           589          
00001592                           590          *Determine how much data to read in, depending on the size of the operation
00001592                           591          *output the size of the operation and the immediate data to console
00001592  4EB9 0000189C            592          JSR     WrapperSizeImmediate
00001598                           593          
00001598                           594          *manually output a comma here...
00001598  43F9 0000251E            595          LEA     Comma,A1        *Loads Comma into address register A1
0000159E  103C 000E                596          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015A2  4E4F                     597          TRAP    #15             *Displays Message        
000015A4                           598          
000015A4                           599          *Determine which EA mode and thus Register/Mem Address this instruction used
000015A4  B43C 0000                600          CMP.B   #$00,D2
000015A8  6700 0418                601          BEQ     DataRegMode *If EA mode is a data register, output that
000015AC                           602          
000015AC  B43C 0002                603          CMP.B   #$02,D2
000015B0  6700 0430                604          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015B4                           605          
000015B4  B43C 0003                606          CMP.B   #$03,D2
000015B8  6700 0438                607          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015BC                           608          
000015BC  B43C 0004                609          CMP.B   #$04,D2
000015C0  6700 0440                610          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015C4                           611          
000015C4  B43C 0007                612          CMP.B   #$07,D2
000015C8  6700 0448                613          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015CC                           614          
000015CC                           615          *If the ea mode isn't equal to any of these, it is an invalid EA
000015CC  4EF9 00001E58            616          JMP     BADEACODE
000015D2                           617  
000015D2                           618  
000015D2                           619  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015D2                           620  *everything up for EA, if is a legit instruction.
000015D2                           621  IS_BCHG_D
000015D2                           622          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015D2                           623          *invalid, branch to BADOPCODE
000015D2  3007                     624          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015D4  0800 0007                625          BTST.L  #$07,D0
000015D8  6600 086E                626          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015DC  0800 0006                627          BTST.L  #$06,D0
000015E0  6700 0866                628          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000015E4                           629          
000015E4                           630          *Output 'BCHG' to console...
000015E4  43F9 00002415            631          LEA     BCHG,A1         *Loads BCHG into address register A1
000015EA  103C 000E                632          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015EE  4E4F                     633          TRAP    #15             *Displays Message
000015F0                           634                  
000015F0                           635                  
000015F0                           636          *Should have a valid BCHG op code. Set data up for EA.
000015F0                           637  
000015F0                           638          *Set D1 to the EA source register located in bits 11-9 of the instruction
000015F0  4281                     639          CLR.L   D1
000015F2  3207                     640          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015F4  C27C 0E00                641          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
000015F8  E049                     642          LSR.W   #$08,D1     *Shift the EA source register bits into LSB
000015FA  E249                     643          LSR.W   #$01,D1
000015FC                           644  
000015FC                           645          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015FC  4282                     646          CLR.L   D2
000015FE  3407                     647          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001600  C47C 0038                648          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001604  E60A                     649          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001606                           650                  
00001606                           651          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001606  4283                     652          CLR.L   D3
00001608  3607                     653          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000160A  C67C 0007                654          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000160E                           655  
0000160E  4EF9 00001614            656          JMP     EA_BCHG_D
00001614                           657  
00001614                           658  EA_BCHG_D
00001614                           659          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001614                           660          *D2 holds the EA mode, and D3 holds the EA register.
00001614                           661          
00001614                           662          *Determine the size of this BCHG instruction. Output the correct size...
00001614  4EB9 0000196A            663          JSR     BCHGSizeHelper
0000161A                           664          
0000161A                           665          *output the source register to console, flag D6 with a 1 so we come back...
0000161A  48E7 0200                666          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
0000161E  48E7 1000                667          MOVEM.L D3,-(SP)    *Push EA destination register into stack            
00001622  1C3C 0001                668          MOVE.B  #$01,D6     *Flag D6
00001626  1601                     669          MOVE.B  D1,D3       *Move source register into D3
00001628  4EB9 000019C2            670          JSR     DataRegMode
0000162E  4CDF 0008                671          MOVEM.L (SP)+,D3    *Pull destination register back into D3
00001632  4CDF 0040                672          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001636                           673          
00001636                           674          *manually output a comma here...
00001636  43F9 0000251E            675          LEA     Comma,A1        *Loads Comma into address register A1
0000163C  103C 000E                676          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001640  4E4F                     677          TRAP    #15             *Displays Message
00001642                           678          
00001642                           679          *Determine which EA mode and thus Register/Mem Address this instruction used
00001642  B43C 0000                680          CMP.B   #$00,D2
00001646  6700 037A                681          BEQ     DataRegMode *If EA mode is a data register, output that
0000164A                           682          
0000164A  B43C 0002                683          CMP.B   #$02,D2
0000164E  6700 0392                684          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001652                           685          
00001652  B43C 0003                686          CMP.B   #$03,D2
00001656  6700 039A                687          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000165A                           688          
0000165A  B43C 0004                689          CMP.B   #$04,D2
0000165E  6700 03A2                690          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001662                           691          
00001662  B43C 0007                692          CMP.B   #$07,D2
00001666  6700 03AA                693          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000166A                           694          
0000166A                           695          *If the ea mode isn't equal to any of these, it is an invalid EA
0000166A  4EF9 00001E58            696          JMP     BADEACODE
00001670                           697  
00001670                           698  
00001670                           699  *Found a possible BCHG(static) instruction. Verify its bit integrity and then set up
00001670                           700  *everything up for EA, if is a legit instruction.
00001670                           701  IS_BCHG_S
00001670                           702          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
00001670                           703          *invalid, branch to BADOPCODE
00001670  3007                     704          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
00001672  0800 0007                705          BTST.L  #$07,D0
00001676  6600 07D0                706          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
0000167A  0800 0006                707          BTST.L  #$06,D0
0000167E  6700 07C8                708          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
00001682                           709          
00001682                           710          *Output 'BCHG' to console...
00001682  43F9 00002415            711          LEA     BCHG,A1         *Loads BCHG into address register A1
00001688  103C 000E                712          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000168C  4E4F                     713          TRAP    #15             *Displays Message
0000168E                           714          
0000168E                           715          
0000168E                           716          *Should have a valid BCHG op code. Set data up for EA.
0000168E                           717          
0000168E                           718          *Move #$00 into D1, BCHG_S's immediate data is always in byte size
0000168E  4281                     719          CLR.L   D1
00001690  323C 0000                720          MOVE.W  #$00,D1
00001694                           721  
00001694                           722          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001694  4282                     723          CLR.L   D2
00001696  3407                     724          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001698  C47C 0038                725          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000169C  E60A                     726          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000169E                           727                  
0000169E                           728          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000169E  4283                     729          CLR.L   D3
000016A0  3607                     730          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000016A2  C67C 0007                731          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000016A6                           732  
000016A6  4EF9 000016AC            733          JMP     EA_BCHG_S
000016AC                           734  
000016AC                           735  EA_BCHG_S
000016AC                           736          *Decode the ea bits of BCHG(static). Assuming D2 holds the EA mode, and 
000016AC                           737          *D3 holds the EA register.
000016AC                           738          
000016AC                           739          *Determine the size of this BCHG instruction. Output the correct size...
000016AC  4EB9 0000196A            740          JSR     BCHGSizeHelper                
000016B2                           741          
000016B2                           742          *output the immediate data of this operation to console (always byte)...
000016B2  4EB9 0000199A            743          JSR     BCHGImmediate
000016B8                           744          
000016B8                           745          *manually output a comma here...
000016B8  43F9 0000251E            746          LEA     Comma,A1        *Loads Comma into address register A1
000016BE  103C 000E                747          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016C2  4E4F                     748          TRAP    #15             *Displays Message
000016C4                           749          
000016C4                           750          *Determine which EA mode and thus Register/Mem Address this instruction used
000016C4  B43C 0000                751          CMP.B   #$00,D2
000016C8  6700 02F8                752          BEQ     DataRegMode *If EA mode is a data register, output that
000016CC                           753          
000016CC  B43C 0002                754          CMP.B   #$02,D2
000016D0  6700 0310                755          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016D4                           756          
000016D4  B43C 0003                757          CMP.B   #$03,D2
000016D8  6700 0318                758          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016DC                           759          
000016DC  B43C 0004                760          CMP.B   #$04,D2
000016E0  6700 0320                761          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000016E4                           762          
000016E4  B43C 0007                763          CMP.B   #$07,D2
000016E8  6700 0328                764          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000016EC                           765          
000016EC                           766          *If the ea mode isn't equal to any of these, it is an invalid EA
000016EC  4EF9 00001E58            767          JMP     BADEACODE
000016F2                           768  
000016F2                           769  
000016F2                           770  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000016F2                           771  IS_CMPI
000016F2                           772          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000016F2                           773          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000016F2  4281                     774          CLR.L   D1
000016F4  3207                     775          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000016F6  C27C 00C0                776          AND.W   #$00C0,D1   *Mask out everything but the size bits
000016FA  EC09                     777          LSR.B   #$06,D1     *Shift the size bits into LSB
000016FC                           778          
000016FC  B23C 0003                779          CMP.B   #$03,D1     *Compare the size bits to $3
00001700  6700 0746                780          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001704                           781          
00001704                           782          *Output 'CMPI' to console...
00001704  43F9 0000241A            783          LEA     CMPI,A1     *Loads CMPI into address register A1
0000170A  103C 000E                784          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000170E  4E4F                     785          TRAP    #15         *Displays Message
00001710                           786          
00001710                           787          
00001710                           788          *Should have a valid CMPI op code. Set data up for EA.
00001710                           789          
00001710                           790          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001710  4282                     791          CLR.L   D2
00001712  3407                     792          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001714  C47C 0038                793          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001718  E60A                     794          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000171A                           795                  
0000171A                           796          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000171A  4283                     797          CLR.L   D3
0000171C  3607                     798          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000171E  C67C 0007                799          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001722                           800          
00001722  4EF9 00001728            801          JMP     EA_CMPI
00001728                           802  
00001728                           803  EA_CMPI
00001728                           804          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
00001728                           805          *and D3 holds the EA register.
00001728                           806          
00001728                           807          *Determine how much data to read in, depending on the size of the operation
00001728                           808          *output the size of the operation and the immediate data to console
00001728  4EB9 0000189C            809          JSR     WrapperSizeImmediate
0000172E                           810          
0000172E                           811          *manually output a comma here...
0000172E  43F9 0000251E            812          LEA     Comma,A1        *Loads Comma into address register A1
00001734  103C 000E                813          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001738  4E4F                     814          TRAP    #15             *Displays Message
0000173A                           815          
0000173A                           816          *Determine which EA mode and thus Register/Mem Address this instruction used
0000173A  B43C 0000                817          CMP.B   #$00,D2
0000173E  6700 0282                818          BEQ     DataRegMode *If EA mode is a data register, output that
00001742                           819          
00001742  B43C 0002                820          CMP.B   #$02,D2
00001746  6700 029A                821          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000174A                           822          
0000174A  B43C 0003                823          CMP.B   #$03,D2
0000174E  6700 02A2                824          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001752                           825          
00001752  B43C 0004                826          CMP.B   #$04,D2
00001756  6700 02AA                827          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000175A                           828          
0000175A  B43C 0007                829          CMP.B   #$07,D2
0000175E  6700 02B2                830          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001762                           831          
00001762                           832          *If the ea mode isn't equal to any of these, it is an invalid EA
00001762  4EF9 00001E58            833          JMP     BADEACODE
00001768                           834        
00001768                           835    
00001768                           836  *STARTS WITH 0001, MOVE.B-----------------------------------
00001768                           837  BUCKET_0001
00001768  =00000001                838  BUCKET0001_BITS EQU $1
00001768                           839          
00001768                           840          *some code...
00001768                           841  
00001768                           842  
00001768                           843  *STARTS WITH 0010, MOVE.L-----------------------------------
00001768                           844  BUCKET_0010
00001768  =00000002                845  BUCKET0010_BITS EQU $2
00001768                           846  
00001768                           847          *some code...
00001768                           848  
00001768                           849  
00001768                           850  *STARTS WITH 0011, MOVE.W-----------------------------------
00001768                           851  BUCKET_0011
00001768  =00000003                852  BUCKET0011_BITS EQU $3
00001768                           853  
00001768                           854          *some code...
00001768                           855  
00001768                           856  
00001768                           857  *-----------------------------------------------------------        
00001768                           858  * Bucket 0100:
00001768                           859  * STARTS WITH 0100, MOVEM | MULS(L)-------------------------
00001768                           860  *                   LEA | CLR | JSR | RTS-------------------
00001768                           861  *-----------------------------------------------------------
00001768                           862  BUCKET_0100
00001768  =00000004                863  BUCKET0100_BITS EQU $4
00001768  4281                     864          CLR.L   D1
0000176A                           865          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000176A  123C 0004                866          MOVE.B  #BUCKET0100_BITS,D1
0000176E                           867          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0100. 
0000176E                           868          *If equal, continue decoding. If not, branch to next bucket.
0000176E  B200                     869          CMP.B   D0,D1
00001770  6600 0124                870          BNE     BUCKET_0101
00001774                           871  
00001774                           872          *Test the 8th bit in this instruction, if it is 1, then it is an LEA 
00001774                           873          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1.
00001774  3007                     874          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001776  0800 0008                875          BTST.L  #$08,D0
0000177A  6600 0038                876          BNE     IS_LEA  *If the zbit was 0 (the 8th bit is 1), branch to IS_LEA
0000177E                           877  
0000177E                           878          *JSR/RTS in this bucket can only be determined by only bits 11-6
0000177E  C07C 0FC0                879          AND.W   #$0FC0,D0   *Mask out everything but bits 11-6
00001782  EC48                     880          LSR.W   #$06,D0     *Move bits 11-6 into LSB position
00001784                           881          
00001784                           882          *Check bits 11-6 in the instruction and branch to different either JSR or RTS 
00001784                           883          *depending on what the bits equal
00001784  B03C 003A                884          CMP.B   #$3A,D0 *Is this a JSR?
00001788  6700 010C                885          BEQ     IS_JSR
0000178C  B03C 0039                886          CMP.B   #$39,D0 *Is this a RTS?
00001790  6700 0104                887          BEQ     IS_RTS
00001794                           888  
00001794                           889          *Now we can use only bits 11-8 and branch to different op-codes only needing these
00001794                           890          *four bits to be unambiguous
00001794  E448                     891          LSR.W   #$02,D0 *Shift the 7-6 bits out, leaving only 11-8
00001796  B03C 0008                892          CMP.B   #$08,D0 *Is this a MOVEM(RegToMem)?
0000179A  6700 0018                893          BEQ     IS_MOVEM_RegToMem
0000179E  B03C 000C                894          CMP.B   #$0C,D0 *Is this a MOVEM(MemToReg)?
000017A2  6700 0010                895          BEQ     IS_MOVEM_MemToReg
000017A6  B03C 0002                896          CMP.B   #$02,D0 *Is this a CLR?
000017AA  6700 0080                897          BEQ     IS_CLR
000017AE                           898          
000017AE                           899          *If we get through all of the compares without finding the specific instruction,
000017AE                           900          *then this instruction is either not in our list of OP CODES to decode, or is an
000017AE                           901          *invalid instruction/syntax.
000017AE  4EF9 00001E48            902          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000017B4                           903  
000017B4                           904  
000017B4                           905  *Now we know this instruction is exactly MOVEM(RegToMem), lets set everything up for EA.
000017B4                           906  IS_MOVEM_RegToMem
000017B4                           907  
000017B4                           908  EA_MOVEM_RegToMem
000017B4                           909  
000017B4                           910  
000017B4                           911  *Now we know this instruction is exactly MOVEM(MemToReg), lets set everything up for EA.
000017B4                           912  IS_MOVEM_MemToReg
000017B4                           913  
000017B4                           914  EA_MOVEM_MemToReg
000017B4                           915  
000017B4                           916  
000017B4                           917  *Now we know this instruction is exactly LEA, lets set everything up for EA.
000017B4                           918  IS_LEA
000017B4                           919          *Check bits 7 and 6, these should be 1 and 1. If not, this instruction is
000017B4                           920          *invalid, branch to BADOPCODE
000017B4  3007                     921          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000017B6  0800 0007                922          BTST.L  #$07,D0
000017BA  6700 068C                923          BEQ     BADOPCODE  *If the zbit was 1 (the 7th bit is 0), branch to BADOPCODE
000017BE  0800 0006                924          BTST.L  #$06,D0
000017C2  6700 0684                925          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000017C6                           926          
000017C6                           927          *Output 'LEA' to console...
000017C6  43F9 0000242A            928          LEA     LEA,A1         *Loads LEA into address register A1
000017CC  103C 000E                929          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000017D0  4E4F                     930          TRAP    #15             *Displays Message
000017D2                           931          
000017D2                           932          
000017D2                           933          *Should have a valid LEA op code. Set data up for EA.      
000017D2                           934          
000017D2                           935          *Set D1 to the EA destination register located in bits 11-9 of the instruction
000017D2  4281                     936          CLR.L   D1
000017D4  3207                     937          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000017D6  C27C 0E00                938          AND.W   #$0E00,D1   *Mask out everything but the EA destination register bits
000017DA  E049                     939          LSR.W   #$08,D1     *Shift the EA destination register bits into LSB
000017DC  E249                     940          LSR.W   #$01,D1
000017DE                           941  
000017DE                           942          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000017DE  4282                     943          CLR.L   D2
000017E0  3407                     944          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000017E2  C47C 0038                945          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000017E6  E60A                     946          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000017E8                           947                  
000017E8                           948          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000017E8  4283                     949          CLR.L   D3
000017EA  3607                     950          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000017EC  C67C 0007                951          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000017F0                           952  
000017F0  4EF9 000017F6            953          JMP     EA_LEA       
000017F6                           954  
000017F6                           955  EA_LEA
000017F6                           956          *Decode the ea bits of LEA. Assuming D1 holds the destination register, D2 holds the
000017F6                           957          *EA mode, and D3 holds the EA register.
000017F6                           958          
000017F6                           959          *Determine which EA mode and thus Register/Mem Address this instruction used
000017F6  48E7 0200                960          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
000017FA  1C3C 0001                961          MOVE.B  #$01,D6     *Flag D6 so that we come back
000017FE                           962          
000017FE  B43C 0002                963          CMP.B   #$02,D2
00001802  6700 01AA                964          BEQ     LEA_AddrIndirectWrapper *If EA mode is an addr indirect, output that
00001806                           965          
00001806  B43C 0007                966          CMP.B   #$07,D2
0000180A  6700 01AC                967          BEQ     LEA_AddrAbsoluteWrapper *If EA mode is an addr absolute word/long, output that
0000180E                           968  
0000180E                           969  EA_LEA_WrapperEnd        
0000180E  4CDF 0040                970          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001812                           971                  
00001812                           972          *manually output a comma here...
00001812  43F9 0000251E            973          LEA     Comma,A1        *Loads Comma into address register A1
00001818  103C 000E                974          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000181C  4E4F                     975          TRAP    #15             *Displays Message
0000181E                           976          
0000181E                           977          *output the destination address register to console
0000181E                           978          *Overwrite the EA register with destination register (no longer need D3 at this point)
0000181E  1601                     979          MOVE.B  D1,D3
00001820  4EB9 000019D2            980          JSR     AddrRegMode
00001826                           981          
00001826                           982          *If the ea mode isn't equal to any of these, it is an invalid EA
00001826  4EF9 00001E58            983          JMP     BADEACODE
0000182C                           984          
0000182C                           985          
0000182C                           986  *Now we know this instruction is exactly CLR, lets set everything up for EA.
0000182C                           987  IS_CLR
0000182C                           988          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000182C                           989          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000182C  4281                     990          CLR.L   D1
0000182E  3207                     991          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001830  C27C 00C0                992          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001834  EC09                     993          LSR.B   #$06,D1     *Shift the size bits into LSB
00001836                           994          
00001836  B23C 0003                995          CMP.B   #$03,D1     *Compare the size bits to $3
0000183A  6700 060C                996          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000183E                           997          
0000183E                           998          *Output 'CLR' to console...
0000183E  43F9 00002434            999          LEA     CLR,A1      *Loads CLR into address register A1
00001844  103C 000E               1000          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001848  4E4F                    1001          TRAP    #15         *Displays Message
0000184A                          1002          
0000184A                          1003          
0000184A                          1004          *Should have a valid CLR op code. Set data up for EA.
0000184A                          1005          
0000184A                          1006          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000184A  4282                    1007          CLR.L   D2
0000184C  3407                    1008          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000184E  C47C 0038               1009          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001852  E60A                    1010          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001854                          1011                  
00001854                          1012          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001854  4283                    1013          CLR.L   D3
00001856  3607                    1014          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001858  C67C 0007               1015          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000185C                          1016          
0000185C  4EF9 00001862           1017          JMP     EA_CLR
00001862                          1018  
00001862                          1019  EA_CLR
00001862                          1020          *Decode the ea bits of CLR. Assuming D1 holds the size, D2 holds the EA mode,
00001862                          1021          *and D3 holds the EA register.
00001862                          1022          
00001862                          1023          *Determine how much data to read in, depending on the size of the operation
00001862                          1024          *output the size of the operation and the immediate data to console
00001862  4EB9 0000191E           1025          JSR     WrapperSize       
00001868                          1026          
00001868                          1027          *Determine which EA mode and thus Register/Mem Address this instruction used
00001868  B43C 0000               1028          CMP.B   #$00,D2
0000186C  6700 0154               1029          BEQ     DataRegMode *If EA mode is a data register, output that
00001870                          1030          
00001870  B43C 0002               1031          CMP.B   #$02,D2
00001874  6700 016C               1032          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001878                          1033          
00001878  B43C 0003               1034          CMP.B   #$03,D2
0000187C  6700 0174               1035          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001880                          1036          
00001880  B43C 0004               1037          CMP.B   #$04,D2
00001884  6700 017C               1038          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001888                          1039          
00001888  B43C 0007               1040          CMP.B   #$07,D2
0000188C  6700 0184               1041          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001890                          1042          
00001890                          1043          *If the ea mode isn't equal to any of these, it is an invalid EA
00001890  4EF9 00001E58           1044          JMP     BADEACODE
00001896                          1045  
00001896                          1046  
00001896                          1047  *Now we know this instruction is exactly JSR, lets set everything up for EA.
00001896                          1048  IS_JSR
00001896                          1049  
00001896                          1050  EA_JSR
00001896                          1051  
00001896                          1052  
00001896                          1053  *Now we know this instruction is exactly RTS, lets set everything up for EA.
00001896                          1054  IS_RTS
00001896                          1055  
00001896                          1056  EA_RTS
00001896                          1057  
00001896                          1058  
00001896                          1059  *STARTS WITH 0101, SUBQ-------------------------------------
00001896                          1060  BUCKET_0101
00001896  =00000005               1061  BUCKET0101_BITS EQU $5
00001896                          1062  
00001896                          1063          *some code...
00001896                          1064  
00001896                          1065  
00001896                          1066  *STARTS WITH 0110, BCC--------------------------------------
00001896                          1067  BUCKET_0110
00001896  =00000006               1068  BUCKET0110_BITS EQU $6
00001896                          1069  
00001896                          1070          *some code...
00001896                          1071  
00001896                          1072  
00001896                          1073  *STARTS WITH 1000, DIVU-------------------------------------
00001896                          1074  BUCKET_1000
00001896  =00000008               1075  BUCKET1000_BITS EQU $8
00001896                          1076  
00001896                          1077          *some code...
00001896                          1078  
00001896                          1079  
00001896                          1080  *STARTS WITH 1001, SUBA-------------------------------------
00001896                          1081  BUCKET_1001
00001896  =00000009               1082  BUCKET1001_BITS EQU $9
00001896                          1083  
00001896                          1084          *some code...
00001896                          1085  
00001896                          1086  
00001896                          1087  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
00001896                          1088  BUCKET_1011
00001896  =0000000B               1089  BUCKET1011_BITS EQU $B
00001896                          1090  
00001896                          1091          *some code...
00001896                          1092  
00001896                          1093  
00001896                          1094  *STARTS WITH 1100, MULS(W) | AND----------------------------
00001896                          1095  BUCKET_1100
00001896  =0000000C               1096  BUCKET1100_BITS EQU $C
00001896                          1097  
00001896                          1098          *some code...
00001896                          1099  
00001896                          1100  
00001896                          1101  *STARTS WITH 1101, ADD | ADDA-------------------------------
00001896                          1102  BUCKET_1101
00001896  =0000000D               1103  BUCKET1101_BITS EQU $D
00001896                          1104  
00001896                          1105          *some code...
00001896                          1106  
00001896                          1107  
00001896                          1108  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
00001896                          1109  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
00001896                          1110  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
00001896                          1111  BUCKET_1110
00001896  =0000000E               1112  BUCKET1110_BITS EQU $E     
00001896                          1113  
00001896                          1114          *some code...
00001896                          1115  
00001896                          1116  
00001896                          1117  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
00001896                          1118  *for this disassembler, jump to BADOPCODE and let I/O take care of it
00001896  4EF9 00001E48           1119          JMP     BADOPCODE  
0000189C                          1120          
0000189C                          1121  
0000189C                          1122  *-----------------------------------------------------------        
0000189C                          1123  * EA operation size decoding functionality for immediate data
0000189C                          1124  *-----------------------------------------------------------   
0000189C                          1125  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
0000189C                          1126  WrapperSizeImmediate
0000189C  4284                    1127          CLR.L   D4
0000189E                          1128          *Depending on the EA size, choose which size to decode
0000189E  B23C 0000               1129          CMP.B   #$00,D1
000018A2  6700 0014               1130          BEQ     ByteSizeImmediate
000018A6                          1131          
000018A6  B23C 0001               1132          CMP.B   #$01,D1
000018AA  6700 002E               1133          BEQ     WordSizeImmediate
000018AE                          1134  
000018AE  B23C 0002               1135          CMP.B   #$02,D1
000018B2  6700 0048               1136          BEQ     LongSizeImmediate
000018B6                          1137          
000018B6                          1138  *Used to get back to what we were doing, after dealing with the specific size
000018B6                          1139  WrapperSizeImmediateEnd
000018B6  4E75                    1140          RTS
000018B8                          1141          
000018B8                          1142  ByteSizeImmediate
000018B8  3818                    1143          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
000018BA                          1144          
000018BA                          1145          *Output '.B' to console...
000018BA  43F9 0000244C           1146          LEA     ByteSize,A1 *Loads ByteSize into address register A1
000018C0  103C 000E               1147          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018C4  4E4F                    1148          TRAP    #15         *Displays Message
000018C6                          1149          
000018C6                          1150          *Output '#$' just before the immediate data
000018C6  43F9 00002523           1151          LEA     ShaBang,A1
000018CC  103C 000E               1152          MOVE.B  #14,D0
000018D0  4E4F                    1153          TRAP    #15  
000018D2                          1154          
000018D2                          1155          *output the immediate data to console with the hex-ascii converter
000018D2  4EB8 11E6               1156          JSR     HEXASCII
000018D6                          1157                  
000018D6  4EF8 18B6               1158          JMP     WrapperSizeImmediateEnd
000018DA                          1159                  
000018DA                          1160  WordSizeImmediate
000018DA  3818                    1161          MOVE.W  (A0)+,D4    *read in next word, data is that word
000018DC                          1162          
000018DC                          1163          *Output '.W' to console...
000018DC  43F9 00002453           1164          LEA     WordSize,A1 *Loads WordSize into address register A1
000018E2  103C 000E               1165          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018E6  4E4F                    1166          TRAP    #15         *Displays Message
000018E8                          1167          
000018E8                          1168          *Output '#$' just before the immediate data
000018E8  43F9 00002523           1169          LEA     ShaBang,A1
000018EE  103C 000E               1170          MOVE.B  #14,D0
000018F2  4E4F                    1171          TRAP    #15  
000018F4                          1172          
000018F4                          1173          *output the immediate data to console with the hex-ascii converter
000018F4  4EB8 11E6               1174          JSR     HEXASCII
000018F8                          1175          
000018F8  4EF8 18B6               1176          JMP     WrapperSizeImmediateEnd
000018FC                          1177                  
000018FC                          1178  LongSizeImmediate
000018FC  2818                    1179          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
000018FE                          1180          
000018FE                          1181          *Output '.L' to console...
000018FE  43F9 0000245A           1182          LEA     LongSize,A1 *Loads LongSize into address register A1
00001904  103C 000E               1183          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001908  4E4F                    1184          TRAP    #15         *Displays Message
0000190A                          1185          
0000190A                          1186          *Output '#$' just before the immediate data
0000190A  43F9 00002523           1187          LEA     ShaBang,A1
00001910  103C 000E               1188          MOVE.B  #14,D0
00001914  4E4F                    1189          TRAP    #15  
00001916                          1190          
00001916                          1191          *output the immediate data to console with the hex-ascii converter
00001916  4EB8 11E6               1192          JSR     HEXASCII
0000191A                          1193          
0000191A  4EF8 18B6               1194          JMP     WrapperSizeImmediateEnd        
0000191E                          1195  
0000191E                          1196  
0000191E                          1197  *-----------------------------------------------------------        
0000191E                          1198  * EA operation size decoding functionality for non-immediate data. Used to figure out
0000191E                          1199  * and output the size affix for a typical opcode.
0000191E                          1200  *-----------------------------------------------------------   
0000191E                          1201  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
0000191E                          1202  WrapperSize
0000191E  4284                    1203          CLR.L   D4
00001920                          1204          *Depending on the EA size, choose which size to decode
00001920  B23C 0000               1205          CMP.B   #$00,D1
00001924  6700 0014               1206          BEQ     ByteSizeOp
00001928                          1207          
00001928  B23C 0001               1208          CMP.B   #$01,D1
0000192C  6700 001C               1209          BEQ     WordSizeOp
00001930                          1210  
00001930  B23C 0002               1211          CMP.B   #$02,D1
00001934  6700 0024               1212          BEQ     LongSizeOp
00001938                          1213          
00001938                          1214  *Used to get back to what we were doing, after dealing with the specific size
00001938                          1215  WrapperSizeEnd
00001938  4E75                    1216          RTS
0000193A                          1217          
0000193A                          1218  ByteSizeOp                
0000193A                          1219          *Output '.B' to console...
0000193A  43F9 0000244C           1220          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001940  103C 000E               1221          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001944  4E4F                    1222          TRAP    #15         *Displays Message                
00001946                          1223                  
00001946  4EF8 1938               1224          JMP     WrapperSizeEnd
0000194A                          1225                  
0000194A                          1226  WordSizeOp
0000194A                          1227          *Output '.W' to console...
0000194A  43F9 00002453           1228          LEA     WordSize,A1 *Loads WordSize into address register A1
00001950  103C 000E               1229          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001954  4E4F                    1230          TRAP    #15         *Displays Message               
00001956                          1231          
00001956  4EF8 1938               1232          JMP     WrapperSizeEnd
0000195A                          1233                  
0000195A                          1234  LongSizeOp      
0000195A                          1235          *Output '.L' to console...
0000195A  43F9 0000245A           1236          LEA     LongSize,A1 *Loads LongSize into address register A1
00001960  103C 000E               1237          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001964  4E4F                    1238          TRAP    #15         *Displays Message                
00001966                          1239          
00001966  4EF8 1938               1240          JMP     WrapperSizeEnd        
0000196A                          1241  
0000196A                          1242  
0000196A                          1243  *-----------------------------------------------------------        
0000196A                          1244  * BCHG Size decoding functionality
0000196A                          1245  *----------------------------------------------------------- 
0000196A                          1246  BCHGSizeHelper
0000196A                          1247          *Determine if the EA mode is a data register. If so, output '.L' to console...
0000196A  B43C 0000               1248          CMP.B   #$00,D2
0000196E  6700 000A               1249          BEQ     BCHGLongSize
00001972                          1250          
00001972                          1251          *If the EA mode isn't a data register, WE MUST output a '.B' to console...
00001972  4EF9 0000198A           1252          JMP     BCHGByteSize
00001978                          1253          
00001978                          1254  *Used to get back to what we were doing, after dealing with the specific size
00001978                          1255  BCHGSizeHelperEnd
00001978  4E75                    1256          RTS  
0000197A                          1257          
0000197A                          1258  BCHGLongSize
0000197A                          1259          *Output '.L' to console...
0000197A  43F9 0000245A           1260          LEA     LongSize,A1 *Loads LongSize into address register A1
00001980  103C 000E               1261          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001984  4E4F                    1262          TRAP    #15         *Displays Message
00001986                          1263  
00001986  4EF8 1978               1264          JMP     BCHGSizeHelperEnd
0000198A                          1265          
0000198A                          1266  BCHGByteSize
0000198A                          1267          *Output '.B' to console...
0000198A  43F9 0000244C           1268          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001990  103C 000E               1269          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001994  4E4F                    1270          TRAP    #15         *Displays Message   
00001996                          1271          
00001996  4EF8 1978               1272          JMP     BCHGSizeHelperEnd
0000199A                          1273          
0000199A                          1274  *Output the immediate data for a BCHG(static). Data is always byte size.
0000199A                          1275  BCHGImmediate
0000199A  3818                    1276          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word        
0000199C                          1277          
0000199C                          1278          *Output '#$' just before the immediate data
0000199C  43F9 00002523           1279          LEA     ShaBang,A1
000019A2  103C 000E               1280          MOVE.B  #14,D0
000019A6  4E4F                    1281          TRAP    #15  
000019A8                          1282          
000019A8                          1283          *output the immediate data to console with the hex-ascii converter
000019A8  4EB8 11E6               1284          JSR     HEXASCII
000019AC                          1285                  
000019AC  4E75                    1286          RTS        
000019AE                          1287  
000019AE                          1288  
000019AE                          1289  *-----------------------------------------------------------        
000019AE                          1290  * LEA Wrappers to conform to design of EA mode/register as destination operand. 
000019AE                          1291  * LEA is weird in that its EA mode/register is used as a source operand.
000019AE                          1292  *-----------------------------------------------------------        
000019AE                          1293  *This conforms LEA to the JSR requirement of AddrIndirectMode. JMPs back to LEA after the JSR.
000019AE                          1294  LEA_AddrIndirectWrapper
000019AE  4EB9 000019E2           1295          JSR     AddrIndirectMode
000019B4                          1296          
000019B4  4EF8 180E               1297          JMP     EA_LEA_WrapperEnd
000019B8                          1298          
000019B8                          1299  *This conforms LEA to the JSR requirement of AddrAbsoluteMode. JMPs back to LEA after the JSR.
000019B8                          1300  LEA_AddrAbsoluteWrapper
000019B8  4EB9 00001A12           1301          JSR     AddrAbsoluteMode
000019BE                          1302          
000019BE  4EF8 180E               1303          JMP     EA_LEA_WrapperEnd
000019C2                          1304  
000019C2                          1305  
000019C2                          1306  *-----------------------------------------------------------        
000019C2                          1307  * EA Mode/EA Register decoding functionality
000019C2                          1308  *-----------------------------------------------------------        
000019C2                          1309  DataRegMode
000019C2                          1310          *Depending on the EA Register, output a different register number
000019C2  4EB9 00001A22           1311          JSR     WrapperDataReg        
000019C8                          1312          
000019C8                          1313          *if this was called for a destination decoding then we are done decoding this        
000019C8                          1314          *instruction, go get the next instruction
000019C8  BC3C 0001               1315          CMP.B   #$01,D6
000019CC  6600 F99E               1316          BNE     GRAB_NEXT_OP
000019D0                          1317          
000019D0                          1318          *else this was a source decoding, rts back to we can keep decoding
000019D0  4E75                    1319          RTS
000019D2                          1320  
000019D2                          1321  AddrRegMode
000019D2  4EB9 00001AE4           1322          JSR     WrapperAddrReg
000019D8                          1323          
000019D8                          1324          *if this was called for a destination decoding then we are done decoding this        
000019D8                          1325          *instruction, go get the next instruction
000019D8  BC3C 0001               1326          CMP.B   #$01,D6
000019DC  6600 F98E               1327          BNE     GRAB_NEXT_OP
000019E0                          1328          
000019E0                          1329          *else this was a source decoding, rts back to we can keep decoding
000019E0  4E75                    1330          RTS
000019E2                          1331  
000019E2                          1332  AddrIndirectMode
000019E2                          1333          *Depending on the EA Register, output a different register number
000019E2  4EB9 00001BA6           1334          JSR     WrapperAddrIndirect
000019E8                          1335                          
000019E8                          1336          *if this was called for a destination decoding then we are done decoding this        
000019E8                          1337          *instruction, go get the next instruction
000019E8  BC3C 0001               1338          CMP.B   #$01,D6
000019EC  6600 F97E               1339          BNE     GRAB_NEXT_OP
000019F0                          1340          
000019F0                          1341          *else this was a source decoding, rts back to we can keep decoding
000019F0  4E75                    1342          RTS
000019F2                          1343  
000019F2                          1344  AddrIndirectPostMode
000019F2                          1345          *Depending on the EA Register, output a different register number
000019F2  4EB9 00001C68           1346          JSR     WrapperAddrIndirectPost
000019F8                          1347  
000019F8                          1348          *if this was called for a destination decoding then we are done decoding this        
000019F8                          1349          *instruction, go get the next instruction
000019F8  BC3C 0001               1350          CMP.B   #$01,D6
000019FC  6600 F96E               1351          BNE     GRAB_NEXT_OP
00001A00                          1352          
00001A00                          1353          *else this was a source decoding, rts back to we can keep decoding
00001A00  4E75                    1354          RTS
00001A02                          1355  
00001A02                          1356  AddrIndirectPreMode
00001A02                          1357          *Depending on the EA Register, output a different register number
00001A02  4EB9 00001D2A           1358          JSR     WrapperAddrIndirectPre
00001A08                          1359  
00001A08                          1360          *if this was called for a destination decoding then we are done decoding this        
00001A08                          1361          *instruction, go get the next instruction
00001A08  BC3C 0001               1362          CMP.B   #$01,D6
00001A0C  6600 F95E               1363          BNE     GRAB_NEXT_OP
00001A10                          1364          
00001A10                          1365          *else this was a source decoding, rts back to we can keep decoding
00001A10  4E75                    1366          RTS
00001A12                          1367  
00001A12                          1368  AddrAbsoluteMode
00001A12                          1369          *Depending on the EA Register, output a different register number
00001A12  4EB9 00001DEC           1370          JSR     WrapperAddrAbsolute        
00001A18                          1371  
00001A18                          1372          *if this was called for a destination decoding then we are done decoding this        
00001A18                          1373          *instruction, go get the next instruction
00001A18  BC3C 0001               1374          CMP.B   #$01,D6
00001A1C  6600 F94E               1375          BNE     GRAB_NEXT_OP
00001A20                          1376          
00001A20                          1377          *else this was a source decoding, rts back to we can keep decoding
00001A20  4E75                    1378          RTS
00001A22                          1379          
00001A22                          1380  ImmediateDataMode
00001A22                          1381          *some code        
00001A22                          1382          
00001A22                          1383          
00001A22                          1384  *-----------------------------------------------------------        
00001A22                          1385  * Output logic for all Data Registers (0-7)
00001A22                          1386  *-----------------------------------------------------------
00001A22                          1387  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001A22                          1388  WrapperDataReg
00001A22                          1389          *Depending on the EA destination register, output a different register number
00001A22  B63C 0000               1390          CMP.B   #$00,D3
00001A26  6700 003C               1391          BEQ     DataReg0
00001A2A                          1392          
00001A2A  B63C 0001               1393          CMP.B   #$01,D3
00001A2E  6700 0044               1394          BEQ     DataReg1
00001A32                          1395          
00001A32  B63C 0002               1396          CMP.B   #$02,D3
00001A36  6700 004C               1397          BEQ     DataReg2
00001A3A                          1398          
00001A3A  B63C 0003               1399          CMP.B   #$03,D3
00001A3E  6700 0054               1400          BEQ     DataReg3
00001A42                          1401          
00001A42  B63C 0004               1402          CMP.B   #$04,D3
00001A46  6700 005C               1403          BEQ     DataReg4
00001A4A                          1404          
00001A4A  B63C 0005               1405          CMP.B   #$05,D3
00001A4E  6700 0064               1406          BEQ     DataReg5
00001A52                          1407          
00001A52  B63C 0006               1408          CMP.B   #$06,D3
00001A56  6700 006C               1409          BEQ     DataReg6
00001A5A                          1410          
00001A5A  B63C 0007               1411          CMP.B   #$07,D3
00001A5E  6700 0074               1412          BEQ     DataReg7        
00001A62                          1413  
00001A62                          1414  *Used to get back to 'DataRegMode', after dealing with the specific register
00001A62                          1415  WrapperDataRegEnd
00001A62  4E75                    1416          RTS
00001A64                          1417  
00001A64                          1418  DataReg0
00001A64                          1419          *Output the specific data register...
00001A64  43F9 00002461           1420          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
00001A6A  103C 000E               1421          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001A6E  4E4F                    1422          TRAP    #15             *Displays Message   
00001A70                          1423          
00001A70  4EF8 1A62               1424          JMP     WrapperDataRegEnd
00001A74                          1425  
00001A74                          1426  DataReg1
00001A74  43F9 00002464           1427          LEA     OutDataReg1,A1
00001A7A  103C 000E               1428          MOVE.B  #14,D0
00001A7E  4E4F                    1429          TRAP    #15
00001A80                          1430          
00001A80  4EF8 1A62               1431          JMP     WrapperDataRegEnd
00001A84                          1432  
00001A84                          1433  DataReg2
00001A84  43F9 00002467           1434          LEA     OutDataReg2,A1
00001A8A  103C 000E               1435          MOVE.B  #14,D0
00001A8E  4E4F                    1436          TRAP    #15
00001A90                          1437  
00001A90  4EF8 1A62               1438          JMP     WrapperDataRegEnd
00001A94                          1439      
00001A94                          1440  DataReg3
00001A94  43F9 0000246A           1441          LEA     OutDataReg3,A1
00001A9A  103C 000E               1442          MOVE.B  #14,D0
00001A9E  4E4F                    1443          TRAP    #15
00001AA0                          1444  
00001AA0  4EF8 1A62               1445          JMP     WrapperDataRegEnd
00001AA4                          1446          
00001AA4                          1447  DataReg4
00001AA4  43F9 0000246D           1448          LEA     OutDataReg4,A1
00001AAA  103C 000E               1449          MOVE.B  #14,D0
00001AAE  4E4F                    1450          TRAP    #15
00001AB0                          1451  
00001AB0  4EF8 1A62               1452          JMP     WrapperDataRegEnd
00001AB4                          1453                 
00001AB4                          1454  DataReg5
00001AB4  43F9 00002470           1455          LEA     OutDataReg5,A1
00001ABA  103C 000E               1456          MOVE.B  #14,D0
00001ABE  4E4F                    1457          TRAP    #15
00001AC0                          1458  
00001AC0  4EF8 1A62               1459          JMP     WrapperDataRegEnd
00001AC4                          1460          
00001AC4                          1461  DataReg6
00001AC4  43F9 00002473           1462          LEA     OutDataReg6,A1 A1
00001ACA  103C 000E               1463          MOVE.B  #14,D0
00001ACE  4E4F                    1464          TRAP    #15
00001AD0                          1465  
00001AD0  4EF8 1A62               1466          JMP     WrapperDataRegEnd
00001AD4                          1467          
00001AD4                          1468  DataReg7
00001AD4  43F9 00002476           1469          LEA     OutDataReg7,A1
00001ADA  103C 000E               1470          MOVE.B  #14,D0
00001ADE  4E4F                    1471          TRAP    #15
00001AE0                          1472          
00001AE0  4EF8 1A62               1473          JMP     WrapperDataRegEnd
00001AE4                          1474  
00001AE4                          1475  
00001AE4                          1476  *-----------------------------------------------------------        
00001AE4                          1477  * Output logic for all Address Registers (0-7)
00001AE4                          1478  *-----------------------------------------------------------     
00001AE4                          1479  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001AE4                          1480  WrapperAddrReg
00001AE4                          1481          *Depending on the EA Register, output a different register number
00001AE4  B63C 0000               1482          CMP.B   #$00,D3
00001AE8  6700 003C               1483          BEQ     AddrReg0
00001AEC                          1484          
00001AEC  B63C 0001               1485          CMP.B   #$01,D3
00001AF0  6700 0044               1486          BEQ     AddrReg1
00001AF4                          1487          
00001AF4  B63C 0002               1488          CMP.B   #$02,D3
00001AF8  6700 004C               1489          BEQ     AddrReg2
00001AFC                          1490          
00001AFC  B63C 0003               1491          CMP.B   #$03,D3
00001B00  6700 0054               1492          BEQ     AddrReg3
00001B04                          1493          
00001B04  B63C 0004               1494          CMP.B   #$04,D3
00001B08  6700 005C               1495          BEQ     AddrReg4
00001B0C                          1496          
00001B0C  B63C 0005               1497          CMP.B   #$05,D3
00001B10  6700 0064               1498          BEQ     AddrReg5
00001B14                          1499          
00001B14  B63C 0006               1500          CMP.B   #$06,D3
00001B18  6700 006C               1501          BEQ     AddrReg6
00001B1C                          1502          
00001B1C  B63C 0007               1503          CMP.B   #$07,D3
00001B20  6700 0074               1504          BEQ     AddrReg7
00001B24                          1505  
00001B24                          1506  *Used to get back to 'AddrRegMode', after dealing with the specific register
00001B24                          1507  WrapperAddrRegEnd
00001B24  4E75                    1508          RTS        
00001B26                          1509  
00001B26                          1510  AddrReg0
00001B26                          1511          *Output the specific address indirect register...
00001B26  43F9 00002479           1512          LEA     OutAddrReg0,A1      *Loads AddrReg0 into address register A1
00001B2C  103C 000E               1513          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001B30  4E4F                    1514          TRAP    #15                 *Displays Message        
00001B32                          1515          
00001B32  4EF8 1B24               1516          JMP     WrapperAddrRegEnd
00001B36                          1517  
00001B36                          1518  AddrReg1
00001B36  43F9 0000247C           1519          LEA     OutAddrReg1,A1
00001B3C  103C 000E               1520          MOVE.B  #14,D0
00001B40  4E4F                    1521          TRAP    #15
00001B42                          1522          
00001B42  4EF8 1B24               1523          JMP     WrapperAddrRegEnd
00001B46                          1524  
00001B46                          1525  AddrReg2
00001B46  43F9 0000247F           1526          LEA     OutAddrReg2,A1
00001B4C  103C 000E               1527          MOVE.B  #14,D0
00001B50  4E4F                    1528          TRAP    #15
00001B52                          1529          
00001B52  4EF8 1B24               1530          JMP     WrapperAddrRegEnd
00001B56                          1531  
00001B56                          1532  AddrReg3
00001B56  43F9 00002482           1533          LEA     OutAddrReg3,A1
00001B5C  103C 000E               1534          MOVE.B  #14,D0
00001B60  4E4F                    1535          TRAP    #15
00001B62                          1536          
00001B62  4EF8 1B24               1537          JMP     WrapperAddrRegEnd
00001B66                          1538  
00001B66                          1539  AddrReg4
00001B66  43F9 00002485           1540          LEA     OutAddrReg4,A1
00001B6C  103C 000E               1541          MOVE.B  #14,D0
00001B70  4E4F                    1542          TRAP    #15
00001B72                          1543          
00001B72  4EF8 1B24               1544          JMP     WrapperAddrRegEnd
00001B76                          1545  
00001B76                          1546  AddrReg5
00001B76  43F9 00002488           1547          LEA     OutAddrReg5,A1
00001B7C  103C 000E               1548          MOVE.B  #14,D0
00001B80  4E4F                    1549          TRAP    #15
00001B82                          1550          
00001B82  4EF8 1B24               1551          JMP     WrapperAddrRegEnd
00001B86                          1552  
00001B86                          1553  AddrReg6
00001B86  43F9 0000248B           1554          LEA     OutAddrReg6,A1
00001B8C  103C 000E               1555          MOVE.B  #14,D0
00001B90  4E4F                    1556          TRAP    #15
00001B92                          1557          
00001B92  4EF8 1B24               1558          JMP     WrapperAddrRegEnd
00001B96                          1559  
00001B96                          1560  AddrReg7
00001B96  43F9 0000248E           1561          LEA     OutAddrReg7,A1
00001B9C  103C 000E               1562          MOVE.B  #14,D0
00001BA0  4E4F                    1563          TRAP    #15
00001BA2                          1564          
00001BA2  4EF8 1B24               1565          JMP     WrapperAddrRegEnd
00001BA6                          1566  
00001BA6                          1567  
00001BA6                          1568  *-----------------------------------------------------------        
00001BA6                          1569  * Output logic for all Address Indirect Registers (0-7)
00001BA6                          1570  *-----------------------------------------------------------     
00001BA6                          1571  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001BA6                          1572  WrapperAddrIndirect
00001BA6                          1573          *Depending on the EA Register, output a different register number
00001BA6  B63C 0000               1574          CMP.B   #$00,D3
00001BAA  6700 003C               1575          BEQ     AddrIndReg0
00001BAE                          1576          
00001BAE  B63C 0001               1577          CMP.B   #$01,D3
00001BB2  6700 0044               1578          BEQ     AddrIndReg1
00001BB6                          1579          
00001BB6  B63C 0002               1580          CMP.B   #$02,D3
00001BBA  6700 004C               1581          BEQ     AddrIndReg2
00001BBE                          1582          
00001BBE  B63C 0003               1583          CMP.B   #$03,D3
00001BC2  6700 0054               1584          BEQ     AddrIndReg3
00001BC6                          1585          
00001BC6  B63C 0004               1586          CMP.B   #$04,D3
00001BCA  6700 005C               1587          BEQ     AddrIndReg4
00001BCE                          1588          
00001BCE  B63C 0005               1589          CMP.B   #$05,D3
00001BD2  6700 0064               1590          BEQ     AddrIndReg5
00001BD6                          1591          
00001BD6  B63C 0006               1592          CMP.B   #$06,D3
00001BDA  6700 006C               1593          BEQ     AddrIndReg6
00001BDE                          1594          
00001BDE  B63C 0007               1595          CMP.B   #$07,D3
00001BE2  6700 0074               1596          BEQ     AddrIndReg7
00001BE6                          1597  
00001BE6                          1598  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
00001BE6                          1599  WrapperAddrIndirectEnd
00001BE6  4E75                    1600          RTS        
00001BE8                          1601  
00001BE8                          1602  AddrIndReg0
00001BE8                          1603          *Output the specific address indirect register...
00001BE8  43F9 00002491           1604          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001BEE  103C 000E               1605          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001BF2  4E4F                    1606          TRAP    #15                 *Displays Message        
00001BF4                          1607          
00001BF4  4EF8 1BE6               1608          JMP     WrapperAddrIndirectEnd
00001BF8                          1609  
00001BF8                          1610  AddrIndReg1
00001BF8  43F9 00002496           1611          LEA     OutAddrIndReg1,A1
00001BFE  103C 000E               1612          MOVE.B  #14,D0
00001C02  4E4F                    1613          TRAP    #15
00001C04                          1614          
00001C04  4EF8 1BE6               1615          JMP     WrapperAddrIndirectEnd
00001C08                          1616  
00001C08                          1617  AddrIndReg2
00001C08  43F9 0000249B           1618          LEA     OutAddrIndReg2,A1
00001C0E  103C 000E               1619          MOVE.B  #14,D0
00001C12  4E4F                    1620          TRAP    #15
00001C14                          1621          
00001C14  4EF8 1BE6               1622          JMP     WrapperAddrIndirectEnd
00001C18                          1623  
00001C18                          1624  AddrIndReg3
00001C18  43F9 000024A0           1625          LEA     OutAddrIndReg3,A1
00001C1E  103C 000E               1626          MOVE.B  #14,D0
00001C22  4E4F                    1627          TRAP    #15
00001C24                          1628          
00001C24  4EF8 1BE6               1629          JMP     WrapperAddrIndirectEnd
00001C28                          1630  
00001C28                          1631  AddrIndReg4
00001C28  43F9 000024A5           1632          LEA     OutAddrIndReg4,A1
00001C2E  103C 000E               1633          MOVE.B  #14,D0
00001C32  4E4F                    1634          TRAP    #15
00001C34                          1635          
00001C34  4EF8 1BE6               1636          JMP     WrapperAddrIndirectEnd
00001C38                          1637  
00001C38                          1638  AddrIndReg5
00001C38  43F9 000024AA           1639          LEA     OutAddrIndReg5,A1
00001C3E  103C 000E               1640          MOVE.B  #14,D0
00001C42  4E4F                    1641          TRAP    #15
00001C44                          1642          
00001C44  4EF8 1BE6               1643          JMP     WrapperAddrIndirectEnd
00001C48                          1644  
00001C48                          1645  AddrIndReg6
00001C48  43F9 000024AF           1646          LEA     OutAddrIndReg6,A1
00001C4E  103C 000E               1647          MOVE.B  #14,D0
00001C52  4E4F                    1648          TRAP    #15
00001C54                          1649          
00001C54  4EF8 1BE6               1650          JMP     WrapperAddrIndirectEnd
00001C58                          1651  
00001C58                          1652  AddrIndReg7
00001C58  43F9 000024B4           1653          LEA     OutAddrIndReg7,A1
00001C5E  103C 000E               1654          MOVE.B  #14,D0
00001C62  4E4F                    1655          TRAP    #15
00001C64                          1656          
00001C64  4EF8 1BE6               1657          JMP     WrapperAddrIndirectEnd
00001C68                          1658          
00001C68                          1659          
00001C68                          1660  *-----------------------------------------------------------        
00001C68                          1661  * Output logic for all Address Indirect Post Increment Registers (0-7)
00001C68                          1662  *-----------------------------------------------------------     
00001C68                          1663  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001C68                          1664  WrapperAddrIndirectPost
00001C68                          1665          *Depending on the EA Register, output a different register number
00001C68  B63C 0000               1666          CMP.B   #$00,D3
00001C6C  6700 003C               1667          BEQ     AddrIndPoReg0
00001C70                          1668          
00001C70  B63C 0001               1669          CMP.B   #$01,D3
00001C74  6700 0044               1670          BEQ     AddrIndPoReg1
00001C78                          1671          
00001C78  B63C 0002               1672          CMP.B   #$02,D3
00001C7C  6700 004C               1673          BEQ     AddrIndPoReg2
00001C80                          1674          
00001C80  B63C 0003               1675          CMP.B   #$03,D3
00001C84  6700 0054               1676          BEQ     AddrIndPoReg3
00001C88                          1677          
00001C88  B63C 0004               1678          CMP.B   #$04,D3
00001C8C  6700 005C               1679          BEQ     AddrIndPoReg4
00001C90                          1680          
00001C90  B63C 0005               1681          CMP.B   #$05,D3
00001C94  6700 0064               1682          BEQ     AddrIndPoReg5
00001C98                          1683          
00001C98  B63C 0006               1684          CMP.B   #$06,D3
00001C9C  6700 006C               1685          BEQ     AddrIndPoReg6
00001CA0                          1686          
00001CA0  B63C 0007               1687          CMP.B   #$07,D3
00001CA4  6700 0074               1688          BEQ     AddrIndPoReg7
00001CA8                          1689  
00001CA8                          1690  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
00001CA8                          1691  WrapperAddrIndirectPostEnd
00001CA8  4E75                    1692          RTS        
00001CAA                          1693  
00001CAA                          1694  AddrIndPoReg0
00001CAA                          1695          *Output the specific address indirect post register...
00001CAA  43F9 000024B9           1696          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001CB0  103C 000E               1697          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001CB4  4E4F                    1698          TRAP    #15                 *Displays Message        
00001CB6                          1699          
00001CB6  4EF8 1CA8               1700          JMP     WrapperAddrIndirectPostEnd
00001CBA                          1701  
00001CBA                          1702  AddrIndPoReg1
00001CBA  43F9 000024BF           1703          LEA     OutAddrIndPoReg1,A1
00001CC0  103C 000E               1704          MOVE.B  #14,D0
00001CC4  4E4F                    1705          TRAP    #15
00001CC6                          1706          
00001CC6  4EF8 1CA8               1707          JMP     WrapperAddrIndirectPostEnd
00001CCA                          1708  
00001CCA                          1709  AddrIndPoReg2
00001CCA  43F9 000024C5           1710          LEA     OutAddrIndPoReg2,A1
00001CD0  103C 000E               1711          MOVE.B  #14,D0
00001CD4  4E4F                    1712          TRAP    #15
00001CD6                          1713          
00001CD6  4EF8 1CA8               1714          JMP     WrapperAddrIndirectPostEnd
00001CDA                          1715  
00001CDA                          1716  AddrIndPoReg3
00001CDA  43F9 000024CB           1717          LEA     OutAddrIndPoReg3,A1
00001CE0  103C 000E               1718          MOVE.B  #14,D0
00001CE4  4E4F                    1719          TRAP    #15
00001CE6                          1720          
00001CE6  4EF8 1CA8               1721          JMP     WrapperAddrIndirectPostEnd
00001CEA                          1722  
00001CEA                          1723  AddrIndPoReg4
00001CEA  43F9 000024D1           1724          LEA     OutAddrIndPoReg4,A1
00001CF0  103C 000E               1725          MOVE.B  #14,D0
00001CF4  4E4F                    1726          TRAP    #15
00001CF6                          1727          
00001CF6  4EF8 1CA8               1728          JMP     WrapperAddrIndirectPostEnd
00001CFA                          1729  
00001CFA                          1730  AddrIndPoReg5
00001CFA  43F9 000024D7           1731          LEA     OutAddrIndPoReg5,A1
00001D00  103C 000E               1732          MOVE.B  #14,D0
00001D04  4E4F                    1733          TRAP    #15
00001D06                          1734          
00001D06  4EF8 1CA8               1735          JMP     WrapperAddrIndirectPostEnd
00001D0A                          1736  
00001D0A                          1737  AddrIndPoReg6
00001D0A  43F9 000024DD           1738          LEA     OutAddrIndPoReg6,A1
00001D10  103C 000E               1739          MOVE.B  #14,D0
00001D14  4E4F                    1740          TRAP    #15
00001D16                          1741          
00001D16  4EF8 1CA8               1742          JMP     WrapperAddrIndirectPostEnd
00001D1A                          1743  
00001D1A                          1744  AddrIndPoReg7
00001D1A  43F9 000024E3           1745          LEA     OutAddrIndPoReg7,A1
00001D20  103C 000E               1746          MOVE.B  #14,D0
00001D24  4E4F                    1747          TRAP    #15
00001D26                          1748          
00001D26  4EF8 1CA8               1749          JMP     WrapperAddrIndirectPostEnd
00001D2A                          1750  
00001D2A                          1751  
00001D2A                          1752  *-----------------------------------------------------------        
00001D2A                          1753  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001D2A                          1754  *-----------------------------------------------------------     
00001D2A                          1755  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001D2A                          1756  WrapperAddrIndirectPre
00001D2A                          1757          *Depending on the EA Register, output a different register number
00001D2A  B63C 0000               1758          CMP.B   #$00,D3
00001D2E  6700 003C               1759          BEQ     AddrIndPrReg0
00001D32                          1760          
00001D32  B63C 0001               1761          CMP.B   #$01,D3
00001D36  6700 0044               1762          BEQ     AddrIndPrReg1
00001D3A                          1763          
00001D3A  B63C 0002               1764          CMP.B   #$02,D3
00001D3E  6700 004C               1765          BEQ     AddrIndPrReg2
00001D42                          1766          
00001D42  B63C 0003               1767          CMP.B   #$03,D3
00001D46  6700 0054               1768          BEQ     AddrIndPrReg3
00001D4A                          1769          
00001D4A  B63C 0004               1770          CMP.B   #$04,D3
00001D4E  6700 005C               1771          BEQ     AddrIndPrReg4
00001D52                          1772          
00001D52  B63C 0005               1773          CMP.B   #$05,D3
00001D56  6700 0064               1774          BEQ     AddrIndPrReg5
00001D5A                          1775          
00001D5A  B63C 0006               1776          CMP.B   #$06,D3
00001D5E  6700 006C               1777          BEQ     AddrIndPrReg6
00001D62                          1778          
00001D62  B63C 0007               1779          CMP.B   #$07,D3
00001D66  6700 0074               1780          BEQ     AddrIndPrReg7
00001D6A                          1781  
00001D6A                          1782  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001D6A                          1783  WrapperAddrIndirectPreEnd
00001D6A  4E75                    1784          RTS        
00001D6C                          1785  
00001D6C                          1786  AddrIndPrReg0
00001D6C                          1787          *Output the specific address indirect post register...
00001D6C  43F9 000024E9           1788          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001D72  103C 000E               1789          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001D76  4E4F                    1790          TRAP    #15                 *Displays Message        
00001D78                          1791          
00001D78  4EF8 1D6A               1792          JMP     WrapperAddrIndirectPreEnd
00001D7C                          1793  
00001D7C                          1794  AddrIndPrReg1
00001D7C  43F9 000024EF           1795          LEA     OutAddrIndPrReg1,A1
00001D82  103C 000E               1796          MOVE.B  #14,D0
00001D86  4E4F                    1797          TRAP    #15
00001D88                          1798          
00001D88  4EF8 1D6A               1799          JMP     WrapperAddrIndirectPreEnd
00001D8C                          1800  
00001D8C                          1801  AddrIndPrReg2
00001D8C  43F9 000024F5           1802          LEA     OutAddrIndPrReg2,A1
00001D92  103C 000E               1803          MOVE.B  #14,D0
00001D96  4E4F                    1804          TRAP    #15
00001D98                          1805          
00001D98  4EF8 1D6A               1806          JMP     WrapperAddrIndirectPreEnd
00001D9C                          1807  
00001D9C                          1808  AddrIndPrReg3
00001D9C  43F9 000024FB           1809          LEA     OutAddrIndPrReg3,A1
00001DA2  103C 000E               1810          MOVE.B  #14,D0
00001DA6  4E4F                    1811          TRAP    #15
00001DA8                          1812          
00001DA8  4EF8 1D6A               1813          JMP     WrapperAddrIndirectPreEnd
00001DAC                          1814  
00001DAC                          1815  AddrIndPrReg4
00001DAC  43F9 00002501           1816          LEA     OutAddrIndPrReg4,A1
00001DB2  103C 000E               1817          MOVE.B  #14,D0
00001DB6  4E4F                    1818          TRAP    #15
00001DB8                          1819          
00001DB8  4EF8 1D6A               1820          JMP     WrapperAddrIndirectPreEnd
00001DBC                          1821  
00001DBC                          1822  AddrIndPrReg5
00001DBC  43F9 00002507           1823          LEA     OutAddrIndPrReg5,A1
00001DC2  103C 000E               1824          MOVE.B  #14,D0
00001DC6  4E4F                    1825          TRAP    #15
00001DC8                          1826          
00001DC8  4EF8 1D6A               1827          JMP     WrapperAddrIndirectPreEnd
00001DCC                          1828  
00001DCC                          1829  AddrIndPrReg6
00001DCC  43F9 0000250D           1830          LEA     OutAddrIndPrReg6,A1
00001DD2  103C 000E               1831          MOVE.B  #14,D0
00001DD6  4E4F                    1832          TRAP    #15
00001DD8                          1833          
00001DD8  4EF8 1D6A               1834          JMP     WrapperAddrIndirectPreEnd
00001DDC                          1835  
00001DDC                          1836  AddrIndPrReg7
00001DDC  43F9 00002513           1837          LEA     OutAddrIndPrReg7,A1
00001DE2  103C 000E               1838          MOVE.B  #14,D0
00001DE6  4E4F                    1839          TRAP    #15
00001DE8                          1840          
00001DE8  4EF8 1D6A               1841          JMP     WrapperAddrIndirectPreEnd
00001DEC                          1842  
00001DEC                          1843  
00001DEC                          1844  *-----------------------------------------------------------        
00001DEC                          1845  * Output logic for absolute memory addressing (0-7)
00001DEC                          1846  *-----------------------------------------------------------     
00001DEC                          1847  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001DEC                          1848  WrapperAddrAbsolute
00001DEC  4284                    1849          CLR.L   D4
00001DEE                          1850          *Depending on the EA Register, choose which size to decode
00001DEE  B63C 0000               1851          CMP.B   #$00,D3
00001DF2  6700 000C               1852          BEQ     WordSizeAbsolute
00001DF6                          1853  
00001DF6  B63C 0001               1854          CMP.B   #$01,D3
00001DFA  6700 0028               1855          BEQ     LongSizeAbsolute
00001DFE                          1856          
00001DFE                          1857  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001DFE                          1858  WrapperAddrAbsoluteEnd
00001DFE  4E75                    1859          RTS
00001E00                          1860  
00001E00                          1861  WordSizeAbsolute        
00001E00  3818                    1862          MOVE.W  (A0)+,D4    *read in next word, data is that word        
00001E02                          1863              
00001E02                          1864          *Output ',$' just after source operand
00001E02  43F9 00002526           1865          LEA     Bang,A1
00001E08  103C 000E               1866          MOVE.B  #14,D0
00001E0C  4E4F                    1867          TRAP    #15
00001E0E                          1868              
00001E0E                          1869          *Push D1 into stack, in case something was using it
00001E0E  48E7 4000               1870          MOVEM.L D1,-(SP)
00001E12                          1871          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001E12  4281                    1872          CLR.L   D1
00001E14  123C 0001               1873          MOVE.B  #$01,D1
00001E18                          1874              
00001E18                          1875          *output the absolute mem address to console with the hex-ascii converter
00001E18  4EB8 11E6               1876          JSR     HEXASCII
00001E1C  4CDF 0002               1877          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001E20                          1878          
00001E20  4EF8 1DFE               1879          JMP     WrapperAddrAbsoluteEnd
00001E24                          1880  
00001E24                          1881  LongSizeAbsolute
00001E24  2818                    1882          MOVE.L  (A0)+,D4    *read in next long, data is that long                
00001E26                          1883                  
00001E26                          1884          *Output ',$' just after source operand
00001E26  43F9 00002526           1885          LEA     Bang,A1
00001E2C  103C 000E               1886          MOVE.B  #14,D0
00001E30  4E4F                    1887          TRAP    #15  
00001E32                          1888          
00001E32                          1889          *Push D1 into stack, in case something was using it
00001E32  48E7 4000               1890          MOVEM.L D1,-(SP)
00001E36                          1891          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001E36  4281                    1892          CLR.L   D1
00001E38  123C 0010               1893          MOVE.B  #$10,D1
00001E3C                          1894              
00001E3C                          1895          *output the absolute mem address to console with the hex-ascii converter
00001E3C  4EB8 11E6               1896          JSR     HEXASCII
00001E40  4CDF 0002               1897          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001E44                          1898          
00001E44  4EF8 1DFE               1899          JMP     WrapperAddrAbsoluteEnd
00001E48                          1900          
00001E48                          1901  
00001E48                          1902  *-----------------------------------------------------------        
00001E48                          1903  * Current handling of bad op/ea codes. Should be revisited.
00001E48                          1904  *----------------------------------------------------------- 
00001E48                          1905  BADOPCODE
00001E48                          1906          *We found a bad op code, output some error to the screen, jump to the 
00001E48                          1907          *next instruction in memory.
00001E48                          1908          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001E48                          1909          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001E48                          1910          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001E48                          1911          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001E48                          1912          *i/o and error message code...
00001E48  43F9 0000252F           1913          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001E4E  103C 000E               1914          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001E52  4E4F                    1915          TRAP    #15         *Displays Message
00001E54  4EF8 136C               1916          JMP     GRAB_NEXT_OP
00001E58                          1917                  
00001E58                          1918  BADEACODE
00001E58                          1919          *We found a bad ea code, output some error to the screen, jump to the
00001E58                          1920          *next instruction in memory.
00001E58                          1921          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001E58                          1922          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001E58  43F9 00002528           1923          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001E5E  103C 000E               1924          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001E62  4E4F                    1925          TRAP    #15         *Displays Message
00001E64  4EF8 136C               1926          JMP     GRAB_NEXT_OP
00001E68                          1927          
00001E68                          1928          
00001E68                          1929  *-----------------------------------------------------------        
00001E68                          1930  * End of Disassembler
00001E68                          1931  *-----------------------------------------------------------    
00001E68                          1932  
00001E68  4E72 2700               1933  DONE    STOP    #$2700  *What does this do? Why was it added?
00001E6C                          1934  
00001E6C  103C 0009               1935  THEEND  MOVE.B  #9,D0
00001E70  4E4F                    1936          TRAP    #15             Halt Simulator        
00001E72                          1937          
00001E72                          1938       
00001E72                          1939  *-----------------------------------------------------------        
00001E72                          1940  * Output stuff
00001E72                          1941  *-----------------------------------------------------------     
00001E72  =0000000D               1942  CR      EQU     $0D             ASCII code for Carriage Return
00001E72  =0000000A               1943  LF      EQU     $0A             ASCII code for Line Feed
00001E72= 2D 2D 2D 2D 2D 2D ...   1944  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001EB1= 7C 7C 20 20 20 20 ...   1945              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001EF0= 2D 2D 2D 2D 2D 2D ...   1946              DC.B    '-------------------------------------------------------------',CR,LF
00001F2F= 2A 2A 2A 2A 2A 2A ...   1947              DC.B    '*************************************************************',CR,LF
00001F6E= 2A 2A 2A 2A 2A 2A ...   1948              DC.B    '*************************************************************',CR,LF
00001FAD= 2A 2A 2A 2A 2A 2A ...   1949              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001FEC= 2A 2A 2A 2A 2A 2A ...   1950              DC.B    '************    ****   ************   *******  **  **********',CR,LF
0000202B= 2A 2A 2A 2A 2A 2A ...   1951              DC.B    '**********    ******        *******   ******        *********',CR,LF
0000206A= 2A 2A 2A 2A 2A 2A ...   1952              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
000020A9= 2A 2A 2A 2A 2A 2A ...   1953              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
000020E8= 2A 2A 2A 2A 2A 2A ...   1954              DC.B    '*************************************************************',CR,LF
00002127= 2A 2A 2A 2A 2A 2A ...   1955              DC.B    '*************************************************************',CR,LF
00002166= 2A 20 20 20 20 20 ...   1956              DC.B    '*                                                           *',CR,LF
000021A5= 2A 20 41 75 74 68 ...   1957              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
000021E4= 2A 20 20 20 20 20 ...   1958              DC.B    '*                                                           *',CR,LF
00002223= 2A 2A 2A 2A 2A 2A ...   1959              DC.B    '*************************************************************',CR,LF,CR,LF
00002264= 53 74 61 72 74 69 ...   1960              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00002281                          1961              
00002281= 57 6F 75 6C 64 20 ...   1962  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
000022B2                          1963  
000022B2= 20 0D 0A                1964  GETSTRTADDR DC.B    ' ',CR,LF
000022B5= 50 6C 65 61 73 65 ...   1965              DC.B    'Please type in your starting address request: ',0
000022E4                          1966              
000022E4= 20 0D 0A                1967  GETENDADDR  DC.B    ' ',CR,LF
000022E7= 50 6C 65 61 73 65 ...   1968              DC.B    'Please type in your ending address request: ',0
00002314                          1969              
00002314= 20 0D 0A                1970  QUES_CONT   DC.B    ' ',CR,LF
00002317= 57 6F 75 6C 64 20 ...   1971              DC.B    'Would you like to continue (Y/N)? ',0
0000233A                          1972              
0000233A= 20 0D 0A                1973  QUIT_MSG    DC.B    ' ',CR,LF
0000233D= 57 6F 75 6C 64 20 ...   1974              DC.B    'Would you like to quit (Y/N)? ',0
0000235C                          1975  
0000235C                          1976  *****************************************************
0000235C                          1977  * I/O storages - assuming users knows what to do.
0000235C                          1978  *****************************************************
0000235C                          1979  CMD_HLD     DS.B    30
0000237A                          1980  CMD_SZ      DS.B    30
00002398                          1981  STADDR      DS.B    10
000023A2                          1982  STADDRSZ    DS.B    10
000023AC                          1983  PROGST      DS.L    1
000023B0                          1984  ENDADDR     DS.B    10
000023BA                          1985  ENDADDRSZ   DS.B    10
000023C4                          1986  PROGEND     DS.L    1
000023C8                          1987  CONT        DS.B    30
000023E6                          1988  *****************************************************
000023E6                          1989  
000023E6                          1990  *Table for 0-9 && A-F
000023E6= 30 00                   1991  PRNT0   DC.B    '0',0
000023E8= 31 00                   1992  PRNT1   DC.B    '1',0
000023EA= 32 00                   1993  PRNT2   DC.B    '2',0
000023EC= 33 00                   1994  PRNT3   DC.B    '3',0
000023EE= 34 00                   1995  PRNT4   DC.B    '4',0
000023F0= 35 00                   1996  PRNT5   DC.B    '5',0
000023F2= 36 00                   1997  PRNT6   DC.B    '6',0
000023F4= 37 00                   1998  PRNT7   DC.B    '7',0
000023F6= 38 00                   1999  PRNT8   DC.B    '8',0
000023F8= 39 00                   2000  PRNT9   DC.B    '9',0
000023FA= 41 00                   2001  PRNTA   DC.B    'A',0
000023FC= 42 00                   2002  PRNTB   DC.B    'B',0
000023FE= 43 00                   2003  PRNTC   DC.B    'C',0
00002400= 44 00                   2004  PRNTD   DC.B    'D',0
00002402= 45 00                   2005  PRNTE   DC.B    'E',0
00002404= 46 00                   2006  PRNTF   DC.B    'F',0
00002406                          2007  
00002406                          2008  *output for all OPCODEs
00002406                          2009  *Bucket 0000
00002406= 41 44 44 49 00          2010  ADDI    DC.B    'ADDI',0
0000240B= 41 4E 44 49 00          2011  ANDI    DC.B    'ANDI',0
00002410= 45 4F 52 49 00          2012  EORI    DC.B    'EORI',0
00002415= 42 43 48 47 00          2013  BCHG    DC.B    'BCHG',0
0000241A= 43 4D 50 49 00          2014  CMPI    DC.B    'CMPI',0
0000241F                          2015  *Bucket 0100
0000241F= 4D 4F 56 45 4D 00       2016  MOVEM   DC.B    'MOVEM',0
00002425= 4D 55 4C 53 00          2017  MULS    DC.B    'MULS',0
0000242A= 4C 45 41 20 20 20 ...   2018  LEA     DC.B    'LEA      ',0   *Need spaces here since LEA has no size
00002434= 43 4C 52 00             2019  CLR     DC.B    'CLR',0
00002438= 4A 53 52 20 20 20 ...   2020  JSR     DC.B    'JSR      ',0   *Need spaces here since JSR has no size
00002442= 52 54 53 20 20 20 ...   2021  RTS     DC.B    'RTS      ',0   *Need spaces here since RTS has no size
0000244C                          2022  
0000244C                          2023  *output for the size of the operation
0000244C= 2E 42 20 20 20 20 00    2024  ByteSize    DC.B    '.B    ',0
00002453= 2E 57 20 20 20 20 00    2025  WordSize    DC.B    '.W    ',0
0000245A= 2E 4C 20 20 20 20 00    2026  LongSize    DC.B    '.L    ',0
00002461                          2027  
00002461                          2028  *output for all data registers (0-7)
00002461= 44 30 00                2029  OutDataReg0 DC.B    'D0',0
00002464= 44 31 00                2030  OutDataReg1 DC.B    'D1',0
00002467= 44 32 00                2031  OutDataReg2 DC.B    'D2',0
0000246A= 44 33 00                2032  OutDataReg3 DC.B    'D3',0
0000246D= 44 34 00                2033  OutDataReg4 DC.B    'D4',0
00002470= 44 35 00                2034  OutDataReg5 DC.B    'D5',0
00002473= 44 36 00                2035  OutDataReg6 DC.B    'D6',0
00002476= 44 37 00                2036  OutDataReg7 DC.B    'D7',0
00002479                          2037  
00002479                          2038  *output for all address registers (0-7)
00002479= 41 30 00                2039  OutAddrReg0 DC.B    'A0',0
0000247C= 41 31 00                2040  OutAddrReg1 DC.B    'A1',0
0000247F= 41 32 00                2041  OutAddrReg2 DC.B    'A2',0
00002482= 41 33 00                2042  OutAddrReg3 DC.B    'A3',0
00002485= 41 34 00                2043  OutAddrReg4 DC.B    'A4',0
00002488= 41 35 00                2044  OutAddrReg5 DC.B    'A5',0
0000248B= 41 36 00                2045  OutAddrReg6 DC.B    'A6',0
0000248E= 41 37 00                2046  OutAddrReg7 DC.B    'A7',0
00002491                          2047          
00002491                          2048  *output for all address indirect registers (0-7)
00002491= 28 41 30 29 00          2049  OutAddrIndReg0  DC.B    '(A0)',0
00002496= 28 41 31 29 00          2050  OutAddrIndReg1  DC.B    '(A1)',0
0000249B= 28 41 32 29 00          2051  OutAddrIndReg2  DC.B    '(A2)',0
000024A0= 28 41 33 29 00          2052  OutAddrIndReg3  DC.B    '(A3)',0
000024A5= 28 41 34 29 00          2053  OutAddrIndReg4  DC.B    '(A4)',0
000024AA= 28 41 35 29 00          2054  OutAddrIndReg5  DC.B    '(A5)',0
000024AF= 28 41 36 29 00          2055  OutAddrIndReg6  DC.B    '(A6)',0
000024B4= 28 41 37 29 00          2056  OutAddrIndReg7  DC.B    '(A7)',0
000024B9                          2057  
000024B9                          2058  *output for all address indirect post registers (0-7)
000024B9= 28 41 30 29 2B 00       2059  OutAddrIndPoReg0    DC.B    '(A0)+',0
000024BF= 28 41 31 29 2B 00       2060  OutAddrIndPoReg1    DC.B    '(A1)+',0
000024C5= 28 41 32 29 2B 00       2061  OutAddrIndPoReg2    DC.B    '(A2)+',0
000024CB= 28 41 33 29 2B 00       2062  OutAddrIndPoReg3    DC.B    '(A3)+',0
000024D1= 28 41 34 29 2B 00       2063  OutAddrIndPoReg4    DC.B    '(A4)+',0
000024D7= 28 41 35 29 2B 00       2064  OutAddrIndPoReg5    DC.B    '(A5)+',0
000024DD= 28 41 36 29 2B 00       2065  OutAddrIndPoReg6    DC.B    '(A6)+',0
000024E3= 28 41 37 29 2B 00       2066  OutAddrIndPoReg7    DC.B    '(A7)+',0
000024E9                          2067  
000024E9                          2068  *output for all address indirect pre registers (0-7)
000024E9= 2D 28 41 30 29 00       2069  OutAddrIndPrReg0    DC.B    '-(A0)',0
000024EF= 2D 28 41 31 29 00       2070  OutAddrIndPrReg1    DC.B    '-(A1)',0
000024F5= 2D 28 41 32 29 00       2071  OutAddrIndPrReg2    DC.B    '-(A2)',0
000024FB= 2D 28 41 33 29 00       2072  OutAddrIndPrReg3    DC.B    '-(A3)',0
00002501= 2D 28 41 34 29 00       2073  OutAddrIndPrReg4    DC.B    '-(A4)',0
00002507= 2D 28 41 35 29 00       2074  OutAddrIndPrReg5    DC.B    '-(A5)',0
0000250D= 2D 28 41 36 29 00       2075  OutAddrIndPrReg6    DC.B    '-(A6)',0
00002513= 2D 28 41 37 29 00       2076  OutAddrIndPrReg7    DC.B    '-(A7)',0
00002519                          2077  
00002519                          2078  *output for a tab only (4 spaces)
00002519= 20 20 20 20 00          2079  Tab DC.B    '    ',0
0000251E                          2080  
0000251E                          2081  *output for a comma only
0000251E= 2C 00                   2082  Comma   DC.B    ',',0
00002520                          2083  
00002520                          2084  *output for a new line only
00002520= 0D 0A 00                2085  NewLine DC.B    CR,LF,0
00002523                          2086  
00002523                          2087  *output for a '#$' and '$' only
00002523= 23 24 00                2088  ShaBang DC.B    '#$',0
00002526= 24 00                   2089  Bang    DC.B    '$',0
00002528                          2090  
00002528                          2091  *current output for error messages
00002528= 42 41 44 20 45 41 00    2092  BADEAMSG    DC.B    'BAD EA',0
0000252F= 42 41 44 20 4F 50 00    2093  BADOPMSG    DC.B    'BAD OP',0
00002536= 49 6D 70 72 6F 70 ...   2094  INV_MSG     DC.B    'Improper command.',CR,LF,0
0000254A= 49 6E 76 61 6C 69 ...   2095  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
00002563= 49 6E 76 61 6C 69 ...   2096  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
0000257A                          2097  
0000257A                          2098          
0000257A                          2099          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                2406
ADDRABSOLUTEMODE    1A12
ADDRINDIRECTMODE    19E2
ADDRINDIRECTPOSTMODE  19F2
ADDRINDIRECTPREMODE  1A02
ADDRINDPOREG0       1CAA
ADDRINDPOREG1       1CBA
ADDRINDPOREG2       1CCA
ADDRINDPOREG3       1CDA
ADDRINDPOREG4       1CEA
ADDRINDPOREG5       1CFA
ADDRINDPOREG6       1D0A
ADDRINDPOREG7       1D1A
ADDRINDPRREG0       1D6C
ADDRINDPRREG1       1D7C
ADDRINDPRREG2       1D8C
ADDRINDPRREG3       1D9C
ADDRINDPRREG4       1DAC
ADDRINDPRREG5       1DBC
ADDRINDPRREG6       1DCC
ADDRINDPRREG7       1DDC
ADDRINDREG0         1BE8
ADDRINDREG1         1BF8
ADDRINDREG2         1C08
ADDRINDREG3         1C18
ADDRINDREG4         1C28
ADDRINDREG5         1C38
ADDRINDREG6         1C48
ADDRINDREG7         1C58
ADDRREG0            1B26
ADDRREG1            1B36
ADDRREG2            1B46
ADDRREG3            1B56
ADDRREG4            1B66
ADDRREG5            1B76
ADDRREG6            1B86
ADDRREG7            1B96
ADDRREGMODE         19D2
ANDI                240B
ASCIIHEX            1174
ASCIIHEX1           1178
BADEACODE           1E58
BADEAMSG            2528
BADOPCODE           1E48
BADOPMSG            252F
BANG                2526
BCHG                2415
BCHGBYTESIZE        198A
BCHGIMMEDIATE       199A
BCHGLONGSIZE        197A
BCHGSIZEHELPER      196A
BCHGSIZEHELPEREND   1978
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         141A
BUCKET_0001         1768
BUCKET_0010         1768
BUCKET_0011         1768
BUCKET_0100         1768
BUCKET_0101         1896
BUCKET_0110         1896
BUCKET_1000         1896
BUCKET_1001         1896
BUCKET_1011         1896
BUCKET_1100         1896
BUCKET_1101         1896
BUCKET_1110         1896
BYTESIZE            244C
BYTESIZEIMMEDIATE   18B8
BYTESIZEOP          193A
CHECK               11EA
CHECKEND1           10FA
CHECKSTRT1          10E4
CHECK_LOWN          112C
CHECK_LOWY          111A
CHECK_N             13F4
CHECK_UPN           1124
CHECK_UPY           1110
CHECK_Y             13E6
CHNG_SZB            121C
CHNG_SZL            1202
CHNG_SZW            1236
CLR                 2434
CMD_HLD             235C
CMD_SZ              237A
CMPI                241A
COMMA               251E
CONT                23C8
CONT_Q              13B4
CONV_LOL            11D4
CONV_LOOP           1250
CONV_NUM            11C0
CONV_UPL            11CA
CR                  D
DATAREG0            1A64
DATAREG1            1A74
DATAREG2            1A84
DATAREG3            1A94
DATAREG4            1AA4
DATAREG5            1AB4
DATAREG6            1AC4
DATAREG7            1AD4
DATAREGMODE         19C2
DONE                1E68
EA_ADDI             14A6
EA_ANDI             151C
EA_BCHG_D           1614
EA_BCHG_S           16AC
EA_CLR              1862
EA_CMPI             1728
EA_EORI             1592
EA_JSR              1896
EA_LEA              17F6
EA_LEA_WRAPPEREND   180E
EA_MOVEM_MEMTOREG   17B4
EA_MOVEM_REGTOMEM   17B4
EA_RTS              1896
ENDADDR             23B0
ENDADDRSZ           23BA
EORI                2410
EXITSUB             11E0
EXIT_CONV           12D6
GETENDADDR          22E4
GETSTRTADDR         22B2
GET_END             108C
GET_STRT            103E
GRAB_NEXT_OP        136C
HEXASCII            11E6
HEXASCIIREG         11FE
IMMEDIATEDATAMODE   1A22
INV2                1404
INVALID1            1134
INVENDMSG           2563
INVSTRTMSG          254A
INV_END1            1160
INV_MSG             2536
INV_STRT1           114C
IS_ADDI             1470
IS_ANDI             14E6
IS_BCHG_D           15D2
IS_BCHG_S           1670
IS_CLR              182C
IS_CMPI             16F2
IS_EORI             155C
IS_JSR              1896
IS_LEA              17B4
IS_MOVEM_MEMTOREG   17B4
IS_MOVEM_REGTOMEM   17B4
IS_RTS              1896
JSR                 2438
LEA                 242A
LEA_ADDRABSOLUTEWRAPPER  19B8
LEA_ADDRINDIRECTWRAPPER  19AE
LF                  A
LONGSIZE            245A
LONGSIZEABSOLUTE    1E24
LONGSIZEIMMEDIATE   18FC
LONGSIZEOP          195A
LOOP_1              1014
LOOP_B              1220
LOOP_L              1206
LOOP_W              123A
MAX_LINE            F
MESSAGE             1E72
MOVEM               241F
MULS                2425
NEWLINE             2520
NUM_0               12E4
NUM_1               12EC
NUM_2               12F4
NUM_3               12FC
NUM_4               1304
NUM_5               130C
NUM_6               1314
NUM_7               131C
NUM_8               1324
NUM_9               132C
NUM_A               1334
NUM_B               133C
NUM_C               1344
NUM_D               134C
NUM_E               1354
NUM_F               135C
OUTADDRINDPOREG0    24B9
OUTADDRINDPOREG1    24BF
OUTADDRINDPOREG2    24C5
OUTADDRINDPOREG3    24CB
OUTADDRINDPOREG4    24D1
OUTADDRINDPOREG5    24D7
OUTADDRINDPOREG6    24DD
OUTADDRINDPOREG7    24E3
OUTADDRINDPRREG0    24E9
OUTADDRINDPRREG1    24EF
OUTADDRINDPRREG2    24F5
OUTADDRINDPRREG3    24FB
OUTADDRINDPRREG4    2501
OUTADDRINDPRREG5    2507
OUTADDRINDPRREG6    250D
OUTADDRINDPRREG7    2513
OUTADDRINDREG0      2491
OUTADDRINDREG1      2496
OUTADDRINDREG2      249B
OUTADDRINDREG3      24A0
OUTADDRINDREG4      24A5
OUTADDRINDREG5      24AA
OUTADDRINDREG6      24AF
OUTADDRINDREG7      24B4
OUTADDRREG0         2479
OUTADDRREG1         247C
OUTADDRREG2         247F
OUTADDRREG3         2482
OUTADDRREG4         2485
OUTADDRREG5         2488
OUTADDRREG6         248B
OUTADDRREG7         248E
OUTDATAREG0         2461
OUTDATAREG1         2464
OUTDATAREG2         2467
OUTDATAREG3         246A
OUTDATAREG4         246D
OUTDATAREG5         2470
OUTDATAREG6         2473
OUTDATAREG7         2476
PRINT_NUM           12DC
PRNT0               23E6
PRNT1               23E8
PRNT2               23EA
PRNT3               23EC
PRNT4               23EE
PRNT5               23F0
PRNT6               23F2
PRNT7               23F4
PRNT8               23F6
PRNT9               23F8
PRNTA               23FA
PRNTB               23FC
PRNTC               23FE
PRNTD               2400
PRNTE               2402
PRNTF               2404
PROGEND             23C4
PROGST              23AC
QUES_CONT           2314
QUIT_MSG            233A
RTS                 2442
SHABANG             2523
STACK               7000
STADDR              2398
STADDRSZ            23A2
START               1000
STARTASSEM          2281
ST_ADDR             7FC6
ST_BAD              11DE
TAB                 2519
THEEND              1E6C
WORDSIZE            2453
WORDSIZEABSOLUTE    1E00
WORDSIZEIMMEDIATE   18DA
WORDSIZEOP          194A
WRAPPERADDRABSOLUTE  1DEC
WRAPPERADDRABSOLUTEEND  1DFE
WRAPPERADDRINDIRECT  1BA6
WRAPPERADDRINDIRECTEND  1BE6
WRAPPERADDRINDIRECTPOST  1C68
WRAPPERADDRINDIRECTPOSTEND  1CA8
WRAPPERADDRINDIRECTPRE  1D2A
WRAPPERADDRINDIRECTPREEND  1D6A
WRAPPERADDRREG      1AE4
WRAPPERADDRREGEND   1B24
WRAPPERDATAREG      1A22
WRAPPERDATAREGEND   1A62
WRAPPERSIZE         191E
WRAPPERSIZEEND      1938
WRAPPERSIZEIMMEDIATE  189C
WRAPPERSIZEIMMEDIATEEND  18B6
