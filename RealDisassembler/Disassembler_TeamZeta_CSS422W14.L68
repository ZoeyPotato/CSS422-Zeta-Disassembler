00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 4:28:59 AM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/11/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC6                  9  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00000000  =0000000F                 11  MAX_LINE    EQU     15      *Maximum number of instructions that can be 
00001000                            12  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 13              LEA stack,SP
00001004  3C3C 000F                 14              MOVE    #MAX_LINE,D6
00001008                            15  
00001008                            16  
00001008                            17  *-----------------------------------------------------------
00001008                            18  * Start of I/O
00001008                            19  *-----------------------------------------------------------            
00001008  43F9 00001B7A             20              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 21              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      22              TRAP    #15         *Displays Message
00001014                            23          
00001014  303C 0000                 24  loop_1      MOVE    #0,D0       
00001018  43F9 00001F89             25              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 26              MOVE.B  #14,D0
00001022  4E4F                      27              TRAP    #15    
00001024  303C 0002                 28              MOVE    #2,D0
00001028  43F9 00002064             29              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      30              TRAP    #15
00001030  0C01 0001                 31              CMPI.B  #01,D1
00001034  6600 00FE                 32              BNE     INVALID1
00001038  4EB9 00001110             33              JSR     CHECK_UPY
0000103E                            34  *-----------------------------------------------------------
0000103E                            35  *
0000103E                            36  * I/O: Check Start Address
0000103E                            37  *
0000103E                            38  * Make sure that start address starts after allocated 
0000103E                            39  * memory addresses. Else, it will print out a message 
0000103E                            40  * saying that requested address is invalid & prompts the
0000103E                            41  * user again for the starting address.
0000103E                            42  *-----------------------------------------------------------
0000103E  43F9 00001FBA             43  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001044  103C 000E                 44              MOVE.B  #14,D0
00001048  4E4F                      45              TRAP    #15
0000104A  43F9 000020A0             46              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001050  3239 000020AA             47              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001056  303C 0002                 48              MOVE    #2,D0           *Get start address
0000105A  4E4F                      49              TRAP    #15
0000105C  4EB9 000010E4             50              JSR     CHECKSTRT1
00001062  4287                      51              CLR.L   D7
00001064  4EB9 00001174             52              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106A  0C03 0001                 53              CMPI.B  #01,D3      *Check if there was a bad start
0000106E  6700 00DC                 54              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001072  0C87 00007FC6             55              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001078  6D00 00D2                 56              BLT     INV_STRT1   *Asks for another start address if invalid
0000107C  0C87 00FFFFFE             57              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001082  6C00 00C8                 58              BGE     INV_STRT1
00001086  23C7 000020B4             59              MOVE.L  D7,PROGST
0000108C                            60  
0000108C  43F9 00001FEC             61  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001092  103C 000E                 62              MOVE.B  #14,D0
00001096  4E4F                      63              TRAP    #15
00001098  43F9 000020B8             64              LEA     ENDADDR,A1      *Buffer to hold end address
0000109E  3239 000020C2             65              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A4  303C 0002                 66              MOVE    #2,D0
000010A8  4E4F                      67              TRAP    #15
000010AA  4EB9 000010FA             68              JSR     CHECKEND1
000010B0  4287                      69              CLR.L   D7
000010B2  4EB9 00001174             70              JSR     ASCIIHEX
000010B8  0C03 0001                 71              CMPI.B  #01,D3
000010BC  6700 00A2                 72              BEQ     INV_END1
000010C0  0C87 000020B4             73              CMPI.L  #PROGST,D7
000010C6  6D00 0098                 74              BLT     INV_END1
000010CA  0C87 00FFFFFF             75              CMPI.L  #$00FFFFFF,D7
000010D0  6C00 008E                 76              BGE     INV_END1
000010D4  23C7 000020CC             77              MOVE.L  D7,PROGEND
000010DA  2079 000020B4             78              MOVEA.L PROGST,A0
000010E0  6000 028A                 79              BRA     GRAB_NEXT_OP            
000010E4                            80                          
000010E4  0C81 00000008             81  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EA  6E00 0060                 82              BGT     INV_STRT1
000010EE  0C81 00000000             83              CMPI.L  #00,D1
000010F4  6300 0056                 84              BLS     INV_STRT1
000010F8  4E75                      85              RTS         
000010FA                            86              
000010FA  0C81 00000008             87  CHECKEND1   CMPI.L  #08,D1
00001100  6E00 005E                 88              BGT     INV_END1
00001104  0C81 00000000             89              CMPI.L  #00,D1
0000110A  6300 0054                 90              BLS     INV_END1
0000110E  4E75                      91              RTS
00001110                            92  
00001110                            93  *-----------------------------------------------------------
00001110                            94  * I/O: Input check for Y, y, N, n
00001110                            95  *-----------------------------------------------------------
00001110  0C11 0059                 96  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001114  6600 0004                 97              BNE     CHECK_LOWY
00001118  4E75                      98              RTS
0000111A  0C11 0079                 99  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
0000111E  6600 0004                100              BNE     CHECK_UPN
00001122  4E75                     101              RTS
00001124  0C11 004E                102  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001128  6700 0A46                103              BEQ     DONE
0000112C                           104              
0000112C  0C11 006E                105  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001130  6700 0A3E                106              BEQ     DONE
00001134                           107              
00001134  163C 0000                108  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001138  303C 0000                109              MOVE    #0,D0       *Prints invalid command msg if not found
0000113C  43F9 000021F9            110              LEA     INV_MSG,A1
00001142  303C 000E                111              MOVE    #14,D0
00001146  4E4F                     112              TRAP    #15
00001148  6000 FECA                113              BRA     loop_1
0000114C                           114              
0000114C  43F9 0000220D            115  INV_STRT1   LEA     INVSTRTMSG,A1
00001152  103C 000E                116              MOVE.B  #14,D0
00001156  4E4F                     117              TRAP    #15
00001158  163C 0000                118              MOVE.B  #00,D3      *Reset flag
0000115C  6000 FEE0                119              BRA     GET_STRT        
00001160                           120              
00001160  43F9 00002226            121  INV_END1    LEA     INVENDMSG,A1
00001166  103C 000E                122              MOVE.B  #14,D0
0000116A  4E4F                     123              TRAP    #15
0000116C  163C 0000                124              MOVE.B  #00,D3      *Reset flag
00001170  6000 FF1A                125              BRA     GET_END
00001174                           126              
00001174                           127  *-----------------------------------------------------------
00001174                           128  * ASCII to Hex converter
00001174                           129  *
00001174                           130  * Checks and converts the ASCII value to the hex equivalent
00001174                           131  *-----------------------------------------------------------
00001174  48E7 6000                132  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001178  0C01 0000                133  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000117C  6700 0062                134              BEQ     exitSub     *Exit subroutine 
00001180  5301                     135              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001182  E99F                     136              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001184  1419                     137              MOVE.B  (A1)+,D2    *Takes the first char
00001186  0C02 0024                138              CMPI.B  #$24,D2     *See if the first char is $
0000118A  67EC                     139              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000118C  0C02 0030                140              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001190  6D00 004C                141              BLT     st_bad      *Put error message
00001194  0C02 0039                142              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001198  6F00 0026                143              BLE     CONV_NUM    *Convert to number, if so
0000119C  0C02 0041                144              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A0  6D00 003C                145              BLT     st_bad      *Put error message
000011A4  0C02 0046                146              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011A8  6F00 0020                147              BLE     CONV_UpL    *Convert to hex
000011AC  0C02 0061                148              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B0  6D00 002C                149              BLT     st_bad
000011B4  0C02 0066                150              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011B8  6F00 001A                151              BLE     CONV_LoL    
000011BC  6E00 0020                152              BGT     st_bad      *Puts error message for anything greater than f value
000011C0                           153              
000011C0  0402 0030                154  CONV_NUM    SUBI.B  #$30,D2
000011C4  8E02                     155              OR.B    D2,D7
000011C6  4EF8 1178                156              JMP     ASCIIHEX1
000011CA  0402 0037                157  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011CE  8E02                     158              OR.B    D2,D7
000011D0  4EF8 1178                159              JMP     ASCIIHEX1
000011D4  0402 0057                160  CONV_LoL    SUBI.B  #$57,D2
000011D8  8E02                     161              OR.B    D2,D7
000011DA  4EF8 1178                162              JMP     ASCIIHEX1   
000011DE                           163  
000011DE  5203                     164  st_bad      ADDI.B  #01,D3
000011E0  4CDF 0006                165  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E4  4E75                     166              RTS
000011E6                           167              
000011E6                           168  *-----------------------------------------------------------
000011E6                           169  * Hex to ASCII converter
000011E6                           170  *-----------------------------------------------------------
000011E6  48E7 4C00                171  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EA  0C01 0000                172  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011EE  6700 002C                173              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F2  B27C 0001                174              CMP.W   #01,D1          
000011F6  6700 003E                175              BEQ     CHNG_SZW
000011FA  6000 0006                176              BRA     CHNG_SZL        
000011FE                           177  
000011FE  48E7 4C00                178  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001202  123C 0008                179  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
00001206  0C01 0000                180  LOOP_L      CMPI.B  #00,D1
0000120A  6700 00CA                181              BEQ     EXIT_CONV
0000120E  5301                     182              SUBI.B  #01,D1
00001210  E99C                     183              ROL.L   #4,D4           * Shift it for next bit
00001212  2A04                     184              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001214  4EB9 00001250            185              JSR     CONV_LOOP
0000121A  60EA                     186              BRA     LOOP_L      
0000121C                           187  
0000121C  123C 0002                188  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001220  0C01 0000                189  LOOP_B      CMPI.B  #00,D1
00001224  6700 00B0                190              BEQ     EXIT_CONV
00001228  5301                     191              SUBI.B  #01,D1
0000122A  E91C                     192              ROL.B   #4,D4           * Shift it for next bit
0000122C  2A04                     193              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000122E  4EB9 00001250            194              JSR     CONV_LOOP
00001234  60EA                     195              BRA     LOOP_B
00001236                           196              
00001236  123C 0004                197  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123A  0C01 0000                198  LOOP_W      CMPI.B  #00,D1
0000123E  6700 0096                199              BEQ     EXIT_CONV
00001242  5301                     200              SUBI.B  #01,D1
00001244  E95C                     201              ROL.W   #4,D4           * Shift it for next bit
00001246  2A04                     202              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001248  4EB9 00001250            203              JSR     CONV_LOOP
0000124E  60EA                     204              BRA     LOOP_W
00001250                           205  
00001250  0285 0000000F            206  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001256  0C05 0000                207              CMPI.B  #$0,D5
0000125A  6700 0088                208              BEQ     NUM_0
0000125E  0C05 0001                209              CMPI.B  #$1,D5
00001262  6700 0088                210              BEQ     NUM_1
00001266  0C05 0002                211              CMPI.B  #$2,D5
0000126A  6700 0088                212              BEQ     NUM_2
0000126E  0C05 0003                213              CMPI.B  #$3,D5
00001272  6700 0088                214              BEQ     NUM_3
00001276  0C05 0004                215              CMPI.B  #$4,D5
0000127A  6700 0088                216              BEQ     NUM_4
0000127E  0C05 0005                217              CMPI.B  #$5,D5
00001282  6700 0088                218              BEQ     NUM_5
00001286  0C05 0006                219              CMPI.B  #$6,D5
0000128A  6700 0088                220              BEQ     NUM_6
0000128E  0C05 0007                221              CMPI.B  #$7,D5
00001292  6700 0088                222              BEQ     NUM_7
00001296  0C05 0008                223              CMPI.B  #$8,D5
0000129A  6700 0088                224              BEQ     NUM_8
0000129E  0C05 0009                225              CMPI.B  #$9,D5
000012A2  6700 0088                226              BEQ     NUM_9
000012A6  0C05 000A                227              CMPI.B  #$A,D5
000012AA  6700 0088                228              BEQ     NUM_A
000012AE  0C05 000B                229              CMPI.B  #$B,D5
000012B2  6700 0088                230              BEQ     NUM_B
000012B6  0C05 000C                231              CMPI.B  #$C,D5
000012BA  6700 0088                232              BEQ     NUM_C
000012BE  0C05 000D                233              CMPI.B  #$D,D5
000012C2  6700 0088                234              BEQ     NUM_D
000012C6  0C05 000E                235              CMPI.B  #$E,D5
000012CA  6700 0088                236              BEQ     NUM_E
000012CE  0C05 000F                237              CMPI.B  #$F,D5
000012D2  6700 0088                238              BEQ     NUM_F
000012D6                           239              
000012D6  4CDF 0032                240  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DA  4E75                     241              RTS
000012DC                           242              
000012DC  303C 000E                243  PRINT_NUM   MOVE    #14,D0
000012E0  4E4F                     244              TRAP    #15
000012E2  4E75                     245              RTS
000012E4  43F9 000020EE            246  NUM_0       LEA     PRNT0,A1
000012EA  60F0                     247              BRA     PRINT_NUM
000012EC  43F9 000020F0            248  NUM_1       LEA     PRNT1,A1
000012F2  60E8                     249              BRA     PRINT_NUM
000012F4  43F9 000020F2            250  NUM_2       LEA     PRNT2,A1
000012FA  60E0                     251              BRA     PRINT_NUM
000012FC  43F9 000020F4            252  NUM_3       LEA     PRNT3,A1
00001302  60D8                     253              BRA     PRINT_NUM
00001304  43F9 000020F6            254  NUM_4       LEA     PRNT4,A1
0000130A  60D0                     255              BRA     PRINT_NUM
0000130C  43F9 000020F8            256  NUM_5       LEA     PRNT5,A1
00001312  60C8                     257              BRA     PRINT_NUM
00001314  43F9 000020FA            258  NUM_6       LEA     PRNT6,A1
0000131A  60C0                     259              BRA     PRINT_NUM
0000131C  43F9 000020FC            260  NUM_7       LEA     PRNT7,A1
00001322  60B8                     261              BRA     PRINT_NUM
00001324  43F9 000020FE            262  NUM_8       LEA     PRNT8,A1
0000132A  60B0                     263              BRA     PRINT_NUM
0000132C  43F9 00002100            264  NUM_9       LEA     PRNT9,A1
00001332  60A8                     265              BRA     PRINT_NUM
00001334  43F9 00002102            266  NUM_A       LEA     PRNTA,A1
0000133A  60A0                     267              BRA     PRINT_NUM
0000133C  43F9 00002104            268  NUM_B       LEA     PRNTB,A1
00001342  6098                     269              BRA     PRINT_NUM
00001344  43F9 00002106            270  NUM_C       LEA     PRNTC,A1
0000134A  6090                     271              BRA     PRINT_NUM
0000134C  43F9 00002108            272  NUM_D       LEA     PRNTD,A1
00001352  6088                     273              BRA     PRINT_NUM
00001354  43F9 0000210A            274  NUM_E       LEA     PRNTE,A1
0000135A  6080                     275              BRA     PRINT_NUM
0000135C  43F9 0000210C            276  NUM_F       LEA     PRNTF,A1
00001362  6000 FF78                277              BRA     PRINT_NUM
00001366                           278  
00001366                           279  
00001366                           280  *-----------------------------------------------------------        
00001366                           281  * Start of Disassembler
00001366                           282  *-----------------------------------------------------------
00001366                           283          *FOR DEBUGGING ONLY!!!
00001366  207C 00007FC6            284          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000136C                           285          
0000136C                           286  GRAB_NEXT_OP
0000136C  2E08                     287          MOVE.L  A0,D7       
0000136E  0C87 000020CC            288          CMPI.L  #PROGEND,D7  *Check and see if A0 == end of test address. 
00001374  6C00 FC9E                289          BGE     loop_1      * Ask user if they want to do the disassembler again
00001378  0C86 00000000            290          CMPI.L  #00,D6      * Check if max line of instructions output on console is reached
0000137E  6700 0026                291          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
00001382  5306                     292          SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
00001384                           293  
00001384                           294          *Output the address of this instruction to console...
00001384  2808                     295          MOVE.L  A0,D4
00001386  4EB8 11FE                296          JSR     HEXASCIIREG
0000138A                           297          
0000138A                           298          *Output a tab (4 spaces) to console, just after the address...
0000138A  43F9 000021DC            299          LEA     Tab,A1  *Loads Tab into address register A1
00001390  103C 000E                300          MOVE.B  #14,D0  *Moves the number 14 into data register D0
00001394  4E4F                     301          TRAP    #15     *Displays Message
00001396                           302          
00001396                           303          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
00001396                           304          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
00001396                           305          *data that may be associated with the instruction.
00001396                           306          *Post increment addr, A0 will point to the start of next instruction or will 
00001396                           307          *point to the start of any immed/abso data with this current instruction
00001396  4280                     308          CLR.L   D0
00001398  3018                     309          MOVE.W  (A0)+,D0
0000139A                           310          *Copy the word data we just moved into D0 into D7. We are copying this data
0000139A                           311          *So we always have a copy of the WHOLE instruction somewhere
0000139A  4287                     312          CLR.L   D7
0000139C  3E00                     313          MOVE.W  D0,D7
0000139E                           314          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
0000139E                           315          *four bits of the instruction. Once we have just the first four bits, we can
0000139E                           316          *begin to see which 'bucket'/category this instruction falls into. 
0000139E  E048                     317          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013A0  E848                     318          LSR.W   #$04,D0
000013A2                           319          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013A2                           320          *list of buckets until we find which one this instruction falls into.
000013A2  6000 0068                321          BRA     BUCKET_0000     * Start with 0000
000013A6                           322  
000013A6                           323  *-----------------------------------------------------------        
000013A6                           324  * Question Prompts
000013A6                           325  *-----------------------------------------------------------        
000013A6  43F9 0000201C            326  CONT_Q      LEA     QUES_CONT,A1
000013AC  303C 000E                327              MOVE    #14,D0
000013B0  4E4F                     328              TRAP    #15
000013B2  43F9 000020D0            329              LEA     CONT,A1     *Need to store Y/N
000013B8  303C 0002                330              MOVE    #2,D0
000013BC  4E4F                     331              TRAP    #15
000013BE  0C01 0001                332              CMPI.B  #01,D1
000013C2  6600 FD70                333              BNE     INVALID1
000013C6  0C39 0059 000020D0       334              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013CE  6600 0008                335              BNE     CHECK_Y
000013D2  3C3C 000F                336              MOVE    #MAX_LINE,D6    *Resets counter
000013D6  4E75                     337              RTS
000013D8  0C11 0079                338  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
000013DC  6600 0008                339              BNE     CHECK_N
000013E0  3C3C 000F                340              MOVE    #MAX_LINE,D6    *Resets counter
000013E4  4E75                     341              RTS
000013E6  0C11 004E                342  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
000013EA  6700 FC28                343              BEQ     loop_1
000013EE  0C11 006E                344              CMPI.B  #$6E,(A1)   *Checks for lowercase n
000013F2  6700 FC20                345              BEQ     loop_1      
000013F6                           346  
000013F6  163C 0000                347  INV2        MOVE.B  #0,D3       *Reset bad flag
000013FA  303C 0000                348              MOVE    #0,D0       *Prints invalid command msg if not found
000013FE  43F9 000021F9            349              LEA     INV_MSG,A1
00001404  303C 000E                350              MOVE    #14,D0
00001408  4E4F                     351              TRAP    #15
0000140A  609A                     352              BRA     CONT_Q
0000140C                           353  
0000140C                           354  *-----------------------------------------------------------        
0000140C                           355  * Bucket 0000:
0000140C                           356  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
0000140C                           357  *                   BCHG(dynamic) | BCHG (static) | CMPI----
0000140C                           358  *-----------------------------------------------------------
0000140C                           359  BUCKET_0000
0000140C  =00000000                360  BUCKET0000_BITS EQU $0
0000140C  4281                     361          CLR.L   D1
0000140E                           362          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000140E  123C 0000                363          MOVE.B  #BUCKET0000_BITS,D1
00001412                           364          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
00001412                           365          *If equal, continue decoding. If not, branch to next bucket.
00001412  B200                     366          CMP.B   D0,D1
00001414  6600 02DE                367          BNE     BUCKET_0001
00001418                           368  
00001418                           369          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001418                           370          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001418  3007                     371          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
0000141A  0800 0008                372          BTST.L  #$08,D0
0000141E  6600 01A4                373          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
00001422                           374          
00001422                           375          *Now we can check bits 11-8 in the instruction and branch to different op-codes
00001422                           376          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
00001422  E048                     377          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001424  0880 0004                378          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001428  0880 0005                379          BCLR.L  #$05,D0
0000142C  0880 0006                380          BCLR.L  #$06,D0
00001430  0880 0007                381          BCLR.L  #$07,D0
00001434                           382          
00001434                           383          *Perform compares with these 4 bits to see which specific instruction it is.
00001434  B03C 0006                384          CMP.B   #$06,D0 *Is this an ADDI?
00001438  6700 0028                385          BEQ     IS_ADDI
0000143C  B03C 0002                386          CMP.B   #$02,D0 *Is this an ANDI?
00001440  6700 0096                387          BEQ     IS_ANDI
00001444  B03C 000A                388          CMP.B   #$0A,D0 *Is this an EORI?
00001448  6700 0104                389          BEQ     IS_EORI
0000144C  B03C 0008                390          CMP.B   #$08,D0 *Is this a BCHG(static)?
00001450  6700 0210                391          BEQ     IS_BCHG_S
00001454  B03C 000C                392          CMP.B   #$0C,D0 *Is this a CMPI?
00001458  6700 0224                393          BEQ     IS_CMPI
0000145C                           394          
0000145C                           395          *If we get through all of the compares without finding the specific instruction,
0000145C                           396          *then this instruction is either not in our list of OP CODES to decode, or is an
0000145C                           397          *invalid instruction/syntax.
0000145C  4EF9 00001B50            398          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
00001462                           399          
00001462                           400          
00001462                           401  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
00001462                           402  IS_ADDI
00001462                           403          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001462                           404          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001462  4281                     405          CLR.L   D1
00001464  3207                     406          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001466  C27C 00C0                407          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000146A  EC09                     408          LSR.B   #$06,D1     *Shift the size bits into LSB
0000146C                           409          
0000146C  B23C 0003                410          CMP.B   #$03,D1     *Compare the size bits to $3
00001470  6700 06DE                411          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001474                           412          
00001474                           413          *Output 'ADDI' to console...
00001474  43F9 0000210E            414          LEA     ADDI,A1     *Loads ADDI into address register A1
0000147A  103C 000E                415          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000147E  4E4F                     416          TRAP    #15         *Displays Message
00001480                           417          
00001480                           418          
00001480                           419          *Should have a valid ADDI op code. Set data up for EA.
00001480                           420          
00001480                           421          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001480  4282                     422          CLR.L   D2
00001482  3407                     423          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001484  C47C 003C                424          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001488  E60A                     425          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000148A                           426                  
0000148A                           427          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000148A  4283                     428          CLR.L   D3
0000148C  3607                     429          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000148E  C67C 0007                430          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001492                           431          
00001492  4EF9 00001498            432          JMP     EA_ADDI
00001498                           433  
00001498                           434  EA_ADDI
00001498                           435          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
00001498                           436          *and D3 holds the EA register.
00001498                           437          
00001498                           438          *Determine how much data to read in, depending on the size of the operation
00001498                           439          *output the size of the operation and the immediate data to console
00001498  4EB9 000016FA            440          JSR     WrapperSizeImmediate
0000149E                           441          
0000149E                           442          *manually output a comma here...
0000149E  43F9 000021E1            443          LEA     Comma,A1        *Loads Comma into address register A1
000014A4  103C 000E                444          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014A8  4E4F                     445          TRAP    #15             *Displays Message        
000014AA                           446          
000014AA                           447          *Determine which EA mode and thus Register/Mem Address this instruction used
000014AA  B43C 0000                448          CMP.B   #$00,D2
000014AE  6700 02FC                449          BEQ     DataRegMode *If EA mode is a data register, output that
000014B2                           450          
000014B2  B43C 0002                451          CMP.B   #$02,D2
000014B6  6700 0304                452          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014BA                           453          
000014BA  B43C 0003                454          CMP.B   #$03,D2
000014BE  6700 030C                455          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014C2                           456          
000014C2  B43C 0004                457          CMP.B   #$04,D2
000014C6  6700 0314                458          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014CA                           459          
000014CA  B43C 0007                460          CMP.B   #$07,D2
000014CE  6700 031C                461          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014D2                           462          
000014D2                           463          *If the ea mode isn't equal to any of these, it is an invalid EA
000014D2  4EF9 00001B60            464          JMP     BADEACODE                               
000014D8                           465          
000014D8                           466  
000014D8                           467  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000014D8                           468  IS_ANDI
000014D8                           469          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014D8                           470          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014D8  4281                     471          CLR.L   D1
000014DA  3207                     472          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014DC  C27C 00C0                473          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014E0  EC09                     474          LSR.B   #$06,D1     *Shift the size bits into LSB
000014E2                           475          
000014E2  B23C 0003                476          CMP.B   #$03,D1     *Compare the size bits to $3
000014E6  6700 0668                477          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014EA                           478          
000014EA                           479          *Output 'ANDI' to console...
000014EA  43F9 00002113            480          LEA     ANDI,A1     *Loads ANDI into address register A1
000014F0  103C 000E                481          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014F4  4E4F                     482          TRAP    #15         *Displays Message
000014F6                           483          
000014F6                           484          
000014F6                           485          *Should have a valid ANDI op code. Set data up for EA.
000014F6                           486          
000014F6                           487          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014F6  4282                     488          CLR.L   D2
000014F8  3407                     489          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014FA  C47C 003C                490          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000014FE  E60A                     491          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001500                           492                  
00001500                           493          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001500  4283                     494          CLR.L   D3
00001502  3607                     495          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001504  C67C 0007                496          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001508                           497          
00001508  4EF9 0000150E            498          JMP     EA_ANDI
0000150E                           499  
0000150E                           500  EA_ANDI
0000150E                           501          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
0000150E                           502          *and D3 holds the EA register.
0000150E                           503          
0000150E                           504          *Determine how much data to read in, depending on the size of the operation
0000150E                           505          *output the size of the operation and the immediate data to console
0000150E  4EB9 000016FA            506          JSR     WrapperSizeImmediate
00001514                           507          
00001514                           508          *manually output a comma here...
00001514  43F9 000021E1            509          LEA     Comma,A1        *Loads Comma into address register A1
0000151A  103C 000E                510          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000151E  4E4F                     511          TRAP    #15             *Displays Message        
00001520                           512          
00001520                           513          *Determine which EA mode and thus Register/Mem Address this instruction used
00001520  B43C 0000                514          CMP.B   #$00,D2
00001524  6700 0286                515          BEQ     DataRegMode *If EA mode is a data register, output that
00001528                           516          
00001528  B43C 0002                517          CMP.B   #$02,D2
0000152C  6700 028E                518          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001530                           519          
00001530  B43C 0003                520          CMP.B   #$03,D2
00001534  6700 0296                521          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001538                           522          
00001538  B43C 0004                523          CMP.B   #$04,D2
0000153C  6700 029E                524          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001540                           525          
00001540  B43C 0007                526          CMP.B   #$07,D2
00001544  6700 02A6                527          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001548                           528          
00001548                           529          *If the ea mode isn't equal to any of these, it is an invalid EA
00001548  4EF9 00001B60            530          JMP     BADEACODE
0000154E                           531          
0000154E                           532  
0000154E                           533  *Now we know this instruction is exactly EORI, lets set everything up for EA.
0000154E                           534  IS_EORI
0000154E                           535          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000154E                           536          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000154E  4281                     537          CLR.L   D1
00001550  3207                     538          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001552  C27C 00C0                539          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001556  EC09                     540          LSR.B   #$06,D1     *Shift the size bits into LSB
00001558                           541          
00001558  B23C 0003                542          CMP.B   #$03,D1     *Compare the size bits to $3
0000155C  6700 05F2                543          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001560                           544          
00001560                           545          *Output 'EORI' to console...
00001560  43F9 00002118            546          LEA     EORI,A1     *Loads EORI into address register A1
00001566  103C 000E                547          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000156A  4E4F                     548          TRAP    #15         *Displays Message
0000156C                           549          
0000156C                           550          
0000156C                           551          *Should have a valid EORI op code. Set data up for EA.
0000156C                           552          
0000156C                           553          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000156C  4282                     554          CLR.L   D2
0000156E  3407                     555          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001570  C47C 003C                556          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001574  E60A                     557          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001576                           558                  
00001576                           559          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001576  4283                     560          CLR.L   D3
00001578  3607                     561          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000157A  C67C 0007                562          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000157E                           563          
0000157E  4EF9 00001584            564          JMP     EA_EORI
00001584                           565  
00001584                           566  EA_EORI
00001584                           567          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
00001584                           568          *and D3 holds the EA register.
00001584                           569          
00001584                           570          *Determine how much data to read in, depending on the size of the operation
00001584                           571          *output the size of the operation and the immediate data to console
00001584  4EB9 000016FA            572          JSR     WrapperSizeImmediate
0000158A                           573          
0000158A                           574          *manually output a comma here...
0000158A  43F9 000021E1            575          LEA     Comma,A1        *Loads Comma into address register A1
00001590  103C 000E                576          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001594  4E4F                     577          TRAP    #15             *Displays Message        
00001596                           578          
00001596                           579          *Determine which EA mode and thus Register/Mem Address this instruction used
00001596  B43C 0000                580          CMP.B   #$00,D2
0000159A  6700 0210                581          BEQ     DataRegMode *If EA mode is a data register, output that
0000159E                           582          
0000159E  B43C 0002                583          CMP.B   #$02,D2
000015A2  6700 0218                584          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015A6                           585          
000015A6  B43C 0003                586          CMP.B   #$03,D2
000015AA  6700 0220                587          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015AE                           588          
000015AE  B43C 0004                589          CMP.B   #$04,D2
000015B2  6700 0228                590          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015B6                           591          
000015B6  B43C 0007                592          CMP.B   #$07,D2
000015BA  6700 0230                593          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015BE                           594          
000015BE                           595          *If the ea mode isn't equal to any of these, it is an invalid EA
000015BE  4EF9 00001B60            596          JMP     BADEACODE
000015C4                           597  
000015C4                           598  
000015C4                           599  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015C4                           600  * everything up for EA if is a legit instruction.
000015C4                           601  IS_BCHG_D
000015C4                           602          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015C4                           603          *invalid, branch to BADOPCODE
000015C4  3007                     604          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015C6  0800 0007                605          BTST.L  #$07,D0
000015CA  6600 0584                606          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015CE  0800 0006                607          BTST.L  #$06,D0
000015D2  6700 057C                608          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000015D6                           609          
000015D6                           610          *Output 'BCHG' to console...
000015D6  43F9 0000211D            611          LEA     BCHG,A1         *Loads BCHG into address register A1
000015DC  103C 000E                612          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015E0  4E4F                     613          TRAP    #15             *Displays Message
000015E2                           614                  
000015E2                           615                  
000015E2                           616          *Should have a valid BCHG op code. Set data up for EA.
000015E2                           617  
000015E2                           618          *Set D1 to the EA source register located in bits 11-9 of the instruction
000015E2  4281                     619          CLR.L   D1
000015E4  3207                     620          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015E6  C27C 0E00                621          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
000015EA  E009                     622          LSR.B   #$08,D1     *Shift the EA source register bits into LSB
000015EC  E209                     623          LSR.B   #$01,D1
000015EE                           624  
000015EE                           625          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015EE  4282                     626          CLR.L   D2
000015F0  3407                     627          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000015F2  C47C 003C                628          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000015F6  E60A                     629          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000015F8                           630                  
000015F8                           631          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000015F8  4283                     632          CLR.L   D3
000015FA  3607                     633          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000015FC  C67C 0007                634          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001600                           635  
00001600  4EF9 00001606            636          JMP     EA_BCHG_D
00001606                           637  
00001606                           638  EA_BCHG_D
00001606                           639          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001606                           640          *D2 holds the EA mode, and D3 holds the EA register.
00001606                           641          
00001606                           642          *Determine the size of this BCHG instruction. Output the correct size...
00001606  4EB9 0000177C            643          JSR     BCHGSizeHelper
0000160C                           644          
0000160C                           645          *output the source register to console, flag D6 with a 1 so we come back...
0000160C  48E7 0200                646          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
00001610  48E7 1000                647          MOVEM.L D3,-(SP)    *Push EA destination register into stack            
00001614  1C3C 0001                648          MOVE.B  #$01,D6     *Flag D6
00001618  1601                     649          MOVE.B  D1,D3       *Move source register into D3
0000161A  4EB9 000017AC            650          JSR     DataRegMode
00001620  4CDF 0008                651          MOVEM.L (SP)+,D3    *Pull destination register back into D3
00001624  4CDF 0040                652          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001628                           653          
00001628                           654          *manually output a comma here...
00001628  43F9 000021E1            655          LEA     Comma,A1        *Loads Comma into address register A1
0000162E  103C 000E                656          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001632  4E4F                     657          TRAP    #15             *Displays Message
00001634                           658          
00001634                           659          *Determine which EA mode and thus Register/Mem Address this instruction used
00001634  B43C 0000                660          CMP.B   #$00,D2
00001638  6700 0172                661          BEQ     DataRegMode *If EA mode is a data register, output that
0000163C                           662          
0000163C  B43C 0002                663          CMP.B   #$02,D2
00001640  6700 017A                664          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001644                           665          
00001644  B43C 0003                666          CMP.B   #$03,D2
00001648  6700 0182                667          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000164C                           668          
0000164C  B43C 0004                669          CMP.B   #$04,D2
00001650  6700 018A                670          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001654                           671          
00001654  B43C 0007                672          CMP.B   #$07,D2
00001658  6700 0192                673          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000165C                           674          
0000165C                           675          *If the ea mode isn't equal to any of these, it is an invalid EA
0000165C  4EF9 00001B60            676          JMP     BADEACODE
00001662                           677  
00001662                           678  
00001662                           679  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
00001662                           680  IS_BCHG_S
00001662                           681          *TODO:Verify bits
00001662                           682  
00001662                           683          *Output 'BCHG' to console...
00001662  43F9 0000211D            684          LEA     BCHG,A1 *Loads FNDBCHG_S into address register A1
00001668  103C 000E                685          MOVE.B  #14,D0  *Moves the number 14 into data register D0
0000166C  4E4F                     686          TRAP    #15     *Displays Message
0000166E                           687          
0000166E                           688          *Should have a valid BCHG_S op code. Set data up for EA.
0000166E                           689          *TODO:
0000166E  163C 000E                690          MOVE.B  #14,D3
00001672  4EF9 00001678            691          JMP     EA_BCHG_S
00001678                           692  
00001678                           693  EA_BCHG_S
00001678  4EF9 00001B74            694          JMP     THEEND  *For now just end
0000167E                           695  
0000167E                           696  
0000167E                           697  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
0000167E                           698  IS_CMPI
0000167E                           699          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000167E                           700          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000167E  4281                     701          CLR.L   D1
00001680  3207                     702          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001682  C27C 00C0                703          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001686  EC09                     704          LSR.B   #$06,D1     *Shift the size bits into LSB
00001688                           705          
00001688  B23C 0003                706          CMP.B   #$03,D1     *Compare the size bits to $3
0000168C  6700 04C2                707          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001690                           708          
00001690                           709          *Output 'CMPI' to console...
00001690  43F9 00002122            710          LEA     CMPI,A1     *Loads CMPI into address register A1
00001696  103C 000E                711          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000169A  4E4F                     712          TRAP    #15         *Displays Message
0000169C                           713          
0000169C                           714          
0000169C                           715          *Should have a valid CMPI op code. Set data up for EA.
0000169C                           716          
0000169C                           717          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000169C  4282                     718          CLR.L   D2
0000169E  3407                     719          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000016A0  C47C 003C                720          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000016A4  E60A                     721          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000016A6                           722                  
000016A6                           723          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000016A6  4283                     724          CLR.L   D3
000016A8  3607                     725          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000016AA  C67C 0007                726          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000016AE                           727          
000016AE  4EF9 000016B4            728          JMP     EA_CMPI
000016B4                           729  
000016B4                           730  EA_CMPI
000016B4                           731          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
000016B4                           732          *and D3 holds the EA register.
000016B4                           733          
000016B4                           734          *Determine how much data to read in, depending on the size of the operation
000016B4                           735          *output the size of the operation and the immediate data to console
000016B4  4EB9 000016FA            736          JSR     WrapperSizeImmediate
000016BA                           737          
000016BA                           738          *manually output a comma here...
000016BA  43F9 000021E1            739          LEA     Comma,A1        *Loads Comma into address register A1
000016C0  103C 000E                740          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016C4  4E4F                     741          TRAP    #15             *Displays Message
000016C6                           742          
000016C6                           743          *Determine which EA mode and thus Register/Mem Address this instruction used
000016C6  B43C 0000                744          CMP.B   #$00,D2
000016CA  6700 00E0                745          BEQ     DataRegMode *If EA mode is a data register, output that
000016CE                           746          
000016CE  B43C 0002                747          CMP.B   #$02,D2
000016D2  6700 00E8                748          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016D6                           749          
000016D6  B43C 0003                750          CMP.B   #$03,D2
000016DA  6700 00F0                751          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016DE                           752          
000016DE  B43C 0004                753          CMP.B   #$04,D2
000016E2  6700 00F8                754          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000016E6                           755          
000016E6  B43C 0007                756          CMP.B   #$07,D2
000016EA  6700 0100                757          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000016EE                           758          
000016EE                           759          *If the ea mode isn't equal to any of these, it is an invalid EA
000016EE  4EF9 00001B60            760          JMP     BADEACODE
000016F4                           761  
000016F4                           762          
000016F4                           763  *STARTS WITH 0001, MOVE.B-----------------------------------
000016F4                           764  BUCKET_0001
000016F4  =00000001                765  BUCKET0001_BITS EQU $1
000016F4                           766          
000016F4                           767          *some code...
000016F4                           768  
000016F4                           769  
000016F4                           770  *STARTS WITH 0010, MOVE.L-----------------------------------
000016F4                           771  BUCKET_0010
000016F4  =00000002                772  BUCKET0010_BITS EQU $2
000016F4                           773  
000016F4                           774          *some code...
000016F4                           775  
000016F4                           776  
000016F4                           777  *STARTS WITH 0011, MOVE.W-----------------------------------
000016F4                           778  BUCKET_0011
000016F4  =00000003                779  BUCKET0011_BITS EQU $3
000016F4                           780  
000016F4                           781          *some code...
000016F4                           782  
000016F4                           783  
000016F4                           784  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
000016F4                           785  BUCKET_0100
000016F4  =00000004                786  BUCKET0100_BITS EQU $4
000016F4                           787  
000016F4                           788          *some code...
000016F4                           789  
000016F4                           790  
000016F4                           791  *STARTS WITH 0101, SUBQ-------------------------------------
000016F4                           792  BUCKET_0101
000016F4  =00000005                793  BUCKET0101_BITS EQU $5
000016F4                           794  
000016F4                           795          *some code...
000016F4                           796  
000016F4                           797  
000016F4                           798  *STARTS WITH 0110, BCC--------------------------------------
000016F4                           799  BUCKET_0110
000016F4  =00000006                800  BUCKET0110_BITS EQU $6
000016F4                           801  
000016F4                           802          *some code...
000016F4                           803  
000016F4                           804  
000016F4                           805  *STARTS WITH 1000, DIVU-------------------------------------
000016F4                           806  BUCKET_1000
000016F4  =00000008                807  BUCKET1000_BITS EQU $8
000016F4                           808  
000016F4                           809          *some code...
000016F4                           810  
000016F4                           811  
000016F4                           812  *STARTS WITH 1001, SUBA-------------------------------------
000016F4                           813  BUCKET_1001
000016F4  =00000009                814  BUCKET1001_BITS EQU $9
000016F4                           815  
000016F4                           816          *some code...
000016F4                           817  
000016F4                           818  
000016F4                           819  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000016F4                           820  BUCKET_1011
000016F4  =0000000B                821  BUCKET1011_BITS EQU $B
000016F4                           822  
000016F4                           823          *some code...
000016F4                           824  
000016F4                           825  
000016F4                           826  *STARTS WITH 1100, MULS(W) | AND----------------------------
000016F4                           827  BUCKET_1100
000016F4  =0000000C                828  BUCKET1100_BITS EQU $C
000016F4                           829  
000016F4                           830          *some code...
000016F4                           831  
000016F4                           832  
000016F4                           833  *STARTS WITH 1101, ADD | ADDA-------------------------------
000016F4                           834  BUCKET_1101
000016F4  =0000000D                835  BUCKET1101_BITS EQU $D
000016F4                           836  
000016F4                           837          *some code...
000016F4                           838  
000016F4                           839  
000016F4                           840  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000016F4                           841  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000016F4                           842  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000016F4                           843  BUCKET_1110
000016F4  =0000000E                844  BUCKET1110_BITS EQU $E     
000016F4                           845  
000016F4                           846          *some code...
000016F4                           847  
000016F4                           848  
000016F4                           849  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000016F4                           850  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000016F4  4EF9 00001B50            851          JMP     BADOPCODE  
000016FA                           852          
000016FA                           853  
000016FA                           854  *-----------------------------------------------------------        
000016FA                           855  * EA operation size decoding functionality for immediate data
000016FA                           856  *-----------------------------------------------------------   
000016FA                           857  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
000016FA                           858  WrapperSizeImmediate
000016FA  4284                     859          CLR.L   D4
000016FC                           860          *Depending on the EA Register, choose which size to decode
000016FC  B23C 0000                861          CMP.B   #$00,D1
00001700  6700 0014                862          BEQ     ByteSizeImmediate
00001704                           863          
00001704  B23C 0001                864          CMP.B   #$01,D1
00001708  6700 002E                865          BEQ     WordSizeImmediate
0000170C                           866  
0000170C  B23C 0002                867          CMP.B   #$02,D1
00001710  6700 0048                868          BEQ     LongSizeImmediate
00001714                           869          
00001714                           870  *Used to get back to what we were doing, after dealing with the specific size
00001714                           871  WrapperSizeImmediateEnd
00001714  4E75                     872          RTS
00001716                           873          
00001716                           874  ByteSizeImmediate
00001716  3818                     875          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
00001718                           876          
00001718                           877          *Output '.B' to console...
00001718  43F9 00002127            878          LEA     ByteSize,A1 *Loads ByteSize into address register A1
0000171E  103C 000E                879          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001722  4E4F                     880          TRAP    #15         *Displays Message
00001724                           881          
00001724                           882          *Output '#$' just before the immediate data
00001724  43F9 000021E6            883          LEA     ShaBang,A1
0000172A  103C 000E                884          MOVE.B  #14,D0
0000172E  4E4F                     885          TRAP    #15  
00001730                           886          
00001730                           887          *output the immediate data to console with the hex-ascii converter
00001730  4EB8 11E6                888          JSR     HEXASCII
00001734                           889                  
00001734  4EF8 1714                890          JMP     WrapperSizeImmediateEnd
00001738                           891                  
00001738                           892  WordSizeImmediate
00001738  3818                     893          MOVE.W  (A0)+,D4    *read in next word, data is that word
0000173A                           894          
0000173A                           895          *Output '.W' to console...
0000173A  43F9 0000212E            896          LEA     WordSize,A1 *Loads WordSize into address register A1
00001740  103C 000E                897          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001744  4E4F                     898          TRAP    #15         *Displays Message
00001746                           899          
00001746                           900          *Output '#$' just before the immediate data
00001746  43F9 000021E6            901          LEA     ShaBang,A1
0000174C  103C 000E                902          MOVE.B  #14,D0
00001750  4E4F                     903          TRAP    #15  
00001752                           904          
00001752                           905          *output the immediate data to console with the hex-ascii converter
00001752  4EB8 11E6                906          JSR     HEXASCII
00001756                           907          
00001756  4EF8 1714                908          JMP     WrapperSizeImmediateEnd
0000175A                           909                  
0000175A                           910  LongSizeImmediate
0000175A  2818                     911          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
0000175C                           912          
0000175C                           913          *Output '.L' to console...
0000175C  43F9 00002135            914          LEA     LongSize,A1 *Loads LongSize into address register A1
00001762  103C 000E                915          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001766  4E4F                     916          TRAP    #15         *Displays Message
00001768                           917          
00001768                           918          *Output '#$' just before the immediate data
00001768  43F9 000021E6            919          LEA     ShaBang,A1
0000176E  103C 000E                920          MOVE.B  #14,D0
00001772  4E4F                     921          TRAP    #15  
00001774                           922          
00001774                           923          *output the immediate data to console with the hex-ascii converter
00001774  4EB8 11E6                924          JSR     HEXASCII
00001778                           925          
00001778  4EF8 1714                926          JMP     WrapperSizeImmediateEnd        
0000177C                           927  
0000177C                           928  
0000177C                           929  *-----------------------------------------------------------        
0000177C                           930  * BCHG Size decoding functionality
0000177C                           931  *----------------------------------------------------------- 
0000177C                           932  BCHGSizeHelper
0000177C                           933          *Determine if the EA mode is a data register. If so, output '.L' to console...
0000177C  B43C 0000                934          CMP.B   #$00,D2
00001780  6700 000A                935          BEQ     BCHGLongSize
00001784                           936          
00001784                           937          *If the EA mode isn't a data register, WE MUST output a '.B' to console...
00001784  4EF9 0000179C            938          JMP     BCHGByteSize
0000178A                           939          
0000178A                           940  *Used to get back to what we were doing, after dealing with the specific size
0000178A                           941  BCHGSizeHelperEnd
0000178A  4E75                     942          RTS  
0000178C                           943          
0000178C                           944  BCHGLongSize
0000178C                           945          *Output '.L' to console...
0000178C  43F9 00002135            946          LEA     LongSize,A1 *Loads LongSize into address register A1
00001792  103C 000E                947          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001796  4E4F                     948          TRAP    #15         *Displays Message
00001798                           949  
00001798  4EF8 178A                950          JMP     BCHGSizeHelperEnd
0000179C                           951          
0000179C                           952  BCHGByteSize
0000179C                           953          *Output '.B' to console...
0000179C  43F9 00002127            954          LEA     ByteSize,A1 *Loads ByteSize into address register A1
000017A2  103C 000E                955          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000017A6  4E4F                     956          TRAP    #15         *Displays Message   
000017A8                           957          
000017A8  4EF8 178A                958          JMP     BCHGSizeHelperEnd
000017AC                           959  
000017AC                           960  
000017AC                           961  *-----------------------------------------------------------        
000017AC                           962  * EA Mode/EA Register decoding functionality
000017AC                           963  *-----------------------------------------------------------        
000017AC                           964  DataRegMode
000017AC                           965          *Depending on the EA Register, output a different register number
000017AC  4EB9 000017FC            966          JSR     WrapperDataReg        
000017B2                           967          
000017B2                           968          *if this was called for a destination decoding then we are done decoding this        
000017B2                           969          *instruction, go get the next instruction
000017B2  BC3C 0001                970          CMP.B   #$01,D6
000017B6  6600 FBB4                971          BNE     GRAB_NEXT_OP
000017BA                           972          
000017BA                           973          *else this was a source decoding, rts back to we can keep decoding
000017BA  4E75                     974          RTS
000017BC                           975  
000017BC                           976  AddrDirectMode
000017BC                           977          *some code...
000017BC                           978  
000017BC                           979  AddrIndirectMode
000017BC                           980          *Depending on the EA Register, output a different register number
000017BC  4EB9 000018BE            981          JSR     WrapperAddrIndirect
000017C2                           982                          
000017C2                           983          *if this was called for a destination decoding then we are done decoding this        
000017C2                           984          *instruction, go get the next instruction
000017C2  BC3C 0001                985          CMP.B   #$01,D6
000017C6  6600 FBA4                986          BNE     GRAB_NEXT_OP
000017CA                           987          
000017CA                           988          *else this was a source decoding, rts back to we can keep decoding
000017CA  4E75                     989          RTS
000017CC                           990  
000017CC                           991  AddrIndirectPostMode
000017CC                           992          *Depending on the EA Register, output a different register number
000017CC  4EB9 00001980            993          JSR     WrapperAddrIndirectPost
000017D2                           994  
000017D2                           995          *if this was called for a destination decoding then we are done decoding this        
000017D2                           996          *instruction, go get the next instruction
000017D2  BC3C 0001                997          CMP.B   #$01,D6
000017D6  6600 FB94                998          BNE     GRAB_NEXT_OP
000017DA                           999          
000017DA                          1000          *else this was a source decoding, rts back to we can keep decoding
000017DA  4E75                    1001          RTS
000017DC                          1002  
000017DC                          1003  AddrIndirectPreMode
000017DC                          1004          *Depending on the EA Register, output a different register number
000017DC  4EB9 00001A42           1005          JSR     WrapperAddrIndirectPre
000017E2                          1006  
000017E2                          1007          *if this was called for a destination decoding then we are done decoding this        
000017E2                          1008          *instruction, go get the next instruction
000017E2  BC3C 0001               1009          CMP.B   #$01,D6
000017E6  6600 FB84               1010          BNE     GRAB_NEXT_OP
000017EA                          1011          
000017EA                          1012          *else this was a source decoding, rts back to we can keep decoding
000017EA  4E75                    1013          RTS
000017EC                          1014  
000017EC                          1015  AddrAbsoluteMode
000017EC                          1016          *Depending on the EA Register, output a different register number
000017EC  4EB9 00001B04           1017          JSR     WrapperAddrAbsolute        
000017F2                          1018  
000017F2                          1019          *if this was called for a destination decoding then we are done decoding this        
000017F2                          1020          *instruction, go get the next instruction
000017F2  BC3C 0001               1021          CMP.B   #$01,D6
000017F6  6600 FB74               1022          BNE     GRAB_NEXT_OP
000017FA                          1023          
000017FA                          1024          *else this was a source decoding, rts back to we can keep decoding
000017FA  4E75                    1025          RTS
000017FC                          1026          
000017FC                          1027  ImmediateDataMode
000017FC                          1028          *some code        
000017FC                          1029          
000017FC                          1030          
000017FC                          1031  *-----------------------------------------------------------        
000017FC                          1032  * Output logic for all Data Registers (0-7)
000017FC                          1033  *-----------------------------------------------------------
000017FC                          1034  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000017FC                          1035  WrapperDataReg
000017FC                          1036          *Depending on the EA destination register, output a different register number
000017FC  B63C 0000               1037          CMP.B   #$00,D3
00001800  6700 003C               1038          BEQ     DataReg0
00001804                          1039          
00001804  B63C 0001               1040          CMP.B   #$01,D3
00001808  6700 0044               1041          BEQ     DataReg1
0000180C                          1042          
0000180C  B63C 0002               1043          CMP.B   #$02,D3
00001810  6700 004C               1044          BEQ     DataReg2
00001814                          1045          
00001814  B63C 0003               1046          CMP.B   #$03,D3
00001818  6700 0054               1047          BEQ     DataReg3
0000181C                          1048          
0000181C  B63C 0004               1049          CMP.B   #$04,D3
00001820  6700 005C               1050          BEQ     DataReg4
00001824                          1051          
00001824  B63C 0005               1052          CMP.B   #$05,D3
00001828  6700 0064               1053          BEQ     DataReg5
0000182C                          1054          
0000182C  B63C 0006               1055          CMP.B   #$06,D3
00001830  6700 006C               1056          BEQ     DataReg6
00001834                          1057          
00001834  B63C 0007               1058          CMP.B   #$07,D3
00001838  6700 0074               1059          BEQ     DataReg7        
0000183C                          1060  
0000183C                          1061  *Used to get back to 'DataRegMode', after dealing with the specific register
0000183C                          1062  WrapperDataRegEnd
0000183C  4E75                    1063          RTS
0000183E                          1064  
0000183E                          1065  DataReg0
0000183E                          1066          *Output the specific data register...
0000183E  43F9 0000213C           1067          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
00001844  103C 000E               1068          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001848  4E4F                    1069          TRAP    #15             *Displays Message   
0000184A                          1070          
0000184A  4EF8 183C               1071          JMP     WrapperDataRegEnd
0000184E                          1072  
0000184E                          1073  DataReg1
0000184E  43F9 0000213F           1074          LEA     OutDataReg1,A1
00001854  103C 000E               1075          MOVE.B  #14,D0
00001858  4E4F                    1076          TRAP    #15
0000185A                          1077          
0000185A  4EF8 183C               1078          JMP     WrapperDataRegEnd
0000185E                          1079  
0000185E                          1080  DataReg2
0000185E  43F9 00002142           1081          LEA     OutDataReg2,A1
00001864  103C 000E               1082          MOVE.B  #14,D0
00001868  4E4F                    1083          TRAP    #15
0000186A                          1084  
0000186A  4EF8 183C               1085          JMP     WrapperDataRegEnd
0000186E                          1086      
0000186E                          1087  DataReg3
0000186E  43F9 00002145           1088          LEA     OutDataReg3,A1
00001874  103C 000E               1089          MOVE.B  #14,D0
00001878  4E4F                    1090          TRAP    #15
0000187A                          1091  
0000187A  4EF8 183C               1092          JMP     WrapperDataRegEnd
0000187E                          1093          
0000187E                          1094  DataReg4
0000187E  43F9 00002148           1095          LEA     OutDataReg4,A1
00001884  103C 000E               1096          MOVE.B  #14,D0
00001888  4E4F                    1097          TRAP    #15
0000188A                          1098  
0000188A  4EF8 183C               1099          JMP     WrapperDataRegEnd
0000188E                          1100                 
0000188E                          1101  DataReg5
0000188E  43F9 0000214B           1102          LEA     OutDataReg5,A1
00001894  103C 000E               1103          MOVE.B  #14,D0
00001898  4E4F                    1104          TRAP    #15
0000189A                          1105  
0000189A  4EF8 183C               1106          JMP     WrapperDataRegEnd
0000189E                          1107          
0000189E                          1108  DataReg6
0000189E  43F9 0000214E           1109          LEA     OutDataReg6,A1 A1
000018A4  103C 000E               1110          MOVE.B  #14,D0
000018A8  4E4F                    1111          TRAP    #15
000018AA                          1112  
000018AA  4EF8 183C               1113          JMP     WrapperDataRegEnd
000018AE                          1114          
000018AE                          1115  DataReg7
000018AE  43F9 00002151           1116          LEA     OutDataReg7,A1
000018B4  103C 000E               1117          MOVE.B  #14,D0
000018B8  4E4F                    1118          TRAP    #15
000018BA                          1119          
000018BA  4EF8 183C               1120          JMP     WrapperDataRegEnd
000018BE                          1121  
000018BE                          1122  
000018BE                          1123  *-----------------------------------------------------------        
000018BE                          1124  * Output logic for all Address Indirect Registers (0-7)
000018BE                          1125  *-----------------------------------------------------------     
000018BE                          1126  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000018BE                          1127  WrapperAddrIndirect
000018BE                          1128          *Depending on the EA Register, output a different register number
000018BE  B63C 0000               1129          CMP.B   #$00,D3
000018C2  6700 003C               1130          BEQ     AddrIndReg0
000018C6                          1131          
000018C6  B63C 0001               1132          CMP.B   #$01,D3
000018CA  6700 0044               1133          BEQ     AddrIndReg1
000018CE                          1134          
000018CE  B63C 0002               1135          CMP.B   #$02,D3
000018D2  6700 004C               1136          BEQ     AddrIndReg2
000018D6                          1137          
000018D6  B63C 0003               1138          CMP.B   #$03,D3
000018DA  6700 0054               1139          BEQ     AddrIndReg3
000018DE                          1140          
000018DE  B63C 0004               1141          CMP.B   #$04,D3
000018E2  6700 005C               1142          BEQ     AddrIndReg4
000018E6                          1143          
000018E6  B63C 0005               1144          CMP.B   #$05,D3
000018EA  6700 0064               1145          BEQ     AddrIndReg5
000018EE                          1146          
000018EE  B63C 0006               1147          CMP.B   #$06,D3
000018F2  6700 006C               1148          BEQ     AddrIndReg6
000018F6                          1149          
000018F6  B63C 0007               1150          CMP.B   #$07,D3
000018FA  6700 0074               1151          BEQ     AddrIndReg7
000018FE                          1152  
000018FE                          1153  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
000018FE                          1154  WrapperAddrIndirectEnd
000018FE  4E75                    1155          RTS        
00001900                          1156  
00001900                          1157  AddrIndReg0
00001900                          1158          *Output the specific address indirect register...
00001900  43F9 00002154           1159          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001906  103C 000E               1160          MOVE.B  #14,D0              *Moves the number 14 into data register D0
0000190A  4E4F                    1161          TRAP    #15                 *Displays Message        
0000190C                          1162          
0000190C  4EF8 18FE               1163          JMP     WrapperAddrIndirectEnd
00001910                          1164  
00001910                          1165  AddrIndReg1
00001910  43F9 00002159           1166          LEA     OutAddrIndReg1,A1
00001916  103C 000E               1167          MOVE.B  #14,D0
0000191A  4E4F                    1168          TRAP    #15
0000191C                          1169          
0000191C  4EF8 18FE               1170          JMP     WrapperAddrIndirectEnd
00001920                          1171  
00001920                          1172  AddrIndReg2
00001920  43F9 0000215E           1173          LEA     OutAddrIndReg2,A1
00001926  103C 000E               1174          MOVE.B  #14,D0
0000192A  4E4F                    1175          TRAP    #15
0000192C                          1176          
0000192C  4EF8 18FE               1177          JMP     WrapperAddrIndirectEnd
00001930                          1178  
00001930                          1179  AddrIndReg3
00001930  43F9 00002163           1180          LEA     OutAddrIndReg3,A1
00001936  103C 000E               1181          MOVE.B  #14,D0
0000193A  4E4F                    1182          TRAP    #15
0000193C                          1183          
0000193C  4EF8 18FE               1184          JMP     WrapperAddrIndirectEnd
00001940                          1185  
00001940                          1186  AddrIndReg4
00001940  43F9 00002168           1187          LEA     OutAddrIndReg4,A1
00001946  103C 000E               1188          MOVE.B  #14,D0
0000194A  4E4F                    1189          TRAP    #15
0000194C                          1190          
0000194C  4EF8 18FE               1191          JMP     WrapperAddrIndirectEnd
00001950                          1192  
00001950                          1193  AddrIndReg5
00001950  43F9 0000216D           1194          LEA     OutAddrIndReg5,A1
00001956  103C 000E               1195          MOVE.B  #14,D0
0000195A  4E4F                    1196          TRAP    #15
0000195C                          1197          
0000195C  4EF8 18FE               1198          JMP     WrapperAddrIndirectEnd
00001960                          1199  
00001960                          1200  AddrIndReg6
00001960  43F9 00002172           1201          LEA     OutAddrIndReg6,A1
00001966  103C 000E               1202          MOVE.B  #14,D0
0000196A  4E4F                    1203          TRAP    #15
0000196C                          1204          
0000196C  4EF8 18FE               1205          JMP     WrapperAddrIndirectEnd
00001970                          1206  
00001970                          1207  AddrIndReg7
00001970  43F9 00002177           1208          LEA     OutAddrIndReg7,A1
00001976  103C 000E               1209          MOVE.B  #14,D0
0000197A  4E4F                    1210          TRAP    #15
0000197C                          1211          
0000197C  4EF8 18FE               1212          JMP     WrapperAddrIndirectEnd
00001980                          1213          
00001980                          1214          
00001980                          1215  *-----------------------------------------------------------        
00001980                          1216  * Output logic for all Address Indirect Post Increment Registers (0-7)
00001980                          1217  *-----------------------------------------------------------     
00001980                          1218  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001980                          1219  WrapperAddrIndirectPost
00001980                          1220          *Depending on the EA Register, output a different register number
00001980  B63C 0000               1221          CMP.B   #$00,D3
00001984  6700 003C               1222          BEQ     AddrIndPoReg0
00001988                          1223          
00001988  B63C 0001               1224          CMP.B   #$01,D3
0000198C  6700 0044               1225          BEQ     AddrIndPoReg1
00001990                          1226          
00001990  B63C 0002               1227          CMP.B   #$02,D3
00001994  6700 004C               1228          BEQ     AddrIndPoReg2
00001998                          1229          
00001998  B63C 0003               1230          CMP.B   #$03,D3
0000199C  6700 0054               1231          BEQ     AddrIndPoReg3
000019A0                          1232          
000019A0  B63C 0004               1233          CMP.B   #$04,D3
000019A4  6700 005C               1234          BEQ     AddrIndPoReg4
000019A8                          1235          
000019A8  B63C 0005               1236          CMP.B   #$05,D3
000019AC  6700 0064               1237          BEQ     AddrIndPoReg5
000019B0                          1238          
000019B0  B63C 0006               1239          CMP.B   #$06,D3
000019B4  6700 006C               1240          BEQ     AddrIndPoReg6
000019B8                          1241          
000019B8  B63C 0007               1242          CMP.B   #$07,D3
000019BC  6700 0074               1243          BEQ     AddrIndPoReg7
000019C0                          1244  
000019C0                          1245  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
000019C0                          1246  WrapperAddrIndirectPostEnd
000019C0  4E75                    1247          RTS        
000019C2                          1248  
000019C2                          1249  AddrIndPoReg0
000019C2                          1250          *Output the specific address indirect post register...
000019C2  43F9 0000217C           1251          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
000019C8  103C 000E               1252          MOVE.B  #14,D0              *Moves the number 14 into data register D0
000019CC  4E4F                    1253          TRAP    #15                 *Displays Message        
000019CE                          1254          
000019CE  4EF8 19C0               1255          JMP     WrapperAddrIndirectPostEnd
000019D2                          1256  
000019D2                          1257  AddrIndPoReg1
000019D2  43F9 00002182           1258          LEA     OutAddrIndPoReg1,A1
000019D8  103C 000E               1259          MOVE.B  #14,D0
000019DC  4E4F                    1260          TRAP    #15
000019DE                          1261          
000019DE  4EF8 19C0               1262          JMP     WrapperAddrIndirectPostEnd
000019E2                          1263  
000019E2                          1264  AddrIndPoReg2
000019E2  43F9 00002188           1265          LEA     OutAddrIndPoReg2,A1
000019E8  103C 000E               1266          MOVE.B  #14,D0
000019EC  4E4F                    1267          TRAP    #15
000019EE                          1268          
000019EE  4EF8 19C0               1269          JMP     WrapperAddrIndirectPostEnd
000019F2                          1270  
000019F2                          1271  AddrIndPoReg3
000019F2  43F9 0000218E           1272          LEA     OutAddrIndPoReg3,A1
000019F8  103C 000E               1273          MOVE.B  #14,D0
000019FC  4E4F                    1274          TRAP    #15
000019FE                          1275          
000019FE  4EF8 19C0               1276          JMP     WrapperAddrIndirectPostEnd
00001A02                          1277  
00001A02                          1278  AddrIndPoReg4
00001A02  43F9 00002194           1279          LEA     OutAddrIndPoReg4,A1
00001A08  103C 000E               1280          MOVE.B  #14,D0
00001A0C  4E4F                    1281          TRAP    #15
00001A0E                          1282          
00001A0E  4EF8 19C0               1283          JMP     WrapperAddrIndirectPostEnd
00001A12                          1284  
00001A12                          1285  AddrIndPoReg5
00001A12  43F9 0000219A           1286          LEA     OutAddrIndPoReg5,A1
00001A18  103C 000E               1287          MOVE.B  #14,D0
00001A1C  4E4F                    1288          TRAP    #15
00001A1E                          1289          
00001A1E  4EF8 19C0               1290          JMP     WrapperAddrIndirectPostEnd
00001A22                          1291  
00001A22                          1292  AddrIndPoReg6
00001A22  43F9 000021A0           1293          LEA     OutAddrIndPoReg6,A1
00001A28  103C 000E               1294          MOVE.B  #14,D0
00001A2C  4E4F                    1295          TRAP    #15
00001A2E                          1296          
00001A2E  4EF8 19C0               1297          JMP     WrapperAddrIndirectPostEnd
00001A32                          1298  
00001A32                          1299  AddrIndPoReg7
00001A32  43F9 000021A6           1300          LEA     OutAddrIndPoReg7,A1
00001A38  103C 000E               1301          MOVE.B  #14,D0
00001A3C  4E4F                    1302          TRAP    #15
00001A3E                          1303          
00001A3E  4EF8 19C0               1304          JMP     WrapperAddrIndirectPostEnd
00001A42                          1305  
00001A42                          1306  
00001A42                          1307  *-----------------------------------------------------------        
00001A42                          1308  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001A42                          1309  *-----------------------------------------------------------     
00001A42                          1310  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001A42                          1311  WrapperAddrIndirectPre
00001A42                          1312          *Depending on the EA Register, output a different register number
00001A42  B63C 0000               1313          CMP.B   #$00,D3
00001A46  6700 003C               1314          BEQ     AddrIndPrReg0
00001A4A                          1315          
00001A4A  B63C 0001               1316          CMP.B   #$01,D3
00001A4E  6700 0044               1317          BEQ     AddrIndPrReg1
00001A52                          1318          
00001A52  B63C 0002               1319          CMP.B   #$02,D3
00001A56  6700 004C               1320          BEQ     AddrIndPrReg2
00001A5A                          1321          
00001A5A  B63C 0003               1322          CMP.B   #$03,D3
00001A5E  6700 0054               1323          BEQ     AddrIndPrReg3
00001A62                          1324          
00001A62  B63C 0004               1325          CMP.B   #$04,D3
00001A66  6700 005C               1326          BEQ     AddrIndPrReg4
00001A6A                          1327          
00001A6A  B63C 0005               1328          CMP.B   #$05,D3
00001A6E  6700 0064               1329          BEQ     AddrIndPrReg5
00001A72                          1330          
00001A72  B63C 0006               1331          CMP.B   #$06,D3
00001A76  6700 006C               1332          BEQ     AddrIndPrReg6
00001A7A                          1333          
00001A7A  B63C 0007               1334          CMP.B   #$07,D3
00001A7E  6700 0074               1335          BEQ     AddrIndPrReg7
00001A82                          1336  
00001A82                          1337  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001A82                          1338  WrapperAddrIndirectPreEnd
00001A82  4E75                    1339          RTS        
00001A84                          1340  
00001A84                          1341  AddrIndPrReg0
00001A84                          1342          *Output the specific address indirect post register...
00001A84  43F9 000021AC           1343          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001A8A  103C 000E               1344          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001A8E  4E4F                    1345          TRAP    #15                 *Displays Message        
00001A90                          1346          
00001A90  4EF8 1A82               1347          JMP     WrapperAddrIndirectPreEnd
00001A94                          1348  
00001A94                          1349  AddrIndPrReg1
00001A94  43F9 000021B2           1350          LEA     OutAddrIndPrReg1,A1
00001A9A  103C 000E               1351          MOVE.B  #14,D0
00001A9E  4E4F                    1352          TRAP    #15
00001AA0                          1353          
00001AA0  4EF8 1A82               1354          JMP     WrapperAddrIndirectPreEnd
00001AA4                          1355  
00001AA4                          1356  AddrIndPrReg2
00001AA4  43F9 000021B8           1357          LEA     OutAddrIndPrReg2,A1
00001AAA  103C 000E               1358          MOVE.B  #14,D0
00001AAE  4E4F                    1359          TRAP    #15
00001AB0                          1360          
00001AB0  4EF8 1A82               1361          JMP     WrapperAddrIndirectPreEnd
00001AB4                          1362  
00001AB4                          1363  AddrIndPrReg3
00001AB4  43F9 000021BE           1364          LEA     OutAddrIndPrReg3,A1
00001ABA  103C 000E               1365          MOVE.B  #14,D0
00001ABE  4E4F                    1366          TRAP    #15
00001AC0                          1367          
00001AC0  4EF8 1A82               1368          JMP     WrapperAddrIndirectPreEnd
00001AC4                          1369  
00001AC4                          1370  AddrIndPrReg4
00001AC4  43F9 000021C4           1371          LEA     OutAddrIndPrReg4,A1
00001ACA  103C 000E               1372          MOVE.B  #14,D0
00001ACE  4E4F                    1373          TRAP    #15
00001AD0                          1374          
00001AD0  4EF8 1A82               1375          JMP     WrapperAddrIndirectPreEnd
00001AD4                          1376  
00001AD4                          1377  AddrIndPrReg5
00001AD4  43F9 000021CA           1378          LEA     OutAddrIndPrReg5,A1
00001ADA  103C 000E               1379          MOVE.B  #14,D0
00001ADE  4E4F                    1380          TRAP    #15
00001AE0                          1381          
00001AE0  4EF8 1A82               1382          JMP     WrapperAddrIndirectPreEnd
00001AE4                          1383  
00001AE4                          1384  AddrIndPrReg6
00001AE4  43F9 000021D0           1385          LEA     OutAddrIndPrReg6,A1
00001AEA  103C 000E               1386          MOVE.B  #14,D0
00001AEE  4E4F                    1387          TRAP    #15
00001AF0                          1388          
00001AF0  4EF8 1A82               1389          JMP     WrapperAddrIndirectPreEnd
00001AF4                          1390  
00001AF4                          1391  AddrIndPrReg7
00001AF4  43F9 000021D6           1392          LEA     OutAddrIndPrReg7,A1
00001AFA  103C 000E               1393          MOVE.B  #14,D0
00001AFE  4E4F                    1394          TRAP    #15
00001B00                          1395          
00001B00  4EF8 1A82               1396          JMP     WrapperAddrIndirectPreEnd
00001B04                          1397  
00001B04                          1398  
00001B04                          1399  *-----------------------------------------------------------        
00001B04                          1400  * Output logic for absolute memory addressing (0-7)
00001B04                          1401  *-----------------------------------------------------------     
00001B04                          1402  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001B04                          1403  WrapperAddrAbsolute
00001B04  4284                    1404          CLR.L   D4
00001B06                          1405          *Depending on the EA Register, choose which size to decode
00001B06  B63C 0000               1406          CMP.B   #$00,D3
00001B0A  6700 000C               1407          BEQ     WordSizeAbsolute
00001B0E                          1408  
00001B0E  B63C 0001               1409          CMP.B   #$01,D3
00001B12  6700 0020               1410          BEQ     LongSizeAbsolute
00001B16                          1411          
00001B16                          1412  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001B16                          1413  WrapperAddrAbsoluteEnd
00001B16  4E75                    1414          RTS
00001B18                          1415  
00001B18                          1416  WordSizeAbsolute        
00001B18  3818                    1417          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001B1A                          1418          
00001B1A                          1419          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001B1A  4281                    1420          CLR.L   D1
00001B1C  123C 0001               1421          MOVE.B  #$01,D1     
00001B20                          1422              
00001B20                          1423          *Output ',$' just after source operand
00001B20  43F9 000021E9           1424          LEA     Bang,A1
00001B26  103C 000E               1425          MOVE.B  #14,D0
00001B2A  4E4F                    1426          TRAP    #15
00001B2C                          1427              
00001B2C                          1428          *output the absolute mem address to console with the hex-ascii converter
00001B2C  4EB8 11E6               1429          JSR     HEXASCII        
00001B30                          1430          
00001B30  4EF8 1B16               1431          JMP     WrapperAddrAbsoluteEnd
00001B34                          1432  
00001B34                          1433  LongSizeAbsolute
00001B34  2818                    1434          MOVE.L  (A0)+,D4    *read in next long, data is that long
00001B36                          1435                  
00001B36                          1436          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001B36  4281                    1437          CLR.L   D1
00001B38  123C 0010               1438          MOVE.B  #$10,D1
00001B3C                          1439                  
00001B3C                          1440          *Output ',$' just after source operand
00001B3C  43F9 000021E9           1441          LEA     Bang,A1
00001B42  103C 000E               1442          MOVE.B  #14,D0
00001B46  4E4F                    1443          TRAP    #15  
00001B48                          1444          
00001B48                          1445          *output the absolute mem address to console with the hex-ascii converter
00001B48  4EB8 11E6               1446          JSR     HEXASCII
00001B4C                          1447          
00001B4C  4EF8 1B16               1448          JMP     WrapperAddrAbsoluteEnd
00001B50                          1449          
00001B50                          1450  
00001B50                          1451  *-----------------------------------------------------------        
00001B50                          1452  * Current handling of bad op/ea codes. Should be revisited.
00001B50                          1453  *----------------------------------------------------------- 
00001B50                          1454  BADOPCODE
00001B50                          1455          *We found a bad op code, output some error to the screen, jump to the 
00001B50                          1456          *next instruction in memory.
00001B50                          1457          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001B50                          1458          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001B50                          1459          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001B50                          1460          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001B50                          1461          *i/o and error message code...
00001B50  43F9 000021F2           1462          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001B56  103C 000E               1463          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001B5A  4E4F                    1464          TRAP    #15         *Displays Message
00001B5C  4EF8 136C               1465          JMP     GRAB_NEXT_OP
00001B60                          1466                  
00001B60                          1467  BADEACODE
00001B60                          1468          *We found a bad ea code, output some error to the screen, jump to the
00001B60                          1469          *next instruction in memory.
00001B60                          1470          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001B60                          1471          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001B60  43F9 000021EB           1472          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001B66  103C 000E               1473          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001B6A  4E4F                    1474          TRAP    #15         *Displays Message
00001B6C  4EF8 136C               1475          JMP     GRAB_NEXT_OP
00001B70                          1476          
00001B70                          1477          
00001B70                          1478  *-----------------------------------------------------------        
00001B70                          1479  * End of Disassembler
00001B70                          1480  *-----------------------------------------------------------    
00001B70                          1481  
00001B70  4E72 2700               1482  DONE    STOP    #$2700  *What does this do? Why was it added?
00001B74                          1483  
00001B74  103C 0009               1484  THEEND  MOVE.B  #9,D0
00001B78  4E4F                    1485          TRAP    #15             Halt Simulator        
00001B7A                          1486          
00001B7A                          1487       
00001B7A                          1488  *-----------------------------------------------------------        
00001B7A                          1489  * Output stuff
00001B7A                          1490  *-----------------------------------------------------------     
00001B7A  =0000000D               1491  CR      EQU     $0D             ASCII code for Carriage Return
00001B7A  =0000000A               1492  LF      EQU     $0A             ASCII code for Line Feed
00001B7A= 2D 2D 2D 2D 2D 2D ...   1493  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001BB9= 7C 7C 20 20 20 20 ...   1494              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001BF8= 2D 2D 2D 2D 2D 2D ...   1495              DC.B    '-------------------------------------------------------------',CR,LF
00001C37= 2A 2A 2A 2A 2A 2A ...   1496              DC.B    '*************************************************************',CR,LF
00001C76= 2A 2A 2A 2A 2A 2A ...   1497              DC.B    '*************************************************************',CR,LF
00001CB5= 2A 2A 2A 2A 2A 2A ...   1498              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001CF4= 2A 2A 2A 2A 2A 2A ...   1499              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001D33= 2A 2A 2A 2A 2A 2A ...   1500              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001D72= 2A 2A 2A 2A 2A 2A ...   1501              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001DB1= 2A 2A 2A 2A 2A 2A ...   1502              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001DF0= 2A 2A 2A 2A 2A 2A ...   1503              DC.B    '*************************************************************',CR,LF
00001E2F= 2A 2A 2A 2A 2A 2A ...   1504              DC.B    '*************************************************************',CR,LF
00001E6E= 2A 20 20 20 20 20 ...   1505              DC.B    '*                                                           *',CR,LF
00001EAD= 2A 20 41 75 74 68 ...   1506              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001EEC= 2A 20 20 20 20 20 ...   1507              DC.B    '*                                                           *',CR,LF
00001F2B= 2A 2A 2A 2A 2A 2A ...   1508              DC.B    '*************************************************************',CR,LF,CR,LF
00001F6C= 53 74 61 72 74 69 ...   1509              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001F89                          1510              
00001F89= 57 6F 75 6C 64 20 ...   1511  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001FBA                          1512  
00001FBA= 20 0D 0A                1513  GETSTRTADDR DC.B    ' ',CR,LF
00001FBD= 50 6C 65 61 73 65 ...   1514              DC.B    'Please type in your starting address request: ',0
00001FEC                          1515              
00001FEC= 20 0D 0A                1516  GETENDADDR  DC.B    ' ',CR,LF
00001FEF= 50 6C 65 61 73 65 ...   1517              DC.B    'Please type in your ending address request: ',0
0000201C                          1518              
0000201C= 20 0D 0A                1519  QUES_CONT   DC.B    ' ',CR,LF
0000201F= 57 6F 75 6C 64 20 ...   1520              DC.B    'Would you like to continue (Y/N)? ',0
00002042                          1521              
00002042= 20 0D 0A                1522  QUIT_MSG    DC.B    ' ',CR,LF
00002045= 57 6F 75 6C 64 20 ...   1523              DC.B    'Would you like to quit (Y/N)? ',0
00002064                          1524  
00002064                          1525  *****************************************************
00002064                          1526  * I/O storages - assuming users knows what to do.
00002064                          1527  *****************************************************
00002064                          1528  CMD_HLD     DS.B    30
00002082                          1529  CMD_SZ      DS.B    30
000020A0                          1530  STADDR      DS.B    10
000020AA                          1531  STADDRSZ    DS.B    10
000020B4                          1532  PROGST      DS.L    1
000020B8                          1533  ENDADDR     DS.B    10
000020C2                          1534  ENDADDRSZ   DS.B    10
000020CC                          1535  PROGEND     DS.L    1
000020D0                          1536  CONT        DS.B    30
000020EE                          1537  *****************************************************
000020EE                          1538  
000020EE                          1539  *Table for 0-9 && A-F
000020EE= 30 00                   1540  PRNT0   DC.B    '0',0
000020F0= 31 00                   1541  PRNT1   DC.B    '1',0
000020F2= 32 00                   1542  PRNT2   DC.B    '2',0
000020F4= 33 00                   1543  PRNT3   DC.B    '3',0
000020F6= 34 00                   1544  PRNT4   DC.B    '4',0
000020F8= 35 00                   1545  PRNT5   DC.B    '5',0
000020FA= 36 00                   1546  PRNT6   DC.B    '6',0
000020FC= 37 00                   1547  PRNT7   DC.B    '7',0
000020FE= 38 00                   1548  PRNT8   DC.B    '8',0
00002100= 39 00                   1549  PRNT9   DC.B    '9',0
00002102= 41 00                   1550  PRNTA   DC.B    'A',0
00002104= 42 00                   1551  PRNTB   DC.B    'B',0
00002106= 43 00                   1552  PRNTC   DC.B    'C',0
00002108= 44 00                   1553  PRNTD   DC.B    'D',0
0000210A= 45 00                   1554  PRNTE   DC.B    'E',0
0000210C= 46 00                   1555  PRNTF   DC.B    'F',0
0000210E                          1556  
0000210E                          1557  *output for all OPCODEs
0000210E= 41 44 44 49 00          1558  ADDI    DC.B    'ADDI',0
00002113= 41 4E 44 49 00          1559  ANDI    DC.B    'ANDI',0
00002118= 45 4F 52 49 00          1560  EORI    DC.B    'EORI',0
0000211D= 42 43 48 47 00          1561  BCHG    DC.B    'BCHG',0
00002122= 43 4D 50 49 00          1562  CMPI    DC.B    'CMPI',0
00002127                          1563  
00002127                          1564  *output for the size of the operation
00002127= 2E 42 20 20 20 20 00    1565  ByteSize    DC.B    '.B    ',0
0000212E= 2E 57 20 20 20 20 00    1566  WordSize    DC.B    '.W    ',0
00002135= 2E 4C 20 20 20 20 00    1567  LongSize    DC.B    '.L    ',0
0000213C                          1568  
0000213C                          1569  *output for all destination data registers (0-7)
0000213C= 44 30 00                1570  OutDataReg0 DC.B    'D0',0
0000213F= 44 31 00                1571  OutDataReg1 DC.B    'D1',0
00002142= 44 32 00                1572  OutDataReg2 DC.B    'D2',0
00002145= 44 33 00                1573  OutDataReg3 DC.B    'D3',0
00002148= 44 34 00                1574  OutDataReg4 DC.B    'D4',0
0000214B= 44 35 00                1575  OutDataReg5 DC.B    'D5',0
0000214E= 44 36 00                1576  OutDataReg6 DC.B    'D6',0
00002151= 44 37 00                1577  OutDataReg7 DC.B    'D7',0
00002154                          1578          
00002154                          1579  *output for all address indirect registers (0-7)
00002154= 28 41 30 29 00          1580  OutAddrIndReg0  DC.B    '(A0)',0
00002159= 28 41 31 29 00          1581  OutAddrIndReg1  DC.B    '(A1)',0
0000215E= 28 41 32 29 00          1582  OutAddrIndReg2  DC.B    '(A2)',0
00002163= 28 41 33 29 00          1583  OutAddrIndReg3  DC.B    '(A3)',0
00002168= 28 41 34 29 00          1584  OutAddrIndReg4  DC.B    '(A4)',0
0000216D= 28 41 35 29 00          1585  OutAddrIndReg5  DC.B    '(A5)',0
00002172= 28 41 36 29 00          1586  OutAddrIndReg6  DC.B    '(A6)',0
00002177= 28 41 37 29 00          1587  OutAddrIndReg7  DC.B    '(A7)',0
0000217C                          1588  
0000217C                          1589  *output for all address indirect post registers (0-7)
0000217C= 28 41 30 29 2B 00       1590  OutAddrIndPoReg0    DC.B    '(A0)+',0
00002182= 28 41 31 29 2B 00       1591  OutAddrIndPoReg1    DC.B    '(A1)+',0
00002188= 28 41 32 29 2B 00       1592  OutAddrIndPoReg2    DC.B    '(A2)+',0
0000218E= 28 41 33 29 2B 00       1593  OutAddrIndPoReg3    DC.B    '(A3)+',0
00002194= 28 41 34 29 2B 00       1594  OutAddrIndPoReg4    DC.B    '(A4)+',0
0000219A= 28 41 35 29 2B 00       1595  OutAddrIndPoReg5    DC.B    '(A5)+',0
000021A0= 28 41 36 29 2B 00       1596  OutAddrIndPoReg6    DC.B    '(A6)+',0
000021A6= 28 41 37 29 2B 00       1597  OutAddrIndPoReg7    DC.B    '(A7)+',0
000021AC                          1598  
000021AC                          1599  *output for all address indirect pre registers (0-7)
000021AC= 2D 28 41 30 29 00       1600  OutAddrIndPrReg0    DC.B    '-(A0)',0
000021B2= 2D 28 41 31 29 00       1601  OutAddrIndPrReg1    DC.B    '-(A1)',0
000021B8= 2D 28 41 32 29 00       1602  OutAddrIndPrReg2    DC.B    '-(A2)',0
000021BE= 2D 28 41 33 29 00       1603  OutAddrIndPrReg3    DC.B    '-(A3)',0
000021C4= 2D 28 41 34 29 00       1604  OutAddrIndPrReg4    DC.B    '-(A4)',0
000021CA= 2D 28 41 35 29 00       1605  OutAddrIndPrReg5    DC.B    '-(A5)',0
000021D0= 2D 28 41 36 29 00       1606  OutAddrIndPrReg6    DC.B    '-(A6)',0
000021D6= 2D 28 41 37 29 00       1607  OutAddrIndPrReg7    DC.B    '-(A7)',0
000021DC                          1608  
000021DC                          1609  *output for a tab only (4 spaces)
000021DC= 20 20 20 20 00          1610  Tab DC.B    '    ',0
000021E1                          1611  
000021E1                          1612  *output for a comma only
000021E1= 2C 00                   1613  Comma   DC.B    ',',0
000021E3                          1614  
000021E3                          1615  *output for a new line only
000021E3= 0D 0A 00                1616  NewLine DC.B    CR,LF,0
000021E6                          1617  
000021E6                          1618  *output for a '#$' and '$' only
000021E6= 23 24 00                1619  ShaBang DC.B    '#$',0
000021E9= 24 00                   1620  Bang    DC.B    '$',0
000021EB                          1621  
000021EB                          1622  *current output for error messages
000021EB= 42 41 44 20 45 41 00    1623  BADEAMSG    DC.B    'BAD EA',0
000021F2= 42 41 44 20 4F 50 00    1624  BADOPMSG    DC.B    'BAD OP',0
000021F9= 49 6D 70 72 6F 70 ...   1625  INV_MSG     DC.B    'Improper command.',CR,LF,0
0000220D= 49 6E 76 61 6C 69 ...   1626  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
00002226= 49 6E 76 61 6C 69 ...   1627  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
0000223D                          1628  
0000223D                          1629          
0000223D                          1630          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                210E
ADDRABSOLUTEMODE    17EC
ADDRDIRECTMODE      17BC
ADDRINDIRECTMODE    17BC
ADDRINDIRECTPOSTMODE  17CC
ADDRINDIRECTPREMODE  17DC
ADDRINDPOREG0       19C2
ADDRINDPOREG1       19D2
ADDRINDPOREG2       19E2
ADDRINDPOREG3       19F2
ADDRINDPOREG4       1A02
ADDRINDPOREG5       1A12
ADDRINDPOREG6       1A22
ADDRINDPOREG7       1A32
ADDRINDPRREG0       1A84
ADDRINDPRREG1       1A94
ADDRINDPRREG2       1AA4
ADDRINDPRREG3       1AB4
ADDRINDPRREG4       1AC4
ADDRINDPRREG5       1AD4
ADDRINDPRREG6       1AE4
ADDRINDPRREG7       1AF4
ADDRINDREG0         1900
ADDRINDREG1         1910
ADDRINDREG2         1920
ADDRINDREG3         1930
ADDRINDREG4         1940
ADDRINDREG5         1950
ADDRINDREG6         1960
ADDRINDREG7         1970
ANDI                2113
ASCIIHEX            1174
ASCIIHEX1           1178
BADEACODE           1B60
BADEAMSG            21EB
BADOPCODE           1B50
BADOPMSG            21F2
BANG                21E9
BCHG                211D
BCHGBYTESIZE        179C
BCHGLONGSIZE        178C
BCHGSIZEHELPER      177C
BCHGSIZEHELPEREND   178A
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         140C
BUCKET_0001         16F4
BUCKET_0010         16F4
BUCKET_0011         16F4
BUCKET_0100         16F4
BUCKET_0101         16F4
BUCKET_0110         16F4
BUCKET_1000         16F4
BUCKET_1001         16F4
BUCKET_1011         16F4
BUCKET_1100         16F4
BUCKET_1101         16F4
BUCKET_1110         16F4
BYTESIZE            2127
BYTESIZEIMMEDIATE   1716
CHECK               11EA
CHECKEND1           10FA
CHECKSTRT1          10E4
CHECK_LOWN          112C
CHECK_LOWY          111A
CHECK_N             13E6
CHECK_UPN           1124
CHECK_UPY           1110
CHECK_Y             13D8
CHNG_SZB            121C
CHNG_SZL            1202
CHNG_SZW            1236
CMD_HLD             2064
CMD_SZ              2082
CMPI                2122
COMMA               21E1
CONT                20D0
CONT_Q              13A6
CONV_LOL            11D4
CONV_LOOP           1250
CONV_NUM            11C0
CONV_UPL            11CA
CR                  D
DATAREG0            183E
DATAREG1            184E
DATAREG2            185E
DATAREG3            186E
DATAREG4            187E
DATAREG5            188E
DATAREG6            189E
DATAREG7            18AE
DATAREGMODE         17AC
DONE                1B70
EA_ADDI             1498
EA_ANDI             150E
EA_BCHG_D           1606
EA_BCHG_S           1678
EA_CMPI             16B4
EA_EORI             1584
ENDADDR             20B8
ENDADDRSZ           20C2
EORI                2118
EXITSUB             11E0
EXIT_CONV           12D6
GETENDADDR          1FEC
GETSTRTADDR         1FBA
GET_END             108C
GET_STRT            103E
GRAB_NEXT_OP        136C
HEXASCII            11E6
HEXASCIIREG         11FE
IMMEDIATEDATAMODE   17FC
INV2                13F6
INVALID1            1134
INVENDMSG           2226
INVSTRTMSG          220D
INV_END1            1160
INV_MSG             21F9
INV_STRT1           114C
IS_ADDI             1462
IS_ANDI             14D8
IS_BCHG_D           15C4
IS_BCHG_S           1662
IS_CMPI             167E
IS_EORI             154E
LF                  A
LONGSIZE            2135
LONGSIZEABSOLUTE    1B34
LONGSIZEIMMEDIATE   175A
LOOP_1              1014
LOOP_B              1220
LOOP_L              1206
LOOP_W              123A
MAX_LINE            F
MESSAGE             1B7A
NEWLINE             21E3
NUM_0               12E4
NUM_1               12EC
NUM_2               12F4
NUM_3               12FC
NUM_4               1304
NUM_5               130C
NUM_6               1314
NUM_7               131C
NUM_8               1324
NUM_9               132C
NUM_A               1334
NUM_B               133C
NUM_C               1344
NUM_D               134C
NUM_E               1354
NUM_F               135C
OUTADDRINDPOREG0    217C
OUTADDRINDPOREG1    2182
OUTADDRINDPOREG2    2188
OUTADDRINDPOREG3    218E
OUTADDRINDPOREG4    2194
OUTADDRINDPOREG5    219A
OUTADDRINDPOREG6    21A0
OUTADDRINDPOREG7    21A6
OUTADDRINDPRREG0    21AC
OUTADDRINDPRREG1    21B2
OUTADDRINDPRREG2    21B8
OUTADDRINDPRREG3    21BE
OUTADDRINDPRREG4    21C4
OUTADDRINDPRREG5    21CA
OUTADDRINDPRREG6    21D0
OUTADDRINDPRREG7    21D6
OUTADDRINDREG0      2154
OUTADDRINDREG1      2159
OUTADDRINDREG2      215E
OUTADDRINDREG3      2163
OUTADDRINDREG4      2168
OUTADDRINDREG5      216D
OUTADDRINDREG6      2172
OUTADDRINDREG7      2177
OUTDATAREG0         213C
OUTDATAREG1         213F
OUTDATAREG2         2142
OUTDATAREG3         2145
OUTDATAREG4         2148
OUTDATAREG5         214B
OUTDATAREG6         214E
OUTDATAREG7         2151
PRINT_NUM           12DC
PRNT0               20EE
PRNT1               20F0
PRNT2               20F2
PRNT3               20F4
PRNT4               20F6
PRNT5               20F8
PRNT6               20FA
PRNT7               20FC
PRNT8               20FE
PRNT9               2100
PRNTA               2102
PRNTB               2104
PRNTC               2106
PRNTD               2108
PRNTE               210A
PRNTF               210C
PROGEND             20CC
PROGST              20B4
QUES_CONT           201C
QUIT_MSG            2042
SHABANG             21E6
STACK               7000
STADDR              20A0
STADDRSZ            20AA
START               1000
STARTASSEM          1F89
ST_ADDR             7FC6
ST_BAD              11DE
TAB                 21DC
THEEND              1B74
WORDSIZE            212E
WORDSIZEABSOLUTE    1B18
WORDSIZEIMMEDIATE   1738
WRAPPERADDRABSOLUTE  1B04
WRAPPERADDRABSOLUTEEND  1B16
WRAPPERADDRINDIRECT  18BE
WRAPPERADDRINDIRECTEND  18FE
WRAPPERADDRINDIRECTPOST  1980
WRAPPERADDRINDIRECTPOSTEND  19C0
WRAPPERADDRINDIRECTPRE  1A42
WRAPPERADDRINDIRECTPREEND  1A82
WRAPPERDATAREG      17FC
WRAPPERDATAREGEND   183C
WRAPPERSIZEIMMEDIATE  16FA
WRAPPERSIZEIMMEDIATEEND  1714
