00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 12:45:59 AM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/11/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC6                  9  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00001000                            11  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 12              LEA stack,SP
00001004                            13  
00001004                            14  
00001004                            15  *-----------------------------------------------------------
00001004                            16  * Start of I/O
00001004                            17  *-----------------------------------------------------------            
00001004  43F9 000019CC             18              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100A  103C 000E                 19              MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000100E  4E4F                      20              TRAP    #15         *Displays Message
00001010                            21          
00001010  303C 0000                 22  loop_1      MOVE    #0,D0       
00001014  43F9 00001DDB             23              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101A  103C 000E                 24              MOVE.B  #14,D0
0000101E  4E4F                      25              TRAP    #15    
00001020  303C 0002                 26              MOVE    #2,D0
00001024  43F9 00001E90             27              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102A  4E4F                      28              TRAP    #15
0000102C  0C01 0001                 29              CMPI.B  #01,D1
00001030  6600 00F2                 30              BNE     INVALID1
00001034  6000 00CE                 31              BRA     CHECK_UPY
00001038                            32  *-----------------------------------------------------------
00001038                            33  *
00001038                            34  * I/O: Check Start Address
00001038                            35  *
00001038                            36  * Make sure that start address starts after allocated 
00001038                            37  * memory addresses. Else, it will print out a message 
00001038                            38  * saying that requested address is invalid & prompts the
00001038                            39  * user again for the starting address.
00001038                            40  *-----------------------------------------------------------
00001038  43F9 00001E0C             41  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
0000103E  103C 000E                 42              MOVE.B  #14,D0
00001042  4E4F                      43              TRAP    #15
00001044  43F9 00001ECC             44              LEA     STADDR,A1   *Need to change where it can hold the start/end address
0000104A  3239 00001ED6             45              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001050  303C 0002                 46              MOVE    #2,D0           *Get start address
00001054  4E4F                      47              TRAP    #15
00001056  4EB9 000010D8             48              JSR     CHECKSTRT1
0000105C  4287                      49              CLR.L   D7
0000105E  4EB9 00001164             50              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
00001064  0C03 0001                 51              CMPI.B  #01,D3      *Check if there was a bad start
00001068  6700 00D2                 52              BEQ     INV_STRT1   *Prints error message if there was a bad start
0000106C  0C87 00007FC6             53              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001072  6D00 00C8                 54              BLT     INV_STRT1   *Asks for another start address if invalid
00001076  0C87 00FFFFFE             55              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
0000107C  6C00 00BE                 56              BGE     INV_STRT1
00001080  23C7 00001EE0             57              MOVE.L  D7,PROGST
00001086                            58  
00001086  43F9 00001E3E             59  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
0000108C  103C 000E                 60              MOVE.B  #14,D0
00001090  4E4F                      61              TRAP    #15
00001092  43F9 00001EE4             62              LEA     ENDADDR,A1      *Buffer to hold end address
00001098  3239 00001EEE             63              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
0000109E  303C 0002                 64              MOVE    #2,D0
000010A2  4E4F                      65              TRAP    #15
000010A4  4EB9 000010EE             66              JSR     CHECKEND1
000010AA  4287                      67              CLR.L   D7
000010AC  4EB9 00001164             68              JSR     ASCIIHEX
000010B2  0C03 0001                 69              CMPI.B  #01,D3
000010B6  6700 0098                 70              BEQ     INV_END1
000010BA  0C87 00001EE0             71              CMPI.L  #PROGST,D7
000010C0  6D00 008E                 72              BLT     INV_END1
000010C4  0C87 00FFFFFF             73              CMPI.L  #$00FFFFFF,D7
000010CA  6C00 0084                 74              BGE     INV_END1
000010CE  2079 00001EE0             75              MOVEA.L PROGST,A0
000010D4  6000 0262                 76              BRA     GRAB_NEXT_OP            
000010D8                            77                          
000010D8  0C81 00000008             78  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010DE  6E00 005C                 79              BGT     INV_STRT1
000010E2  0C81 00000000             80              CMPI.L  #00,D1
000010E8  6300 0052                 81              BLS     INV_STRT1
000010EC  4E75                      82              RTS         
000010EE                            83              
000010EE  0C81 00000008             84  CHECKEND1   CMPI.L  #08,D1
000010F4  6E00 005A                 85              BGT     INV_END1
000010F8  0C81 00000000             86              CMPI.L  #00,D1
000010FE  6300 0050                 87              BLS     INV_END1
00001102  4E75                      88              RTS
00001104                            89  
00001104                            90  *-----------------------------------------------------------
00001104                            91  * I/O: Input check for Y, y, N, n
00001104                            92  *-----------------------------------------------------------
00001104  0C11 0059                 93  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001108  6700 FF2E                 94              BEQ     GET_STRT
0000110C                            95              
0000110C  0C11 0079                 96  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
00001110  6700 FF26                 97              BEQ     GET_STRT
00001114                            98              
00001114  0C11 004E                 99  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001118  6700 08A8                100              BEQ     DONE
0000111C                           101              
0000111C  0C11 006E                102  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001120  6700 08A0                103              BEQ     DONE
00001124                           104              
00001124  163C 0000                105  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001128  303C 0000                106              MOVE    #0,D0       *Prints invalid command msg if not found
0000112C  43F9 00002078            107              LEA     INV_MSG,A1
00001132  303C 000E                108              MOVE    #14,D0
00001136  4E4F                     109              TRAP    #15
00001138  6000 FED6                110              BRA     loop_1
0000113C                           111              
0000113C  43F9 0000208C            112  INV_STRT1   LEA     INVSTRTMSG,A1
00001142  103C 000E                113              MOVE.B  #14,D0
00001146  4E4F                     114              TRAP    #15
00001148  163C 0000                115              MOVE.B  #00,D3      *Reset flag
0000114C  6000 FEEA                116              BRA     GET_STRT        
00001150                           117              
00001150  43F9 000020A5            118  INV_END1    LEA     INVENDMSG,A1
00001156  103C 000E                119              MOVE.B  #14,D0
0000115A  4E4F                     120              TRAP    #15
0000115C  163C 0000                121              MOVE.B  #00,D3      *Reset flag
00001160  6000 FF24                122              BRA     GET_END
00001164                           123              
00001164                           124  *-----------------------------------------------------------
00001164                           125  * ASCII to Hex converter
00001164                           126  *
00001164                           127  * Checks and converts the ASCII value to the hex equivalent
00001164                           128  *-----------------------------------------------------------
00001164  48E7 6000                129  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001168  0C01 0000                130  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000116C  6700 0062                131              BEQ     exitSub     *Exit subroutine 
00001170  5301                     132              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001172  E99F                     133              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001174  1419                     134              MOVE.B  (A1)+,D2    *Takes the first char
00001176  0C02 0024                135              CMPI.B  #$24,D2     *See if the first char is $
0000117A  67EC                     136              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000117C  0C02 0030                137              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001180  6D00 004C                138              BLT     st_bad      *Put error message
00001184  0C02 0039                139              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001188  6F00 0026                140              BLE     CONV_NUM    *Convert to number, if so
0000118C  0C02 0041                141              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
00001190  6D00 003C                142              BLT     st_bad      *Put error message
00001194  0C02 0046                143              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
00001198  6F00 0020                144              BLE     CONV_UpL    *Convert to hex
0000119C  0C02 0061                145              CMPI.B  #$61,D2     *Checks for non-valid chars
000011A0  6D00 002C                146              BLT     st_bad
000011A4  0C02 0066                147              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011A8  6F00 001A                148              BLE     CONV_LoL    
000011AC  6E00 0020                149              BGT     st_bad      *Puts error message for anything greater than f value
000011B0                           150              
000011B0  0402 0030                151  CONV_NUM    SUBI.B  #$30,D2
000011B4  8E02                     152              OR.B    D2,D7
000011B6  4EF8 1168                153              JMP     ASCIIHEX1
000011BA  0402 0037                154  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011BE  8E02                     155              OR.B    D2,D7
000011C0  4EF8 1168                156              JMP     ASCIIHEX1
000011C4  0402 0057                157  CONV_LoL    SUBI.B  #$57,D2
000011C8  8E02                     158              OR.B    D2,D7
000011CA  4EF8 1168                159              JMP     ASCIIHEX1   
000011CE                           160  
000011CE  5203                     161  st_bad      ADDI.B  #01,D3
000011D0  4CDF 0006                162  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011D4  4E75                     163              RTS
000011D6                           164              
000011D6                           165  *-----------------------------------------------------------
000011D6                           166  * Hex to ASCII converter
000011D6                           167  *-----------------------------------------------------------
000011D6  48E7 4C00                168  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011DA  0C01 0000                169              CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011DE  6700 001A                170              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011E2  B27C 0001                171              CMP.W   #01,D1          
000011E6  6700 001A                172              BEQ     CHNG_SZW
000011EA  6000 0006                173              BRA     CHNG_SZL        
000011EE                           174  
000011EE  48E7 4C00                175  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011F2  123C 0008                176  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
000011F6  6000 0012                177              BRA     CONV_LOOP       * Move on to the converter loop
000011FA                           178  
000011FA  123C 0002                179  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
000011FE  6000 000A                180              BRA     CONV_LOOP       * Move on to converter loop
00001202  123C 0004                181  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
00001206  6000 0002                182              BRA     CONV_LOOP
0000120A                           183  
0000120A  0C01 0000                184  CONV_LOOP   CMPI.B  #00,D1
0000120E  6700 008E                185              BEQ     EXIT_CONV
00001212  5301                     186              SUBI.B  #01,D1
00001214  E91C                     187              ROL.B   #4,D4           * Shift it for next bit
00001216  2A04                     188              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001218                           189              *ROR.B  #4,D4           * Shift it for next bit
00001218  0285 0000000F            190              ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
0000121E  0C05 0000                191              CMPI.B  #$0,D5
00001222  6700 008A                192              BEQ     NUM_0
00001226  0C05 0001                193              CMPI.B  #$1,D5
0000122A  6700 008A                194              BEQ     NUM_1
0000122E  0C05 0002                195              CMPI.B  #$2,D5
00001232  6700 008A                196              BEQ     NUM_2
00001236  0C05 0003                197              CMPI.B  #$3,D5
0000123A  6700 008A                198              BEQ     NUM_3
0000123E  0C05 0004                199              CMPI.B  #$4,D5
00001242  6700 008A                200              BEQ     NUM_4
00001246  0C05 0005                201              CMPI.B  #$5,D5
0000124A  6700 008A                202              BEQ     NUM_5
0000124E  0C05 0006                203              CMPI.B  #$6,D5
00001252  6700 008A                204              BEQ     NUM_6
00001256  0C05 0007                205              CMPI.B  #$7,D5
0000125A  6700 008A                206              BEQ     NUM_7
0000125E  0C05 0008                207              CMPI.B  #$8,D5
00001262  6700 008A                208              BEQ     NUM_8
00001266  0C05 0009                209              CMPI.B  #$9,D5
0000126A  6700 008A                210              BEQ     NUM_9
0000126E  0C05 000A                211              CMPI.B  #$A,D5
00001272  6700 008A                212              BEQ     NUM_A
00001276  0C05 000B                213              CMPI.B  #$B,D5
0000127A  6700 008A                214              BEQ     NUM_B
0000127E  0C05 000C                215              CMPI.B  #$C,D5
00001282  6700 008A                216              BEQ     NUM_C
00001286  0C05 000D                217              CMPI.B  #$D,D5
0000128A  6700 008A                218              BEQ     NUM_D
0000128E  0C05 000E                219              CMPI.B  #$E,D5
00001292  6700 008A                220              BEQ     NUM_E
00001296  0C05 000F                221              CMPI.B  #$F,D5
0000129A  6700 008C                222              BEQ     NUM_F
0000129E                           223              
0000129E  4CDF 0032                224  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012A2  4E75                     225              RTS
000012A4                           226              
000012A4  303C 000E                227  PRINT_NUM   MOVE    #14,D0
000012A8  4E4F                     228              TRAP    #15
000012AA  6000 FF5E                229              BRA     CONV_LOOP
000012AE  43F9 00001EFC            230  NUM_0       LEA     PRNT0,A1
000012B4  60EE                     231              BRA     PRINT_NUM
000012B6  43F9 00001EFE            232  NUM_1       LEA     PRNT1,A1
000012BC  60E6                     233              BRA     PRINT_NUM
000012BE  43F9 00001F00            234  NUM_2       LEA     PRNT2,A1
000012C4  60DE                     235              BRA     PRINT_NUM
000012C6  43F9 00001F02            236  NUM_3       LEA     PRNT3,A1
000012CC  60D6                     237              BRA     PRINT_NUM
000012CE  43F9 00001F04            238  NUM_4       LEA     PRNT4,A1
000012D4  60CE                     239              BRA     PRINT_NUM
000012D6  43F9 00001F06            240  NUM_5       LEA     PRNT5,A1
000012DC  60C6                     241              BRA     PRINT_NUM
000012DE  43F9 00001F08            242  NUM_6       LEA     PRNT6,A1
000012E4  60BE                     243              BRA     PRINT_NUM
000012E6  43F9 00001F0A            244  NUM_7       LEA     PRNT7,A1
000012EC  60B6                     245              BRA     PRINT_NUM
000012EE  43F9 00001F0C            246  NUM_8       LEA     PRNT8,A1
000012F4  60AE                     247              BRA     PRINT_NUM
000012F6  43F9 00001F0E            248  NUM_9       LEA     PRNT9,A1
000012FC  60A6                     249              BRA     PRINT_NUM
000012FE  43F9 00001F10            250  NUM_A       LEA     PRNTA,A1
00001304  609E                     251              BRA     PRINT_NUM
00001306  43F9 00001F12            252  NUM_B       LEA     PRNTB,A1
0000130C  6096                     253              BRA     PRINT_NUM
0000130E  43F9 00001F14            254  NUM_C       LEA     PRNTC,A1
00001314  608E                     255              BRA     PRINT_NUM
00001316  43F9 00001F16            256  NUM_D       LEA     PRNTD,A1
0000131C  6086                     257              BRA     PRINT_NUM
0000131E  43F9 00001F18            258  NUM_E       LEA     PRNTE,A1
00001324  6000 FF7E                259              BRA     PRINT_NUM
00001328  43F9 00001F1A            260  NUM_F       LEA     PRNTF,A1
0000132E  6000 FF74                261              BRA     PRINT_NUM
00001332                           262  
00001332                           263  *-----------------------------------------------------------        
00001332                           264  * Start of Disassembler
00001332                           265  *-----------------------------------------------------------
00001332                           266          *FOR DEBUGGING ONLY!!!
00001332  207C 00007FC6            267          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
00001338                           268          
00001338                           269  GRAB_NEXT_OP
00001338                           270          *Need a check here to see if A0 == end of test address
00001338                           271          *if so, go to end.
00001338                           272          
00001338                           273          
00001338                           274          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
00001338                           275          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
00001338                           276          *data that may be associated with the instruction.
00001338                           277          *Post increment addr, A0 will point to the start of next instruction or will 
00001338                           278          *point to the start of any immed/abso data with this current instruction
00001338  4280                     279          CLR.L   D0
0000133A  3018                     280          MOVE.W  (A0)+,D0
0000133C                           281          *Copy the word data we just moved into D0 into D7. We are copying this data
0000133C                           282          *So we always have a copy of the WHOLE instruction somewhere
0000133C  4287                     283          CLR.L   D7
0000133E  3E00                     284          MOVE.W  D0,D7
00001340                           285          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
00001340                           286          *four bits of the instruction. Once we have just the first four bits, we can
00001340                           287          *begin to see which 'bucket'/category this instruction falls into. 
00001340  E048                     288          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
00001342  E848                     289          LSR.W   #$04,D0
00001344                           290          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
00001344                           291          *list of buckets until we find which one this instruction falls into.
00001344                           292  
00001344                           293  
00001344                           294  *-----------------------------------------------------------        
00001344                           295  * Bucket 0000:
00001344                           296  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
00001344                           297  *                   BCHG(dynamic) | BCHG (static) | CMPI----
00001344                           298  *-----------------------------------------------------------
00001344                           299  BUCKET_0000
00001344  =00000000                300  BUCKET0000_BITS EQU $0
00001344  4281                     301          CLR.L   D1
00001346                           302          *Load the first 4 bits (really a byte) of BUCKET0 into D1
00001346  123C 0000                303          MOVE.B  #BUCKET0000_BITS,D1
0000134A                           304          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
0000134A                           305          *If equal, continue decoding. If not, branch to next bucket.
0000134A  B200                     306          CMP.B   D0,D1
0000134C  6600 023A                307          BNE     BUCKET_0001
00001350                           308  
00001350                           309          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001350                           310          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001350  3007                     311          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001352  0800 0008                312          BTST.L  #$08,D0
00001356  6600 0180                313          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
0000135A                           314          
0000135A                           315          *Now we can check bits 11-8 in the instruction and branch to different op-codes
0000135A                           316          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
0000135A  E048                     317          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
0000135C  0880 0004                318          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001360  0880 0005                319          BCLR.L  #$05,D0
00001364  0880 0006                320          BCLR.L  #$06,D0
00001368  0880 0007                321          BCLR.L  #$07,D0
0000136C                           322          
0000136C                           323          *Perform compares with these 4 bits to see which specific instruction it is.
0000136C  B03C 0006                324          CMP.B   #$06,D0 *Is this an ADDI?
00001370  6700 0028                325          BEQ     IS_ADDI
00001374  B03C 0002                326          CMP.B   #$02,D0 *Is this an ANDI?
00001378  6700 008A                327          BEQ     IS_ANDI
0000137C  B03C 000A                328          CMP.B   #$0A,D0 *Is this an EORI?
00001380  6700 00EC                329          BEQ     IS_EORI
00001384  B03C 0008                330          CMP.B   #$08,D0 *Is this a BCHG(static)?
00001388  6700 0178                331          BEQ     IS_BCHG_S
0000138C  B03C 000C                332          CMP.B   #$0C,D0 *Is this a CMPI?
00001390  6700 018C                333          BEQ     IS_CMPI
00001394                           334          
00001394                           335          *If we get through all of the compares without finding the specific instruction,
00001394                           336          *then this instruction is either not in our list of OP CODES to decode, or is an
00001394                           337          *invalid instruction/syntax.
00001394  4EF9 000019A2            338          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
0000139A                           339          
0000139A                           340          
0000139A                           341  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
0000139A                           342  IS_ADDI
0000139A                           343          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000139A                           344          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000139A  4281                     345          CLR.L   D1
0000139C  3207                     346          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000139E  C27C 00C0                347          AND.W   #$00C0,D1   *Mask out everything but the size bits
000013A2  EC09                     348          LSR.B   #$06,D1     *Shift the size bits into LSB
000013A4                           349          
000013A4  B23C 0003                350          CMP.B   #$03,D1     *Compare the size bits to $3
000013A8  6700 05F8                351          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000013AC                           352          
000013AC                           353          *Output 'ADDI' to console...
000013AC  43F9 00001F1C            354          LEA     ADDI,A1     *Loads ADDI into address register A1
000013B2  103C 000E                355          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000013B6  4E4F                     356          TRAP    #15         *Displays Message
000013B8                           357          
000013B8                           358          
000013B8                           359          *Should have a valid ADDI op code. Set data up for EA.
000013B8                           360          
000013B8                           361          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000013B8  4282                     362          CLR.L   D2
000013BA  3407                     363          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000013BC  C47C 003C                364          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000013C0  E60A                     365          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000013C2                           366                  
000013C2                           367          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000013C2  4283                     368          CLR.L   D3
000013C4  3607                     369          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000013C6  C67C 0007                370          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000013CA                           371          
000013CA  4EF9 000013D0            372          JMP     EA_ADDI
000013D0                           373  
000013D0                           374  EA_ADDI
000013D0                           375          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
000013D0                           376          *and D3 holds the EA register.
000013D0                           377          
000013D0                           378          *Determine how much data to read in, depending on the size of the operation
000013D0                           379          *output the size of the operation and the immediate data to console
000013D0  4EB9 0000158E            380          JSR     WrapperSizeImmediate
000013D6                           381          
000013D6                           382          *Determine which EA mode and thus Register/Mem Address this instruction used
000013D6  B43C 0000                383          CMP.B   #$00,D2
000013DA  6700 0234                384          BEQ     DataRegMode *If EA mode is a data register, output that
000013DE                           385          
000013DE  B43C 0002                386          CMP.B   #$02,D2
000013E2  6700 0236                387          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000013E6                           388          
000013E6  B43C 0003                389          CMP.B   #$03,D2
000013EA  6700 0238                390          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000013EE                           391          
000013EE  B43C 0004                392          CMP.B   #$04,D2
000013F2  6700 023A                393          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000013F6                           394          
000013F6  B43C 0007                395          CMP.B   #$07,D2
000013FA  6700 023C                396          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000013FE                           397          
000013FE                           398          *If the ea mode isn't equal to any of these, it is an invalid EA
000013FE  4EF9 000019B2            399          JMP     BADEACODE                               
00001404                           400          
00001404                           401  
00001404                           402  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
00001404                           403  IS_ANDI
00001404                           404          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001404                           405          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001404  4281                     406          CLR.L   D1
00001406  3207                     407          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001408  C27C 00C0                408          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000140C  EC09                     409          LSR.B   #$06,D1     *Shift the size bits into LSB
0000140E                           410          
0000140E  B23C 0003                411          CMP.B   #$03,D1     *Compare the size bits to $3
00001412  6700 058E                412          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001416                           413          
00001416                           414          *Output 'ANDI' to console...
00001416  43F9 00001F21            415          LEA     ANDI,A1     *Loads ANDI into address register A1
0000141C  103C 000E                416          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001420  4E4F                     417          TRAP    #15         *Displays Message
00001422                           418          
00001422                           419          
00001422                           420          *Should have a valid ANDI op code. Set data up for EA.
00001422                           421          
00001422                           422          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001422  4282                     423          CLR.L   D2
00001424  3407                     424          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001426  C47C 003C                425          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
0000142A  E60A                     426          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000142C                           427                  
0000142C                           428          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000142C  4283                     429          CLR.L   D3
0000142E  3607                     430          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001430  C67C 0007                431          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001434                           432          
00001434  4EF9 0000143A            433          JMP     EA_ANDI
0000143A                           434  
0000143A                           435  EA_ANDI
0000143A                           436          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
0000143A                           437          *and D3 holds the EA register.
0000143A                           438          
0000143A                           439          *Determine how much data to read in, depending on the size of the operation
0000143A                           440          *output the size of the operation and the immediate data to console
0000143A  4EB9 0000158E            441          JSR     WrapperSizeImmediate
00001440                           442          
00001440                           443          *Determine which EA mode and thus Register/Mem Address this instruction used
00001440  B43C 0000                444          CMP.B   #$00,D2
00001444  6700 01CA                445          BEQ     DataRegMode *If EA mode is a data register, output that
00001448                           446          
00001448  B43C 0002                447          CMP.B   #$02,D2
0000144C  6700 01CC                448          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001450                           449          
00001450  B43C 0003                450          CMP.B   #$03,D2
00001454  6700 01CE                451          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001458                           452          
00001458  B43C 0004                453          CMP.B   #$04,D2
0000145C  6700 01D0                454          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001460                           455          
00001460  B43C 0007                456          CMP.B   #$07,D2
00001464  6700 01D2                457          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001468                           458          
00001468                           459          *If the ea mode isn't equal to any of these, it is an invalid EA
00001468  4EF9 000019B2            460          JMP     BADEACODE
0000146E                           461          
0000146E                           462  
0000146E                           463  *Now we know this instruction is exactly EORI, lets set everything up for EA.
0000146E                           464  IS_EORI
0000146E                           465          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000146E                           466          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000146E  4281                     467          CLR.L   D1
00001470  3207                     468          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001472  C27C 00C0                469          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001476  EC09                     470          LSR.B   #$06,D1     *Shift the size bits into LSB
00001478                           471          
00001478  B23C 0003                472          CMP.B   #$03,D1     *Compare the size bits to $3
0000147C  6700 0524                473          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001480                           474          
00001480                           475          *Output 'EORI' to console...
00001480  43F9 00001F26            476          LEA     EORI,A1     *Loads EORI into address register A1
00001486  103C 000E                477          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000148A  4E4F                     478          TRAP    #15         *Displays Message
0000148C                           479          
0000148C                           480          
0000148C                           481          *Should have a valid EORI op code. Set data up for EA.
0000148C                           482          
0000148C                           483          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000148C  4282                     484          CLR.L   D2
0000148E  3407                     485          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001490  C47C 003C                486          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001494  E60A                     487          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001496                           488                  
00001496                           489          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001496  4283                     490          CLR.L   D3
00001498  3607                     491          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000149A  C67C 0007                492          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000149E                           493          
0000149E  4EF9 000014A4            494          JMP     EA_EORI
000014A4                           495  
000014A4                           496  EA_EORI
000014A4                           497          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
000014A4                           498          *and D3 holds the EA register.
000014A4                           499          
000014A4                           500          *Determine how much data to read in, depending on the size of the operation
000014A4                           501          *output the size of the operation and the immediate data to console
000014A4  4EB9 0000158E            502          JSR     WrapperSizeImmediate
000014AA                           503          
000014AA                           504          *Determine which EA mode and thus Register/Mem Address this instruction used
000014AA  B43C 0000                505          CMP.B   #$00,D2
000014AE  6700 0160                506          BEQ     DataRegMode *If EA mode is a data register, output that
000014B2                           507          
000014B2  B43C 0002                508          CMP.B   #$02,D2
000014B6  6700 0162                509          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014BA                           510          
000014BA  B43C 0003                511          CMP.B   #$03,D2
000014BE  6700 0164                512          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014C2                           513          
000014C2  B43C 0004                514          CMP.B   #$04,D2
000014C6  6700 0166                515          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014CA                           516          
000014CA  B43C 0007                517          CMP.B   #$07,D2
000014CE  6700 0168                518          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014D2                           519          
000014D2                           520          *If the ea mode isn't equal to any of these, it is an invalid EA
000014D2  4EF9 000019B2            521          JMP     BADEACODE
000014D8                           522  
000014D8                           523  
000014D8                           524  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000014D8                           525  * everything up for EA if is a legit instruction.
000014D8                           526  IS_BCHG_D
000014D8                           527          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000014D8                           528          *invalid, branch to BADOPCODE
000014D8  3007                     529          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000014DA  0800 0007                530          BTST.L  #$07,D0
000014DE  6600 04C2                531          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000014E2  0800 0006                532          BTST.L  #$06,D0
000014E6  6700 04BA                533          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000014EA                           534          
000014EA                           535          *Output 'BCHG' to console...
000014EA  43F9 00001F2B            536          LEA     BCHG,A1         *Loads BCHG into address register A1
000014F0  103C 000E                537          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014F4  4E4F                     538          TRAP    #15             *Displays Message
000014F6                           539                  
000014F6                           540                  
000014F6                           541          *Should have a valid BCHG op code. Set data up for EA.
000014F6                           542  
000014F6                           543  *        *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014F6                           544  *        CLR.L   D2
000014F6                           545  *        MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014F6                           546  *        AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000014F6                           547  *        LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000014F6                           548  *                
000014F6                           549  *        *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000014F6                           550  *        CLR.L   D3
000014F6                           551  *        MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000014F6                           552  *        AND.W   #$0007,D3   *Mask out everything but the EA register bits
000014F6                           553  
000014F6  4EF9 000014FC            554          JMP     EA_BCHG_D
000014FC                           555  
000014FC                           556  EA_BCHG_D
000014FC  4EF9 000019C6            557          JMP     THEEND  *For now just end
00001502                           558  
00001502                           559  
00001502                           560  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
00001502                           561  IS_BCHG_S
00001502                           562          *TODO:Verify bits
00001502                           563  
00001502                           564          *Output 'BCHG' to console...
00001502  43F9 00001F2B            565          LEA     BCHG,A1 *Loads FNDBCHG_S into address register A1
00001508  103C 000E                566          MOVE.B  #14,D0  *Moves the number 14 into data register D0
0000150C  4E4F                     567          TRAP    #15     *Displays Message
0000150E                           568          
0000150E                           569          *Should have a valid BCHG_S op code. Set data up for EA.
0000150E                           570          *TODO:
0000150E  163C 000E                571          MOVE.B  #14,D3
00001512  4EF9 00001518            572          JMP     EA_BCHG_S
00001518                           573  
00001518                           574  EA_BCHG_S
00001518  4EF9 000019C6            575          JMP     THEEND  *For now just end
0000151E                           576  
0000151E                           577  
0000151E                           578  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
0000151E                           579  IS_CMPI
0000151E                           580          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000151E                           581          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000151E  4281                     582          CLR.L   D1
00001520  3207                     583          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001522  C27C 00C0                584          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001526  EC09                     585          LSR.B   #$06,D1     *Shift the size bits into LSB
00001528                           586          
00001528  B23C 0003                587          CMP.B   #$03,D1     *Compare the size bits to $3
0000152C  6700 0474                588          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001530                           589          
00001530                           590          *Output 'CMPI' to console...
00001530  43F9 00001F30            591          LEA     CMPI,A1     *Loads CMPI into address register A1
00001536  103C 000E                592          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000153A  4E4F                     593          TRAP    #15         *Displays Message
0000153C                           594          
0000153C                           595          
0000153C                           596          *Should have a valid CMPI op code. Set data up for EA.
0000153C                           597          
0000153C                           598          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000153C  4282                     599          CLR.L   D2
0000153E  3407                     600          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001540  C47C 003C                601          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001544  E60A                     602          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001546                           603                  
00001546                           604          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001546  4283                     605          CLR.L   D3
00001548  3607                     606          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000154A  C67C 0007                607          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000154E                           608          
0000154E  4EF9 00001554            609          JMP     EA_CMPI
00001554                           610  
00001554                           611  EA_CMPI
00001554                           612          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
00001554                           613          *and D3 holds the EA register.
00001554                           614          
00001554                           615          *Determine how much data to read in, depending on the size of the operation
00001554                           616          *output the size of the operation and the immediate data to console
00001554  4EB9 0000158E            617          JSR     WrapperSizeImmediate
0000155A                           618          
0000155A                           619          *Determine which EA mode and thus Register/Mem Address this instruction used
0000155A  B43C 0000                620          CMP.B   #$00,D2
0000155E  6700 00B0                621          BEQ     DataRegMode *If EA mode is a data register, output that
00001562                           622          
00001562  B43C 0002                623          CMP.B   #$02,D2
00001566  6700 00B2                624          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000156A                           625          
0000156A  B43C 0003                626          CMP.B   #$03,D2
0000156E  6700 00B4                627          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001572                           628          
00001572  B43C 0004                629          CMP.B   #$04,D2
00001576  6700 00B6                630          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000157A                           631          
0000157A  B43C 0007                632          CMP.B   #$07,D2
0000157E  6700 00B8                633          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001582                           634          
00001582                           635          *If the ea mode isn't equal to any of these, it is an invalid EA
00001582  4EF9 000019B2            636          JMP     BADEACODE
00001588                           637  
00001588                           638          
00001588                           639  *STARTS WITH 0001, MOVE.B-----------------------------------
00001588                           640  BUCKET_0001
00001588  =00000001                641  BUCKET0001_BITS EQU $1
00001588                           642          
00001588                           643          *some code...
00001588                           644  
00001588                           645  
00001588                           646  *STARTS WITH 0010, MOVE.L-----------------------------------
00001588                           647  BUCKET_0010
00001588  =00000002                648  BUCKET0010_BITS EQU $2
00001588                           649  
00001588                           650          *some code...
00001588                           651  
00001588                           652  
00001588                           653  *STARTS WITH 0011, MOVE.W-----------------------------------
00001588                           654  BUCKET_0011
00001588  =00000003                655  BUCKET0011_BITS EQU $3
00001588                           656  
00001588                           657          *some code...
00001588                           658  
00001588                           659  
00001588                           660  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
00001588                           661  BUCKET_0100
00001588  =00000004                662  BUCKET0100_BITS EQU $4
00001588                           663  
00001588                           664          *some code...
00001588                           665  
00001588                           666  
00001588                           667  *STARTS WITH 0101, SUBQ-------------------------------------
00001588                           668  BUCKET_0101
00001588  =00000005                669  BUCKET0101_BITS EQU $5
00001588                           670  
00001588                           671          *some code...
00001588                           672  
00001588                           673  
00001588                           674  *STARTS WITH 0110, BCC--------------------------------------
00001588                           675  BUCKET_0110
00001588  =00000006                676  BUCKET0110_BITS EQU $6
00001588                           677  
00001588                           678          *some code...
00001588                           679  
00001588                           680  
00001588                           681  *STARTS WITH 1000, DIVU-------------------------------------
00001588                           682  BUCKET_1000
00001588  =00000008                683  BUCKET1000_BITS EQU $8
00001588                           684  
00001588                           685          *some code...
00001588                           686  
00001588                           687  
00001588                           688  *STARTS WITH 1001, SUBA-------------------------------------
00001588                           689  BUCKET_1001
00001588  =00000009                690  BUCKET1001_BITS EQU $9
00001588                           691  
00001588                           692          *some code...
00001588                           693  
00001588                           694  
00001588                           695  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
00001588                           696  BUCKET_1011
00001588  =0000000B                697  BUCKET1011_BITS EQU $B
00001588                           698  
00001588                           699          *some code...
00001588                           700  
00001588                           701  
00001588                           702  *STARTS WITH 1100, MULS(W) | AND----------------------------
00001588                           703  BUCKET_1100
00001588  =0000000C                704  BUCKET1100_BITS EQU $C
00001588                           705  
00001588                           706          *some code...
00001588                           707  
00001588                           708  
00001588                           709  *STARTS WITH 1101, ADD | ADDA-------------------------------
00001588                           710  BUCKET_1101
00001588  =0000000D                711  BUCKET1101_BITS EQU $D
00001588                           712  
00001588                           713          *some code...
00001588                           714  
00001588                           715  
00001588                           716  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
00001588                           717  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
00001588                           718  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
00001588                           719  BUCKET_1110
00001588  =0000000E                720  BUCKET1110_BITS EQU $E     
00001588                           721  
00001588                           722          *some code...
00001588                           723  
00001588                           724  
00001588                           725  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
00001588                           726  *for this disassembler, jump to BADOPCODE and let I/O take care of it
00001588  4EF9 000019A2            727          JMP     BADOPCODE  
0000158E                           728          
0000158E                           729  
0000158E                           730  *-----------------------------------------------------------        
0000158E                           731  * EA operation size decoding functionality
0000158E                           732  *-----------------------------------------------------------   
0000158E                           733  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
0000158E                           734  WrapperSizeImmediate
0000158E  4284                     735          CLR.L   D4
00001590                           736          *Depending on the EA Register, choose which size to decode
00001590  B23C 0000                737          CMP.B   #$00,D1
00001594  6700 0014                738          BEQ     ByteSizeImmediate
00001598                           739          
00001598  B23C 0001                740          CMP.B   #$01,D1
0000159C  6700 002E                741          BEQ     WordSizeImmediate
000015A0                           742  
000015A0  B23C 0002                743          CMP.B   #$02,D1
000015A4  6700 0048                744          BEQ     LongSizeImmediate
000015A8                           745          
000015A8                           746  *Used to get back to what we were doing, after dealing with the specific size
000015A8                           747  WrapperSizeImmediateEnd
000015A8  4E75                     748          RTS
000015AA                           749          
000015AA                           750  ByteSizeImmediate
000015AA  3818                     751          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
000015AC                           752          
000015AC                           753          *Output '.B' to console...
000015AC  43F9 00001F35            754          LEA     ByteSize,A1 *Loads ByteSize into address register A1
000015B2  103C 000E                755          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000015B6  4E4F                     756          TRAP    #15         *Displays Message
000015B8                           757          
000015B8                           758          *Output '#$' just before the immediate data
000015B8  43F9 0000204D            759          LEA     ShaBang,A1
000015BE  103C 000E                760          MOVE.B  #14,D0
000015C2  4E4F                     761          TRAP    #15  
000015C4                           762          
000015C4                           763          *output the immediate data to console with the hex-ascii converter
000015C4  4EB8 11D6                764          JSR     HEXASCII
000015C8                           765                  
000015C8  4EF8 15A8                766          JMP     WrapperSizeImmediateEnd
000015CC                           767                  
000015CC                           768  WordSizeImmediate
000015CC  3818                     769          MOVE.W  (A0)+,D4    *read in next word, data is that word
000015CE                           770          
000015CE                           771          *Output '.W' to console...
000015CE  43F9 00001F3C            772          LEA     WordSize,A1 *Loads WordSize into address register A1
000015D4  103C 000E                773          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000015D8  4E4F                     774          TRAP    #15         *Displays Message
000015DA                           775          
000015DA                           776          *Output '#$' just before the immediate data
000015DA  43F9 0000204D            777          LEA     ShaBang,A1
000015E0  103C 000E                778          MOVE.B  #14,D0
000015E4  4E4F                     779          TRAP    #15  
000015E6                           780          
000015E6                           781          *output the immediate data to console with the hex-ascii converter
000015E6  4EB8 11D6                782          JSR     HEXASCII
000015EA                           783          
000015EA  4EF8 15A8                784          JMP     WrapperSizeImmediateEnd
000015EE                           785                  
000015EE                           786  LongSizeImmediate
000015EE  2818                     787          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
000015F0                           788          
000015F0                           789          *Output '.L' to console...
000015F0  43F9 00001F43            790          LEA     LongSize,A1 *Loads LongSize into address register A1
000015F6  103C 000E                791          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000015FA  4E4F                     792          TRAP    #15         *Displays Message
000015FC                           793          
000015FC                           794          *Output '#$' just before the immediate data
000015FC  43F9 0000204D            795          LEA     ShaBang,A1
00001602  103C 000E                796          MOVE.B  #14,D0
00001606  4E4F                     797          TRAP    #15  
00001608                           798          
00001608                           799          *output the immediate data to console with the hex-ascii converter
00001608  4EB8 11D6                800          JSR     HEXASCII
0000160C                           801          
0000160C  4EF8 15A8                802          JMP     WrapperSizeImmediateEnd
00001610                           803  
00001610                           804  
00001610                           805  *-----------------------------------------------------------        
00001610                           806  * EA Mode/EA Register decoding functionality
00001610                           807  *-----------------------------------------------------------        
00001610                           808  DataRegMode
00001610                           809          *Depending on the EA Register, output a different register number
00001610  4EB9 00001642            810          JSR     WrapperDataReg
00001616                           811          
00001616                           812          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001616                           813          *some wrapper (i'll define later)
00001616                           814          
00001616                           815          *else this was a destination EA decoding, we can just go get the next instruction
00001616                           816          *since there is no more decoding to do for the current instruction
00001616  4EF8 1338                817          JMP     GRAB_NEXT_OP
0000161A                           818  
0000161A                           819  AddrDirectMode
0000161A                           820          *some code...
0000161A                           821  
0000161A                           822  AddrIndirectMode
0000161A                           823          *Depending on the EA Register, output a different register number
0000161A  4EB9 00001704            824          JSR     WrapperAddrIndirect
00001620                           825                          
00001620                           826          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001620                           827          *some wrapper (i'll define later)
00001620                           828          
00001620                           829          *else this was a destination EA decoding, we can just go get the next instruction
00001620                           830          *since there is no more decoding to do for the current instruction
00001620  4EF8 1338                831          JMP     GRAB_NEXT_OP
00001624                           832  
00001624                           833  AddrIndirectPostMode
00001624                           834          *Depending on the EA Register, output a different register number
00001624  4EB9 000017C6            835          JSR     WrapperAddrIndirectPost
0000162A                           836  
0000162A                           837          *need to read some flag, if this was called from a source EA decoding then jmp to 
0000162A                           838          *some wrapper (i'll define later)
0000162A                           839          
0000162A                           840          *else this was a destination EA decoding, we can just go get the next instruction
0000162A                           841          *since there is no more decoding to do for the current instruction
0000162A  4EF8 1338                842          JMP     GRAB_NEXT_OP
0000162E                           843  
0000162E                           844  AddrIndirectPreMode
0000162E                           845          *Depending on the EA Register, output a different register number
0000162E  4EB9 00001888            846          JSR     WrapperAddrIndirectPre
00001634                           847  
00001634                           848          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001634                           849          *some wrapper (i'll define later)
00001634                           850          
00001634                           851          *else this was a destination EA decoding, we can just go get the next instruction
00001634                           852          *since there is no more decoding to do for the current instruction
00001634  4EF8 1338                853          JMP     GRAB_NEXT_OP
00001638                           854  
00001638                           855  AddrAbsoluteMode
00001638                           856          *Depending on the EA Register, output a different register number
00001638  4EB9 0000194A            857          JSR     WrapperAddrAbsolute        
0000163E                           858  
0000163E                           859          *need to read some flag, if this was called from a source EA decoding then jmp to 
0000163E                           860          *some wrapper (i'll define later)
0000163E                           861          
0000163E                           862          *else this was a destination EA decoding, we can just go get the next instruction
0000163E                           863          *since there is no more decoding to do for the current instruction
0000163E  4EF8 1338                864          JMP     GRAB_NEXT_OP
00001642                           865          
00001642                           866  ImmediateDataMode
00001642                           867          *some code      
00001642                           868  
00001642                           869  
00001642                           870  *-----------------------------------------------------------        
00001642                           871  * Output logic for all Data Registers (0-7)
00001642                           872  *-----------------------------------------------------------     
00001642                           873  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001642                           874  WrapperDataReg
00001642                           875          *Depending on the EA Register, output a different register number
00001642  B63C 0000                876          CMP.B   #$00,D3
00001646  6700 003C                877          BEQ     DataReg0
0000164A                           878          
0000164A  B63C 0001                879          CMP.B   #$01,D3
0000164E  6700 0044                880          BEQ     DataReg1
00001652                           881          
00001652  B63C 0002                882          CMP.B   #$02,D3
00001656  6700 004C                883          BEQ     DataReg2
0000165A                           884          
0000165A  B63C 0003                885          CMP.B   #$03,D3
0000165E  6700 0054                886          BEQ     DataReg3
00001662                           887          
00001662  B63C 0004                888          CMP.B   #$04,D3
00001666  6700 005C                889          BEQ     DataReg4
0000166A                           890          
0000166A  B63C 0005                891          CMP.B   #$05,D3
0000166E  6700 0064                892          BEQ     DataReg5
00001672                           893          
00001672  B63C 0006                894          CMP.B   #$06,D3
00001676  6700 006C                895          BEQ     DataReg6
0000167A                           896          
0000167A  B63C 0007                897          CMP.B   #$07,D3
0000167E  6700 0074                898          BEQ     DataReg7        
00001682                           899  
00001682                           900  *Used to get back to 'DataRegMode', after dealing with the specific register
00001682                           901  WrapperDataRegEnd
00001682  4E75                     902          RTS
00001684                           903  
00001684                           904  DataReg0
00001684                           905          *Output the specific data register...
00001684  43F9 00001F4A            906          LEA     OutDataReg0,A1  *Loads DataReg0 into address register A1
0000168A  103C 000E                907          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000168E  4E4F                     908          TRAP    #15             *Displays Message   
00001690                           909          
00001690  4EF8 1682                910          JMP     WrapperDataRegEnd
00001694                           911  
00001694                           912  DataReg1
00001694  43F9 00001F50            913          LEA     OutDataReg1,A1
0000169A  103C 000E                914          MOVE.B  #14,D0
0000169E  4E4F                     915          TRAP    #15
000016A0                           916          
000016A0  4EF8 1682                917          JMP     WrapperDataRegEnd
000016A4                           918  
000016A4                           919  DataReg2
000016A4  43F9 00001F56            920          LEA     OutDataReg2,A1
000016AA  103C 000E                921          MOVE.B  #14,D0
000016AE  4E4F                     922          TRAP    #15
000016B0                           923  
000016B0  4EF8 1682                924          JMP     WrapperDataRegEnd
000016B4                           925      
000016B4                           926  DataReg3
000016B4  43F9 00001F5C            927          LEA     OutDataReg3,A1
000016BA  103C 000E                928          MOVE.B  #14,D0
000016BE  4E4F                     929          TRAP    #15
000016C0                           930  
000016C0  4EF8 1682                931          JMP     WrapperDataRegEnd
000016C4                           932          
000016C4                           933  DataReg4
000016C4  43F9 00001F62            934          LEA     OutDataReg4,A1
000016CA  103C 000E                935          MOVE.B  #14,D0
000016CE  4E4F                     936          TRAP    #15
000016D0                           937  
000016D0  4EF8 1682                938          JMP     WrapperDataRegEnd
000016D4                           939                 
000016D4                           940  DataReg5
000016D4  43F9 00001F68            941          LEA     OutDataReg5,A1
000016DA  103C 000E                942          MOVE.B  #14,D0
000016DE  4E4F                     943          TRAP    #15
000016E0                           944  
000016E0  4EF8 1682                945          JMP     WrapperDataRegEnd
000016E4                           946          
000016E4                           947  DataReg6
000016E4  43F9 00001F6E            948          LEA     OutDataReg6,A1 A1
000016EA  103C 000E                949          MOVE.B  #14,D0
000016EE  4E4F                     950          TRAP    #15
000016F0                           951  
000016F0  4EF8 1682                952          JMP     WrapperDataRegEnd
000016F4                           953          
000016F4                           954  DataReg7
000016F4  43F9 00001F74            955          LEA     OutDataReg7,A1
000016FA  103C 000E                956          MOVE.B  #14,D0
000016FE  4E4F                     957          TRAP    #15
00001700                           958          
00001700  4EF8 1682                959          JMP     WrapperDataRegEnd
00001704                           960  
00001704                           961  
00001704                           962  *-----------------------------------------------------------        
00001704                           963  * Output logic for all Address Indirect Registers (0-7)
00001704                           964  *-----------------------------------------------------------     
00001704                           965  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001704                           966  WrapperAddrIndirect
00001704                           967          *Depending on the EA Register, output a different register number
00001704  B63C 0000                968          CMP.B   #$00,D3
00001708  6700 003C                969          BEQ     AddrIndReg0
0000170C                           970          
0000170C  B63C 0001                971          CMP.B   #$01,D3
00001710  6700 0044                972          BEQ     AddrIndReg1
00001714                           973          
00001714  B63C 0002                974          CMP.B   #$02,D3
00001718  6700 004C                975          BEQ     AddrIndReg2
0000171C                           976          
0000171C  B63C 0003                977          CMP.B   #$03,D3
00001720  6700 0054                978          BEQ     AddrIndReg3
00001724                           979          
00001724  B63C 0004                980          CMP.B   #$04,D3
00001728  6700 005C                981          BEQ     AddrIndReg4
0000172C                           982          
0000172C  B63C 0005                983          CMP.B   #$05,D3
00001730  6700 0064                984          BEQ     AddrIndReg5
00001734                           985          
00001734  B63C 0006                986          CMP.B   #$06,D3
00001738  6700 006C                987          BEQ     AddrIndReg6
0000173C                           988          
0000173C  B63C 0007                989          CMP.B   #$07,D3
00001740  6700 0074                990          BEQ     AddrIndReg7
00001744                           991  
00001744                           992  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
00001744                           993  WrapperAddrIndirectEnd
00001744  4E75                     994          RTS        
00001746                           995  
00001746                           996  AddrIndReg0
00001746                           997          *Output the specific address indirect register...
00001746  43F9 00001F7A            998          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
0000174C  103C 000E                999          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001750  4E4F                    1000          TRAP    #15                 *Displays Message        
00001752                          1001          
00001752  4EF8 1744               1002          JMP     WrapperAddrIndirectEnd
00001756                          1003  
00001756                          1004  AddrIndReg1
00001756  43F9 00001F82           1005          LEA     OutAddrIndReg1,A1
0000175C  103C 000E               1006          MOVE.B  #14,D0
00001760  4E4F                    1007          TRAP    #15
00001762                          1008          
00001762  4EF8 1744               1009          JMP     WrapperAddrIndirectEnd
00001766                          1010  
00001766                          1011  AddrIndReg2
00001766  43F9 00001F8A           1012          LEA     OutAddrIndReg2,A1
0000176C  103C 000E               1013          MOVE.B  #14,D0
00001770  4E4F                    1014          TRAP    #15
00001772                          1015          
00001772  4EF8 1744               1016          JMP     WrapperAddrIndirectEnd
00001776                          1017  
00001776                          1018  AddrIndReg3
00001776  43F9 00001F92           1019          LEA     OutAddrIndReg3,A1
0000177C  103C 000E               1020          MOVE.B  #14,D0
00001780  4E4F                    1021          TRAP    #15
00001782                          1022          
00001782  4EF8 1744               1023          JMP     WrapperAddrIndirectEnd
00001786                          1024  
00001786                          1025  AddrIndReg4
00001786  43F9 00001F9A           1026          LEA     OutAddrIndReg4,A1
0000178C  103C 000E               1027          MOVE.B  #14,D0
00001790  4E4F                    1028          TRAP    #15
00001792                          1029          
00001792  4EF8 1744               1030          JMP     WrapperAddrIndirectEnd
00001796                          1031  
00001796                          1032  AddrIndReg5
00001796  43F9 00001FA2           1033          LEA     OutAddrIndReg5,A1
0000179C  103C 000E               1034          MOVE.B  #14,D0
000017A0  4E4F                    1035          TRAP    #15
000017A2                          1036          
000017A2  4EF8 1744               1037          JMP     WrapperAddrIndirectEnd
000017A6                          1038  
000017A6                          1039  AddrIndReg6
000017A6  43F9 00001FAA           1040          LEA     OutAddrIndReg6,A1
000017AC  103C 000E               1041          MOVE.B  #14,D0
000017B0  4E4F                    1042          TRAP    #15
000017B2                          1043          
000017B2  4EF8 1744               1044          JMP     WrapperAddrIndirectEnd
000017B6                          1045  
000017B6                          1046  AddrIndReg7
000017B6  43F9 00001FB2           1047          LEA     OutAddrIndReg7,A1
000017BC  103C 000E               1048          MOVE.B  #14,D0
000017C0  4E4F                    1049          TRAP    #15
000017C2                          1050          
000017C2  4EF8 1744               1051          JMP     WrapperAddrIndirectEnd
000017C6                          1052          
000017C6                          1053          
000017C6                          1054  *-----------------------------------------------------------        
000017C6                          1055  * Output logic for all Address Indirect Post Increment Registers (0-7)
000017C6                          1056  *-----------------------------------------------------------     
000017C6                          1057  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000017C6                          1058  WrapperAddrIndirectPost
000017C6                          1059          *Depending on the EA Register, output a different register number
000017C6  B63C 0000               1060          CMP.B   #$00,D3
000017CA  6700 003C               1061          BEQ     AddrIndPoReg0
000017CE                          1062          
000017CE  B63C 0001               1063          CMP.B   #$01,D3
000017D2  6700 0044               1064          BEQ     AddrIndPoReg1
000017D6                          1065          
000017D6  B63C 0002               1066          CMP.B   #$02,D3
000017DA  6700 004C               1067          BEQ     AddrIndPoReg2
000017DE                          1068          
000017DE  B63C 0003               1069          CMP.B   #$03,D3
000017E2  6700 0054               1070          BEQ     AddrIndPoReg3
000017E6                          1071          
000017E6  B63C 0004               1072          CMP.B   #$04,D3
000017EA  6700 005C               1073          BEQ     AddrIndPoReg4
000017EE                          1074          
000017EE  B63C 0005               1075          CMP.B   #$05,D3
000017F2  6700 0064               1076          BEQ     AddrIndPoReg5
000017F6                          1077          
000017F6  B63C 0006               1078          CMP.B   #$06,D3
000017FA  6700 006C               1079          BEQ     AddrIndPoReg6
000017FE                          1080          
000017FE  B63C 0007               1081          CMP.B   #$07,D3
00001802  6700 0074               1082          BEQ     AddrIndPoReg7
00001806                          1083  
00001806                          1084  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
00001806                          1085  WrapperAddrIndirectPostEnd
00001806  4E75                    1086          RTS        
00001808                          1087  
00001808                          1088  AddrIndPoReg0
00001808                          1089          *Output the specific address indirect post register...
00001808  43F9 00001FBA           1090          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
0000180E  103C 000E               1091          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001812  4E4F                    1092          TRAP    #15                 *Displays Message        
00001814                          1093          
00001814  4EF8 1806               1094          JMP     WrapperAddrIndirectPostEnd
00001818                          1095  
00001818                          1096  AddrIndPoReg1
00001818  43F9 00001FC3           1097          LEA     OutAddrIndPoReg1,A1
0000181E  103C 000E               1098          MOVE.B  #14,D0
00001822  4E4F                    1099          TRAP    #15
00001824                          1100          
00001824  4EF8 1806               1101          JMP     WrapperAddrIndirectPostEnd
00001828                          1102  
00001828                          1103  AddrIndPoReg2
00001828  43F9 00001FCC           1104          LEA     OutAddrIndPoReg2,A1
0000182E  103C 000E               1105          MOVE.B  #14,D0
00001832  4E4F                    1106          TRAP    #15
00001834                          1107          
00001834  4EF8 1806               1108          JMP     WrapperAddrIndirectPostEnd
00001838                          1109  
00001838                          1110  AddrIndPoReg3
00001838  43F9 00001FD5           1111          LEA     OutAddrIndPoReg3,A1
0000183E  103C 000E               1112          MOVE.B  #14,D0
00001842  4E4F                    1113          TRAP    #15
00001844                          1114          
00001844  4EF8 1806               1115          JMP     WrapperAddrIndirectPostEnd
00001848                          1116  
00001848                          1117  AddrIndPoReg4
00001848  43F9 00001FDE           1118          LEA     OutAddrIndPoReg4,A1
0000184E  103C 000E               1119          MOVE.B  #14,D0
00001852  4E4F                    1120          TRAP    #15
00001854                          1121          
00001854  4EF8 1806               1122          JMP     WrapperAddrIndirectPostEnd
00001858                          1123  
00001858                          1124  AddrIndPoReg5
00001858  43F9 00001FE7           1125          LEA     OutAddrIndPoReg5,A1
0000185E  103C 000E               1126          MOVE.B  #14,D0
00001862  4E4F                    1127          TRAP    #15
00001864                          1128          
00001864  4EF8 1806               1129          JMP     WrapperAddrIndirectPostEnd
00001868                          1130  
00001868                          1131  AddrIndPoReg6
00001868  43F9 00001FF0           1132          LEA     OutAddrIndPoReg6,A1
0000186E  103C 000E               1133          MOVE.B  #14,D0
00001872  4E4F                    1134          TRAP    #15
00001874                          1135          
00001874  4EF8 1806               1136          JMP     WrapperAddrIndirectPostEnd
00001878                          1137  
00001878                          1138  AddrIndPoReg7
00001878  43F9 00001FF9           1139          LEA     OutAddrIndPoReg7,A1
0000187E  103C 000E               1140          MOVE.B  #14,D0
00001882  4E4F                    1141          TRAP    #15
00001884                          1142          
00001884  4EF8 1806               1143          JMP     WrapperAddrIndirectPostEnd
00001888                          1144  
00001888                          1145  
00001888                          1146  *-----------------------------------------------------------        
00001888                          1147  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001888                          1148  *-----------------------------------------------------------     
00001888                          1149  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001888                          1150  WrapperAddrIndirectPre
00001888                          1151          *Depending on the EA Register, output a different register number
00001888  B63C 0000               1152          CMP.B   #$00,D3
0000188C  6700 003C               1153          BEQ     AddrIndPrReg0
00001890                          1154          
00001890  B63C 0001               1155          CMP.B   #$01,D3
00001894  6700 0044               1156          BEQ     AddrIndPrReg1
00001898                          1157          
00001898  B63C 0002               1158          CMP.B   #$02,D3
0000189C  6700 004C               1159          BEQ     AddrIndPrReg2
000018A0                          1160          
000018A0  B63C 0003               1161          CMP.B   #$03,D3
000018A4  6700 0054               1162          BEQ     AddrIndPrReg3
000018A8                          1163          
000018A8  B63C 0004               1164          CMP.B   #$04,D3
000018AC  6700 005C               1165          BEQ     AddrIndPrReg4
000018B0                          1166          
000018B0  B63C 0005               1167          CMP.B   #$05,D3
000018B4  6700 0064               1168          BEQ     AddrIndPrReg5
000018B8                          1169          
000018B8  B63C 0006               1170          CMP.B   #$06,D3
000018BC  6700 006C               1171          BEQ     AddrIndPrReg6
000018C0                          1172          
000018C0  B63C 0007               1173          CMP.B   #$07,D3
000018C4  6700 0074               1174          BEQ     AddrIndPrReg7
000018C8                          1175  
000018C8                          1176  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
000018C8                          1177  WrapperAddrIndirectPreEnd
000018C8  4E75                    1178          RTS        
000018CA                          1179  
000018CA                          1180  AddrIndPrReg0
000018CA                          1181          *Output the specific address indirect post register...
000018CA  43F9 00002002           1182          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
000018D0  103C 000E               1183          MOVE.B  #14,D0              *Moves the number 14 into data register D0
000018D4  4E4F                    1184          TRAP    #15                 *Displays Message        
000018D6                          1185          
000018D6  4EF8 18C8               1186          JMP     WrapperAddrIndirectPreEnd
000018DA                          1187  
000018DA                          1188  AddrIndPrReg1
000018DA  43F9 0000200B           1189          LEA     OutAddrIndPrReg1,A1
000018E0  103C 000E               1190          MOVE.B  #14,D0
000018E4  4E4F                    1191          TRAP    #15
000018E6                          1192          
000018E6  4EF8 18C8               1193          JMP     WrapperAddrIndirectPreEnd
000018EA                          1194  
000018EA                          1195  AddrIndPrReg2
000018EA  43F9 00002014           1196          LEA     OutAddrIndPrReg2,A1
000018F0  103C 000E               1197          MOVE.B  #14,D0
000018F4  4E4F                    1198          TRAP    #15
000018F6                          1199          
000018F6  4EF8 18C8               1200          JMP     WrapperAddrIndirectPreEnd
000018FA                          1201  
000018FA                          1202  AddrIndPrReg3
000018FA  43F9 0000201D           1203          LEA     OutAddrIndPrReg3,A1
00001900  103C 000E               1204          MOVE.B  #14,D0
00001904  4E4F                    1205          TRAP    #15
00001906                          1206          
00001906  4EF8 18C8               1207          JMP     WrapperAddrIndirectPreEnd
0000190A                          1208  
0000190A                          1209  AddrIndPrReg4
0000190A  43F9 00002026           1210          LEA     OutAddrIndPrReg4,A1
00001910  103C 000E               1211          MOVE.B  #14,D0
00001914  4E4F                    1212          TRAP    #15
00001916                          1213          
00001916  4EF8 18C8               1214          JMP     WrapperAddrIndirectPreEnd
0000191A                          1215  
0000191A                          1216  AddrIndPrReg5
0000191A  43F9 0000202F           1217          LEA     OutAddrIndPrReg5,A1
00001920  103C 000E               1218          MOVE.B  #14,D0
00001924  4E4F                    1219          TRAP    #15
00001926                          1220          
00001926  4EF8 18C8               1221          JMP     WrapperAddrIndirectPreEnd
0000192A                          1222  
0000192A                          1223  AddrIndPrReg6
0000192A  43F9 00002038           1224          LEA     OutAddrIndPrReg6,A1
00001930  103C 000E               1225          MOVE.B  #14,D0
00001934  4E4F                    1226          TRAP    #15
00001936                          1227          
00001936  4EF8 18C8               1228          JMP     WrapperAddrIndirectPreEnd
0000193A                          1229  
0000193A                          1230  AddrIndPrReg7
0000193A  43F9 00002041           1231          LEA     OutAddrIndPrReg7,A1
00001940  103C 000E               1232          MOVE.B  #14,D0
00001944  4E4F                    1233          TRAP    #15
00001946                          1234          
00001946  4EF8 18C8               1235          JMP     WrapperAddrIndirectPreEnd
0000194A                          1236  
0000194A                          1237  
0000194A                          1238  *-----------------------------------------------------------        
0000194A                          1239  * Output logic for absolute memory addressing (0-7)
0000194A                          1240  *-----------------------------------------------------------     
0000194A                          1241  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
0000194A                          1242  WrapperAddrAbsolute
0000194A  4284                    1243          CLR.L   D4
0000194C                          1244          *Depending on the EA Register, choose which size to decode
0000194C  B63C 0000               1245          CMP.B   #$00,D3
00001950  6700 000C               1246          BEQ     WordSizeAbsolute
00001954                          1247  
00001954  B63C 0001               1248          CMP.B   #$01,D3
00001958  6700 0026               1249          BEQ     LongSizeAbsolute
0000195C                          1250          
0000195C                          1251  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
0000195C                          1252  WrapperAddrAbsoluteEnd
0000195C  4E75                    1253          RTS
0000195E                          1254  
0000195E                          1255  WordSizeAbsolute        
0000195E  3818                    1256          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001960                          1257              
00001960                          1258          *Output ',$' just after source operand
00001960  43F9 00002050           1259          LEA     Bang,A1
00001966  103C 000E               1260          MOVE.B  #14,D0
0000196A  4E4F                    1261          TRAP    #15
0000196C                          1262              
0000196C                          1263          *output the absolute mem address to console with the hex-ascii converter
0000196C  4EB8 11D6               1264          JSR     HEXASCII
00001970                          1265          
00001970                          1266          *Print a new line, since this should be the last piece of data for an instruction
00001970  43F9 0000204A           1267          LEA     NewLine,A1
00001976  103C 000E               1268          MOVE.B  #14,D0
0000197A  4E4F                    1269          TRAP    #15
0000197C                          1270          
0000197C  4EF8 195C               1271          JMP     WrapperAddrAbsoluteEnd
00001980                          1272  
00001980                          1273  LongSizeAbsolute
00001980  2818                    1274          MOVE.L  (A0)+,D4    *read in next long, data is that long
00001982                          1275                  
00001982                          1276          *Output ',$' just after source operand
00001982  43F9 00002050           1277          LEA     Bang,A1
00001988  103C 000E               1278          MOVE.B  #14,D0
0000198C  4E4F                    1279          TRAP    #15  
0000198E                          1280          
0000198E                          1281          *output the absolute mem address to console with the hex-ascii converter
0000198E  4EB8 11D6               1282          JSR     HEXASCII
00001992                          1283          
00001992                          1284          *Print a new line, since this should be the last piece of data for an instruction
00001992  43F9 0000204A           1285          LEA     NewLine,A1
00001998  103C 000E               1286          MOVE.B  #14,D0
0000199C  4E4F                    1287          TRAP    #15
0000199E                          1288  
0000199E  4EF8 195C               1289          JMP     WrapperAddrAbsoluteEnd
000019A2                          1290          
000019A2                          1291  
000019A2                          1292  *-----------------------------------------------------------        
000019A2                          1293  * Current handling of bad op/ea codes. Should be revisited.
000019A2                          1294  *----------------------------------------------------------- 
000019A2                          1295  BADOPCODE
000019A2                          1296          *We found a bad op code, output some error to the screen, jump to the 
000019A2                          1297          *next instruction in memory.
000019A2                          1298          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
000019A2                          1299          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
000019A2                          1300          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
000019A2                          1301          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
000019A2                          1302          *i/o and error message code...
000019A2  43F9 00002063           1303          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
000019A8  103C 000E               1304          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019AC  4E4F                    1305          TRAP    #15         *Displays Message
000019AE  4EF8 1338               1306          JMP     GRAB_NEXT_OP
000019B2                          1307                  
000019B2                          1308  BADEACODE
000019B2                          1309          *We found a bad ea code, output some error to the screen, jump to the
000019B2                          1310          *next instruction in memory.
000019B2                          1311          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
000019B2                          1312          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
000019B2  43F9 00002053           1313          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
000019B8  103C 000E               1314          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019BC  4E4F                    1315          TRAP    #15         *Displays Message
000019BE  4EF8 1338               1316          JMP     GRAB_NEXT_OP
000019C2                          1317          
000019C2                          1318          
000019C2                          1319  *-----------------------------------------------------------        
000019C2                          1320  * End of Disassembler
000019C2                          1321  *-----------------------------------------------------------    
000019C2                          1322  
000019C2  4E72 2700               1323  DONE    STOP    #$2700  *What does this do? Why was it added?
000019C6                          1324  
000019C6  103C 0009               1325  THEEND  MOVE.B  #9,D0
000019CA  4E4F                    1326          TRAP    #15             Halt Simulator        
000019CC                          1327          
000019CC                          1328       
000019CC                          1329  *-----------------------------------------------------------        
000019CC                          1330  * Output stuff
000019CC                          1331  *-----------------------------------------------------------     
000019CC  =0000000D               1332  CR      EQU     $0D             ASCII code for Carriage Return
000019CC  =0000000A               1333  LF      EQU     $0A             ASCII code for Line Feed
000019CC= 2D 2D 2D 2D 2D 2D ...   1334  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001A0B= 7C 7C 20 20 20 20 ...   1335              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001A4A= 2D 2D 2D 2D 2D 2D ...   1336              DC.B    '-------------------------------------------------------------',CR,LF
00001A89= 2A 2A 2A 2A 2A 2A ...   1337              DC.B    '*************************************************************',CR,LF
00001AC8= 2A 2A 2A 2A 2A 2A ...   1338              DC.B    '*************************************************************',CR,LF
00001B07= 2A 2A 2A 2A 2A 2A ...   1339              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001B46= 2A 2A 2A 2A 2A 2A ...   1340              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001B85= 2A 2A 2A 2A 2A 2A ...   1341              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001BC4= 2A 2A 2A 2A 2A 2A ...   1342              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001C03= 2A 2A 2A 2A 2A 2A ...   1343              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001C42= 2A 2A 2A 2A 2A 2A ...   1344              DC.B    '*************************************************************',CR,LF
00001C81= 2A 2A 2A 2A 2A 2A ...   1345              DC.B    '*************************************************************',CR,LF
00001CC0= 2A 20 20 20 20 20 ...   1346              DC.B    '*                                                           *',CR,LF
00001CFF= 2A 20 41 75 74 68 ...   1347              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001D3E= 2A 20 20 20 20 20 ...   1348              DC.B    '*                                                           *',CR,LF
00001D7D= 2A 2A 2A 2A 2A 2A ...   1349              DC.B    '*************************************************************',CR,LF,CR,LF
00001DBE= 53 74 61 72 74 69 ...   1350              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001DDB                          1351              
00001DDB= 57 6F 75 6C 64 20 ...   1352  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001E0C                          1353  
00001E0C= 20 0D 0A                1354  GETSTRTADDR DC.B    ' ',CR,LF
00001E0F= 50 6C 65 61 73 65 ...   1355              DC.B    'Please type in your starting address request: ',0
00001E3E                          1356              
00001E3E= 20 0D 0A                1357  GETENDADDR  DC.B    ' ',CR,LF
00001E41= 50 6C 65 61 73 65 ...   1358              DC.B    'Please type in your ending address request: ',0
00001E6E                          1359              
00001E6E= 20 0D 0A                1360  QUIT_MSG    DC.B    ' ',CR,LF
00001E71= 57 6F 75 6C 64 20 ...   1361              DC.B    'Would you like to quit (Y/N)? ',0
00001E90                          1362  
00001E90                          1363  *****************************************************
00001E90                          1364  * I/O storages - assuming users knows what to do.
00001E90                          1365  *****************************************************
00001E90                          1366  CMD_HLD     DS.B    30
00001EAE                          1367  CMD_SZ      DS.B    30
00001ECC                          1368  STADDR      DS.B    10
00001ED6                          1369  STADDRSZ    DS.B    10
00001EE0                          1370  PROGST      DS.L    1
00001EE4                          1371  ENDADDR     DS.B    10
00001EEE                          1372  ENDADDRSZ   DS.B    10
00001EF8                          1373  PROGEND     DS.L    1
00001EFC                          1374  *****************************************************
00001EFC                          1375  
00001EFC                          1376  *Table for 0-9 && A-F
00001EFC= 30 00                   1377  PRNT0   DC.B    '0',0
00001EFE= 31 00                   1378  PRNT1   DC.B    '1',0
00001F00= 32 00                   1379  PRNT2   DC.B    '2',0
00001F02= 33 00                   1380  PRNT3   DC.B    '3',0
00001F04= 34 00                   1381  PRNT4   DC.B    '4',0
00001F06= 35 00                   1382  PRNT5   DC.B    '5',0
00001F08= 36 00                   1383  PRNT6   DC.B    '6',0
00001F0A= 37 00                   1384  PRNT7   DC.B    '7',0
00001F0C= 38 00                   1385  PRNT8   DC.B    '8',0
00001F0E= 39 00                   1386  PRNT9   DC.B    '9',0
00001F10= 41 00                   1387  PRNTA   DC.B    'A',0
00001F12= 42 00                   1388  PRNTB   DC.B    'B',0
00001F14= 43 00                   1389  PRNTC   DC.B    'C',0
00001F16= 44 00                   1390  PRNTD   DC.B    'D',0
00001F18= 45 00                   1391  PRNTE   DC.B    'E',0
00001F1A= 46 00                   1392  PRNTF   DC.B    'F',0
00001F1C                          1393  
00001F1C                          1394  *output for all OPCODEs
00001F1C= 41 44 44 49 00          1395  ADDI    DC.B    'ADDI',0
00001F21= 41 4E 44 49 00          1396  ANDI    DC.B    'ANDI',0
00001F26= 45 4F 52 49 00          1397  EORI    DC.B    'EORI',0
00001F2B= 42 43 48 47 00          1398  BCHG    DC.B    'BCHG',0
00001F30= 43 4D 50 49 00          1399  CMPI    DC.B    'CMPI',0
00001F35                          1400  
00001F35                          1401  *output for the size of the operation
00001F35= 2E 42 20 20 20 20 00    1402  ByteSize    DC.B    '.B    ',0
00001F3C= 2E 57 20 20 20 20 00    1403  WordSize    DC.B    '.W    ',0
00001F43= 2E 4C 20 20 20 20 00    1404  LongSize    DC.B    '.L    ',0
00001F4A                          1405  
00001F4A                          1406  *output for all data registers (0-7)
00001F4A= 2C 44 30 0D 0A 00       1407  OutDataReg0 DC.B    ',D0',CR,LF,0
00001F50= 2C 44 31 0D 0A 00       1408  OutDataReg1 DC.B    ',D1',CR,LF,0
00001F56= 2C 44 32 0D 0A 00       1409  OutDataReg2 DC.B    ',D2',CR,LF,0
00001F5C= 2C 44 33 0D 0A 00       1410  OutDataReg3 DC.B    ',D3',CR,LF,0
00001F62= 2C 44 34 0D 0A 00       1411  OutDataReg4 DC.B    ',D4',CR,LF,0
00001F68= 2C 44 35 0D 0A 00       1412  OutDataReg5 DC.B    ',D5',CR,LF,0
00001F6E= 2C 44 36 0D 0A 00       1413  OutDataReg6 DC.B    ',D6',CR,LF,0
00001F74= 2C 44 37 0D 0A 00       1414  OutDataReg7 DC.B    ',D7',CR,LF,0
00001F7A                          1415  
00001F7A                          1416  *output for all address indirect registers (0-7)
00001F7A= 2C 28 41 30 29 0D ...   1417  OutAddrIndReg0  DC.B    ',(A0)',CR,LF,0
00001F82= 2C 28 41 31 29 0D ...   1418  OutAddrIndReg1  DC.B    ',(A1)',CR,LF,0
00001F8A= 2C 28 41 32 29 0D ...   1419  OutAddrIndReg2  DC.B    ',(A2)',CR,LF,0
00001F92= 2C 28 41 33 29 0D ...   1420  OutAddrIndReg3  DC.B    ',(A3)',CR,LF,0
00001F9A= 2C 28 41 34 29 0D ...   1421  OutAddrIndReg4  DC.B    ',(A4)',CR,LF,0
00001FA2= 2C 28 41 35 29 0D ...   1422  OutAddrIndReg5  DC.B    ',(A5)',CR,LF,0
00001FAA= 2C 28 41 36 29 0D ...   1423  OutAddrIndReg6  DC.B    ',(A6)',CR,LF,0
00001FB2= 2C 28 41 37 29 0D ...   1424  OutAddrIndReg7  DC.B    ',(A7)',CR,LF,0
00001FBA                          1425  
00001FBA                          1426  *output for all address indirect post registers (0-7)
00001FBA= 2C 28 41 30 29 2B ...   1427  OutAddrIndPoReg0    DC.B    ',(A0)+',CR,LF,0
00001FC3= 2C 28 41 31 29 2B ...   1428  OutAddrIndPoReg1    DC.B    ',(A1)+',CR,LF,0
00001FCC= 2C 28 41 32 29 2B ...   1429  OutAddrIndPoReg2    DC.B    ',(A2)+',CR,LF,0
00001FD5= 2C 28 41 33 29 2B ...   1430  OutAddrIndPoReg3    DC.B    ',(A3)+',CR,LF,0
00001FDE= 2C 28 41 34 29 2B ...   1431  OutAddrIndPoReg4    DC.B    ',(A4)+',CR,LF,0
00001FE7= 2C 28 41 35 29 2B ...   1432  OutAddrIndPoReg5    DC.B    ',(A5)+',CR,LF,0
00001FF0= 2C 28 41 36 29 2B ...   1433  OutAddrIndPoReg6    DC.B    ',(A6)+',CR,LF,0
00001FF9= 2C 28 41 37 29 2B ...   1434  OutAddrIndPoReg7    DC.B    ',(A7)+',CR,LF,0
00002002                          1435  
00002002                          1436  *output for all address indirect pre registers (0-7)
00002002= 2C 2D 28 41 30 29 ...   1437  OutAddrIndPrReg0    DC.B    ',-(A0)',CR,LF,0
0000200B= 2C 2D 28 41 31 29 ...   1438  OutAddrIndPrReg1    DC.B    ',-(A1)',CR,LF,0
00002014= 2C 2D 28 41 32 29 ...   1439  OutAddrIndPrReg2    DC.B    ',-(A2)',CR,LF,0
0000201D= 2C 2D 28 41 33 29 ...   1440  OutAddrIndPrReg3    DC.B    ',-(A3)',CR,LF,0
00002026= 2C 2D 28 41 34 29 ...   1441  OutAddrIndPrReg4    DC.B    ',-(A4)',CR,LF,0
0000202F= 2C 2D 28 41 35 29 ...   1442  OutAddrIndPrReg5    DC.B    ',-(A5)',CR,LF,0
00002038= 2C 2D 28 41 36 29 ...   1443  OutAddrIndPrReg6    DC.B    ',-(A6)',CR,LF,0
00002041= 2C 2D 28 41 37 29 ...   1444  OutAddrIndPrReg7    DC.B    ',-(A7)',CR,LF,0
0000204A                          1445  
0000204A                          1446  *output for a new line only
0000204A= 0D 0A 00                1447  NewLine DC.B    CR,LF,0
0000204D                          1448  
0000204D                          1449  *output for a '#$' and ',$' only
0000204D= 23 24 00                1450  ShaBang DC.B    '#$',0
00002050= 2C 24 00                1451  Bang    DC.B    ',$',0
00002053                          1452  
00002053                          1453  *current output for error messages
00002053= 42 41 44 20 45 41 ...   1454  BADEAMSG    DC.B    'BAD EA, WHY?!',CR,LF,0
00002063= 42 41 44 20 4F 50 ...   1455  BADOPMSG    DC.B    'BAD OP CODE, WHY?!',CR,LF,0
00002078= 49 6D 70 72 6F 70 ...   1456  INV_MSG     DC.B    'Improper command.',CR,LF,0
0000208C= 49 6E 76 61 6C 69 ...   1457  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
000020A5= 49 6E 76 61 6C 69 ...   1458  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
000020BC                          1459  
000020BC                          1460          
000020BC                          1461          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                1F1C
ADDRABSOLUTEMODE    1638
ADDRDIRECTMODE      161A
ADDRINDIRECTMODE    161A
ADDRINDIRECTPOSTMODE  1624
ADDRINDIRECTPREMODE  162E
ADDRINDPOREG0       1808
ADDRINDPOREG1       1818
ADDRINDPOREG2       1828
ADDRINDPOREG3       1838
ADDRINDPOREG4       1848
ADDRINDPOREG5       1858
ADDRINDPOREG6       1868
ADDRINDPOREG7       1878
ADDRINDPRREG0       18CA
ADDRINDPRREG1       18DA
ADDRINDPRREG2       18EA
ADDRINDPRREG3       18FA
ADDRINDPRREG4       190A
ADDRINDPRREG5       191A
ADDRINDPRREG6       192A
ADDRINDPRREG7       193A
ADDRINDREG0         1746
ADDRINDREG1         1756
ADDRINDREG2         1766
ADDRINDREG3         1776
ADDRINDREG4         1786
ADDRINDREG5         1796
ADDRINDREG6         17A6
ADDRINDREG7         17B6
ANDI                1F21
ASCIIHEX            1164
ASCIIHEX1           1168
BADEACODE           19B2
BADEAMSG            2053
BADOPCODE           19A2
BADOPMSG            2063
BANG                2050
BCHG                1F2B
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         1344
BUCKET_0001         1588
BUCKET_0010         1588
BUCKET_0011         1588
BUCKET_0100         1588
BUCKET_0101         1588
BUCKET_0110         1588
BUCKET_1000         1588
BUCKET_1001         1588
BUCKET_1011         1588
BUCKET_1100         1588
BUCKET_1101         1588
BUCKET_1110         1588
BYTESIZE            1F35
BYTESIZEIMMEDIATE   15AA
CHECKEND1           10EE
CHECKSTRT1          10D8
CHECK_LOWN          111C
CHECK_LOWY          110C
CHECK_UPN           1114
CHECK_UPY           1104
CHNG_SZB            11FA
CHNG_SZL            11F2
CHNG_SZW            1202
CMD_HLD             1E90
CMD_SZ              1EAE
CMPI                1F30
CONV_LOL            11C4
CONV_LOOP           120A
CONV_NUM            11B0
CONV_UPL            11BA
CR                  D
DATAREG0            1684
DATAREG1            1694
DATAREG2            16A4
DATAREG3            16B4
DATAREG4            16C4
DATAREG5            16D4
DATAREG6            16E4
DATAREG7            16F4
DATAREGMODE         1610
DONE                19C2
EA_ADDI             13D0
EA_ANDI             143A
EA_BCHG_D           14FC
EA_BCHG_S           1518
EA_CMPI             1554
EA_EORI             14A4
ENDADDR             1EE4
ENDADDRSZ           1EEE
EORI                1F26
EXITSUB             11D0
EXIT_CONV           129E
GETENDADDR          1E3E
GETSTRTADDR         1E0C
GET_END             1086
GET_STRT            1038
GRAB_NEXT_OP        1338
HEXASCII            11D6
HEXASCIIREG         11EE
IMMEDIATEDATAMODE   1642
INVALID1            1124
INVENDMSG           20A5
INVSTRTMSG          208C
INV_END1            1150
INV_MSG             2078
INV_STRT1           113C
IS_ADDI             139A
IS_ANDI             1404
IS_BCHG_D           14D8
IS_BCHG_S           1502
IS_CMPI             151E
IS_EORI             146E
LF                  A
LONGSIZE            1F43
LONGSIZEABSOLUTE    1980
LONGSIZEIMMEDIATE   15EE
LOOP_1              1010
MESSAGE             19CC
NEWLINE             204A
NUM_0               12AE
NUM_1               12B6
NUM_2               12BE
NUM_3               12C6
NUM_4               12CE
NUM_5               12D6
NUM_6               12DE
NUM_7               12E6
NUM_8               12EE
NUM_9               12F6
NUM_A               12FE
NUM_B               1306
NUM_C               130E
NUM_D               1316
NUM_E               131E
NUM_F               1328
OUTADDRINDPOREG0    1FBA
OUTADDRINDPOREG1    1FC3
OUTADDRINDPOREG2    1FCC
OUTADDRINDPOREG3    1FD5
OUTADDRINDPOREG4    1FDE
OUTADDRINDPOREG5    1FE7
OUTADDRINDPOREG6    1FF0
OUTADDRINDPOREG7    1FF9
OUTADDRINDPRREG0    2002
OUTADDRINDPRREG1    200B
OUTADDRINDPRREG2    2014
OUTADDRINDPRREG3    201D
OUTADDRINDPRREG4    2026
OUTADDRINDPRREG5    202F
OUTADDRINDPRREG6    2038
OUTADDRINDPRREG7    2041
OUTADDRINDREG0      1F7A
OUTADDRINDREG1      1F82
OUTADDRINDREG2      1F8A
OUTADDRINDREG3      1F92
OUTADDRINDREG4      1F9A
OUTADDRINDREG5      1FA2
OUTADDRINDREG6      1FAA
OUTADDRINDREG7      1FB2
OUTDATAREG0         1F4A
OUTDATAREG1         1F50
OUTDATAREG2         1F56
OUTDATAREG3         1F5C
OUTDATAREG4         1F62
OUTDATAREG5         1F68
OUTDATAREG6         1F6E
OUTDATAREG7         1F74
PRINT_NUM           12A4
PRNT0               1EFC
PRNT1               1EFE
PRNT2               1F00
PRNT3               1F02
PRNT4               1F04
PRNT5               1F06
PRNT6               1F08
PRNT7               1F0A
PRNT8               1F0C
PRNT9               1F0E
PRNTA               1F10
PRNTB               1F12
PRNTC               1F14
PRNTD               1F16
PRNTE               1F18
PRNTF               1F1A
PROGEND             1EF8
PROGST              1EE0
QUIT_MSG            1E6E
SHABANG             204D
STACK               7000
STADDR              1ECC
STADDRSZ            1ED6
START               1000
STARTASSEM          1DDB
ST_ADDR             7FC6
ST_BAD              11CE
THEEND              19C6
WORDSIZE            1F3C
WORDSIZEABSOLUTE    195E
WORDSIZEIMMEDIATE   15CC
WRAPPERADDRABSOLUTE  194A
WRAPPERADDRABSOLUTEEND  195C
WRAPPERADDRINDIRECT  1704
WRAPPERADDRINDIRECTEND  1744
WRAPPERADDRINDIRECTPOST  17C6
WRAPPERADDRINDIRECTPOSTEND  1806
WRAPPERADDRINDIRECTPRE  1888
WRAPPERADDRINDIRECTPREEND  18C8
WRAPPERDATAREG      1642
WRAPPERDATAREGEND   1682
WRAPPERSIZEIMMEDIATE  158E
WRAPPERSIZEIMMEDIATEEND  15A8
