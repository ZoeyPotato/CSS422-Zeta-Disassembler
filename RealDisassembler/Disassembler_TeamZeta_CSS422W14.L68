00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.0
Created On: 3/14/2014 9:53:02 PM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/14/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. After specifying
00000000                             7  * where the program to be disassembled is located, this program will disassemble
00000000                             8  * instructions of that program, and output the contents to console.
00000000                             9  *
00000000                            10  * For use with the EASy68K Emulator. To run, open this program in the emulator.
00000000                            11  * Hit 'F9' to execute. In the execution window, open the test input file, and press
00000000                            12  * 'F9' to run the program.
00000000                            13  *
00000000                            14  * This program will not disassemble every 68k instruction, only a subset of instructions
00000000                            15  * that we have currently implemented. See corresponding documentation for more details.
00000000                            16  *-------------------------------------------------------------
00000000  =00007FC6                 17  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 18  STACK       EQU $7000   *Stack location
00000000  =00000020                 19  MAX_LINE    EQU 32      *Maximum number of instructions that can be displayed
00001000                            20  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 21              LEA stack,SP
00001004  3C3C 0020                 22              MOVE    #MAX_LINE,D6
00001008                            23              
00001008                            24  
00001008                            25  *-----------------------------------------------------------
00001008                            26  * Start of I/O
00001008                            27  *-----------------------------------------------------------            
00001008  43F9 00001EE6             28              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 29              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      30              TRAP    #15         *Displays Message
00001014                            31          
00001014  303C 0000                 32  loop_1      MOVE    #0,D0
00001018  363C 0000                 33              MOVE    #0,D3       
0000101C  43F9 000022F5             34              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
00001022  103C 000D                 35              MOVE.B  #13,D0
00001026  4E4F                      36              TRAP    #15    
00001028  303C 0002                 37              MOVE    #2,D0
0000102C  43F9 000023D0             38              LEA     CMD_HLD,A1  *Store the command in a buffer
00001032  4E4F                      39              TRAP    #15
00001034  0C01 0001                 40              CMPI.B  #01,D1
00001038  6600 00FE                 41              BNE     INVALID1
0000103C  4EB9 00001114             42              JSR     CHECK_UPY
00001042                            43              
00001042                            44              
00001042                            45  *-----------------------------------------------------------
00001042                            46  * I/O: Check Start Address
00001042                            47  *
00001042                            48  * Make sure that start address starts after allocated 
00001042                            49  * memory addresses. Else, it will print out a message 
00001042                            50  * saying that requested address is invalid & prompts the
00001042                            51  * user again for the starting address.
00001042                            52  *-----------------------------------------------------------
00001042  43F9 00002326             53  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001048  103C 000E                 54              MOVE.B  #14,D0
0000104C  4E4F                      55              TRAP    #15
0000104E  43F9 0000240C             56              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001054  3239 00002416             57              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
0000105A  303C 0002                 58              MOVE    #2,D0           *Get start address
0000105E  4E4F                      59              TRAP    #15
00001060  4EB9 000010E8             60              JSR     CHECKSTRT1
00001066  4287                      61              CLR.L   D7
00001068  4EB9 00001178             62              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106E  0C03 0001                 63              CMPI.B  #01,D3      *Check if there was a bad start
00001072  6700 00DC                 64              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001076  0C87 00007FC6             65              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
0000107C  6D00 00D2                 66              BLT     INV_STRT1   *Asks for another start address if invalid
00001080  0C87 00FFFFFE             67              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001086  6C00 00C8                 68              BGE     INV_STRT1
0000108A  23C7 00002420             69              MOVE.L  D7,PROGST
00001090                            70  
00001090  43F9 00002358             71  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001096  103C 000E                 72              MOVE.B  #14,D0
0000109A  4E4F                      73              TRAP    #15
0000109C  43F9 00002424             74              LEA     ENDADDR,A1      *Buffer to hold end address
000010A2  3239 0000242E             75              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A8  303C 0002                 76              MOVE    #2,D0
000010AC  4E4F                      77              TRAP    #15
000010AE  4EB9 000010FE             78              JSR     CHECKEND1
000010B4  4287                      79              CLR.L   D7
000010B6  4EB9 00001178             80              JSR     ASCIIHEX
000010BC  0C03 0001                 81              CMPI.B  #01,D3
000010C0  6700 00A2                 82              BEQ     INV_END1
000010C4  0C87 00002420             83              CMPI.L  #PROGST,D7
000010CA  6D00 0098                 84              BLT     INV_END1
000010CE  0C87 00FFFFFF             85              CMPI.L  #$00FFFFFF,D7
000010D4  6C00 008E                 86              BGE     INV_END1
000010D8  23C7 00002438             87              MOVE.L  D7,PROGEND
000010DE  2079 00002420             88              MOVEA.L PROGST,A0
000010E4  6000 02A0                 89              BRA     GRAB_NEXT_OP            
000010E8                            90                          
000010E8  0C81 00000008             91  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EE  6E00 0060                 92              BGT     INV_STRT1
000010F2  0C81 00000000             93              CMPI.L  #00,D1
000010F8  6300 0056                 94              BLS     INV_STRT1
000010FC  4E75                      95              RTS         
000010FE                            96              
000010FE  0C81 00000008             97  CHECKEND1   CMPI.L  #08,D1
00001104  6E00 005E                 98              BGT     INV_END1
00001108  0C81 00000000             99              CMPI.L  #00,D1
0000110E  6300 0054                100              BLS     INV_END1
00001112  4E75                     101              RTS
00001114                           102  
00001114                           103  
00001114                           104  *-----------------------------------------------------------
00001114                           105  * I/O: Input check for Y, y, N, n
00001114                           106  *-----------------------------------------------------------
00001114  0C11 0059                107  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001118  6600 0004                108              BNE     CHECK_LOWY
0000111C  4E75                     109              RTS
0000111E  0C11 0079                110  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
00001122  6600 0004                111              BNE     CHECK_UPN
00001126  4E75                     112              RTS
00001128  0C11 004E                113  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
0000112C  6700 0DAE                114              BEQ     DONE
00001130                           115              
00001130  0C11 006E                116  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001134  6700 0DA6                117              BEQ     DONE
00001138                           118              
00001138  163C 0000                119  INVALID1    MOVE.B  #0,D3       *Reset bad flag
0000113C  303C 0000                120              MOVE    #0,D0       *Prints invalid command msg if not found
00001140  43F9 000025AA            121              LEA     INV_MSG,A1
00001146  303C 000E                122              MOVE    #14,D0
0000114A  4E4F                     123              TRAP    #15
0000114C  6000 FEC6                124              BRA     loop_1
00001150                           125              
00001150  43F9 000025BE            126  INV_STRT1   LEA     INVSTRTMSG,A1
00001156  103C 000E                127              MOVE.B  #14,D0
0000115A  4E4F                     128              TRAP    #15
0000115C  163C 0000                129              MOVE.B  #00,D3      *Reset flag
00001160  6000 FEE0                130              BRA     GET_STRT        
00001164                           131              
00001164  43F9 000025D7            132  INV_END1    LEA     INVENDMSG,A1
0000116A  103C 000E                133              MOVE.B  #14,D0
0000116E  4E4F                     134              TRAP    #15
00001170  163C 0000                135              MOVE.B  #00,D3      *Reset flag
00001174  6000 FF1A                136              BRA     GET_END
00001178                           137              
00001178                           138              
00001178                           139  *-----------------------------------------------------------
00001178                           140  * ASCII to Hex converter
00001178                           141  *
00001178                           142  * Checks and converts the ASCII value to the hex equivalent
00001178                           143  *-----------------------------------------------------------
00001178  48E7 6000                144  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
0000117C  0C01 0000                145  ASCIIHEX1   CMPI.B  #00,D1      *See if done
00001180  6700 0062                146              BEQ     exitSub     *Exit subroutine 
00001184  5301                     147              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001186  E99F                     148              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001188  1419                     149              MOVE.B  (A1)+,D2    *Takes the first char
0000118A  0C02 0024                150              CMPI.B  #$24,D2     *See if the first char is $
0000118E  67EC                     151              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
00001190  0C02 0030                152              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001194  6D00 004C                153              BLT     st_bad      *Put error message
00001198  0C02 0039                154              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
0000119C  6F00 0026                155              BLE     CONV_NUM    *Convert to number, if so
000011A0  0C02 0041                156              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A4  6D00 003C                157              BLT     st_bad      *Put error message
000011A8  0C02 0046                158              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011AC  6F00 0020                159              BLE     CONV_UpL    *Convert to hex
000011B0  0C02 0061                160              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B4  6D00 002C                161              BLT     st_bad
000011B8  0C02 0066                162              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011BC  6F00 001A                163              BLE     CONV_LoL    
000011C0  6E00 0020                164              BGT     st_bad      *Puts error message for anything greater than f value
000011C4                           165              
000011C4  0402 0030                166  CONV_NUM    SUBI.B  #$30,D2
000011C8  8E02                     167              OR.B    D2,D7
000011CA  4EF8 117C                168              JMP     ASCIIHEX1
000011CE  0402 0037                169  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011D2  8E02                     170              OR.B    D2,D7
000011D4  4EF8 117C                171              JMP     ASCIIHEX1
000011D8  0402 0057                172  CONV_LoL    SUBI.B  #$57,D2
000011DC  8E02                     173              OR.B    D2,D7
000011DE  4EF8 117C                174              JMP     ASCIIHEX1   
000011E2                           175  
000011E2  5203                     176  st_bad      ADDI.B  #01,D3
000011E4  4CDF 0006                177  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E8  4E75                     178              RTS
000011EA                           179              
000011EA                           180              
000011EA                           181  *-----------------------------------------------------------
000011EA                           182  * Hex to ASCII converter
000011EA                           183  *-----------------------------------------------------------
000011EA  48E7 4C00                184  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EE  0C01 0000                185  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011F2  6700 002C                186              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F6  B27C 0001                187              CMP.W   #01,D1          
000011FA  6700 003E                188              BEQ     CHNG_SZW
000011FE  6000 0006                189              BRA     CHNG_SZL        
00001202                           190  
00001202  48E7 4C00                191  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001206  123C 0008                192  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
0000120A  0C01 0000                193  LOOP_L      CMPI.B  #00,D1
0000120E  6700 00CA                194              BEQ     EXIT_CONV
00001212  5301                     195              SUBI.B  #01,D1
00001214  E99C                     196              ROL.L   #4,D4           * Shift it for next bit
00001216  2A04                     197              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001218  4EB9 00001254            198              JSR     CONV_LOOP
0000121E  60EA                     199              BRA     LOOP_L      
00001220                           200  
00001220  123C 0002                201  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001224  0C01 0000                202  LOOP_B      CMPI.B  #00,D1
00001228  6700 00B0                203              BEQ     EXIT_CONV
0000122C  5301                     204              SUBI.B  #01,D1
0000122E  E91C                     205              ROL.B   #4,D4           * Shift it for next bit
00001230  2A04                     206              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001232  4EB9 00001254            207              JSR     CONV_LOOP
00001238  60EA                     208              BRA     LOOP_B
0000123A                           209              
0000123A  123C 0004                210  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123E  0C01 0000                211  LOOP_W      CMPI.B  #00,D1
00001242  6700 0096                212              BEQ     EXIT_CONV
00001246  5301                     213              SUBI.B  #01,D1
00001248  E95C                     214              ROL.W   #4,D4           * Shift it for next bit
0000124A  2A04                     215              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000124C  4EB9 00001254            216              JSR     CONV_LOOP
00001252  60EA                     217              BRA     LOOP_W
00001254                           218  
00001254  0285 0000000F            219  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
0000125A  0C05 0000                220              CMPI.B  #$0,D5
0000125E  6700 0088                221              BEQ     NUM_0
00001262  0C05 0001                222              CMPI.B  #$1,D5
00001266  6700 0088                223              BEQ     NUM_1
0000126A  0C05 0002                224              CMPI.B  #$2,D5
0000126E  6700 0088                225              BEQ     NUM_2
00001272  0C05 0003                226              CMPI.B  #$3,D5
00001276  6700 0088                227              BEQ     NUM_3
0000127A  0C05 0004                228              CMPI.B  #$4,D5
0000127E  6700 0088                229              BEQ     NUM_4
00001282  0C05 0005                230              CMPI.B  #$5,D5
00001286  6700 0088                231              BEQ     NUM_5
0000128A  0C05 0006                232              CMPI.B  #$6,D5
0000128E  6700 0088                233              BEQ     NUM_6
00001292  0C05 0007                234              CMPI.B  #$7,D5
00001296  6700 0088                235              BEQ     NUM_7
0000129A  0C05 0008                236              CMPI.B  #$8,D5
0000129E  6700 0088                237              BEQ     NUM_8
000012A2  0C05 0009                238              CMPI.B  #$9,D5
000012A6  6700 0088                239              BEQ     NUM_9
000012AA  0C05 000A                240              CMPI.B  #$A,D5
000012AE  6700 0088                241              BEQ     NUM_A
000012B2  0C05 000B                242              CMPI.B  #$B,D5
000012B6  6700 0088                243              BEQ     NUM_B
000012BA  0C05 000C                244              CMPI.B  #$C,D5
000012BE  6700 0088                245              BEQ     NUM_C
000012C2  0C05 000D                246              CMPI.B  #$D,D5
000012C6  6700 0088                247              BEQ     NUM_D
000012CA  0C05 000E                248              CMPI.B  #$E,D5
000012CE  6700 0088                249              BEQ     NUM_E
000012D2  0C05 000F                250              CMPI.B  #$F,D5
000012D6  6700 0088                251              BEQ     NUM_F
000012DA                           252              
000012DA  4CDF 0032                253  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DE  4E75                     254              RTS
000012E0                           255              
000012E0  303C 000E                256  PRINT_NUM   MOVE    #14,D0
000012E4  4E4F                     257              TRAP    #15
000012E6  4E75                     258              RTS
000012E8  43F9 0000245A            259  NUM_0       LEA     PRNT0,A1
000012EE  60F0                     260              BRA     PRINT_NUM
000012F0  43F9 0000245C            261  NUM_1       LEA     PRNT1,A1
000012F6  60E8                     262              BRA     PRINT_NUM
000012F8  43F9 0000245E            263  NUM_2       LEA     PRNT2,A1
000012FE  60E0                     264              BRA     PRINT_NUM
00001300  43F9 00002460            265  NUM_3       LEA     PRNT3,A1
00001306  60D8                     266              BRA     PRINT_NUM
00001308  43F9 00002462            267  NUM_4       LEA     PRNT4,A1
0000130E  60D0                     268              BRA     PRINT_NUM
00001310  43F9 00002464            269  NUM_5       LEA     PRNT5,A1
00001316  60C8                     270              BRA     PRINT_NUM
00001318  43F9 00002466            271  NUM_6       LEA     PRNT6,A1
0000131E  60C0                     272              BRA     PRINT_NUM
00001320  43F9 00002468            273  NUM_7       LEA     PRNT7,A1
00001326  60B8                     274              BRA     PRINT_NUM
00001328  43F9 0000246A            275  NUM_8       LEA     PRNT8,A1
0000132E  60B0                     276              BRA     PRINT_NUM
00001330  43F9 0000246C            277  NUM_9       LEA     PRNT9,A1
00001336  60A8                     278              BRA     PRINT_NUM
00001338  43F9 0000246E            279  NUM_A       LEA     PRNTA,A1
0000133E  60A0                     280              BRA     PRINT_NUM
00001340  43F9 00002470            281  NUM_B       LEA     PRNTB,A1
00001346  6098                     282              BRA     PRINT_NUM
00001348  43F9 00002472            283  NUM_C       LEA     PRNTC,A1
0000134E  6090                     284              BRA     PRINT_NUM
00001350  43F9 00002474            285  NUM_D       LEA     PRNTD,A1
00001356  6088                     286              BRA     PRINT_NUM
00001358  43F9 00002476            287  NUM_E       LEA     PRNTE,A1
0000135E  6080                     288              BRA     PRINT_NUM
00001360  43F9 00002478            289  NUM_F       LEA     PRNTF,A1
00001366  6000 FF78                290              BRA     PRINT_NUM
0000136A                           291  
0000136A                           292  
0000136A                           293  *-----------------------------------------------------------        
0000136A                           294  * Start of Disassembler
0000136A                           295  *-----------------------------------------------------------
0000136A                           296          *FOR DEBUGGING ONLY!!!
0000136A  207C 00007FC6            297          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
00001370  4286                     298  CLR_D6  CLR.L   D6
00001372  3C3C 0020                299          MOVE    #MAX_LINE,D6
00001376  43F9 00002594            300          LEA     NewLine,A1  *Loads NewLine into address register A1
0000137C  103C 000E                301          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001380  4E4F                     302          TRAP    #15         *Displays Message
00001382  6000 FC90                303          BRA     loop_1
00001386                           304          
00001386                           305  GRAB_NEXT_OP
00001386                           306          *Check and see if A0 == end of test address. If so, we need to end.
00001386  2E08                     307          MOVE.L  A0,D7
00001388  2479 00002438            308          MOVEA.L PROGEND,A2
0000138E  BE8A                     309          CMP.L   A2,D7       * Check and see if A0 == end of test address. 
00001390  6CDE                     310          BGE     CLR_D6      * Ask user if they want to do the disassembler again
00001392  0C86 00000002            311          CMPI.L  #02,D6      * Check if max line of instructions output on console is reached
00001398  6700 0032                312          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
0000139C  5306                     313  CONT_OP SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
0000139E                           314  
0000139E                           315          *Output a newline to console...        
0000139E  43F9 00002594            316          LEA     NewLine,A1  *Loads NewLine into address register A1
000013A4  103C 000E                317          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000013A8  4E4F                     318          TRAP    #15         *Displays Message
000013AA                           319  
000013AA                           320          *Output the address of this instruction to console...
000013AA  2808                     321          MOVE.L  A0,D4
000013AC  4EB8 1202                322          JSR     HEXASCIIREG
000013B0                           323          
000013B0                           324          *Output a tab (4 spaces) to console, just after the address...
000013B0  43F9 0000258D            325          LEA     Tab,A1  *Loads Tab into address register A1
000013B6  103C 000E                326          MOVE.B  #14,D0  *Moves the number 14 into data register D0
000013BA  4E4F                     327          TRAP    #15     *Displays Message
000013BC                           328          
000013BC                           329          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
000013BC                           330          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
000013BC                           331          *data that may be associated with the instruction.
000013BC                           332          *Post increment addr, A0 will point to the start of next instruction or will 
000013BC                           333          *point to the start of any immed/abso data with this current instruction
000013BC  4280                     334          CLR.L   D0
000013BE  3018                     335          MOVE.W  (A0)+,D0
000013C0                           336          *Copy the word data we just moved into D0 into D7. We are copying this data
000013C0                           337          *So we always have a copy of the WHOLE instruction somewhere
000013C0  4287                     338          CLR.L   D7
000013C2  3E00                     339          MOVE.W  D0,D7
000013C4                           340          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000013C4                           341          *four bits of the instruction. Once we have just the first four bits, we can
000013C4                           342          *begin to see which 'bucket'/category this instruction falls into. 
000013C4  E048                     343          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013C6  E848                     344          LSR.W   #$04,D0
000013C8                           345          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013C8                           346          *list of buckets until we find which one this instruction falls into.
000013C8  6000 006C                347          BRA     BUCKET_0000     * Start with 0000
000013CC                           348  
000013CC                           349  
000013CC                           350  *-----------------------------------------------------------        
000013CC                           351  * Question Prompts
000013CC                           352  *-----------------------------------------------------------        
000013CC  43F9 00002388            353  CONT_Q      LEA     QUES_CONT,A1
000013D2  303C 000E                354              MOVE    #14,D0
000013D6  4E4F                     355              TRAP    #15
000013D8  43F9 0000243C            356              LEA     CONT,A1     *Need to store Y/N
000013DE  303C 0002                357              MOVE    #2,D0
000013E2  4E4F                     358              TRAP    #15
000013E4  0C01 0001                359              CMPI.B  #01,D1
000013E8  6600 FD4E                360              BNE     INVALID1
000013EC  0C39 0059 0000243C       361              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013F4  6600 000A                362              BNE     CHECK_Y
000013F8  4286                     363              CLR.L   D6
000013FA  3C3C 0020                364              MOVE    #MAX_LINE,D6    *Resets counter
000013FE  609C                     365              BRA     CONT_OP
00001400  0C11 0079                366  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
00001404  6600 000A                367              BNE     CHECK_N
00001408  4286                     368              CLR.L   D6
0000140A  3C3C 0020                369              MOVE    #MAX_LINE,D6    *Resets counter
0000140E  608C                     370              BRA     CONT_OP
00001410  0C11 004E                371  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001414  6700 FBFE                372              BEQ     loop_1
00001418  0C11 006E                373              CMPI.B  #$6E,(A1)   *Checks for lowercase n
0000141C  6700 FBF6                374              BEQ     loop_1      
00001420                           375  
00001420  163C 0000                376  INV2        MOVE.B  #0,D3       *Reset bad flag
00001424  303C 0000                377              MOVE    #0,D0       *Prints invalid command msg if not found
00001428  43F9 000025AA            378              LEA     INV_MSG,A1
0000142E  303C 000E                379              MOVE    #14,D0
00001432  4E4F                     380              TRAP    #15
00001434  6096                     381              BRA     CONT_Q
00001436                           382  
00001436                           383  *-----------------------------------------------------------        
00001436                           384  * Bucket 0000:
00001436                           385  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
00001436                           386  *                   BCHG(dynamic) | BCHG (static) | CMPI----
00001436                           387  *-----------------------------------------------------------
00001436                           388  BUCKET_0000
00001436  =00000000                389  BUCKET0000_BITS EQU $0
00001436  4281                     390          CLR.L   D1
00001438                           391          *Load the first 4 bits (really a byte) of BUCKET0 into D1
00001438  123C 0000                392          MOVE.B  #BUCKET0000_BITS,D1
0000143C                           393          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0000. 
0000143C                           394          *If equal, continue decoding. If not, branch to next bucket.
0000143C  B200                     395          CMP.B   D0,D1
0000143E  6600 0344                396          BNE     BUCKET_0001
00001442                           397  
00001442                           398          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001442                           399          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001442  3007                     400          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001444  0800 0008                401          BTST.L  #$08,D0
00001448  6600 01A4                402          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to IS_BCHG_D
0000144C                           403          
0000144C                           404          *Now we can check bits 11-8 in the instruction and branch to different op-codes
0000144C                           405          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
0000144C  E048                     406          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
0000144E  0880 0004                407          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001452  0880 0005                408          BCLR.L  #$05,D0
00001456  0880 0006                409          BCLR.L  #$06,D0
0000145A  0880 0007                410          BCLR.L  #$07,D0
0000145E                           411          
0000145E                           412          *Perform compares with these 4 bits to see which specific instruction it is.
0000145E  B03C 0006                413          CMP.B   #$06,D0 *Is this an ADDI?
00001462  6700 0028                414          BEQ     IS_ADDI
00001466  B03C 0002                415          CMP.B   #$02,D0 *Is this an ANDI?
0000146A  6700 0096                416          BEQ     IS_ANDI
0000146E  B03C 000A                417          CMP.B   #$0A,D0 *Is this an EORI?
00001472  6700 0104                418          BEQ     IS_EORI
00001476  B03C 0008                419          CMP.B   #$08,D0 *Is this a BCHG(static)?
0000147A  6700 0210                420          BEQ     IS_BCHG_S
0000147E  B03C 000C                421          CMP.B   #$0C,D0 *Is this a CMPI?
00001482  6700 028A                422          BEQ     IS_CMPI
00001486                           423          
00001486                           424          *If we get through all of the compares without finding the specific instruction,
00001486                           425          *then this instruction is either not in our list of OP CODES to decode, or is an
00001486                           426          *invalid instruction/syntax.
00001486  4EF9 00001EBC            427          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
0000148C                           428          
0000148C                           429          
0000148C                           430  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
0000148C                           431  IS_ADDI
0000148C                           432          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000148C                           433          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000148C  4281                     434          CLR.L   D1
0000148E  3207                     435          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001490  C27C 00C0                436          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001494  EC09                     437          LSR.B   #$06,D1     *Shift the size bits into LSB
00001496                           438          
00001496  B23C 0003                439          CMP.B   #$03,D1     *Compare the size bits to $3
0000149A  6700 0A20                440          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000149E                           441          
0000149E                           442          *Output 'ADDI' to console...
0000149E  43F9 0000247A            443          LEA     ADDI,A1     *Loads ADDI into address register A1
000014A4  103C 000E                444          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014A8  4E4F                     445          TRAP    #15         *Displays Message
000014AA                           446          
000014AA                           447          
000014AA                           448          *Should have a valid ADDI op code. Set data up for EA.
000014AA                           449          
000014AA                           450          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014AA  4282                     451          CLR.L   D2
000014AC  3407                     452          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014AE  C47C 0038                453          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000014B2  E60A                     454          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000014B4                           455                  
000014B4                           456          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000014B4  4283                     457          CLR.L   D3
000014B6  3607                     458          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000014B8  C67C 0007                459          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000014BC                           460          
000014BC  4EF9 000014C2            461          JMP     EA_ADDI
000014C2                           462  
000014C2                           463  EA_ADDI
000014C2                           464          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
000014C2                           465          *and D3 holds the EA register.
000014C2                           466          
000014C2                           467          *Determine how much data to read in, depending on the size of the operation
000014C2                           468          *output the size of the operation and the immediate data to console
000014C2  4EB9 00001910            469          JSR     WrapperSizeImmediate
000014C8                           470          
000014C8                           471          *manually output a comma here...
000014C8  43F9 00002592            472          LEA     Comma,A1        *Loads Comma into address register A1
000014CE  103C 000E                473          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014D2  4E4F                     474          TRAP    #15             *Displays Message        
000014D4                           475          
000014D4                           476          *Determine which EA mode and thus Register/Mem Address this instruction used
000014D4  B43C 0000                477          CMP.B   #$00,D2
000014D8  6700 055C                478          BEQ     DataRegMode *If EA mode is a data register, output that
000014DC                           479          
000014DC  B43C 0002                480          CMP.B   #$02,D2
000014E0  6700 0574                481          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014E4                           482          
000014E4  B43C 0003                483          CMP.B   #$03,D2
000014E8  6700 057C                484          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014EC                           485          
000014EC  B43C 0004                486          CMP.B   #$04,D2
000014F0  6700 0584                487          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014F4                           488          
000014F4  B43C 0007                489          CMP.B   #$07,D2
000014F8  6700 058C                490          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014FC                           491          
000014FC                           492          *If the ea mode isn't equal to any of these, it is an invalid EA
000014FC  4EF9 00001ECC            493          JMP     BADEACODE                               
00001502                           494          
00001502                           495  
00001502                           496  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
00001502                           497  IS_ANDI
00001502                           498          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001502                           499          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001502  4281                     500          CLR.L   D1
00001504  3207                     501          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001506  C27C 00C0                502          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000150A  EC09                     503          LSR.B   #$06,D1     *Shift the size bits into LSB
0000150C                           504          
0000150C  B23C 0003                505          CMP.B   #$03,D1     *Compare the size bits to $3
00001510  6700 09AA                506          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001514                           507          
00001514                           508          *Output 'ANDI' to console...
00001514  43F9 0000247F            509          LEA     ANDI,A1     *Loads ANDI into address register A1
0000151A  103C 000E                510          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000151E  4E4F                     511          TRAP    #15         *Displays Message
00001520                           512          
00001520                           513          
00001520                           514          *Should have a valid ANDI op code. Set data up for EA.
00001520                           515          
00001520                           516          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001520  4282                     517          CLR.L   D2
00001522  3407                     518          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001524  C47C 0038                519          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001528  E60A                     520          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000152A                           521                  
0000152A                           522          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000152A  4283                     523          CLR.L   D3
0000152C  3607                     524          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000152E  C67C 0007                525          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001532                           526          
00001532  4EF9 00001538            527          JMP     EA_ANDI
00001538                           528  
00001538                           529  EA_ANDI
00001538                           530          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
00001538                           531          *and D3 holds the EA register.
00001538                           532          
00001538                           533          *Determine how much data to read in, depending on the size of the operation
00001538                           534          *output the size of the operation and the immediate data to console
00001538  4EB9 00001910            535          JSR     WrapperSizeImmediate
0000153E                           536          
0000153E                           537          *manually output a comma here...
0000153E  43F9 00002592            538          LEA     Comma,A1        *Loads Comma into address register A1
00001544  103C 000E                539          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001548  4E4F                     540          TRAP    #15             *Displays Message        
0000154A                           541          
0000154A                           542          *Determine which EA mode and thus Register/Mem Address this instruction used
0000154A  B43C 0000                543          CMP.B   #$00,D2
0000154E  6700 04E6                544          BEQ     DataRegMode *If EA mode is a data register, output that
00001552                           545          
00001552  B43C 0002                546          CMP.B   #$02,D2
00001556  6700 04FE                547          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000155A                           548          
0000155A  B43C 0003                549          CMP.B   #$03,D2
0000155E  6700 0506                550          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001562                           551          
00001562  B43C 0004                552          CMP.B   #$04,D2
00001566  6700 050E                553          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000156A                           554          
0000156A  B43C 0007                555          CMP.B   #$07,D2
0000156E  6700 0516                556          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001572                           557          
00001572                           558          *If the ea mode isn't equal to any of these, it is an invalid EA
00001572  4EF9 00001ECC            559          JMP     BADEACODE
00001578                           560          
00001578                           561  
00001578                           562  *Now we know this instruction is exactly EORI, lets set everything up for EA.
00001578                           563  IS_EORI
00001578                           564          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001578                           565          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001578  4281                     566          CLR.L   D1
0000157A  3207                     567          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000157C  C27C 00C0                568          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001580  EC09                     569          LSR.B   #$06,D1     *Shift the size bits into LSB
00001582                           570          
00001582  B23C 0003                571          CMP.B   #$03,D1     *Compare the size bits to $3
00001586  6700 0934                572          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000158A                           573          
0000158A                           574          *Output 'EORI' to console...
0000158A  43F9 00002484            575          LEA     EORI,A1     *Loads EORI into address register A1
00001590  103C 000E                576          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001594  4E4F                     577          TRAP    #15         *Displays Message
00001596                           578          
00001596                           579          
00001596                           580          *Should have a valid EORI op code. Set data up for EA.
00001596                           581          
00001596                           582          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001596  4282                     583          CLR.L   D2
00001598  3407                     584          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000159A  C47C 0038                585          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000159E  E60A                     586          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000015A0                           587                  
000015A0                           588          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000015A0  4283                     589          CLR.L   D3
000015A2  3607                     590          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000015A4  C67C 0007                591          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000015A8                           592          
000015A8  4EF9 000015AE            593          JMP     EA_EORI
000015AE                           594  
000015AE                           595  EA_EORI
000015AE                           596          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
000015AE                           597          *and D3 holds the EA register.
000015AE                           598          
000015AE                           599          *Determine how much data to read in, depending on the size of the operation
000015AE                           600          *output the size of the operation and the immediate data to console
000015AE  4EB9 00001910            601          JSR     WrapperSizeImmediate
000015B4                           602          
000015B4                           603          *manually output a comma here...
000015B4  43F9 00002592            604          LEA     Comma,A1        *Loads Comma into address register A1
000015BA  103C 000E                605          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015BE  4E4F                     606          TRAP    #15             *Displays Message        
000015C0                           607          
000015C0                           608          *Determine which EA mode and thus Register/Mem Address this instruction used
000015C0  B43C 0000                609          CMP.B   #$00,D2
000015C4  6700 0470                610          BEQ     DataRegMode *If EA mode is a data register, output that
000015C8                           611          
000015C8  B43C 0002                612          CMP.B   #$02,D2
000015CC  6700 0488                613          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015D0                           614          
000015D0  B43C 0003                615          CMP.B   #$03,D2
000015D4  6700 0490                616          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015D8                           617          
000015D8  B43C 0004                618          CMP.B   #$04,D2
000015DC  6700 0498                619          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015E0                           620          
000015E0  B43C 0007                621          CMP.B   #$07,D2
000015E4  6700 04A0                622          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015E8                           623          
000015E8                           624          *If the ea mode isn't equal to any of these, it is an invalid EA
000015E8  4EF9 00001ECC            625          JMP     BADEACODE
000015EE                           626  
000015EE                           627  
000015EE                           628  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015EE                           629  *everything up for EA, if is a legit instruction.
000015EE                           630  IS_BCHG_D
000015EE                           631          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015EE                           632          *invalid, branch to BADOPCODE
000015EE  3007                     633          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015F0  0800 0007                634          BTST.L  #$07,D0
000015F4  6600 08C6                635          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015F8  0800 0006                636          BTST.L  #$06,D0
000015FC  6700 08BE                637          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
00001600                           638          
00001600                           639          *Output 'BCHG' to console...
00001600  43F9 00002489            640          LEA     BCHG,A1         *Loads BCHG into address register A1
00001606  103C 000E                641          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000160A  4E4F                     642          TRAP    #15             *Displays Message
0000160C                           643                  
0000160C                           644                  
0000160C                           645          *Should have a valid BCHG op code. Set data up for EA.
0000160C                           646  
0000160C                           647          *Set D1 to the EA source register located in bits 11-9 of the instruction
0000160C  4281                     648          CLR.L   D1
0000160E  3207                     649          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001610  C27C 0E00                650          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
00001614  E049                     651          LSR.W   #$08,D1     *Shift the EA source register bits into LSB
00001616  E249                     652          LSR.W   #$01,D1
00001618                           653  
00001618                           654          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001618  4282                     655          CLR.L   D2
0000161A  3407                     656          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000161C  C47C 0038                657          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001620  E60A                     658          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001622                           659                  
00001622                           660          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001622  4283                     661          CLR.L   D3
00001624  3607                     662          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001626  C67C 0007                663          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000162A                           664  
0000162A  4EF9 00001630            665          JMP     EA_BCHG_D
00001630                           666  
00001630                           667  EA_BCHG_D
00001630                           668          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001630                           669          *D2 holds the EA mode, and D3 holds the EA register.
00001630                           670          
00001630                           671          *Determine the size of this BCHG instruction. Output the correct size...
00001630  4EB9 000019DE            672          JSR     BCHGSizeHelper
00001636                           673          
00001636                           674          *output the source register to console, flag D6 with a 1 so we come back...
00001636  48E7 0200                675          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
0000163A  48E7 1000                676          MOVEM.L D3,-(SP)    *Push EA destination register into stack            
0000163E  1C3C 0001                677          MOVE.B  #$01,D6     *Flag D6
00001642  1601                     678          MOVE.B  D1,D3       *Move source register into D3
00001644  4EB9 00001A36            679          JSR     DataRegMode
0000164A  4CDF 0008                680          MOVEM.L (SP)+,D3    *Pull destination register back into D3
0000164E  4CDF 0040                681          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001652                           682          
00001652                           683          *manually output a comma here...
00001652  43F9 00002592            684          LEA     Comma,A1        *Loads Comma into address register A1
00001658  103C 000E                685          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000165C  4E4F                     686          TRAP    #15             *Displays Message
0000165E                           687          
0000165E                           688          *Determine which EA mode and thus Register/Mem Address this instruction used
0000165E  B43C 0000                689          CMP.B   #$00,D2
00001662  6700 03D2                690          BEQ     DataRegMode *If EA mode is a data register, output that
00001666                           691          
00001666  B43C 0002                692          CMP.B   #$02,D2
0000166A  6700 03EA                693          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000166E                           694          
0000166E  B43C 0003                695          CMP.B   #$03,D2
00001672  6700 03F2                696          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001676                           697          
00001676  B43C 0004                698          CMP.B   #$04,D2
0000167A  6700 03FA                699          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000167E                           700          
0000167E  B43C 0007                701          CMP.B   #$07,D2
00001682  6700 0402                702          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001686                           703          
00001686                           704          *If the ea mode isn't equal to any of these, it is an invalid EA
00001686  4EF9 00001ECC            705          JMP     BADEACODE
0000168C                           706  
0000168C                           707  
0000168C                           708  *Found a possible BCHG(static) instruction. Verify its bit integrity and then set up
0000168C                           709  *everything up for EA, if is a legit instruction.
0000168C                           710  IS_BCHG_S
0000168C                           711          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
0000168C                           712          *invalid, branch to BADOPCODE
0000168C  3007                     713          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
0000168E  0800 0007                714          BTST.L  #$07,D0
00001692  6600 0828                715          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
00001696  0800 0006                716          BTST.L  #$06,D0
0000169A  6700 0820                717          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
0000169E                           718          
0000169E                           719          *Output 'BCHG' to console...
0000169E  43F9 00002489            720          LEA     BCHG,A1         *Loads BCHG into address register A1
000016A4  103C 000E                721          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016A8  4E4F                     722          TRAP    #15             *Displays Message
000016AA                           723          
000016AA                           724          
000016AA                           725          *Should have a valid BCHG op code. Set data up for EA.
000016AA                           726          
000016AA                           727          *Move #$00 into D1, BCHG_S's immediate data is always in byte size
000016AA  4281                     728          CLR.L   D1
000016AC  323C 0000                729          MOVE.W  #$00,D1
000016B0                           730  
000016B0                           731          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000016B0  4282                     732          CLR.L   D2
000016B2  3407                     733          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000016B4  C47C 0038                734          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000016B8  E60A                     735          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000016BA                           736                  
000016BA                           737          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000016BA  4283                     738          CLR.L   D3
000016BC  3607                     739          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000016BE  C67C 0007                740          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000016C2                           741  
000016C2  4EF9 000016C8            742          JMP     EA_BCHG_S
000016C8                           743  
000016C8                           744  EA_BCHG_S
000016C8                           745          *Decode the ea bits of BCHG(static). Assuming D2 holds the EA mode, and 
000016C8                           746          *D3 holds the EA register.
000016C8                           747          
000016C8                           748          *Determine the size of this BCHG instruction. Output the correct size...
000016C8  4EB9 000019DE            749          JSR     BCHGSizeHelper                
000016CE                           750          
000016CE                           751          *output the immediate data of this operation to console (always byte)...
000016CE  4EB9 00001A0E            752          JSR     BCHGImmediate
000016D4                           753          
000016D4                           754          *manually output a comma here...
000016D4  43F9 00002592            755          LEA     Comma,A1        *Loads Comma into address register A1
000016DA  103C 000E                756          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016DE  4E4F                     757          TRAP    #15             *Displays Message
000016E0                           758          
000016E0                           759          *Determine which EA mode and thus Register/Mem Address this instruction used
000016E0  B43C 0000                760          CMP.B   #$00,D2
000016E4  6700 0350                761          BEQ     DataRegMode *If EA mode is a data register, output that
000016E8                           762          
000016E8  B43C 0002                763          CMP.B   #$02,D2
000016EC  6700 0368                764          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016F0                           765          
000016F0  B43C 0003                766          CMP.B   #$03,D2
000016F4  6700 0370                767          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016F8                           768          
000016F8  B43C 0004                769          CMP.B   #$04,D2
000016FC  6700 0378                770          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001700                           771          
00001700  B43C 0007                772          CMP.B   #$07,D2
00001704  6700 0380                773          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001708                           774          
00001708                           775          *If the ea mode isn't equal to any of these, it is an invalid EA
00001708  4EF9 00001ECC            776          JMP     BADEACODE
0000170E                           777  
0000170E                           778  
0000170E                           779  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
0000170E                           780  IS_CMPI
0000170E                           781          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000170E                           782          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000170E  4281                     783          CLR.L   D1
00001710  3207                     784          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001712  C27C 00C0                785          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001716  EC09                     786          LSR.B   #$06,D1     *Shift the size bits into LSB
00001718                           787          
00001718  B23C 0003                788          CMP.B   #$03,D1     *Compare the size bits to $3
0000171C  6700 079E                789          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001720                           790          
00001720                           791          *Output 'CMPI' to console...
00001720  43F9 0000248E            792          LEA     CMPI,A1     *Loads CMPI into address register A1
00001726  103C 000E                793          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000172A  4E4F                     794          TRAP    #15         *Displays Message
0000172C                           795          
0000172C                           796          
0000172C                           797          *Should have a valid CMPI op code. Set data up for EA.
0000172C                           798          
0000172C                           799          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000172C  4282                     800          CLR.L   D2
0000172E  3407                     801          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001730  C47C 0038                802          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001734  E60A                     803          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001736                           804                  
00001736                           805          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001736  4283                     806          CLR.L   D3
00001738  3607                     807          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000173A  C67C 0007                808          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000173E                           809          
0000173E  4EF9 00001744            810          JMP     EA_CMPI
00001744                           811  
00001744                           812  EA_CMPI
00001744                           813          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
00001744                           814          *and D3 holds the EA register.
00001744                           815          
00001744                           816          *Determine how much data to read in, depending on the size of the operation
00001744                           817          *output the size of the operation and the immediate data to console
00001744  4EB9 00001910            818          JSR     WrapperSizeImmediate
0000174A                           819          
0000174A                           820          *manually output a comma here...
0000174A  43F9 00002592            821          LEA     Comma,A1        *Loads Comma into address register A1
00001750  103C 000E                822          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001754  4E4F                     823          TRAP    #15             *Displays Message
00001756                           824          
00001756                           825          *Determine which EA mode and thus Register/Mem Address this instruction used
00001756  B43C 0000                826          CMP.B   #$00,D2
0000175A  6700 02DA                827          BEQ     DataRegMode *If EA mode is a data register, output that
0000175E                           828          
0000175E  B43C 0002                829          CMP.B   #$02,D2
00001762  6700 02F2                830          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001766                           831          
00001766  B43C 0003                832          CMP.B   #$03,D2
0000176A  6700 02FA                833          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000176E                           834          
0000176E  B43C 0004                835          CMP.B   #$04,D2
00001772  6700 0302                836          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001776                           837          
00001776  B43C 0007                838          CMP.B   #$07,D2
0000177A  6700 030A                839          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000177E                           840          
0000177E                           841          *If the ea mode isn't equal to any of these, it is an invalid EA
0000177E  4EF9 00001ECC            842          JMP     BADEACODE
00001784                           843        
00001784                           844    
00001784                           845  *STARTS WITH 0001, MOVE.B-----------------------------------
00001784                           846  BUCKET_0001
00001784  =00000001                847  BUCKET0001_BITS EQU $1
00001784                           848          
00001784                           849          *some code...
00001784                           850  
00001784                           851  
00001784                           852  *STARTS WITH 0010, MOVE.L-----------------------------------
00001784                           853  BUCKET_0010
00001784  =00000002                854  BUCKET0010_BITS EQU $2
00001784                           855  
00001784                           856          *some code...
00001784                           857  
00001784                           858  
00001784                           859  *STARTS WITH 0011, MOVE.W-----------------------------------
00001784                           860  BUCKET_0011
00001784  =00000003                861  BUCKET0011_BITS EQU $3
00001784                           862  
00001784                           863          *some code...
00001784                           864  
00001784                           865  
00001784                           866  *-----------------------------------------------------------        
00001784                           867  * Bucket 0100:
00001784                           868  * STARTS WITH 0100, MOVEM | MULS(L)-------------------------
00001784                           869  *                   LEA | CLR | JSR | RTS-------------------
00001784                           870  *-----------------------------------------------------------
00001784                           871  BUCKET_0100
00001784  =00000004                872  BUCKET0100_BITS EQU $4
00001784  4281                     873          CLR.L   D1
00001786                           874          *Load the first 4 bits (really a byte) of BUCKET0 into D1
00001786  123C 0004                875          MOVE.B  #BUCKET0100_BITS,D1
0000178A                           876          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0100. 
0000178A                           877          *If equal, continue decoding. If not, branch to next bucket.
0000178A  B200                     878          CMP.B   D0,D1
0000178C  6600 017C                879          BNE     BUCKET_0101
00001790                           880  
00001790                           881          *Test the 8th bit in this instruction, if it is 1, then it is an LEA 
00001790                           882          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1.
00001790  3007                     883          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001792  0800 0008                884          BTST.L  #$08,D0
00001796  6600 0038                885          BNE     IS_LEA  *If the zbit was 0 (the 8th bit is 1), branch to IS_LEA
0000179A                           886  
0000179A                           887          *JSR/RTS in this bucket can only be determined by only bits 11-6
0000179A  C07C 0FC0                888          AND.W   #$0FC0,D0   *Mask out everything but bits 11-6
0000179E  EC48                     889          LSR.W   #$06,D0     *Move bits 11-6 into LSB position
000017A0                           890          
000017A0                           891          *Check bits 11-6 in the instruction and branch to different either JSR or RTS 
000017A0                           892          *depending on what the bits equal
000017A0  B03C 003A                893          CMP.B   #$3A,D0 *Is this a JSR?
000017A4  6700 010C                894          BEQ     IS_JSR
000017A8  B03C 0039                895          CMP.B   #$39,D0 *Is this a RTS?
000017AC  6700 013C                896          BEQ     IS_RTS
000017B0                           897  
000017B0                           898          *Now we can use only bits 11-8 and branch to different op-codes only needing these
000017B0                           899          *four bits to be unambiguous
000017B0  E448                     900          LSR.W   #$02,D0 *Shift the 7-6 bits out, leaving only 11-8
000017B2  B03C 0008                901          CMP.B   #$08,D0 *Is this a MOVEM(RegToMem)?
000017B6  6700 0018                902          BEQ     IS_MOVEM_RegToMem
000017BA  B03C 000C                903          CMP.B   #$0C,D0 *Is this a MOVEM(MemToReg)?
000017BE  6700 0010                904          BEQ     IS_MOVEM_MemToReg
000017C2  B03C 0002                905          CMP.B   #$02,D0 *Is this a CLR?
000017C6  6700 0080                906          BEQ     IS_CLR
000017CA                           907          
000017CA                           908          *If we get through all of the compares without finding the specific instruction,
000017CA                           909          *then this instruction is either not in our list of OP CODES to decode, or is an
000017CA                           910          *invalid instruction/syntax.
000017CA  4EF9 00001EBC            911          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000017D0                           912  
000017D0                           913  
000017D0                           914  *Now we know this instruction is exactly MOVEM(RegToMem), lets set everything up for EA.
000017D0                           915  IS_MOVEM_RegToMem
000017D0                           916  
000017D0                           917  EA_MOVEM_RegToMem
000017D0                           918  
000017D0                           919  
000017D0                           920  *Now we know this instruction is exactly MOVEM(MemToReg), lets set everything up for EA.
000017D0                           921  IS_MOVEM_MemToReg
000017D0                           922  
000017D0                           923  EA_MOVEM_MemToReg
000017D0                           924  
000017D0                           925  
000017D0                           926  *Now we know this instruction is exactly LEA, lets set everything up for EA.
000017D0                           927  IS_LEA
000017D0                           928          *Check bits 7 and 6, these should be 1 and 1. If not, this instruction is
000017D0                           929          *invalid, branch to BADOPCODE
000017D0  3007                     930          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000017D2  0800 0007                931          BTST.L  #$07,D0
000017D6  6700 06E4                932          BEQ     BADOPCODE  *If the zbit was 1 (the 7th bit is 0), branch to BADOPCODE
000017DA  0800 0006                933          BTST.L  #$06,D0
000017DE  6700 06DC                934          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000017E2                           935          
000017E2                           936          *Output 'LEA' to console...
000017E2  43F9 0000249E            937          LEA     LEA,A1         *Loads LEA into address register A1
000017E8  103C 000E                938          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000017EC  4E4F                     939          TRAP    #15             *Displays Message
000017EE                           940          
000017EE                           941          
000017EE                           942          *Should have a valid LEA op code. Set data up for EA.      
000017EE                           943          
000017EE                           944          *Set D1 to the EA destination register located in bits 11-9 of the instruction
000017EE  4281                     945          CLR.L   D1
000017F0  3207                     946          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000017F2  C27C 0E00                947          AND.W   #$0E00,D1   *Mask out everything but the EA destination register bits
000017F6  E049                     948          LSR.W   #$08,D1     *Shift the EA destination register bits into LSB
000017F8  E249                     949          LSR.W   #$01,D1
000017FA                           950  
000017FA                           951          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000017FA  4282                     952          CLR.L   D2
000017FC  3407                     953          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000017FE  C47C 0038                954          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001802  E60A                     955          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001804                           956                  
00001804                           957          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001804  4283                     958          CLR.L   D3
00001806  3607                     959          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001808  C67C 0007                960          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000180C                           961  
0000180C  4EF9 00001812            962          JMP     EA_LEA       
00001812                           963  
00001812                           964  EA_LEA
00001812                           965          *Decode the ea bits of LEA. Assuming D1 holds the destination register, D2 holds the
00001812                           966          *EA mode, and D3 holds the EA register.
00001812                           967          
00001812                           968          *Determine which EA mode and thus Register/Mem Address this instruction used
00001812  48E7 0200                969          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
00001816  1C3C 0001                970          MOVE.B  #$01,D6     *Flag D6 so that we come back
0000181A                           971          
0000181A  B43C 0002                972          CMP.B   #$02,D2
0000181E  6700 0202                973          BEQ     LEA_AddrIndirectWrapper *If EA mode is an addr indirect, output that
00001822                           974          
00001822  B43C 0007                975          CMP.B   #$07,D2
00001826  6700 0204                976          BEQ     LEA_AddrAbsoluteWrapper *If EA mode is an addr absolute word/long, output that
0000182A                           977  
0000182A                           978  EA_LEA_WrapperEnd        
0000182A  4CDF 0040                979          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
0000182E                           980                  
0000182E                           981          *manually output a comma here...
0000182E  43F9 00002592            982          LEA     Comma,A1        *Loads Comma into address register A1
00001834  103C 000E                983          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001838  4E4F                     984          TRAP    #15             *Displays Message
0000183A                           985          
0000183A                           986          *output the destination address register to console
0000183A                           987          *Overwrite the EA register with destination register (no longer need D3 at this point)
0000183A  1601                     988          MOVE.B  D1,D3
0000183C  4EB9 00001A46            989          JSR     AddrRegMode
00001842                           990          
00001842                           991          *If the ea mode isn't equal to any of these, it is an invalid EA
00001842  4EF9 00001ECC            992          JMP     BADEACODE
00001848                           993          
00001848                           994          
00001848                           995  *Now we know this instruction is exactly CLR, lets set everything up for EA.
00001848                           996  IS_CLR
00001848                           997          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001848                           998          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001848  4281                     999          CLR.L   D1
0000184A  3207                    1000          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000184C  C27C 00C0               1001          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001850  EC09                    1002          LSR.B   #$06,D1     *Shift the size bits into LSB
00001852                          1003          
00001852  B23C 0003               1004          CMP.B   #$03,D1     *Compare the size bits to $3
00001856  6700 0664               1005          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000185A                          1006          
0000185A                          1007          *Output 'CLR' to console...
0000185A  43F9 000024A8           1008          LEA     CLR,A1      *Loads CLR into address register A1
00001860  103C 000E               1009          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001864  4E4F                    1010          TRAP    #15         *Displays Message
00001866                          1011          
00001866                          1012          
00001866                          1013          *Should have a valid CLR op code. Set data up for EA.
00001866                          1014          
00001866                          1015          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001866  4282                    1016          CLR.L   D2
00001868  3407                    1017          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000186A  C47C 0038               1018          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000186E  E60A                    1019          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001870                          1020                  
00001870                          1021          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001870  4283                    1022          CLR.L   D3
00001872  3607                    1023          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001874  C67C 0007               1024          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001878                          1025          
00001878  4EF9 0000187E           1026          JMP     EA_CLR
0000187E                          1027  
0000187E                          1028  EA_CLR
0000187E                          1029          *Decode the ea bits of CLR. Assuming D1 holds the size, D2 holds the EA mode,
0000187E                          1030          *and D3 holds the EA register.
0000187E                          1031          
0000187E                          1032          *Determine how much data to read in, depending on the size of the operation
0000187E                          1033          *output the size of the operation and the immediate data to console
0000187E  4EB9 00001992           1034          JSR     WrapperSize       
00001884                          1035          
00001884                          1036          *Determine which EA mode and thus Register/Mem Address this instruction used
00001884  B43C 0000               1037          CMP.B   #$00,D2
00001888  6700 01AC               1038          BEQ     DataRegMode *If EA mode is a data register, output that
0000188C                          1039          
0000188C  B43C 0002               1040          CMP.B   #$02,D2
00001890  6700 01C4               1041          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001894                          1042          
00001894  B43C 0003               1043          CMP.B   #$03,D2
00001898  6700 01CC               1044          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000189C                          1045          
0000189C  B43C 0004               1046          CMP.B   #$04,D2
000018A0  6700 01D4               1047          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000018A4                          1048          
000018A4  B43C 0007               1049          CMP.B   #$07,D2
000018A8  6700 01DC               1050          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000018AC                          1051          
000018AC                          1052          *If the ea mode isn't equal to any of these, it is an invalid EA
000018AC  4EF9 00001ECC           1053          JMP     BADEACODE
000018B2                          1054  
000018B2                          1055  
000018B2                          1056  *Now we know this instruction is exactly JSR, lets set everything up for EA.
000018B2                          1057  IS_JSR        
000018B2                          1058          *Output 'JSR' to console...
000018B2  43F9 000024AC           1059          LEA     JSR,A1      *Loads JSR into address register A1
000018B8  103C 000E               1060          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018BC  4E4F                    1061          TRAP    #15         *Displays Message
000018BE                          1062          
000018BE                          1063          
000018BE                          1064          *Should have a valid JSR op code. Set data up for EA.
000018BE                          1065          
000018BE                          1066          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000018BE  4282                    1067          CLR.L   D2
000018C0  3407                    1068          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000018C2  C47C 0038               1069          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000018C6  E60A                    1070          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000018C8                          1071                  
000018C8                          1072          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000018C8  4283                    1073          CLR.L   D3
000018CA  3607                    1074          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000018CC  C67C 0007               1075          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000018D0                          1076          
000018D0  4EF8 187E               1077          JMP     EA_CLR
000018D4                          1078  
000018D4                          1079  EA_JSR
000018D4                          1080          *Decode the ea bits of JSR. Assuming D1 holds the size, D2 holds the EA mode,
000018D4                          1081          *and D3 holds the EA register.               
000018D4                          1082          
000018D4                          1083          *Determine which EA mode and thus Register/Mem Address this instruction used        
000018D4  B43C 0002               1084          CMP.B   #$02,D2
000018D8  6700 017C               1085          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000018DC                          1086                         
000018DC  B43C 0007               1087          CMP.B   #$07,D2
000018E0  6700 01A4               1088          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000018E4                          1089          
000018E4                          1090          *If the ea mode isn't equal to any of these, it is an invalid EA
000018E4  4EF9 00001ECC           1091          JMP     BADEACODE
000018EA                          1092  
000018EA                          1093  
000018EA                          1094  *Now we know this instruction is exactly RTS, lets set everything up for EA.
000018EA                          1095  IS_RTS
000018EA                          1096          *Verify bits 5-0 of this instruction. If its not equal to %11 0101, it is an
000018EA                          1097          *invalid op code        
000018EA  4282                    1098          CLR.L   D2
000018EC  3407                    1099          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000018EE  C47C 003F               1100          AND.W   #$003F,D2   *Mask out everything but bits 5-0
000018F2                          1101          
000018F2                          1102          *Bits 5-0 aren't equal to $35, bad op code
000018F2  B43C 0035               1103          CMP.B   #$35,D2
000018F6  6600 05C4               1104          BNE     BADOPCODE
000018FA                          1105  
000018FA                          1106          *Output 'RTS' to console...
000018FA  43F9 000024B6           1107          LEA     RTS,A1      *Loads RTS into address register A1
00001900  103C 000E               1108          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001904  4E4F                    1109          TRAP    #15         *Displays Message
00001906                          1110                          
00001906                          1111          *Should have a valid RTS op code. Note: No EA decoding is needed for RTS!        
00001906  4EF8 1386               1112          JMP     GRAB_NEXT_OP
0000190A                          1113  
0000190A                          1114  
0000190A                          1115  *STARTS WITH 0101, SUBQ-------------------------------------
0000190A                          1116  BUCKET_0101
0000190A  =00000005               1117  BUCKET0101_BITS EQU $5
0000190A                          1118  
0000190A                          1119          *some code...
0000190A                          1120  
0000190A                          1121  
0000190A                          1122  *STARTS WITH 0110, BCC--------------------------------------
0000190A                          1123  BUCKET_0110
0000190A  =00000006               1124  BUCKET0110_BITS EQU $6
0000190A                          1125  
0000190A                          1126          *some code...
0000190A                          1127  
0000190A                          1128  
0000190A                          1129  *STARTS WITH 1000, DIVU-------------------------------------
0000190A                          1130  BUCKET_1000
0000190A  =00000008               1131  BUCKET1000_BITS EQU $8
0000190A                          1132  
0000190A                          1133          *some code...
0000190A                          1134  
0000190A                          1135  
0000190A                          1136  *STARTS WITH 1001, SUBA-------------------------------------
0000190A                          1137  BUCKET_1001
0000190A  =00000009               1138  BUCKET1001_BITS EQU $9
0000190A                          1139  
0000190A                          1140          *some code...
0000190A                          1141  
0000190A                          1142  
0000190A                          1143  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
0000190A                          1144  BUCKET_1011
0000190A  =0000000B               1145  BUCKET1011_BITS EQU $B
0000190A                          1146  
0000190A                          1147          *some code...
0000190A                          1148  
0000190A                          1149  
0000190A                          1150  *STARTS WITH 1100, MULS(W) | AND----------------------------
0000190A                          1151  BUCKET_1100
0000190A  =0000000C               1152  BUCKET1100_BITS EQU $C
0000190A                          1153  
0000190A                          1154          *some code...
0000190A                          1155  
0000190A                          1156  
0000190A                          1157  *STARTS WITH 1101, ADD | ADDA-------------------------------
0000190A                          1158  BUCKET_1101
0000190A  =0000000D               1159  BUCKET1101_BITS EQU $D
0000190A                          1160  
0000190A                          1161          *some code...
0000190A                          1162  
0000190A                          1163  
0000190A                          1164  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
0000190A                          1165  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
0000190A                          1166  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
0000190A                          1167  BUCKET_1110
0000190A  =0000000E               1168  BUCKET1110_BITS EQU $E     
0000190A                          1169  
0000190A                          1170          *some code...
0000190A                          1171  
0000190A                          1172  
0000190A                          1173  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
0000190A                          1174  *for this disassembler, jump to BADOPCODE and let I/O take care of it
0000190A  4EF9 00001EBC           1175          JMP     BADOPCODE  
00001910                          1176          
00001910                          1177  
00001910                          1178  *-----------------------------------------------------------        
00001910                          1179  * EA operation size decoding functionality for immediate data
00001910                          1180  *-----------------------------------------------------------   
00001910                          1181  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001910                          1182  WrapperSizeImmediate
00001910  4284                    1183          CLR.L   D4
00001912                          1184          *Depending on the EA size, choose which size to decode
00001912  B23C 0000               1185          CMP.B   #$00,D1
00001916  6700 0014               1186          BEQ     ByteSizeImmediate
0000191A                          1187          
0000191A  B23C 0001               1188          CMP.B   #$01,D1
0000191E  6700 002E               1189          BEQ     WordSizeImmediate
00001922                          1190  
00001922  B23C 0002               1191          CMP.B   #$02,D1
00001926  6700 0048               1192          BEQ     LongSizeImmediate
0000192A                          1193          
0000192A                          1194  *Used to get back to what we were doing, after dealing with the specific size
0000192A                          1195  WrapperSizeImmediateEnd
0000192A  4E75                    1196          RTS
0000192C                          1197          
0000192C                          1198  ByteSizeImmediate
0000192C  3818                    1199          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
0000192E                          1200          
0000192E                          1201          *Output '.B' to console...
0000192E  43F9 000024C0           1202          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001934  103C 000E               1203          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001938  4E4F                    1204          TRAP    #15         *Displays Message
0000193A                          1205          
0000193A                          1206          *Output '#$' just before the immediate data
0000193A  43F9 00002597           1207          LEA     ShaBang,A1
00001940  103C 000E               1208          MOVE.B  #14,D0
00001944  4E4F                    1209          TRAP    #15  
00001946                          1210          
00001946                          1211          *output the immediate data to console with the hex-ascii converter
00001946  4EB8 11EA               1212          JSR     HEXASCII
0000194A                          1213                  
0000194A  4EF8 192A               1214          JMP     WrapperSizeImmediateEnd
0000194E                          1215                  
0000194E                          1216  WordSizeImmediate
0000194E  3818                    1217          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001950                          1218          
00001950                          1219          *Output '.W' to console...
00001950  43F9 000024C7           1220          LEA     WordSize,A1 *Loads WordSize into address register A1
00001956  103C 000E               1221          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000195A  4E4F                    1222          TRAP    #15         *Displays Message
0000195C                          1223          
0000195C                          1224          *Output '#$' just before the immediate data
0000195C  43F9 00002597           1225          LEA     ShaBang,A1
00001962  103C 000E               1226          MOVE.B  #14,D0
00001966  4E4F                    1227          TRAP    #15  
00001968                          1228          
00001968                          1229          *output the immediate data to console with the hex-ascii converter
00001968  4EB8 11EA               1230          JSR     HEXASCII
0000196C                          1231          
0000196C  4EF8 192A               1232          JMP     WrapperSizeImmediateEnd
00001970                          1233                  
00001970                          1234  LongSizeImmediate
00001970  2818                    1235          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
00001972                          1236          
00001972                          1237          *Output '.L' to console...
00001972  43F9 000024CE           1238          LEA     LongSize,A1 *Loads LongSize into address register A1
00001978  103C 000E               1239          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000197C  4E4F                    1240          TRAP    #15         *Displays Message
0000197E                          1241          
0000197E                          1242          *Output '#$' just before the immediate data
0000197E  43F9 00002597           1243          LEA     ShaBang,A1
00001984  103C 000E               1244          MOVE.B  #14,D0
00001988  4E4F                    1245          TRAP    #15  
0000198A                          1246          
0000198A                          1247          *output the immediate data to console with the hex-ascii converter
0000198A  4EB8 11EA               1248          JSR     HEXASCII
0000198E                          1249          
0000198E  4EF8 192A               1250          JMP     WrapperSizeImmediateEnd        
00001992                          1251  
00001992                          1252  
00001992                          1253  *-----------------------------------------------------------        
00001992                          1254  * EA operation size decoding functionality for non-immediate data. Used to figure out
00001992                          1255  * and output the size affix for a typical opcode.
00001992                          1256  *-----------------------------------------------------------   
00001992                          1257  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001992                          1258  WrapperSize
00001992  4284                    1259          CLR.L   D4
00001994                          1260          *Depending on the EA size, choose which size to decode
00001994  B23C 0000               1261          CMP.B   #$00,D1
00001998  6700 0014               1262          BEQ     ByteSizeOp
0000199C                          1263          
0000199C  B23C 0001               1264          CMP.B   #$01,D1
000019A0  6700 001C               1265          BEQ     WordSizeOp
000019A4                          1266  
000019A4  B23C 0002               1267          CMP.B   #$02,D1
000019A8  6700 0024               1268          BEQ     LongSizeOp
000019AC                          1269          
000019AC                          1270  *Used to get back to what we were doing, after dealing with the specific size
000019AC                          1271  WrapperSizeEnd
000019AC  4E75                    1272          RTS
000019AE                          1273          
000019AE                          1274  ByteSizeOp                
000019AE                          1275          *Output '.B' to console...
000019AE  43F9 000024C0           1276          LEA     ByteSize,A1 *Loads ByteSize into address register A1
000019B4  103C 000E               1277          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019B8  4E4F                    1278          TRAP    #15         *Displays Message                
000019BA                          1279                  
000019BA  4EF8 19AC               1280          JMP     WrapperSizeEnd
000019BE                          1281                  
000019BE                          1282  WordSizeOp
000019BE                          1283          *Output '.W' to console...
000019BE  43F9 000024C7           1284          LEA     WordSize,A1 *Loads WordSize into address register A1
000019C4  103C 000E               1285          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019C8  4E4F                    1286          TRAP    #15         *Displays Message               
000019CA                          1287          
000019CA  4EF8 19AC               1288          JMP     WrapperSizeEnd
000019CE                          1289                  
000019CE                          1290  LongSizeOp      
000019CE                          1291          *Output '.L' to console...
000019CE  43F9 000024CE           1292          LEA     LongSize,A1 *Loads LongSize into address register A1
000019D4  103C 000E               1293          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019D8  4E4F                    1294          TRAP    #15         *Displays Message                
000019DA                          1295          
000019DA  4EF8 19AC               1296          JMP     WrapperSizeEnd        
000019DE                          1297  
000019DE                          1298  
000019DE                          1299  *-----------------------------------------------------------        
000019DE                          1300  * BCHG Size decoding functionality
000019DE                          1301  *----------------------------------------------------------- 
000019DE                          1302  BCHGSizeHelper
000019DE                          1303          *Determine if the EA mode is a data register. If so, output '.L' to console...
000019DE  B43C 0000               1304          CMP.B   #$00,D2
000019E2  6700 000A               1305          BEQ     BCHGLongSize
000019E6                          1306          
000019E6                          1307          *If the EA mode isn't a data register, WE MUST output a '.B' to console...
000019E6  4EF9 000019FE           1308          JMP     BCHGByteSize
000019EC                          1309          
000019EC                          1310  *Used to get back to what we were doing, after dealing with the specific size
000019EC                          1311  BCHGSizeHelperEnd
000019EC  4E75                    1312          RTS  
000019EE                          1313          
000019EE                          1314  BCHGLongSize
000019EE                          1315          *Output '.L' to console...
000019EE  43F9 000024CE           1316          LEA     LongSize,A1 *Loads LongSize into address register A1
000019F4  103C 000E               1317          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019F8  4E4F                    1318          TRAP    #15         *Displays Message
000019FA                          1319  
000019FA  4EF8 19EC               1320          JMP     BCHGSizeHelperEnd
000019FE                          1321          
000019FE                          1322  BCHGByteSize
000019FE                          1323          *Output '.B' to console...
000019FE  43F9 000024C0           1324          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001A04  103C 000E               1325          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A08  4E4F                    1326          TRAP    #15         *Displays Message   
00001A0A                          1327          
00001A0A  4EF8 19EC               1328          JMP     BCHGSizeHelperEnd
00001A0E                          1329          
00001A0E                          1330  *Output the immediate data for a BCHG(static). Data is always byte size.
00001A0E                          1331  BCHGImmediate
00001A0E  3818                    1332          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word        
00001A10                          1333          
00001A10                          1334          *Output '#$' just before the immediate data
00001A10  43F9 00002597           1335          LEA     ShaBang,A1
00001A16  103C 000E               1336          MOVE.B  #14,D0
00001A1A  4E4F                    1337          TRAP    #15  
00001A1C                          1338          
00001A1C                          1339          *output the immediate data to console with the hex-ascii converter
00001A1C  4EB8 11EA               1340          JSR     HEXASCII
00001A20                          1341                  
00001A20  4E75                    1342          RTS        
00001A22                          1343  
00001A22                          1344  
00001A22                          1345  *-----------------------------------------------------------        
00001A22                          1346  * LEA Wrappers to conform to design of EA mode/register as destination operand. 
00001A22                          1347  * LEA is weird in that its EA mode/register is used as a source operand.
00001A22                          1348  *-----------------------------------------------------------        
00001A22                          1349  *This conforms LEA to the JSR requirement of AddrIndirectMode. JMPs back to LEA after the JSR.
00001A22                          1350  LEA_AddrIndirectWrapper
00001A22  4EB9 00001A56           1351          JSR     AddrIndirectMode
00001A28                          1352          
00001A28  4EF8 182A               1353          JMP     EA_LEA_WrapperEnd
00001A2C                          1354          
00001A2C                          1355  *This conforms LEA to the JSR requirement of AddrAbsoluteMode. JMPs back to LEA after the JSR.
00001A2C                          1356  LEA_AddrAbsoluteWrapper
00001A2C  4EB9 00001A86           1357          JSR     AddrAbsoluteMode
00001A32                          1358          
00001A32  4EF8 182A               1359          JMP     EA_LEA_WrapperEnd
00001A36                          1360  
00001A36                          1361  
00001A36                          1362  *-----------------------------------------------------------        
00001A36                          1363  * EA Mode/EA Register decoding functionality
00001A36                          1364  *-----------------------------------------------------------        
00001A36                          1365  DataRegMode
00001A36                          1366          *Depending on the EA Register, output a different register number
00001A36  4EB9 00001A96           1367          JSR     WrapperDataReg        
00001A3C                          1368          
00001A3C                          1369          *if this was called for a destination decoding then we are done decoding this        
00001A3C                          1370          *instruction, go get the next instruction
00001A3C  BC3C 0001               1371          CMP.B   #$01,D6
00001A40  6600 F944               1372          BNE     GRAB_NEXT_OP
00001A44                          1373          
00001A44                          1374          *else this was a source decoding, rts back to we can keep decoding
00001A44  4E75                    1375          RTS
00001A46                          1376  
00001A46                          1377  AddrRegMode
00001A46  4EB9 00001B58           1378          JSR     WrapperAddrReg
00001A4C                          1379          
00001A4C                          1380          *if this was called for a destination decoding then we are done decoding this        
00001A4C                          1381          *instruction, go get the next instruction
00001A4C  BC3C 0001               1382          CMP.B   #$01,D6
00001A50  6600 F934               1383          BNE     GRAB_NEXT_OP
00001A54                          1384          
00001A54                          1385          *else this was a source decoding, rts back to we can keep decoding
00001A54  4E75                    1386          RTS
00001A56                          1387  
00001A56                          1388  AddrIndirectMode
00001A56                          1389          *Depending on the EA Register, output a different register number
00001A56  4EB9 00001C1A           1390          JSR     WrapperAddrIndirect
00001A5C                          1391                          
00001A5C                          1392          *if this was called for a destination decoding then we are done decoding this        
00001A5C                          1393          *instruction, go get the next instruction
00001A5C  BC3C 0001               1394          CMP.B   #$01,D6
00001A60  6600 F924               1395          BNE     GRAB_NEXT_OP
00001A64                          1396          
00001A64                          1397          *else this was a source decoding, rts back to we can keep decoding
00001A64  4E75                    1398          RTS
00001A66                          1399  
00001A66                          1400  AddrIndirectPostMode
00001A66                          1401          *Depending on the EA Register, output a different register number
00001A66  4EB9 00001CDC           1402          JSR     WrapperAddrIndirectPost
00001A6C                          1403  
00001A6C                          1404          *if this was called for a destination decoding then we are done decoding this        
00001A6C                          1405          *instruction, go get the next instruction
00001A6C  BC3C 0001               1406          CMP.B   #$01,D6
00001A70  6600 F914               1407          BNE     GRAB_NEXT_OP
00001A74                          1408          
00001A74                          1409          *else this was a source decoding, rts back to we can keep decoding
00001A74  4E75                    1410          RTS
00001A76                          1411  
00001A76                          1412  AddrIndirectPreMode
00001A76                          1413          *Depending on the EA Register, output a different register number
00001A76  4EB9 00001D9E           1414          JSR     WrapperAddrIndirectPre
00001A7C                          1415  
00001A7C                          1416          *if this was called for a destination decoding then we are done decoding this        
00001A7C                          1417          *instruction, go get the next instruction
00001A7C  BC3C 0001               1418          CMP.B   #$01,D6
00001A80  6600 F904               1419          BNE     GRAB_NEXT_OP
00001A84                          1420          
00001A84                          1421          *else this was a source decoding, rts back to we can keep decoding
00001A84  4E75                    1422          RTS
00001A86                          1423  
00001A86                          1424  AddrAbsoluteMode
00001A86                          1425          *Depending on the EA Register, output a different register number
00001A86  4EB9 00001E60           1426          JSR     WrapperAddrAbsolute        
00001A8C                          1427  
00001A8C                          1428          *if this was called for a destination decoding then we are done decoding this        
00001A8C                          1429          *instruction, go get the next instruction
00001A8C  BC3C 0001               1430          CMP.B   #$01,D6
00001A90  6600 F8F4               1431          BNE     GRAB_NEXT_OP
00001A94                          1432          
00001A94                          1433          *else this was a source decoding, rts back to we can keep decoding
00001A94  4E75                    1434          RTS
00001A96                          1435          
00001A96                          1436  ImmediateDataMode
00001A96                          1437          *some code        
00001A96                          1438          
00001A96                          1439          
00001A96                          1440  *-----------------------------------------------------------        
00001A96                          1441  * Output logic for all Data Registers (0-7)
00001A96                          1442  *-----------------------------------------------------------
00001A96                          1443  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001A96                          1444  WrapperDataReg
00001A96                          1445          *Depending on the EA destination register, output a different register number
00001A96  B63C 0000               1446          CMP.B   #$00,D3
00001A9A  6700 003C               1447          BEQ     DataReg0
00001A9E                          1448          
00001A9E  B63C 0001               1449          CMP.B   #$01,D3
00001AA2  6700 0044               1450          BEQ     DataReg1
00001AA6                          1451          
00001AA6  B63C 0002               1452          CMP.B   #$02,D3
00001AAA  6700 004C               1453          BEQ     DataReg2
00001AAE                          1454          
00001AAE  B63C 0003               1455          CMP.B   #$03,D3
00001AB2  6700 0054               1456          BEQ     DataReg3
00001AB6                          1457          
00001AB6  B63C 0004               1458          CMP.B   #$04,D3
00001ABA  6700 005C               1459          BEQ     DataReg4
00001ABE                          1460          
00001ABE  B63C 0005               1461          CMP.B   #$05,D3
00001AC2  6700 0064               1462          BEQ     DataReg5
00001AC6                          1463          
00001AC6  B63C 0006               1464          CMP.B   #$06,D3
00001ACA  6700 006C               1465          BEQ     DataReg6
00001ACE                          1466          
00001ACE  B63C 0007               1467          CMP.B   #$07,D3
00001AD2  6700 0074               1468          BEQ     DataReg7        
00001AD6                          1469  
00001AD6                          1470  *Used to get back to 'DataRegMode', after dealing with the specific register
00001AD6                          1471  WrapperDataRegEnd
00001AD6  4E75                    1472          RTS
00001AD8                          1473  
00001AD8                          1474  DataReg0
00001AD8                          1475          *Output the specific data register...
00001AD8  43F9 000024D5           1476          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
00001ADE  103C 000E               1477          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001AE2  4E4F                    1478          TRAP    #15             *Displays Message   
00001AE4                          1479          
00001AE4  4EF8 1AD6               1480          JMP     WrapperDataRegEnd
00001AE8                          1481  
00001AE8                          1482  DataReg1
00001AE8  43F9 000024D8           1483          LEA     OutDataReg1,A1
00001AEE  103C 000E               1484          MOVE.B  #14,D0
00001AF2  4E4F                    1485          TRAP    #15
00001AF4                          1486          
00001AF4  4EF8 1AD6               1487          JMP     WrapperDataRegEnd
00001AF8                          1488  
00001AF8                          1489  DataReg2
00001AF8  43F9 000024DB           1490          LEA     OutDataReg2,A1
00001AFE  103C 000E               1491          MOVE.B  #14,D0
00001B02  4E4F                    1492          TRAP    #15
00001B04                          1493  
00001B04  4EF8 1AD6               1494          JMP     WrapperDataRegEnd
00001B08                          1495      
00001B08                          1496  DataReg3
00001B08  43F9 000024DE           1497          LEA     OutDataReg3,A1
00001B0E  103C 000E               1498          MOVE.B  #14,D0
00001B12  4E4F                    1499          TRAP    #15
00001B14                          1500  
00001B14  4EF8 1AD6               1501          JMP     WrapperDataRegEnd
00001B18                          1502          
00001B18                          1503  DataReg4
00001B18  43F9 000024E1           1504          LEA     OutDataReg4,A1
00001B1E  103C 000E               1505          MOVE.B  #14,D0
00001B22  4E4F                    1506          TRAP    #15
00001B24                          1507  
00001B24  4EF8 1AD6               1508          JMP     WrapperDataRegEnd
00001B28                          1509                 
00001B28                          1510  DataReg5
00001B28  43F9 000024E4           1511          LEA     OutDataReg5,A1
00001B2E  103C 000E               1512          MOVE.B  #14,D0
00001B32  4E4F                    1513          TRAP    #15
00001B34                          1514  
00001B34  4EF8 1AD6               1515          JMP     WrapperDataRegEnd
00001B38                          1516          
00001B38                          1517  DataReg6
00001B38  43F9 000024E7           1518          LEA     OutDataReg6,A1 A1
00001B3E  103C 000E               1519          MOVE.B  #14,D0
00001B42  4E4F                    1520          TRAP    #15
00001B44                          1521  
00001B44  4EF8 1AD6               1522          JMP     WrapperDataRegEnd
00001B48                          1523          
00001B48                          1524  DataReg7
00001B48  43F9 000024EA           1525          LEA     OutDataReg7,A1
00001B4E  103C 000E               1526          MOVE.B  #14,D0
00001B52  4E4F                    1527          TRAP    #15
00001B54                          1528          
00001B54  4EF8 1AD6               1529          JMP     WrapperDataRegEnd
00001B58                          1530  
00001B58                          1531  
00001B58                          1532  *-----------------------------------------------------------        
00001B58                          1533  * Output logic for all Address Registers (0-7)
00001B58                          1534  *-----------------------------------------------------------     
00001B58                          1535  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001B58                          1536  WrapperAddrReg
00001B58                          1537          *Depending on the EA Register, output a different register number
00001B58  B63C 0000               1538          CMP.B   #$00,D3
00001B5C  6700 003C               1539          BEQ     AddrReg0
00001B60                          1540          
00001B60  B63C 0001               1541          CMP.B   #$01,D3
00001B64  6700 0044               1542          BEQ     AddrReg1
00001B68                          1543          
00001B68  B63C 0002               1544          CMP.B   #$02,D3
00001B6C  6700 004C               1545          BEQ     AddrReg2
00001B70                          1546          
00001B70  B63C 0003               1547          CMP.B   #$03,D3
00001B74  6700 0054               1548          BEQ     AddrReg3
00001B78                          1549          
00001B78  B63C 0004               1550          CMP.B   #$04,D3
00001B7C  6700 005C               1551          BEQ     AddrReg4
00001B80                          1552          
00001B80  B63C 0005               1553          CMP.B   #$05,D3
00001B84  6700 0064               1554          BEQ     AddrReg5
00001B88                          1555          
00001B88  B63C 0006               1556          CMP.B   #$06,D3
00001B8C  6700 006C               1557          BEQ     AddrReg6
00001B90                          1558          
00001B90  B63C 0007               1559          CMP.B   #$07,D3
00001B94  6700 0074               1560          BEQ     AddrReg7
00001B98                          1561  
00001B98                          1562  *Used to get back to 'AddrRegMode', after dealing with the specific register
00001B98                          1563  WrapperAddrRegEnd
00001B98  4E75                    1564          RTS        
00001B9A                          1565  
00001B9A                          1566  AddrReg0
00001B9A                          1567          *Output the specific address indirect register...
00001B9A  43F9 000024ED           1568          LEA     OutAddrReg0,A1      *Loads AddrReg0 into address register A1
00001BA0  103C 000E               1569          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001BA4  4E4F                    1570          TRAP    #15                 *Displays Message        
00001BA6                          1571          
00001BA6  4EF8 1B98               1572          JMP     WrapperAddrRegEnd
00001BAA                          1573  
00001BAA                          1574  AddrReg1
00001BAA  43F9 000024F0           1575          LEA     OutAddrReg1,A1
00001BB0  103C 000E               1576          MOVE.B  #14,D0
00001BB4  4E4F                    1577          TRAP    #15
00001BB6                          1578          
00001BB6  4EF8 1B98               1579          JMP     WrapperAddrRegEnd
00001BBA                          1580  
00001BBA                          1581  AddrReg2
00001BBA  43F9 000024F3           1582          LEA     OutAddrReg2,A1
00001BC0  103C 000E               1583          MOVE.B  #14,D0
00001BC4  4E4F                    1584          TRAP    #15
00001BC6                          1585          
00001BC6  4EF8 1B98               1586          JMP     WrapperAddrRegEnd
00001BCA                          1587  
00001BCA                          1588  AddrReg3
00001BCA  43F9 000024F6           1589          LEA     OutAddrReg3,A1
00001BD0  103C 000E               1590          MOVE.B  #14,D0
00001BD4  4E4F                    1591          TRAP    #15
00001BD6                          1592          
00001BD6  4EF8 1B98               1593          JMP     WrapperAddrRegEnd
00001BDA                          1594  
00001BDA                          1595  AddrReg4
00001BDA  43F9 000024F9           1596          LEA     OutAddrReg4,A1
00001BE0  103C 000E               1597          MOVE.B  #14,D0
00001BE4  4E4F                    1598          TRAP    #15
00001BE6                          1599          
00001BE6  4EF8 1B98               1600          JMP     WrapperAddrRegEnd
00001BEA                          1601  
00001BEA                          1602  AddrReg5
00001BEA  43F9 000024FC           1603          LEA     OutAddrReg5,A1
00001BF0  103C 000E               1604          MOVE.B  #14,D0
00001BF4  4E4F                    1605          TRAP    #15
00001BF6                          1606          
00001BF6  4EF8 1B98               1607          JMP     WrapperAddrRegEnd
00001BFA                          1608  
00001BFA                          1609  AddrReg6
00001BFA  43F9 000024FF           1610          LEA     OutAddrReg6,A1
00001C00  103C 000E               1611          MOVE.B  #14,D0
00001C04  4E4F                    1612          TRAP    #15
00001C06                          1613          
00001C06  4EF8 1B98               1614          JMP     WrapperAddrRegEnd
00001C0A                          1615  
00001C0A                          1616  AddrReg7
00001C0A  43F9 00002502           1617          LEA     OutAddrReg7,A1
00001C10  103C 000E               1618          MOVE.B  #14,D0
00001C14  4E4F                    1619          TRAP    #15
00001C16                          1620          
00001C16  4EF8 1B98               1621          JMP     WrapperAddrRegEnd
00001C1A                          1622  
00001C1A                          1623  
00001C1A                          1624  *-----------------------------------------------------------        
00001C1A                          1625  * Output logic for all Address Indirect Registers (0-7)
00001C1A                          1626  *-----------------------------------------------------------     
00001C1A                          1627  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001C1A                          1628  WrapperAddrIndirect
00001C1A                          1629          *Depending on the EA Register, output a different register number
00001C1A  B63C 0000               1630          CMP.B   #$00,D3
00001C1E  6700 003C               1631          BEQ     AddrIndReg0
00001C22                          1632          
00001C22  B63C 0001               1633          CMP.B   #$01,D3
00001C26  6700 0044               1634          BEQ     AddrIndReg1
00001C2A                          1635          
00001C2A  B63C 0002               1636          CMP.B   #$02,D3
00001C2E  6700 004C               1637          BEQ     AddrIndReg2
00001C32                          1638          
00001C32  B63C 0003               1639          CMP.B   #$03,D3
00001C36  6700 0054               1640          BEQ     AddrIndReg3
00001C3A                          1641          
00001C3A  B63C 0004               1642          CMP.B   #$04,D3
00001C3E  6700 005C               1643          BEQ     AddrIndReg4
00001C42                          1644          
00001C42  B63C 0005               1645          CMP.B   #$05,D3
00001C46  6700 0064               1646          BEQ     AddrIndReg5
00001C4A                          1647          
00001C4A  B63C 0006               1648          CMP.B   #$06,D3
00001C4E  6700 006C               1649          BEQ     AddrIndReg6
00001C52                          1650          
00001C52  B63C 0007               1651          CMP.B   #$07,D3
00001C56  6700 0074               1652          BEQ     AddrIndReg7
00001C5A                          1653  
00001C5A                          1654  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
00001C5A                          1655  WrapperAddrIndirectEnd
00001C5A  4E75                    1656          RTS        
00001C5C                          1657  
00001C5C                          1658  AddrIndReg0
00001C5C                          1659          *Output the specific address indirect register...
00001C5C  43F9 00002505           1660          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001C62  103C 000E               1661          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001C66  4E4F                    1662          TRAP    #15                 *Displays Message        
00001C68                          1663          
00001C68  4EF8 1C5A               1664          JMP     WrapperAddrIndirectEnd
00001C6C                          1665  
00001C6C                          1666  AddrIndReg1
00001C6C  43F9 0000250A           1667          LEA     OutAddrIndReg1,A1
00001C72  103C 000E               1668          MOVE.B  #14,D0
00001C76  4E4F                    1669          TRAP    #15
00001C78                          1670          
00001C78  4EF8 1C5A               1671          JMP     WrapperAddrIndirectEnd
00001C7C                          1672  
00001C7C                          1673  AddrIndReg2
00001C7C  43F9 0000250F           1674          LEA     OutAddrIndReg2,A1
00001C82  103C 000E               1675          MOVE.B  #14,D0
00001C86  4E4F                    1676          TRAP    #15
00001C88                          1677          
00001C88  4EF8 1C5A               1678          JMP     WrapperAddrIndirectEnd
00001C8C                          1679  
00001C8C                          1680  AddrIndReg3
00001C8C  43F9 00002514           1681          LEA     OutAddrIndReg3,A1
00001C92  103C 000E               1682          MOVE.B  #14,D0
00001C96  4E4F                    1683          TRAP    #15
00001C98                          1684          
00001C98  4EF8 1C5A               1685          JMP     WrapperAddrIndirectEnd
00001C9C                          1686  
00001C9C                          1687  AddrIndReg4
00001C9C  43F9 00002519           1688          LEA     OutAddrIndReg4,A1
00001CA2  103C 000E               1689          MOVE.B  #14,D0
00001CA6  4E4F                    1690          TRAP    #15
00001CA8                          1691          
00001CA8  4EF8 1C5A               1692          JMP     WrapperAddrIndirectEnd
00001CAC                          1693  
00001CAC                          1694  AddrIndReg5
00001CAC  43F9 0000251E           1695          LEA     OutAddrIndReg5,A1
00001CB2  103C 000E               1696          MOVE.B  #14,D0
00001CB6  4E4F                    1697          TRAP    #15
00001CB8                          1698          
00001CB8  4EF8 1C5A               1699          JMP     WrapperAddrIndirectEnd
00001CBC                          1700  
00001CBC                          1701  AddrIndReg6
00001CBC  43F9 00002523           1702          LEA     OutAddrIndReg6,A1
00001CC2  103C 000E               1703          MOVE.B  #14,D0
00001CC6  4E4F                    1704          TRAP    #15
00001CC8                          1705          
00001CC8  4EF8 1C5A               1706          JMP     WrapperAddrIndirectEnd
00001CCC                          1707  
00001CCC                          1708  AddrIndReg7
00001CCC  43F9 00002528           1709          LEA     OutAddrIndReg7,A1
00001CD2  103C 000E               1710          MOVE.B  #14,D0
00001CD6  4E4F                    1711          TRAP    #15
00001CD8                          1712          
00001CD8  4EF8 1C5A               1713          JMP     WrapperAddrIndirectEnd
00001CDC                          1714          
00001CDC                          1715          
00001CDC                          1716  *-----------------------------------------------------------        
00001CDC                          1717  * Output logic for all Address Indirect Post Increment Registers (0-7)
00001CDC                          1718  *-----------------------------------------------------------     
00001CDC                          1719  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001CDC                          1720  WrapperAddrIndirectPost
00001CDC                          1721          *Depending on the EA Register, output a different register number
00001CDC  B63C 0000               1722          CMP.B   #$00,D3
00001CE0  6700 003C               1723          BEQ     AddrIndPoReg0
00001CE4                          1724          
00001CE4  B63C 0001               1725          CMP.B   #$01,D3
00001CE8  6700 0044               1726          BEQ     AddrIndPoReg1
00001CEC                          1727          
00001CEC  B63C 0002               1728          CMP.B   #$02,D3
00001CF0  6700 004C               1729          BEQ     AddrIndPoReg2
00001CF4                          1730          
00001CF4  B63C 0003               1731          CMP.B   #$03,D3
00001CF8  6700 0054               1732          BEQ     AddrIndPoReg3
00001CFC                          1733          
00001CFC  B63C 0004               1734          CMP.B   #$04,D3
00001D00  6700 005C               1735          BEQ     AddrIndPoReg4
00001D04                          1736          
00001D04  B63C 0005               1737          CMP.B   #$05,D3
00001D08  6700 0064               1738          BEQ     AddrIndPoReg5
00001D0C                          1739          
00001D0C  B63C 0006               1740          CMP.B   #$06,D3
00001D10  6700 006C               1741          BEQ     AddrIndPoReg6
00001D14                          1742          
00001D14  B63C 0007               1743          CMP.B   #$07,D3
00001D18  6700 0074               1744          BEQ     AddrIndPoReg7
00001D1C                          1745  
00001D1C                          1746  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
00001D1C                          1747  WrapperAddrIndirectPostEnd
00001D1C  4E75                    1748          RTS        
00001D1E                          1749  
00001D1E                          1750  AddrIndPoReg0
00001D1E                          1751          *Output the specific address indirect post register...
00001D1E  43F9 0000252D           1752          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001D24  103C 000E               1753          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001D28  4E4F                    1754          TRAP    #15                 *Displays Message        
00001D2A                          1755          
00001D2A  4EF8 1D1C               1756          JMP     WrapperAddrIndirectPostEnd
00001D2E                          1757  
00001D2E                          1758  AddrIndPoReg1
00001D2E  43F9 00002533           1759          LEA     OutAddrIndPoReg1,A1
00001D34  103C 000E               1760          MOVE.B  #14,D0
00001D38  4E4F                    1761          TRAP    #15
00001D3A                          1762          
00001D3A  4EF8 1D1C               1763          JMP     WrapperAddrIndirectPostEnd
00001D3E                          1764  
00001D3E                          1765  AddrIndPoReg2
00001D3E  43F9 00002539           1766          LEA     OutAddrIndPoReg2,A1
00001D44  103C 000E               1767          MOVE.B  #14,D0
00001D48  4E4F                    1768          TRAP    #15
00001D4A                          1769          
00001D4A  4EF8 1D1C               1770          JMP     WrapperAddrIndirectPostEnd
00001D4E                          1771  
00001D4E                          1772  AddrIndPoReg3
00001D4E  43F9 0000253F           1773          LEA     OutAddrIndPoReg3,A1
00001D54  103C 000E               1774          MOVE.B  #14,D0
00001D58  4E4F                    1775          TRAP    #15
00001D5A                          1776          
00001D5A  4EF8 1D1C               1777          JMP     WrapperAddrIndirectPostEnd
00001D5E                          1778  
00001D5E                          1779  AddrIndPoReg4
00001D5E  43F9 00002545           1780          LEA     OutAddrIndPoReg4,A1
00001D64  103C 000E               1781          MOVE.B  #14,D0
00001D68  4E4F                    1782          TRAP    #15
00001D6A                          1783          
00001D6A  4EF8 1D1C               1784          JMP     WrapperAddrIndirectPostEnd
00001D6E                          1785  
00001D6E                          1786  AddrIndPoReg5
00001D6E  43F9 0000254B           1787          LEA     OutAddrIndPoReg5,A1
00001D74  103C 000E               1788          MOVE.B  #14,D0
00001D78  4E4F                    1789          TRAP    #15
00001D7A                          1790          
00001D7A  4EF8 1D1C               1791          JMP     WrapperAddrIndirectPostEnd
00001D7E                          1792  
00001D7E                          1793  AddrIndPoReg6
00001D7E  43F9 00002551           1794          LEA     OutAddrIndPoReg6,A1
00001D84  103C 000E               1795          MOVE.B  #14,D0
00001D88  4E4F                    1796          TRAP    #15
00001D8A                          1797          
00001D8A  4EF8 1D1C               1798          JMP     WrapperAddrIndirectPostEnd
00001D8E                          1799  
00001D8E                          1800  AddrIndPoReg7
00001D8E  43F9 00002557           1801          LEA     OutAddrIndPoReg7,A1
00001D94  103C 000E               1802          MOVE.B  #14,D0
00001D98  4E4F                    1803          TRAP    #15
00001D9A                          1804          
00001D9A  4EF8 1D1C               1805          JMP     WrapperAddrIndirectPostEnd
00001D9E                          1806  
00001D9E                          1807  
00001D9E                          1808  *-----------------------------------------------------------        
00001D9E                          1809  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001D9E                          1810  *-----------------------------------------------------------     
00001D9E                          1811  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001D9E                          1812  WrapperAddrIndirectPre
00001D9E                          1813          *Depending on the EA Register, output a different register number
00001D9E  B63C 0000               1814          CMP.B   #$00,D3
00001DA2  6700 003C               1815          BEQ     AddrIndPrReg0
00001DA6                          1816          
00001DA6  B63C 0001               1817          CMP.B   #$01,D3
00001DAA  6700 0044               1818          BEQ     AddrIndPrReg1
00001DAE                          1819          
00001DAE  B63C 0002               1820          CMP.B   #$02,D3
00001DB2  6700 004C               1821          BEQ     AddrIndPrReg2
00001DB6                          1822          
00001DB6  B63C 0003               1823          CMP.B   #$03,D3
00001DBA  6700 0054               1824          BEQ     AddrIndPrReg3
00001DBE                          1825          
00001DBE  B63C 0004               1826          CMP.B   #$04,D3
00001DC2  6700 005C               1827          BEQ     AddrIndPrReg4
00001DC6                          1828          
00001DC6  B63C 0005               1829          CMP.B   #$05,D3
00001DCA  6700 0064               1830          BEQ     AddrIndPrReg5
00001DCE                          1831          
00001DCE  B63C 0006               1832          CMP.B   #$06,D3
00001DD2  6700 006C               1833          BEQ     AddrIndPrReg6
00001DD6                          1834          
00001DD6  B63C 0007               1835          CMP.B   #$07,D3
00001DDA  6700 0074               1836          BEQ     AddrIndPrReg7
00001DDE                          1837  
00001DDE                          1838  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001DDE                          1839  WrapperAddrIndirectPreEnd
00001DDE  4E75                    1840          RTS        
00001DE0                          1841  
00001DE0                          1842  AddrIndPrReg0
00001DE0                          1843          *Output the specific address indirect post register...
00001DE0  43F9 0000255D           1844          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001DE6  103C 000E               1845          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001DEA  4E4F                    1846          TRAP    #15                 *Displays Message        
00001DEC                          1847          
00001DEC  4EF8 1DDE               1848          JMP     WrapperAddrIndirectPreEnd
00001DF0                          1849  
00001DF0                          1850  AddrIndPrReg1
00001DF0  43F9 00002563           1851          LEA     OutAddrIndPrReg1,A1
00001DF6  103C 000E               1852          MOVE.B  #14,D0
00001DFA  4E4F                    1853          TRAP    #15
00001DFC                          1854          
00001DFC  4EF8 1DDE               1855          JMP     WrapperAddrIndirectPreEnd
00001E00                          1856  
00001E00                          1857  AddrIndPrReg2
00001E00  43F9 00002569           1858          LEA     OutAddrIndPrReg2,A1
00001E06  103C 000E               1859          MOVE.B  #14,D0
00001E0A  4E4F                    1860          TRAP    #15
00001E0C                          1861          
00001E0C  4EF8 1DDE               1862          JMP     WrapperAddrIndirectPreEnd
00001E10                          1863  
00001E10                          1864  AddrIndPrReg3
00001E10  43F9 0000256F           1865          LEA     OutAddrIndPrReg3,A1
00001E16  103C 000E               1866          MOVE.B  #14,D0
00001E1A  4E4F                    1867          TRAP    #15
00001E1C                          1868          
00001E1C  4EF8 1DDE               1869          JMP     WrapperAddrIndirectPreEnd
00001E20                          1870  
00001E20                          1871  AddrIndPrReg4
00001E20  43F9 00002575           1872          LEA     OutAddrIndPrReg4,A1
00001E26  103C 000E               1873          MOVE.B  #14,D0
00001E2A  4E4F                    1874          TRAP    #15
00001E2C                          1875          
00001E2C  4EF8 1DDE               1876          JMP     WrapperAddrIndirectPreEnd
00001E30                          1877  
00001E30                          1878  AddrIndPrReg5
00001E30  43F9 0000257B           1879          LEA     OutAddrIndPrReg5,A1
00001E36  103C 000E               1880          MOVE.B  #14,D0
00001E3A  4E4F                    1881          TRAP    #15
00001E3C                          1882          
00001E3C  4EF8 1DDE               1883          JMP     WrapperAddrIndirectPreEnd
00001E40                          1884  
00001E40                          1885  AddrIndPrReg6
00001E40  43F9 00002581           1886          LEA     OutAddrIndPrReg6,A1
00001E46  103C 000E               1887          MOVE.B  #14,D0
00001E4A  4E4F                    1888          TRAP    #15
00001E4C                          1889          
00001E4C  4EF8 1DDE               1890          JMP     WrapperAddrIndirectPreEnd
00001E50                          1891  
00001E50                          1892  AddrIndPrReg7
00001E50  43F9 00002587           1893          LEA     OutAddrIndPrReg7,A1
00001E56  103C 000E               1894          MOVE.B  #14,D0
00001E5A  4E4F                    1895          TRAP    #15
00001E5C                          1896          
00001E5C  4EF8 1DDE               1897          JMP     WrapperAddrIndirectPreEnd
00001E60                          1898  
00001E60                          1899  
00001E60                          1900  *-----------------------------------------------------------        
00001E60                          1901  * Output logic for absolute memory addressing (0-7)
00001E60                          1902  *-----------------------------------------------------------     
00001E60                          1903  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001E60                          1904  WrapperAddrAbsolute
00001E60  4284                    1905          CLR.L   D4
00001E62                          1906          *Depending on the EA Register, choose which size to decode
00001E62  B63C 0000               1907          CMP.B   #$00,D3
00001E66  6700 000C               1908          BEQ     WordSizeAbsolute
00001E6A                          1909  
00001E6A  B63C 0001               1910          CMP.B   #$01,D3
00001E6E  6700 0028               1911          BEQ     LongSizeAbsolute
00001E72                          1912          
00001E72                          1913  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001E72                          1914  WrapperAddrAbsoluteEnd
00001E72  4E75                    1915          RTS
00001E74                          1916  
00001E74                          1917  WordSizeAbsolute        
00001E74  3818                    1918          MOVE.W  (A0)+,D4    *read in next word, data is that word        
00001E76                          1919              
00001E76                          1920          *Output ',$' just after source operand
00001E76  43F9 0000259A           1921          LEA     Bang,A1
00001E7C  103C 000E               1922          MOVE.B  #14,D0
00001E80  4E4F                    1923          TRAP    #15
00001E82                          1924              
00001E82                          1925          *Push D1 into stack, in case something was using it
00001E82  48E7 4000               1926          MOVEM.L D1,-(SP)
00001E86                          1927          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001E86  4281                    1928          CLR.L   D1
00001E88  123C 0001               1929          MOVE.B  #$01,D1
00001E8C                          1930              
00001E8C                          1931          *output the absolute mem address to console with the hex-ascii converter
00001E8C  4EB8 11EA               1932          JSR     HEXASCII
00001E90  4CDF 0002               1933          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001E94                          1934          
00001E94  4EF8 1E72               1935          JMP     WrapperAddrAbsoluteEnd
00001E98                          1936  
00001E98                          1937  LongSizeAbsolute
00001E98  2818                    1938          MOVE.L  (A0)+,D4    *read in next long, data is that long                
00001E9A                          1939                  
00001E9A                          1940          *Output ',$' just after source operand
00001E9A  43F9 0000259A           1941          LEA     Bang,A1
00001EA0  103C 000E               1942          MOVE.B  #14,D0
00001EA4  4E4F                    1943          TRAP    #15  
00001EA6                          1944          
00001EA6                          1945          *Push D1 into stack, in case something was using it
00001EA6  48E7 4000               1946          MOVEM.L D1,-(SP)
00001EAA                          1947          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001EAA  4281                    1948          CLR.L   D1
00001EAC  123C 0010               1949          MOVE.B  #$10,D1
00001EB0                          1950              
00001EB0                          1951          *output the absolute mem address to console with the hex-ascii converter
00001EB0  4EB8 11EA               1952          JSR     HEXASCII
00001EB4  4CDF 0002               1953          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001EB8                          1954          
00001EB8  4EF8 1E72               1955          JMP     WrapperAddrAbsoluteEnd
00001EBC                          1956          
00001EBC                          1957  
00001EBC                          1958  *-----------------------------------------------------------        
00001EBC                          1959  * Current handling of bad op/ea codes. Should be revisited.
00001EBC                          1960  *----------------------------------------------------------- 
00001EBC                          1961  BADOPCODE
00001EBC                          1962          *We found a bad op code, output some error to the screen, jump to the 
00001EBC                          1963          *next instruction in memory.
00001EBC                          1964          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001EBC                          1965          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001EBC                          1966          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001EBC                          1967          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001EBC                          1968          *i/o and error message code...
00001EBC  43F9 000025A3           1969          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001EC2  103C 000E               1970          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001EC6  4E4F                    1971          TRAP    #15         *Displays Message
00001EC8  4EF8 1386               1972          JMP     GRAB_NEXT_OP
00001ECC                          1973                  
00001ECC                          1974  BADEACODE
00001ECC                          1975          *We found a bad ea code, output some error to the screen, jump to the
00001ECC                          1976          *next instruction in memory.
00001ECC                          1977          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001ECC                          1978          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001ECC  43F9 0000259C           1979          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001ED2  103C 000E               1980          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001ED6  4E4F                    1981          TRAP    #15         *Displays Message
00001ED8  4EF8 1386               1982          JMP     GRAB_NEXT_OP
00001EDC                          1983          
00001EDC                          1984          
00001EDC                          1985  *-----------------------------------------------------------        
00001EDC                          1986  * End of Disassembler
00001EDC                          1987  *-----------------------------------------------------------    
00001EDC                          1988  
00001EDC  4E72 2700               1989  DONE    STOP    #$2700  *What does this do? Why was it added?
00001EE0                          1990  
00001EE0  103C 0009               1991  THEEND  MOVE.B  #9,D0
00001EE4  4E4F                    1992          TRAP    #15             Halt Simulator        
00001EE6                          1993          
00001EE6                          1994       
00001EE6                          1995  *-----------------------------------------------------------        
00001EE6                          1996  * Output stuff
00001EE6                          1997  *-----------------------------------------------------------     
00001EE6  =0000000D               1998  CR      EQU     $0D             ASCII code for Carriage Return
00001EE6  =0000000A               1999  LF      EQU     $0A             ASCII code for Line Feed
00001EE6= 2D 2D 2D 2D 2D 2D ...   2000  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001F25= 7C 7C 20 20 20 20 ...   2001              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001F64= 2D 2D 2D 2D 2D 2D ...   2002              DC.B    '-------------------------------------------------------------',CR,LF
00001FA3= 2A 2A 2A 2A 2A 2A ...   2003              DC.B    '*************************************************************',CR,LF
00001FE2= 2A 2A 2A 2A 2A 2A ...   2004              DC.B    '*************************************************************',CR,LF
00002021= 2A 2A 2A 2A 2A 2A ...   2005              DC.B    '******           ***        ***           ****    ***********',CR,LF
00002060= 2A 2A 2A 2A 2A 2A ...   2006              DC.B    '************    ****   ************   *******  **  **********',CR,LF
0000209F= 2A 2A 2A 2A 2A 2A ...   2007              DC.B    '**********    ******        *******   ******        *********',CR,LF
000020DE= 2A 2A 2A 2A 2A 2A ...   2008              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
0000211D= 2A 2A 2A 2A 2A 2A ...   2009              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
0000215C= 2A 2A 2A 2A 2A 2A ...   2010              DC.B    '*************************************************************',CR,LF
0000219B= 2A 2A 2A 2A 2A 2A ...   2011              DC.B    '*************************************************************',CR,LF
000021DA= 2A 20 20 20 20 20 ...   2012              DC.B    '*                                                           *',CR,LF
00002219= 2A 20 41 75 74 68 ...   2013              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00002258= 2A 20 20 20 20 20 ...   2014              DC.B    '*                                                           *',CR,LF
00002297= 2A 2A 2A 2A 2A 2A ...   2015              DC.B    '*************************************************************',CR,LF,CR,LF
000022D8= 53 74 61 72 74 69 ...   2016              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
000022F5                          2017              
000022F5= 57 6F 75 6C 64 20 ...   2018  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00002326                          2019  
00002326= 20 0D 0A                2020  GETSTRTADDR DC.B    ' ',CR,LF
00002329= 50 6C 65 61 73 65 ...   2021              DC.B    'Please type in your starting address request: ',0
00002358                          2022              
00002358= 20 0D 0A                2023  GETENDADDR  DC.B    ' ',CR,LF
0000235B= 50 6C 65 61 73 65 ...   2024              DC.B    'Please type in your ending address request: ',0
00002388                          2025              
00002388= 20 0D 0A                2026  QUES_CONT   DC.B    ' ',CR,LF
0000238B= 57 6F 75 6C 64 20 ...   2027              DC.B    'Would you like to continue (Y/N)? ',0
000023AE                          2028              
000023AE= 20 0D 0A                2029  QUIT_MSG    DC.B    ' ',CR,LF
000023B1= 57 6F 75 6C 64 20 ...   2030              DC.B    'Would you like to quit (Y/N)? ',0
000023D0                          2031  
000023D0                          2032  *****************************************************
000023D0                          2033  * I/O storages - assuming users knows what to do.
000023D0                          2034  *****************************************************
000023D0                          2035  CMD_HLD     DS.B    30
000023EE                          2036  CMD_SZ      DS.B    30
0000240C                          2037  STADDR      DS.B    10
00002416                          2038  STADDRSZ    DS.B    10
00002420                          2039  PROGST      DS.L    1
00002424                          2040  ENDADDR     DS.B    10
0000242E                          2041  ENDADDRSZ   DS.B    10
00002438                          2042  PROGEND     DS.L    1
0000243C                          2043  CONT        DS.B    30
0000245A                          2044  *****************************************************
0000245A                          2045  
0000245A                          2046  *Table for 0-9 && A-F
0000245A= 30 00                   2047  PRNT0   DC.B    '0',0
0000245C= 31 00                   2048  PRNT1   DC.B    '1',0
0000245E= 32 00                   2049  PRNT2   DC.B    '2',0
00002460= 33 00                   2050  PRNT3   DC.B    '3',0
00002462= 34 00                   2051  PRNT4   DC.B    '4',0
00002464= 35 00                   2052  PRNT5   DC.B    '5',0
00002466= 36 00                   2053  PRNT6   DC.B    '6',0
00002468= 37 00                   2054  PRNT7   DC.B    '7',0
0000246A= 38 00                   2055  PRNT8   DC.B    '8',0
0000246C= 39 00                   2056  PRNT9   DC.B    '9',0
0000246E= 41 00                   2057  PRNTA   DC.B    'A',0
00002470= 42 00                   2058  PRNTB   DC.B    'B',0
00002472= 43 00                   2059  PRNTC   DC.B    'C',0
00002474= 44 00                   2060  PRNTD   DC.B    'D',0
00002476= 45 00                   2061  PRNTE   DC.B    'E',0
00002478= 46 00                   2062  PRNTF   DC.B    'F',0
0000247A                          2063  
0000247A                          2064  *output for all OPCODEs
0000247A                          2065  *Bucket 0000
0000247A= 41 44 44 49 00          2066  ADDI    DC.B    'ADDI',0
0000247F= 41 4E 44 49 00          2067  ANDI    DC.B    'ANDI',0
00002484= 45 4F 52 49 00          2068  EORI    DC.B    'EORI',0
00002489= 42 43 48 47 00          2069  BCHG    DC.B    'BCHG',0
0000248E= 43 4D 50 49 00          2070  CMPI    DC.B    'CMPI',0
00002493                          2071  *Bucket 0100
00002493= 4D 4F 56 45 4D 00       2072  MOVEM   DC.B    'MOVEM',0
00002499= 4D 55 4C 53 00          2073  MULS    DC.B    'MULS',0
0000249E= 4C 45 41 20 20 20 ...   2074  LEA     DC.B    'LEA      ',0   *Need spaces here since LEA has no size
000024A8= 43 4C 52 00             2075  CLR     DC.B    'CLR',0
000024AC= 4A 53 52 20 20 20 ...   2076  JSR     DC.B    'JSR      ',0   *Need spaces here since JSR has no size
000024B6= 52 54 53 20 20 20 ...   2077  RTS     DC.B    'RTS      ',0   *Need spaces here since RTS has no size
000024C0                          2078  
000024C0                          2079  *output for the size of the operation
000024C0= 2E 42 20 20 20 20 00    2080  ByteSize    DC.B    '.B    ',0
000024C7= 2E 57 20 20 20 20 00    2081  WordSize    DC.B    '.W    ',0
000024CE= 2E 4C 20 20 20 20 00    2082  LongSize    DC.B    '.L    ',0
000024D5                          2083  
000024D5                          2084  *output for all data registers (0-7)
000024D5= 44 30 00                2085  OutDataReg0 DC.B    'D0',0
000024D8= 44 31 00                2086  OutDataReg1 DC.B    'D1',0
000024DB= 44 32 00                2087  OutDataReg2 DC.B    'D2',0
000024DE= 44 33 00                2088  OutDataReg3 DC.B    'D3',0
000024E1= 44 34 00                2089  OutDataReg4 DC.B    'D4',0
000024E4= 44 35 00                2090  OutDataReg5 DC.B    'D5',0
000024E7= 44 36 00                2091  OutDataReg6 DC.B    'D6',0
000024EA= 44 37 00                2092  OutDataReg7 DC.B    'D7',0
000024ED                          2093  
000024ED                          2094  *output for all address registers (0-7)
000024ED= 41 30 00                2095  OutAddrReg0 DC.B    'A0',0
000024F0= 41 31 00                2096  OutAddrReg1 DC.B    'A1',0
000024F3= 41 32 00                2097  OutAddrReg2 DC.B    'A2',0
000024F6= 41 33 00                2098  OutAddrReg3 DC.B    'A3',0
000024F9= 41 34 00                2099  OutAddrReg4 DC.B    'A4',0
000024FC= 41 35 00                2100  OutAddrReg5 DC.B    'A5',0
000024FF= 41 36 00                2101  OutAddrReg6 DC.B    'A6',0
00002502= 41 37 00                2102  OutAddrReg7 DC.B    'A7',0
00002505                          2103          
00002505                          2104  *output for all address indirect registers (0-7)
00002505= 28 41 30 29 00          2105  OutAddrIndReg0  DC.B    '(A0)',0
0000250A= 28 41 31 29 00          2106  OutAddrIndReg1  DC.B    '(A1)',0
0000250F= 28 41 32 29 00          2107  OutAddrIndReg2  DC.B    '(A2)',0
00002514= 28 41 33 29 00          2108  OutAddrIndReg3  DC.B    '(A3)',0
00002519= 28 41 34 29 00          2109  OutAddrIndReg4  DC.B    '(A4)',0
0000251E= 28 41 35 29 00          2110  OutAddrIndReg5  DC.B    '(A5)',0
00002523= 28 41 36 29 00          2111  OutAddrIndReg6  DC.B    '(A6)',0
00002528= 28 41 37 29 00          2112  OutAddrIndReg7  DC.B    '(A7)',0
0000252D                          2113  
0000252D                          2114  *output for all address indirect post registers (0-7)
0000252D= 28 41 30 29 2B 00       2115  OutAddrIndPoReg0    DC.B    '(A0)+',0
00002533= 28 41 31 29 2B 00       2116  OutAddrIndPoReg1    DC.B    '(A1)+',0
00002539= 28 41 32 29 2B 00       2117  OutAddrIndPoReg2    DC.B    '(A2)+',0
0000253F= 28 41 33 29 2B 00       2118  OutAddrIndPoReg3    DC.B    '(A3)+',0
00002545= 28 41 34 29 2B 00       2119  OutAddrIndPoReg4    DC.B    '(A4)+',0
0000254B= 28 41 35 29 2B 00       2120  OutAddrIndPoReg5    DC.B    '(A5)+',0
00002551= 28 41 36 29 2B 00       2121  OutAddrIndPoReg6    DC.B    '(A6)+',0
00002557= 28 41 37 29 2B 00       2122  OutAddrIndPoReg7    DC.B    '(A7)+',0
0000255D                          2123  
0000255D                          2124  *output for all address indirect pre registers (0-7)
0000255D= 2D 28 41 30 29 00       2125  OutAddrIndPrReg0    DC.B    '-(A0)',0
00002563= 2D 28 41 31 29 00       2126  OutAddrIndPrReg1    DC.B    '-(A1)',0
00002569= 2D 28 41 32 29 00       2127  OutAddrIndPrReg2    DC.B    '-(A2)',0
0000256F= 2D 28 41 33 29 00       2128  OutAddrIndPrReg3    DC.B    '-(A3)',0
00002575= 2D 28 41 34 29 00       2129  OutAddrIndPrReg4    DC.B    '-(A4)',0
0000257B= 2D 28 41 35 29 00       2130  OutAddrIndPrReg5    DC.B    '-(A5)',0
00002581= 2D 28 41 36 29 00       2131  OutAddrIndPrReg6    DC.B    '-(A6)',0
00002587= 2D 28 41 37 29 00       2132  OutAddrIndPrReg7    DC.B    '-(A7)',0
0000258D                          2133  
0000258D                          2134  *output for a tab only (4 spaces)
0000258D= 20 20 20 20 00          2135  Tab DC.B    '    ',0
00002592                          2136  
00002592                          2137  *output for a comma only
00002592= 2C 00                   2138  Comma   DC.B    ',',0
00002594                          2139  
00002594                          2140  *output for a new line only
00002594= 0D 0A 00                2141  NewLine DC.B    CR,LF,0
00002597                          2142  
00002597                          2143  *output for a '#$' and '$' only
00002597= 23 24 00                2144  ShaBang DC.B    '#$',0
0000259A= 24 00                   2145  Bang    DC.B    '$',0
0000259C                          2146  
0000259C                          2147  *current output for error messages
0000259C= 42 41 44 20 45 41 00    2148  BADEAMSG    DC.B    'BAD EA',0
000025A3= 42 41 44 20 4F 50 00    2149  BADOPMSG    DC.B    'BAD OP',0
000025AA= 49 6D 70 72 6F 70 ...   2150  INV_MSG     DC.B    'Improper command.',CR,LF,0
000025BE= 49 6E 76 61 6C 69 ...   2151  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
000025D7= 49 6E 76 61 6C 69 ...   2152  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
000025EE                          2153  
000025EE                          2154          
000025EE                          2155          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                247A
ADDRABSOLUTEMODE    1A86
ADDRINDIRECTMODE    1A56
ADDRINDIRECTPOSTMODE  1A66
ADDRINDIRECTPREMODE  1A76
ADDRINDPOREG0       1D1E
ADDRINDPOREG1       1D2E
ADDRINDPOREG2       1D3E
ADDRINDPOREG3       1D4E
ADDRINDPOREG4       1D5E
ADDRINDPOREG5       1D6E
ADDRINDPOREG6       1D7E
ADDRINDPOREG7       1D8E
ADDRINDPRREG0       1DE0
ADDRINDPRREG1       1DF0
ADDRINDPRREG2       1E00
ADDRINDPRREG3       1E10
ADDRINDPRREG4       1E20
ADDRINDPRREG5       1E30
ADDRINDPRREG6       1E40
ADDRINDPRREG7       1E50
ADDRINDREG0         1C5C
ADDRINDREG1         1C6C
ADDRINDREG2         1C7C
ADDRINDREG3         1C8C
ADDRINDREG4         1C9C
ADDRINDREG5         1CAC
ADDRINDREG6         1CBC
ADDRINDREG7         1CCC
ADDRREG0            1B9A
ADDRREG1            1BAA
ADDRREG2            1BBA
ADDRREG3            1BCA
ADDRREG4            1BDA
ADDRREG5            1BEA
ADDRREG6            1BFA
ADDRREG7            1C0A
ADDRREGMODE         1A46
ANDI                247F
ASCIIHEX            1178
ASCIIHEX1           117C
BADEACODE           1ECC
BADEAMSG            259C
BADOPCODE           1EBC
BADOPMSG            25A3
BANG                259A
BCHG                2489
BCHGBYTESIZE        19FE
BCHGIMMEDIATE       1A0E
BCHGLONGSIZE        19EE
BCHGSIZEHELPER      19DE
BCHGSIZEHELPEREND   19EC
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         1436
BUCKET_0001         1784
BUCKET_0010         1784
BUCKET_0011         1784
BUCKET_0100         1784
BUCKET_0101         190A
BUCKET_0110         190A
BUCKET_1000         190A
BUCKET_1001         190A
BUCKET_1011         190A
BUCKET_1100         190A
BUCKET_1101         190A
BUCKET_1110         190A
BYTESIZE            24C0
BYTESIZEIMMEDIATE   192C
BYTESIZEOP          19AE
CHECK               11EE
CHECKEND1           10FE
CHECKSTRT1          10E8
CHECK_LOWN          1130
CHECK_LOWY          111E
CHECK_N             1410
CHECK_UPN           1128
CHECK_UPY           1114
CHECK_Y             1400
CHNG_SZB            1220
CHNG_SZL            1206
CHNG_SZW            123A
CLR                 24A8
CLR_D6              1370
CMD_HLD             23D0
CMD_SZ              23EE
CMPI                248E
COMMA               2592
CONT                243C
CONT_OP             139C
CONT_Q              13CC
CONV_LOL            11D8
CONV_LOOP           1254
CONV_NUM            11C4
CONV_UPL            11CE
CR                  D
DATAREG0            1AD8
DATAREG1            1AE8
DATAREG2            1AF8
DATAREG3            1B08
DATAREG4            1B18
DATAREG5            1B28
DATAREG6            1B38
DATAREG7            1B48
DATAREGMODE         1A36
DONE                1EDC
EA_ADDI             14C2
EA_ANDI             1538
EA_BCHG_D           1630
EA_BCHG_S           16C8
EA_CLR              187E
EA_CMPI             1744
EA_EORI             15AE
EA_JSR              18D4
EA_LEA              1812
EA_LEA_WRAPPEREND   182A
EA_MOVEM_MEMTOREG   17D0
EA_MOVEM_REGTOMEM   17D0
ENDADDR             2424
ENDADDRSZ           242E
EORI                2484
EXITSUB             11E4
EXIT_CONV           12DA
GETENDADDR          2358
GETSTRTADDR         2326
GET_END             1090
GET_STRT            1042
GRAB_NEXT_OP        1386
HEXASCII            11EA
HEXASCIIREG         1202
IMMEDIATEDATAMODE   1A96
INV2                1420
INVALID1            1138
INVENDMSG           25D7
INVSTRTMSG          25BE
INV_END1            1164
INV_MSG             25AA
INV_STRT1           1150
IS_ADDI             148C
IS_ANDI             1502
IS_BCHG_D           15EE
IS_BCHG_S           168C
IS_CLR              1848
IS_CMPI             170E
IS_EORI             1578
IS_JSR              18B2
IS_LEA              17D0
IS_MOVEM_MEMTOREG   17D0
IS_MOVEM_REGTOMEM   17D0
IS_RTS              18EA
JSR                 24AC
LEA                 249E
LEA_ADDRABSOLUTEWRAPPER  1A2C
LEA_ADDRINDIRECTWRAPPER  1A22
LF                  A
LONGSIZE            24CE
LONGSIZEABSOLUTE    1E98
LONGSIZEIMMEDIATE   1970
LONGSIZEOP          19CE
LOOP_1              1014
LOOP_B              1224
LOOP_L              120A
LOOP_W              123E
MAX_LINE            20
MESSAGE             1EE6
MOVEM               2493
MULS                2499
NEWLINE             2594
NUM_0               12E8
NUM_1               12F0
NUM_2               12F8
NUM_3               1300
NUM_4               1308
NUM_5               1310
NUM_6               1318
NUM_7               1320
NUM_8               1328
NUM_9               1330
NUM_A               1338
NUM_B               1340
NUM_C               1348
NUM_D               1350
NUM_E               1358
NUM_F               1360
OUTADDRINDPOREG0    252D
OUTADDRINDPOREG1    2533
OUTADDRINDPOREG2    2539
OUTADDRINDPOREG3    253F
OUTADDRINDPOREG4    2545
OUTADDRINDPOREG5    254B
OUTADDRINDPOREG6    2551
OUTADDRINDPOREG7    2557
OUTADDRINDPRREG0    255D
OUTADDRINDPRREG1    2563
OUTADDRINDPRREG2    2569
OUTADDRINDPRREG3    256F
OUTADDRINDPRREG4    2575
OUTADDRINDPRREG5    257B
OUTADDRINDPRREG6    2581
OUTADDRINDPRREG7    2587
OUTADDRINDREG0      2505
OUTADDRINDREG1      250A
OUTADDRINDREG2      250F
OUTADDRINDREG3      2514
OUTADDRINDREG4      2519
OUTADDRINDREG5      251E
OUTADDRINDREG6      2523
OUTADDRINDREG7      2528
OUTADDRREG0         24ED
OUTADDRREG1         24F0
OUTADDRREG2         24F3
OUTADDRREG3         24F6
OUTADDRREG4         24F9
OUTADDRREG5         24FC
OUTADDRREG6         24FF
OUTADDRREG7         2502
OUTDATAREG0         24D5
OUTDATAREG1         24D8
OUTDATAREG2         24DB
OUTDATAREG3         24DE
OUTDATAREG4         24E1
OUTDATAREG5         24E4
OUTDATAREG6         24E7
OUTDATAREG7         24EA
PRINT_NUM           12E0
PRNT0               245A
PRNT1               245C
PRNT2               245E
PRNT3               2460
PRNT4               2462
PRNT5               2464
PRNT6               2466
PRNT7               2468
PRNT8               246A
PRNT9               246C
PRNTA               246E
PRNTB               2470
PRNTC               2472
PRNTD               2474
PRNTE               2476
PRNTF               2478
PROGEND             2438
PROGST              2420
QUES_CONT           2388
QUIT_MSG            23AE
RTS                 24B6
SHABANG             2597
STACK               7000
STADDR              240C
STADDRSZ            2416
START               1000
STARTASSEM          22F5
ST_ADDR             7FC6
ST_BAD              11E2
TAB                 258D
THEEND              1EE0
WORDSIZE            24C7
WORDSIZEABSOLUTE    1E74
WORDSIZEIMMEDIATE   194E
WORDSIZEOP          19BE
WRAPPERADDRABSOLUTE  1E60
WRAPPERADDRABSOLUTEEND  1E72
WRAPPERADDRINDIRECT  1C1A
WRAPPERADDRINDIRECTEND  1C5A
WRAPPERADDRINDIRECTPOST  1CDC
WRAPPERADDRINDIRECTPOSTEND  1D1C
WRAPPERADDRINDIRECTPRE  1D9E
WRAPPERADDRINDIRECTPREEND  1DDE
WRAPPERADDRREG      1B58
WRAPPERADDRREGEND   1B98
WRAPPERDATAREG      1A96
WRAPPERDATAREGEND   1AD6
WRAPPERSIZE         1992
WRAPPERSIZEEND      19AC
WRAPPERSIZEIMMEDIATE  1910
WRAPPERSIZEIMMEDIATEEND  192A
