00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 9:18:21 PM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/14/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. After specifying
00000000                             7  * where the program to be disassembled is located, this program will disassemble
00000000                             8  * instructions of that program, and output the contents to console.
00000000                             9  *
00000000                            10  * For use with the EASy68K Emulator. To run, open this program in the emulator.
00000000                            11  * Hit 'F9' to execute. In the execution window, open the test input file, and press
00000000                            12  * 'F9' to run the program.
00000000                            13  *
00000000                            14  * This program will not disassemble every 68k instruction, only a subset of instructions
00000000                            15  * that we have currently implemented. See corresponding documentation for more details.
00000000                            16  *-------------------------------------------------------------
00000000  =00007FC6                 17  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 18  STACK       EQU $7000   *Stack location
00000000  =0000000F                 19  MAX_LINE    EQU 15      *Maximum number of instructions that can be displayed
00001000                            20  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 21              LEA stack,SP
00001004  3C3C 000F                 22              MOVE    #MAX_LINE,D6
00001008                            23  
00001008                            24  
00001008                            25  *-----------------------------------------------------------
00001008                            26  * Start of I/O
00001008                            27  *-----------------------------------------------------------            
00001008  43F9 00001ECA             28              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 29              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      30              TRAP    #15         *Displays Message
00001014                            31          
00001014  303C 0000                 32  loop_1      MOVE    #0,D0       
00001018  43F9 000022D9             33              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 34              MOVE.B  #14,D0
00001022  4E4F                      35              TRAP    #15    
00001024  303C 0002                 36              MOVE    #2,D0
00001028  43F9 000023B4             37              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      38              TRAP    #15
00001030  0C01 0001                 39              CMPI.B  #01,D1
00001034  6600 00FE                 40              BNE     INVALID1
00001038  4EB9 00001110             41              JSR     CHECK_UPY
0000103E                            42              
0000103E                            43              
0000103E                            44  *-----------------------------------------------------------
0000103E                            45  * I/O: Check Start Address
0000103E                            46  *
0000103E                            47  * Make sure that start address starts after allocated 
0000103E                            48  * memory addresses. Else, it will print out a message 
0000103E                            49  * saying that requested address is invalid & prompts the
0000103E                            50  * user again for the starting address.
0000103E                            51  *-----------------------------------------------------------
0000103E  43F9 0000230A             52  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001044  103C 000E                 53              MOVE.B  #14,D0
00001048  4E4F                      54              TRAP    #15
0000104A  43F9 000023F0             55              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001050  3239 000023FA             56              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001056  303C 0002                 57              MOVE    #2,D0           *Get start address
0000105A  4E4F                      58              TRAP    #15
0000105C  4EB9 000010E4             59              JSR     CHECKSTRT1
00001062  4287                      60              CLR.L   D7
00001064  4EB9 00001174             61              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106A  0C03 0001                 62              CMPI.B  #01,D3      *Check if there was a bad start
0000106E  6700 00DC                 63              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001072  0C87 00007FC6             64              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001078  6D00 00D2                 65              BLT     INV_STRT1   *Asks for another start address if invalid
0000107C  0C87 00FFFFFE             66              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001082  6C00 00C8                 67              BGE     INV_STRT1
00001086  23C7 00002404             68              MOVE.L  D7,PROGST
0000108C                            69  
0000108C  43F9 0000233C             70  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001092  103C 000E                 71              MOVE.B  #14,D0
00001096  4E4F                      72              TRAP    #15
00001098  43F9 00002408             73              LEA     ENDADDR,A1      *Buffer to hold end address
0000109E  3239 00002412             74              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A4  303C 0002                 75              MOVE    #2,D0
000010A8  4E4F                      76              TRAP    #15
000010AA  4EB9 000010FA             77              JSR     CHECKEND1
000010B0  4287                      78              CLR.L   D7
000010B2  4EB9 00001174             79              JSR     ASCIIHEX
000010B8  0C03 0001                 80              CMPI.B  #01,D3
000010BC  6700 00A2                 81              BEQ     INV_END1
000010C0  0C87 00002404             82              CMPI.L  #PROGST,D7
000010C6  6D00 0098                 83              BLT     INV_END1
000010CA  0C87 00FFFFFF             84              CMPI.L  #$00FFFFFF,D7
000010D0  6C00 008E                 85              BGE     INV_END1
000010D4  23C7 0000241C             86              MOVE.L  D7,PROGEND
000010DA  2079 00002404             87              MOVEA.L PROGST,A0
000010E0  6000 028A                 88              BRA     GRAB_NEXT_OP            
000010E4                            89                          
000010E4  0C81 00000008             90  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EA  6E00 0060                 91              BGT     INV_STRT1
000010EE  0C81 00000000             92              CMPI.L  #00,D1
000010F4  6300 0056                 93              BLS     INV_STRT1
000010F8  4E75                      94              RTS         
000010FA                            95              
000010FA  0C81 00000008             96  CHECKEND1   CMPI.L  #08,D1
00001100  6E00 005E                 97              BGT     INV_END1
00001104  0C81 00000000             98              CMPI.L  #00,D1
0000110A  6300 0054                 99              BLS     INV_END1
0000110E  4E75                     100              RTS
00001110                           101  
00001110                           102  
00001110                           103  *-----------------------------------------------------------
00001110                           104  * I/O: Input check for Y, y, N, n
00001110                           105  *-----------------------------------------------------------
00001110  0C11 0059                106  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001114  6600 0004                107              BNE     CHECK_LOWY
00001118  4E75                     108              RTS
0000111A  0C11 0079                109  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
0000111E  6600 0004                110              BNE     CHECK_UPN
00001122  4E75                     111              RTS
00001124  0C11 004E                112  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001128  6700 0D96                113              BEQ     DONE
0000112C                           114              
0000112C  0C11 006E                115  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001130  6700 0D8E                116              BEQ     DONE
00001134                           117              
00001134  163C 0000                118  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001138  303C 0000                119              MOVE    #0,D0       *Prints invalid command msg if not found
0000113C  43F9 0000258E            120              LEA     INV_MSG,A1
00001142  303C 000E                121              MOVE    #14,D0
00001146  4E4F                     122              TRAP    #15
00001148  6000 FECA                123              BRA     loop_1
0000114C                           124              
0000114C  43F9 000025A2            125  INV_STRT1   LEA     INVSTRTMSG,A1
00001152  103C 000E                126              MOVE.B  #14,D0
00001156  4E4F                     127              TRAP    #15
00001158  163C 0000                128              MOVE.B  #00,D3      *Reset flag
0000115C  6000 FEE0                129              BRA     GET_STRT        
00001160                           130              
00001160  43F9 000025BB            131  INV_END1    LEA     INVENDMSG,A1
00001166  103C 000E                132              MOVE.B  #14,D0
0000116A  4E4F                     133              TRAP    #15
0000116C  163C 0000                134              MOVE.B  #00,D3      *Reset flag
00001170  6000 FF1A                135              BRA     GET_END
00001174                           136              
00001174                           137              
00001174                           138  *-----------------------------------------------------------
00001174                           139  * ASCII to Hex converter
00001174                           140  *
00001174                           141  * Checks and converts the ASCII value to the hex equivalent
00001174                           142  *-----------------------------------------------------------
00001174  48E7 6000                143  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001178  0C01 0000                144  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000117C  6700 0062                145              BEQ     exitSub     *Exit subroutine 
00001180  5301                     146              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001182  E99F                     147              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001184  1419                     148              MOVE.B  (A1)+,D2    *Takes the first char
00001186  0C02 0024                149              CMPI.B  #$24,D2     *See if the first char is $
0000118A  67EC                     150              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000118C  0C02 0030                151              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001190  6D00 004C                152              BLT     st_bad      *Put error message
00001194  0C02 0039                153              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001198  6F00 0026                154              BLE     CONV_NUM    *Convert to number, if so
0000119C  0C02 0041                155              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A0  6D00 003C                156              BLT     st_bad      *Put error message
000011A4  0C02 0046                157              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011A8  6F00 0020                158              BLE     CONV_UpL    *Convert to hex
000011AC  0C02 0061                159              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B0  6D00 002C                160              BLT     st_bad
000011B4  0C02 0066                161              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011B8  6F00 001A                162              BLE     CONV_LoL    
000011BC  6E00 0020                163              BGT     st_bad      *Puts error message for anything greater than f value
000011C0                           164              
000011C0  0402 0030                165  CONV_NUM    SUBI.B  #$30,D2
000011C4  8E02                     166              OR.B    D2,D7
000011C6  4EF8 1178                167              JMP     ASCIIHEX1
000011CA  0402 0037                168  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011CE  8E02                     169              OR.B    D2,D7
000011D0  4EF8 1178                170              JMP     ASCIIHEX1
000011D4  0402 0057                171  CONV_LoL    SUBI.B  #$57,D2
000011D8  8E02                     172              OR.B    D2,D7
000011DA  4EF8 1178                173              JMP     ASCIIHEX1   
000011DE                           174  
000011DE  5203                     175  st_bad      ADDI.B  #01,D3
000011E0  4CDF 0006                176  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E4  4E75                     177              RTS
000011E6                           178              
000011E6                           179              
000011E6                           180  *-----------------------------------------------------------
000011E6                           181  * Hex to ASCII converter
000011E6                           182  *-----------------------------------------------------------
000011E6  48E7 4C00                183  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EA  0C01 0000                184  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011EE  6700 002C                185              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F2  B27C 0001                186              CMP.W   #01,D1          
000011F6  6700 003E                187              BEQ     CHNG_SZW
000011FA  6000 0006                188              BRA     CHNG_SZL        
000011FE                           189  
000011FE  48E7 4C00                190  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001202  123C 0008                191  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
00001206  0C01 0000                192  LOOP_L      CMPI.B  #00,D1
0000120A  6700 00CA                193              BEQ     EXIT_CONV
0000120E  5301                     194              SUBI.B  #01,D1
00001210  E99C                     195              ROL.L   #4,D4           * Shift it for next bit
00001212  2A04                     196              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001214  4EB9 00001250            197              JSR     CONV_LOOP
0000121A  60EA                     198              BRA     LOOP_L      
0000121C                           199  
0000121C  123C 0002                200  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001220  0C01 0000                201  LOOP_B      CMPI.B  #00,D1
00001224  6700 00B0                202              BEQ     EXIT_CONV
00001228  5301                     203              SUBI.B  #01,D1
0000122A  E91C                     204              ROL.B   #4,D4           * Shift it for next bit
0000122C  2A04                     205              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000122E  4EB9 00001250            206              JSR     CONV_LOOP
00001234  60EA                     207              BRA     LOOP_B
00001236                           208              
00001236  123C 0004                209  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123A  0C01 0000                210  LOOP_W      CMPI.B  #00,D1
0000123E  6700 0096                211              BEQ     EXIT_CONV
00001242  5301                     212              SUBI.B  #01,D1
00001244  E95C                     213              ROL.W   #4,D4           * Shift it for next bit
00001246  2A04                     214              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001248  4EB9 00001250            215              JSR     CONV_LOOP
0000124E  60EA                     216              BRA     LOOP_W
00001250                           217  
00001250  0285 0000000F            218  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001256  0C05 0000                219              CMPI.B  #$0,D5
0000125A  6700 0088                220              BEQ     NUM_0
0000125E  0C05 0001                221              CMPI.B  #$1,D5
00001262  6700 0088                222              BEQ     NUM_1
00001266  0C05 0002                223              CMPI.B  #$2,D5
0000126A  6700 0088                224              BEQ     NUM_2
0000126E  0C05 0003                225              CMPI.B  #$3,D5
00001272  6700 0088                226              BEQ     NUM_3
00001276  0C05 0004                227              CMPI.B  #$4,D5
0000127A  6700 0088                228              BEQ     NUM_4
0000127E  0C05 0005                229              CMPI.B  #$5,D5
00001282  6700 0088                230              BEQ     NUM_5
00001286  0C05 0006                231              CMPI.B  #$6,D5
0000128A  6700 0088                232              BEQ     NUM_6
0000128E  0C05 0007                233              CMPI.B  #$7,D5
00001292  6700 0088                234              BEQ     NUM_7
00001296  0C05 0008                235              CMPI.B  #$8,D5
0000129A  6700 0088                236              BEQ     NUM_8
0000129E  0C05 0009                237              CMPI.B  #$9,D5
000012A2  6700 0088                238              BEQ     NUM_9
000012A6  0C05 000A                239              CMPI.B  #$A,D5
000012AA  6700 0088                240              BEQ     NUM_A
000012AE  0C05 000B                241              CMPI.B  #$B,D5
000012B2  6700 0088                242              BEQ     NUM_B
000012B6  0C05 000C                243              CMPI.B  #$C,D5
000012BA  6700 0088                244              BEQ     NUM_C
000012BE  0C05 000D                245              CMPI.B  #$D,D5
000012C2  6700 0088                246              BEQ     NUM_D
000012C6  0C05 000E                247              CMPI.B  #$E,D5
000012CA  6700 0088                248              BEQ     NUM_E
000012CE  0C05 000F                249              CMPI.B  #$F,D5
000012D2  6700 0088                250              BEQ     NUM_F
000012D6                           251              
000012D6  4CDF 0032                252  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DA  4E75                     253              RTS
000012DC                           254              
000012DC  303C 000E                255  PRINT_NUM   MOVE    #14,D0
000012E0  4E4F                     256              TRAP    #15
000012E2  4E75                     257              RTS
000012E4  43F9 0000243E            258  NUM_0       LEA     PRNT0,A1
000012EA  60F0                     259              BRA     PRINT_NUM
000012EC  43F9 00002440            260  NUM_1       LEA     PRNT1,A1
000012F2  60E8                     261              BRA     PRINT_NUM
000012F4  43F9 00002442            262  NUM_2       LEA     PRNT2,A1
000012FA  60E0                     263              BRA     PRINT_NUM
000012FC  43F9 00002444            264  NUM_3       LEA     PRNT3,A1
00001302  60D8                     265              BRA     PRINT_NUM
00001304  43F9 00002446            266  NUM_4       LEA     PRNT4,A1
0000130A  60D0                     267              BRA     PRINT_NUM
0000130C  43F9 00002448            268  NUM_5       LEA     PRNT5,A1
00001312  60C8                     269              BRA     PRINT_NUM
00001314  43F9 0000244A            270  NUM_6       LEA     PRNT6,A1
0000131A  60C0                     271              BRA     PRINT_NUM
0000131C  43F9 0000244C            272  NUM_7       LEA     PRNT7,A1
00001322  60B8                     273              BRA     PRINT_NUM
00001324  43F9 0000244E            274  NUM_8       LEA     PRNT8,A1
0000132A  60B0                     275              BRA     PRINT_NUM
0000132C  43F9 00002450            276  NUM_9       LEA     PRNT9,A1
00001332  60A8                     277              BRA     PRINT_NUM
00001334  43F9 00002452            278  NUM_A       LEA     PRNTA,A1
0000133A  60A0                     279              BRA     PRINT_NUM
0000133C  43F9 00002454            280  NUM_B       LEA     PRNTB,A1
00001342  6098                     281              BRA     PRINT_NUM
00001344  43F9 00002456            282  NUM_C       LEA     PRNTC,A1
0000134A  6090                     283              BRA     PRINT_NUM
0000134C  43F9 00002458            284  NUM_D       LEA     PRNTD,A1
00001352  6088                     285              BRA     PRINT_NUM
00001354  43F9 0000245A            286  NUM_E       LEA     PRNTE,A1
0000135A  6080                     287              BRA     PRINT_NUM
0000135C  43F9 0000245C            288  NUM_F       LEA     PRNTF,A1
00001362  6000 FF78                289              BRA     PRINT_NUM
00001366                           290  
00001366                           291  
00001366                           292  *-----------------------------------------------------------        
00001366                           293  * Start of Disassembler
00001366                           294  *-----------------------------------------------------------
00001366                           295          *FOR DEBUGGING ONLY!!!
00001366  207C 00007FC6            296          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000136C                           297          
0000136C                           298  GRAB_NEXT_OP
0000136C                           299          *Check and see if A0 == end of test address. If so, we need to end.
0000136C  2E08                     300          MOVE.L  A0,D7
0000136E  2479 0000241C            301          MOVEA.L PROGEND,A2
00001374  BE8A                     302          CMP.L   A2,D7       * Check and see if A0 == end of test address. 
00001376  6C00 FC9C                303          BGE     loop_1      * Ask user if they want to do the disassembler again
0000137A  0C86 00000000            304          CMPI.L  #00,D6      * Check if max line of instructions output on console is reached
00001380  6700 0032                305          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
00001384  5306                     306          SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
00001386                           307  
00001386                           308          *Output a newline to console...        
00001386  43F9 00002578            309          LEA     NewLine,A1  *Loads NewLine into address register A1
0000138C  103C 000E                310          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001390  4E4F                     311          TRAP    #15         *Displays Message
00001392                           312  
00001392                           313          *Output the address of this instruction to console...
00001392  2808                     314          MOVE.L  A0,D4
00001394  4EB8 11FE                315          JSR     HEXASCIIREG
00001398                           316          
00001398                           317          *Output a tab (4 spaces) to console, just after the address...
00001398  43F9 00002571            318          LEA     Tab,A1  *Loads Tab into address register A1
0000139E  103C 000E                319          MOVE.B  #14,D0  *Moves the number 14 into data register D0
000013A2  4E4F                     320          TRAP    #15     *Displays Message
000013A4                           321          
000013A4                           322          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
000013A4                           323          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
000013A4                           324          *data that may be associated with the instruction.
000013A4                           325          *Post increment addr, A0 will point to the start of next instruction or will 
000013A4                           326          *point to the start of any immed/abso data with this current instruction
000013A4  4280                     327          CLR.L   D0
000013A6  3018                     328          MOVE.W  (A0)+,D0
000013A8                           329          *Copy the word data we just moved into D0 into D7. We are copying this data
000013A8                           330          *So we always have a copy of the WHOLE instruction somewhere
000013A8  4287                     331          CLR.L   D7
000013AA  3E00                     332          MOVE.W  D0,D7
000013AC                           333          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000013AC                           334          *four bits of the instruction. Once we have just the first four bits, we can
000013AC                           335          *begin to see which 'bucket'/category this instruction falls into. 
000013AC  E048                     336          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013AE  E848                     337          LSR.W   #$04,D0
000013B0                           338          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013B0                           339          *list of buckets until we find which one this instruction falls into.
000013B0  6000 0068                340          BRA     BUCKET_0000     * Start with 0000
000013B4                           341  
000013B4                           342  
000013B4                           343  *-----------------------------------------------------------        
000013B4                           344  * Question Prompts
000013B4                           345  *-----------------------------------------------------------        
000013B4  43F9 0000236C            346  CONT_Q      LEA     QUES_CONT,A1
000013BA  303C 000E                347              MOVE    #14,D0
000013BE  4E4F                     348              TRAP    #15
000013C0  43F9 00002420            349              LEA     CONT,A1     *Need to store Y/N
000013C6  303C 0002                350              MOVE    #2,D0
000013CA  4E4F                     351              TRAP    #15
000013CC  0C01 0001                352              CMPI.B  #01,D1
000013D0  6600 FD62                353              BNE     INVALID1
000013D4  0C39 0059 00002420       354              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013DC  6600 0008                355              BNE     CHECK_Y
000013E0  3C3C 000F                356              MOVE    #MAX_LINE,D6    *Resets counter
000013E4  4E75                     357              RTS
000013E6  0C11 0079                358  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
000013EA  6600 0008                359              BNE     CHECK_N
000013EE  3C3C 000F                360              MOVE    #MAX_LINE,D6    *Resets counter
000013F2  4E75                     361              RTS
000013F4  0C11 004E                362  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
000013F8  6700 FC1A                363              BEQ     loop_1
000013FC  0C11 006E                364              CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001400  6700 FC12                365              BEQ     loop_1      
00001404                           366  
00001404  163C 0000                367  INV2        MOVE.B  #0,D3       *Reset bad flag
00001408  303C 0000                368              MOVE    #0,D0       *Prints invalid command msg if not found
0000140C  43F9 0000258E            369              LEA     INV_MSG,A1
00001412  303C 000E                370              MOVE    #14,D0
00001416  4E4F                     371              TRAP    #15
00001418  609A                     372              BRA     CONT_Q
0000141A                           373  
0000141A                           374  *-----------------------------------------------------------        
0000141A                           375  * Bucket 0000:
0000141A                           376  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
0000141A                           377  *                   BCHG(dynamic) | BCHG (static) | CMPI----
0000141A                           378  *-----------------------------------------------------------
0000141A                           379  BUCKET_0000
0000141A  =00000000                380  BUCKET0000_BITS EQU $0
0000141A  4281                     381          CLR.L   D1
0000141C                           382          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000141C  123C 0000                383          MOVE.B  #BUCKET0000_BITS,D1
00001420                           384          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0000. 
00001420                           385          *If equal, continue decoding. If not, branch to next bucket.
00001420  B200                     386          CMP.B   D0,D1
00001422  6600 0344                387          BNE     BUCKET_0001
00001426                           388  
00001426                           389          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001426                           390          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001426  3007                     391          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001428  0800 0008                392          BTST.L  #$08,D0
0000142C  6600 01A4                393          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to IS_BCHG_D
00001430                           394          
00001430                           395          *Now we can check bits 11-8 in the instruction and branch to different op-codes
00001430                           396          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
00001430  E048                     397          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001432  0880 0004                398          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001436  0880 0005                399          BCLR.L  #$05,D0
0000143A  0880 0006                400          BCLR.L  #$06,D0
0000143E  0880 0007                401          BCLR.L  #$07,D0
00001442                           402          
00001442                           403          *Perform compares with these 4 bits to see which specific instruction it is.
00001442  B03C 0006                404          CMP.B   #$06,D0 *Is this an ADDI?
00001446  6700 0028                405          BEQ     IS_ADDI
0000144A  B03C 0002                406          CMP.B   #$02,D0 *Is this an ANDI?
0000144E  6700 0096                407          BEQ     IS_ANDI
00001452  B03C 000A                408          CMP.B   #$0A,D0 *Is this an EORI?
00001456  6700 0104                409          BEQ     IS_EORI
0000145A  B03C 0008                410          CMP.B   #$08,D0 *Is this a BCHG(static)?
0000145E  6700 0210                411          BEQ     IS_BCHG_S
00001462  B03C 000C                412          CMP.B   #$0C,D0 *Is this a CMPI?
00001466  6700 028A                413          BEQ     IS_CMPI
0000146A                           414          
0000146A                           415          *If we get through all of the compares without finding the specific instruction,
0000146A                           416          *then this instruction is either not in our list of OP CODES to decode, or is an
0000146A                           417          *invalid instruction/syntax.
0000146A  4EF9 00001EA0            418          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
00001470                           419          
00001470                           420          
00001470                           421  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
00001470                           422  IS_ADDI
00001470                           423          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001470                           424          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001470  4281                     425          CLR.L   D1
00001472  3207                     426          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001474  C27C 00C0                427          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001478  EC09                     428          LSR.B   #$06,D1     *Shift the size bits into LSB
0000147A                           429          
0000147A  B23C 0003                430          CMP.B   #$03,D1     *Compare the size bits to $3
0000147E  6700 0A20                431          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001482                           432          
00001482                           433          *Output 'ADDI' to console...
00001482  43F9 0000245E            434          LEA     ADDI,A1     *Loads ADDI into address register A1
00001488  103C 000E                435          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000148C  4E4F                     436          TRAP    #15         *Displays Message
0000148E                           437          
0000148E                           438          
0000148E                           439          *Should have a valid ADDI op code. Set data up for EA.
0000148E                           440          
0000148E                           441          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000148E  4282                     442          CLR.L   D2
00001490  3407                     443          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001492  C47C 0038                444          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001496  E60A                     445          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001498                           446                  
00001498                           447          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001498  4283                     448          CLR.L   D3
0000149A  3607                     449          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000149C  C67C 0007                450          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000014A0                           451          
000014A0  4EF9 000014A6            452          JMP     EA_ADDI
000014A6                           453  
000014A6                           454  EA_ADDI
000014A6                           455          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
000014A6                           456          *and D3 holds the EA register.
000014A6                           457          
000014A6                           458          *Determine how much data to read in, depending on the size of the operation
000014A6                           459          *output the size of the operation and the immediate data to console
000014A6  4EB9 000018F4            460          JSR     WrapperSizeImmediate
000014AC                           461          
000014AC                           462          *manually output a comma here...
000014AC  43F9 00002576            463          LEA     Comma,A1        *Loads Comma into address register A1
000014B2  103C 000E                464          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014B6  4E4F                     465          TRAP    #15             *Displays Message        
000014B8                           466          
000014B8                           467          *Determine which EA mode and thus Register/Mem Address this instruction used
000014B8  B43C 0000                468          CMP.B   #$00,D2
000014BC  6700 055C                469          BEQ     DataRegMode *If EA mode is a data register, output that
000014C0                           470          
000014C0  B43C 0002                471          CMP.B   #$02,D2
000014C4  6700 0574                472          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014C8                           473          
000014C8  B43C 0003                474          CMP.B   #$03,D2
000014CC  6700 057C                475          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014D0                           476          
000014D0  B43C 0004                477          CMP.B   #$04,D2
000014D4  6700 0584                478          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014D8                           479          
000014D8  B43C 0007                480          CMP.B   #$07,D2
000014DC  6700 058C                481          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014E0                           482          
000014E0                           483          *If the ea mode isn't equal to any of these, it is an invalid EA
000014E0  4EF9 00001EB0            484          JMP     BADEACODE                               
000014E6                           485          
000014E6                           486  
000014E6                           487  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000014E6                           488  IS_ANDI
000014E6                           489          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014E6                           490          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014E6  4281                     491          CLR.L   D1
000014E8  3207                     492          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014EA  C27C 00C0                493          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014EE  EC09                     494          LSR.B   #$06,D1     *Shift the size bits into LSB
000014F0                           495          
000014F0  B23C 0003                496          CMP.B   #$03,D1     *Compare the size bits to $3
000014F4  6700 09AA                497          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014F8                           498          
000014F8                           499          *Output 'ANDI' to console...
000014F8  43F9 00002463            500          LEA     ANDI,A1     *Loads ANDI into address register A1
000014FE  103C 000E                501          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001502  4E4F                     502          TRAP    #15         *Displays Message
00001504                           503          
00001504                           504          
00001504                           505          *Should have a valid ANDI op code. Set data up for EA.
00001504                           506          
00001504                           507          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001504  4282                     508          CLR.L   D2
00001506  3407                     509          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001508  C47C 0038                510          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000150C  E60A                     511          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000150E                           512                  
0000150E                           513          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000150E  4283                     514          CLR.L   D3
00001510  3607                     515          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001512  C67C 0007                516          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001516                           517          
00001516  4EF9 0000151C            518          JMP     EA_ANDI
0000151C                           519  
0000151C                           520  EA_ANDI
0000151C                           521          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
0000151C                           522          *and D3 holds the EA register.
0000151C                           523          
0000151C                           524          *Determine how much data to read in, depending on the size of the operation
0000151C                           525          *output the size of the operation and the immediate data to console
0000151C  4EB9 000018F4            526          JSR     WrapperSizeImmediate
00001522                           527          
00001522                           528          *manually output a comma here...
00001522  43F9 00002576            529          LEA     Comma,A1        *Loads Comma into address register A1
00001528  103C 000E                530          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000152C  4E4F                     531          TRAP    #15             *Displays Message        
0000152E                           532          
0000152E                           533          *Determine which EA mode and thus Register/Mem Address this instruction used
0000152E  B43C 0000                534          CMP.B   #$00,D2
00001532  6700 04E6                535          BEQ     DataRegMode *If EA mode is a data register, output that
00001536                           536          
00001536  B43C 0002                537          CMP.B   #$02,D2
0000153A  6700 04FE                538          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000153E                           539          
0000153E  B43C 0003                540          CMP.B   #$03,D2
00001542  6700 0506                541          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001546                           542          
00001546  B43C 0004                543          CMP.B   #$04,D2
0000154A  6700 050E                544          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000154E                           545          
0000154E  B43C 0007                546          CMP.B   #$07,D2
00001552  6700 0516                547          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001556                           548          
00001556                           549          *If the ea mode isn't equal to any of these, it is an invalid EA
00001556  4EF9 00001EB0            550          JMP     BADEACODE
0000155C                           551          
0000155C                           552  
0000155C                           553  *Now we know this instruction is exactly EORI, lets set everything up for EA.
0000155C                           554  IS_EORI
0000155C                           555          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000155C                           556          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000155C  4281                     557          CLR.L   D1
0000155E  3207                     558          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001560  C27C 00C0                559          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001564  EC09                     560          LSR.B   #$06,D1     *Shift the size bits into LSB
00001566                           561          
00001566  B23C 0003                562          CMP.B   #$03,D1     *Compare the size bits to $3
0000156A  6700 0934                563          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000156E                           564          
0000156E                           565          *Output 'EORI' to console...
0000156E  43F9 00002468            566          LEA     EORI,A1     *Loads EORI into address register A1
00001574  103C 000E                567          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001578  4E4F                     568          TRAP    #15         *Displays Message
0000157A                           569          
0000157A                           570          
0000157A                           571          *Should have a valid EORI op code. Set data up for EA.
0000157A                           572          
0000157A                           573          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000157A  4282                     574          CLR.L   D2
0000157C  3407                     575          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000157E  C47C 0038                576          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001582  E60A                     577          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001584                           578                  
00001584                           579          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001584  4283                     580          CLR.L   D3
00001586  3607                     581          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001588  C67C 0007                582          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000158C                           583          
0000158C  4EF9 00001592            584          JMP     EA_EORI
00001592                           585  
00001592                           586  EA_EORI
00001592                           587          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
00001592                           588          *and D3 holds the EA register.
00001592                           589          
00001592                           590          *Determine how much data to read in, depending on the size of the operation
00001592                           591          *output the size of the operation and the immediate data to console
00001592  4EB9 000018F4            592          JSR     WrapperSizeImmediate
00001598                           593          
00001598                           594          *manually output a comma here...
00001598  43F9 00002576            595          LEA     Comma,A1        *Loads Comma into address register A1
0000159E  103C 000E                596          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015A2  4E4F                     597          TRAP    #15             *Displays Message        
000015A4                           598          
000015A4                           599          *Determine which EA mode and thus Register/Mem Address this instruction used
000015A4  B43C 0000                600          CMP.B   #$00,D2
000015A8  6700 0470                601          BEQ     DataRegMode *If EA mode is a data register, output that
000015AC                           602          
000015AC  B43C 0002                603          CMP.B   #$02,D2
000015B0  6700 0488                604          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015B4                           605          
000015B4  B43C 0003                606          CMP.B   #$03,D2
000015B8  6700 0490                607          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015BC                           608          
000015BC  B43C 0004                609          CMP.B   #$04,D2
000015C0  6700 0498                610          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015C4                           611          
000015C4  B43C 0007                612          CMP.B   #$07,D2
000015C8  6700 04A0                613          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015CC                           614          
000015CC                           615          *If the ea mode isn't equal to any of these, it is an invalid EA
000015CC  4EF9 00001EB0            616          JMP     BADEACODE
000015D2                           617  
000015D2                           618  
000015D2                           619  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015D2                           620  *everything up for EA, if is a legit instruction.
000015D2                           621  IS_BCHG_D
000015D2                           622          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015D2                           623          *invalid, branch to BADOPCODE
000015D2  3007                     624          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015D4  0800 0007                625          BTST.L  #$07,D0
000015D8  6600 08C6                626          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015DC  0800 0006                627          BTST.L  #$06,D0
000015E0  6700 08BE                628          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000015E4                           629          
000015E4                           630          *Output 'BCHG' to console...
000015E4  43F9 0000246D            631          LEA     BCHG,A1         *Loads BCHG into address register A1
000015EA  103C 000E                632          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015EE  4E4F                     633          TRAP    #15             *Displays Message
000015F0                           634                  
000015F0                           635                  
000015F0                           636          *Should have a valid BCHG op code. Set data up for EA.
000015F0                           637  
000015F0                           638          *Set D1 to the EA source register located in bits 11-9 of the instruction
000015F0  4281                     639          CLR.L   D1
000015F2  3207                     640          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015F4  C27C 0E00                641          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
000015F8  E049                     642          LSR.W   #$08,D1     *Shift the EA source register bits into LSB
000015FA  E249                     643          LSR.W   #$01,D1
000015FC                           644  
000015FC                           645          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015FC  4282                     646          CLR.L   D2
000015FE  3407                     647          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001600  C47C 0038                648          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001604  E60A                     649          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001606                           650                  
00001606                           651          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001606  4283                     652          CLR.L   D3
00001608  3607                     653          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000160A  C67C 0007                654          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000160E                           655  
0000160E  4EF9 00001614            656          JMP     EA_BCHG_D
00001614                           657  
00001614                           658  EA_BCHG_D
00001614                           659          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001614                           660          *D2 holds the EA mode, and D3 holds the EA register.
00001614                           661          
00001614                           662          *Determine the size of this BCHG instruction. Output the correct size...
00001614  4EB9 000019C2            663          JSR     BCHGSizeHelper
0000161A                           664          
0000161A                           665          *output the source register to console, flag D6 with a 1 so we come back...
0000161A  48E7 0200                666          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
0000161E  48E7 1000                667          MOVEM.L D3,-(SP)    *Push EA destination register into stack            
00001622  1C3C 0001                668          MOVE.B  #$01,D6     *Flag D6
00001626  1601                     669          MOVE.B  D1,D3       *Move source register into D3
00001628  4EB9 00001A1A            670          JSR     DataRegMode
0000162E  4CDF 0008                671          MOVEM.L (SP)+,D3    *Pull destination register back into D3
00001632  4CDF 0040                672          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001636                           673          
00001636                           674          *manually output a comma here...
00001636  43F9 00002576            675          LEA     Comma,A1        *Loads Comma into address register A1
0000163C  103C 000E                676          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001640  4E4F                     677          TRAP    #15             *Displays Message
00001642                           678          
00001642                           679          *Determine which EA mode and thus Register/Mem Address this instruction used
00001642  B43C 0000                680          CMP.B   #$00,D2
00001646  6700 03D2                681          BEQ     DataRegMode *If EA mode is a data register, output that
0000164A                           682          
0000164A  B43C 0002                683          CMP.B   #$02,D2
0000164E  6700 03EA                684          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001652                           685          
00001652  B43C 0003                686          CMP.B   #$03,D2
00001656  6700 03F2                687          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000165A                           688          
0000165A  B43C 0004                689          CMP.B   #$04,D2
0000165E  6700 03FA                690          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001662                           691          
00001662  B43C 0007                692          CMP.B   #$07,D2
00001666  6700 0402                693          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000166A                           694          
0000166A                           695          *If the ea mode isn't equal to any of these, it is an invalid EA
0000166A  4EF9 00001EB0            696          JMP     BADEACODE
00001670                           697  
00001670                           698  
00001670                           699  *Found a possible BCHG(static) instruction. Verify its bit integrity and then set up
00001670                           700  *everything up for EA, if is a legit instruction.
00001670                           701  IS_BCHG_S
00001670                           702          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
00001670                           703          *invalid, branch to BADOPCODE
00001670  3007                     704          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
00001672  0800 0007                705          BTST.L  #$07,D0
00001676  6600 0828                706          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
0000167A  0800 0006                707          BTST.L  #$06,D0
0000167E  6700 0820                708          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
00001682                           709          
00001682                           710          *Output 'BCHG' to console...
00001682  43F9 0000246D            711          LEA     BCHG,A1         *Loads BCHG into address register A1
00001688  103C 000E                712          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000168C  4E4F                     713          TRAP    #15             *Displays Message
0000168E                           714          
0000168E                           715          
0000168E                           716          *Should have a valid BCHG op code. Set data up for EA.
0000168E                           717          
0000168E                           718          *Move #$00 into D1, BCHG_S's immediate data is always in byte size
0000168E  4281                     719          CLR.L   D1
00001690  323C 0000                720          MOVE.W  #$00,D1
00001694                           721  
00001694                           722          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001694  4282                     723          CLR.L   D2
00001696  3407                     724          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001698  C47C 0038                725          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000169C  E60A                     726          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000169E                           727                  
0000169E                           728          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000169E  4283                     729          CLR.L   D3
000016A0  3607                     730          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000016A2  C67C 0007                731          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000016A6                           732  
000016A6  4EF9 000016AC            733          JMP     EA_BCHG_S
000016AC                           734  
000016AC                           735  EA_BCHG_S
000016AC                           736          *Decode the ea bits of BCHG(static). Assuming D2 holds the EA mode, and 
000016AC                           737          *D3 holds the EA register.
000016AC                           738          
000016AC                           739          *Determine the size of this BCHG instruction. Output the correct size...
000016AC  4EB9 000019C2            740          JSR     BCHGSizeHelper                
000016B2                           741          
000016B2                           742          *output the immediate data of this operation to console (always byte)...
000016B2  4EB9 000019F2            743          JSR     BCHGImmediate
000016B8                           744          
000016B8                           745          *manually output a comma here...
000016B8  43F9 00002576            746          LEA     Comma,A1        *Loads Comma into address register A1
000016BE  103C 000E                747          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016C2  4E4F                     748          TRAP    #15             *Displays Message
000016C4                           749          
000016C4                           750          *Determine which EA mode and thus Register/Mem Address this instruction used
000016C4  B43C 0000                751          CMP.B   #$00,D2
000016C8  6700 0350                752          BEQ     DataRegMode *If EA mode is a data register, output that
000016CC                           753          
000016CC  B43C 0002                754          CMP.B   #$02,D2
000016D0  6700 0368                755          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016D4                           756          
000016D4  B43C 0003                757          CMP.B   #$03,D2
000016D8  6700 0370                758          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016DC                           759          
000016DC  B43C 0004                760          CMP.B   #$04,D2
000016E0  6700 0378                761          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000016E4                           762          
000016E4  B43C 0007                763          CMP.B   #$07,D2
000016E8  6700 0380                764          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000016EC                           765          
000016EC                           766          *If the ea mode isn't equal to any of these, it is an invalid EA
000016EC  4EF9 00001EB0            767          JMP     BADEACODE
000016F2                           768  
000016F2                           769  
000016F2                           770  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000016F2                           771  IS_CMPI
000016F2                           772          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000016F2                           773          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000016F2  4281                     774          CLR.L   D1
000016F4  3207                     775          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000016F6  C27C 00C0                776          AND.W   #$00C0,D1   *Mask out everything but the size bits
000016FA  EC09                     777          LSR.B   #$06,D1     *Shift the size bits into LSB
000016FC                           778          
000016FC  B23C 0003                779          CMP.B   #$03,D1     *Compare the size bits to $3
00001700  6700 079E                780          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001704                           781          
00001704                           782          *Output 'CMPI' to console...
00001704  43F9 00002472            783          LEA     CMPI,A1     *Loads CMPI into address register A1
0000170A  103C 000E                784          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000170E  4E4F                     785          TRAP    #15         *Displays Message
00001710                           786          
00001710                           787          
00001710                           788          *Should have a valid CMPI op code. Set data up for EA.
00001710                           789          
00001710                           790          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001710  4282                     791          CLR.L   D2
00001712  3407                     792          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001714  C47C 0038                793          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001718  E60A                     794          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000171A                           795                  
0000171A                           796          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000171A  4283                     797          CLR.L   D3
0000171C  3607                     798          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000171E  C67C 0007                799          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001722                           800          
00001722  4EF9 00001728            801          JMP     EA_CMPI
00001728                           802  
00001728                           803  EA_CMPI
00001728                           804          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
00001728                           805          *and D3 holds the EA register.
00001728                           806          
00001728                           807          *Determine how much data to read in, depending on the size of the operation
00001728                           808          *output the size of the operation and the immediate data to console
00001728  4EB9 000018F4            809          JSR     WrapperSizeImmediate
0000172E                           810          
0000172E                           811          *manually output a comma here...
0000172E  43F9 00002576            812          LEA     Comma,A1        *Loads Comma into address register A1
00001734  103C 000E                813          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001738  4E4F                     814          TRAP    #15             *Displays Message
0000173A                           815          
0000173A                           816          *Determine which EA mode and thus Register/Mem Address this instruction used
0000173A  B43C 0000                817          CMP.B   #$00,D2
0000173E  6700 02DA                818          BEQ     DataRegMode *If EA mode is a data register, output that
00001742                           819          
00001742  B43C 0002                820          CMP.B   #$02,D2
00001746  6700 02F2                821          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000174A                           822          
0000174A  B43C 0003                823          CMP.B   #$03,D2
0000174E  6700 02FA                824          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001752                           825          
00001752  B43C 0004                826          CMP.B   #$04,D2
00001756  6700 0302                827          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000175A                           828          
0000175A  B43C 0007                829          CMP.B   #$07,D2
0000175E  6700 030A                830          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001762                           831          
00001762                           832          *If the ea mode isn't equal to any of these, it is an invalid EA
00001762  4EF9 00001EB0            833          JMP     BADEACODE
00001768                           834        
00001768                           835    
00001768                           836  *STARTS WITH 0001, MOVE.B-----------------------------------
00001768                           837  BUCKET_0001
00001768  =00000001                838  BUCKET0001_BITS EQU $1
00001768                           839          
00001768                           840          *some code...
00001768                           841  
00001768                           842  
00001768                           843  *STARTS WITH 0010, MOVE.L-----------------------------------
00001768                           844  BUCKET_0010
00001768  =00000002                845  BUCKET0010_BITS EQU $2
00001768                           846  
00001768                           847          *some code...
00001768                           848  
00001768                           849  
00001768                           850  *STARTS WITH 0011, MOVE.W-----------------------------------
00001768                           851  BUCKET_0011
00001768  =00000003                852  BUCKET0011_BITS EQU $3
00001768                           853  
00001768                           854          *some code...
00001768                           855  
00001768                           856  
00001768                           857  *-----------------------------------------------------------        
00001768                           858  * Bucket 0100:
00001768                           859  * STARTS WITH 0100, MOVEM | MULS(L)-------------------------
00001768                           860  *                   LEA | CLR | JSR | RTS-------------------
00001768                           861  *-----------------------------------------------------------
00001768                           862  BUCKET_0100
00001768  =00000004                863  BUCKET0100_BITS EQU $4
00001768  4281                     864          CLR.L   D1
0000176A                           865          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000176A  123C 0004                866          MOVE.B  #BUCKET0100_BITS,D1
0000176E                           867          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0100. 
0000176E                           868          *If equal, continue decoding. If not, branch to next bucket.
0000176E  B200                     869          CMP.B   D0,D1
00001770  6600 017C                870          BNE     BUCKET_0101
00001774                           871  
00001774                           872          *Test the 8th bit in this instruction, if it is 1, then it is an LEA 
00001774                           873          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1.
00001774  3007                     874          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001776  0800 0008                875          BTST.L  #$08,D0
0000177A  6600 0038                876          BNE     IS_LEA  *If the zbit was 0 (the 8th bit is 1), branch to IS_LEA
0000177E                           877  
0000177E                           878          *JSR/RTS in this bucket can only be determined by only bits 11-6
0000177E  C07C 0FC0                879          AND.W   #$0FC0,D0   *Mask out everything but bits 11-6
00001782  EC48                     880          LSR.W   #$06,D0     *Move bits 11-6 into LSB position
00001784                           881          
00001784                           882          *Check bits 11-6 in the instruction and branch to different either JSR or RTS 
00001784                           883          *depending on what the bits equal
00001784  B03C 003A                884          CMP.B   #$3A,D0 *Is this a JSR?
00001788  6700 010C                885          BEQ     IS_JSR
0000178C  B03C 0039                886          CMP.B   #$39,D0 *Is this a RTS?
00001790  6700 013C                887          BEQ     IS_RTS
00001794                           888  
00001794                           889          *Now we can use only bits 11-8 and branch to different op-codes only needing these
00001794                           890          *four bits to be unambiguous
00001794  E448                     891          LSR.W   #$02,D0 *Shift the 7-6 bits out, leaving only 11-8
00001796  B03C 0008                892          CMP.B   #$08,D0 *Is this a MOVEM(RegToMem)?
0000179A  6700 0018                893          BEQ     IS_MOVEM_RegToMem
0000179E  B03C 000C                894          CMP.B   #$0C,D0 *Is this a MOVEM(MemToReg)?
000017A2  6700 0010                895          BEQ     IS_MOVEM_MemToReg
000017A6  B03C 0002                896          CMP.B   #$02,D0 *Is this a CLR?
000017AA  6700 0080                897          BEQ     IS_CLR
000017AE                           898          
000017AE                           899          *If we get through all of the compares without finding the specific instruction,
000017AE                           900          *then this instruction is either not in our list of OP CODES to decode, or is an
000017AE                           901          *invalid instruction/syntax.
000017AE  4EF9 00001EA0            902          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000017B4                           903  
000017B4                           904  
000017B4                           905  *Now we know this instruction is exactly MOVEM(RegToMem), lets set everything up for EA.
000017B4                           906  IS_MOVEM_RegToMem
000017B4                           907  
000017B4                           908  EA_MOVEM_RegToMem
000017B4                           909  
000017B4                           910  
000017B4                           911  *Now we know this instruction is exactly MOVEM(MemToReg), lets set everything up for EA.
000017B4                           912  IS_MOVEM_MemToReg
000017B4                           913  
000017B4                           914  EA_MOVEM_MemToReg
000017B4                           915  
000017B4                           916  
000017B4                           917  *Now we know this instruction is exactly LEA, lets set everything up for EA.
000017B4                           918  IS_LEA
000017B4                           919          *Check bits 7 and 6, these should be 1 and 1. If not, this instruction is
000017B4                           920          *invalid, branch to BADOPCODE
000017B4  3007                     921          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000017B6  0800 0007                922          BTST.L  #$07,D0
000017BA  6700 06E4                923          BEQ     BADOPCODE  *If the zbit was 1 (the 7th bit is 0), branch to BADOPCODE
000017BE  0800 0006                924          BTST.L  #$06,D0
000017C2  6700 06DC                925          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000017C6                           926          
000017C6                           927          *Output 'LEA' to console...
000017C6  43F9 00002482            928          LEA     LEA,A1         *Loads LEA into address register A1
000017CC  103C 000E                929          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000017D0  4E4F                     930          TRAP    #15             *Displays Message
000017D2                           931          
000017D2                           932          
000017D2                           933          *Should have a valid LEA op code. Set data up for EA.      
000017D2                           934          
000017D2                           935          *Set D1 to the EA destination register located in bits 11-9 of the instruction
000017D2  4281                     936          CLR.L   D1
000017D4  3207                     937          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000017D6  C27C 0E00                938          AND.W   #$0E00,D1   *Mask out everything but the EA destination register bits
000017DA  E049                     939          LSR.W   #$08,D1     *Shift the EA destination register bits into LSB
000017DC  E249                     940          LSR.W   #$01,D1
000017DE                           941  
000017DE                           942          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000017DE  4282                     943          CLR.L   D2
000017E0  3407                     944          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000017E2  C47C 0038                945          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000017E6  E60A                     946          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000017E8                           947                  
000017E8                           948          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000017E8  4283                     949          CLR.L   D3
000017EA  3607                     950          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000017EC  C67C 0007                951          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000017F0                           952  
000017F0  4EF9 000017F6            953          JMP     EA_LEA       
000017F6                           954  
000017F6                           955  EA_LEA
000017F6                           956          *Decode the ea bits of LEA. Assuming D1 holds the destination register, D2 holds the
000017F6                           957          *EA mode, and D3 holds the EA register.
000017F6                           958          
000017F6                           959          *Determine which EA mode and thus Register/Mem Address this instruction used
000017F6  48E7 0200                960          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
000017FA  1C3C 0001                961          MOVE.B  #$01,D6     *Flag D6 so that we come back
000017FE                           962          
000017FE  B43C 0002                963          CMP.B   #$02,D2
00001802  6700 0202                964          BEQ     LEA_AddrIndirectWrapper *If EA mode is an addr indirect, output that
00001806                           965          
00001806  B43C 0007                966          CMP.B   #$07,D2
0000180A  6700 0204                967          BEQ     LEA_AddrAbsoluteWrapper *If EA mode is an addr absolute word/long, output that
0000180E                           968  
0000180E                           969  EA_LEA_WrapperEnd        
0000180E  4CDF 0040                970          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001812                           971                  
00001812                           972          *manually output a comma here...
00001812  43F9 00002576            973          LEA     Comma,A1        *Loads Comma into address register A1
00001818  103C 000E                974          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000181C  4E4F                     975          TRAP    #15             *Displays Message
0000181E                           976          
0000181E                           977          *output the destination address register to console
0000181E                           978          *Overwrite the EA register with destination register (no longer need D3 at this point)
0000181E  1601                     979          MOVE.B  D1,D3
00001820  4EB9 00001A2A            980          JSR     AddrRegMode
00001826                           981          
00001826                           982          *If the ea mode isn't equal to any of these, it is an invalid EA
00001826  4EF9 00001EB0            983          JMP     BADEACODE
0000182C                           984          
0000182C                           985          
0000182C                           986  *Now we know this instruction is exactly CLR, lets set everything up for EA.
0000182C                           987  IS_CLR
0000182C                           988          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000182C                           989          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000182C  4281                     990          CLR.L   D1
0000182E  3207                     991          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001830  C27C 00C0                992          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001834  EC09                     993          LSR.B   #$06,D1     *Shift the size bits into LSB
00001836                           994          
00001836  B23C 0003                995          CMP.B   #$03,D1     *Compare the size bits to $3
0000183A  6700 0664                996          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000183E                           997          
0000183E                           998          *Output 'CLR' to console...
0000183E  43F9 0000248C            999          LEA     CLR,A1      *Loads CLR into address register A1
00001844  103C 000E               1000          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001848  4E4F                    1001          TRAP    #15         *Displays Message
0000184A                          1002          
0000184A                          1003          
0000184A                          1004          *Should have a valid CLR op code. Set data up for EA.
0000184A                          1005          
0000184A                          1006          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000184A  4282                    1007          CLR.L   D2
0000184C  3407                    1008          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000184E  C47C 0038               1009          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001852  E60A                    1010          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001854                          1011                  
00001854                          1012          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001854  4283                    1013          CLR.L   D3
00001856  3607                    1014          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001858  C67C 0007               1015          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000185C                          1016          
0000185C  4EF9 00001862           1017          JMP     EA_CLR
00001862                          1018  
00001862                          1019  EA_CLR
00001862                          1020          *Decode the ea bits of CLR. Assuming D1 holds the size, D2 holds the EA mode,
00001862                          1021          *and D3 holds the EA register.
00001862                          1022          
00001862                          1023          *Determine how much data to read in, depending on the size of the operation
00001862                          1024          *output the size of the operation and the immediate data to console
00001862  4EB9 00001976           1025          JSR     WrapperSize       
00001868                          1026          
00001868                          1027          *Determine which EA mode and thus Register/Mem Address this instruction used
00001868  B43C 0000               1028          CMP.B   #$00,D2
0000186C  6700 01AC               1029          BEQ     DataRegMode *If EA mode is a data register, output that
00001870                          1030          
00001870  B43C 0002               1031          CMP.B   #$02,D2
00001874  6700 01C4               1032          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001878                          1033          
00001878  B43C 0003               1034          CMP.B   #$03,D2
0000187C  6700 01CC               1035          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001880                          1036          
00001880  B43C 0004               1037          CMP.B   #$04,D2
00001884  6700 01D4               1038          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001888                          1039          
00001888  B43C 0007               1040          CMP.B   #$07,D2
0000188C  6700 01DC               1041          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001890                          1042          
00001890                          1043          *If the ea mode isn't equal to any of these, it is an invalid EA
00001890  4EF9 00001EB0           1044          JMP     BADEACODE
00001896                          1045  
00001896                          1046  
00001896                          1047  *Now we know this instruction is exactly JSR, lets set everything up for EA.
00001896                          1048  IS_JSR        
00001896                          1049          *Output 'JSR' to console...
00001896  43F9 00002490           1050          LEA     JSR,A1      *Loads JSR into address register A1
0000189C  103C 000E               1051          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018A0  4E4F                    1052          TRAP    #15         *Displays Message
000018A2                          1053          
000018A2                          1054          
000018A2                          1055          *Should have a valid JSR op code. Set data up for EA.
000018A2                          1056          
000018A2                          1057          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000018A2  4282                    1058          CLR.L   D2
000018A4  3407                    1059          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000018A6  C47C 0038               1060          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000018AA  E60A                    1061          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000018AC                          1062                  
000018AC                          1063          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000018AC  4283                    1064          CLR.L   D3
000018AE  3607                    1065          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000018B0  C67C 0007               1066          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000018B4                          1067          
000018B4  4EF8 1862               1068          JMP     EA_CLR
000018B8                          1069  
000018B8                          1070  EA_JSR
000018B8                          1071          *Decode the ea bits of JSR. Assuming D1 holds the size, D2 holds the EA mode,
000018B8                          1072          *and D3 holds the EA register.               
000018B8                          1073          
000018B8                          1074          *Determine which EA mode and thus Register/Mem Address this instruction used        
000018B8  B43C 0002               1075          CMP.B   #$02,D2
000018BC  6700 017C               1076          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000018C0                          1077                         
000018C0  B43C 0007               1078          CMP.B   #$07,D2
000018C4  6700 01A4               1079          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000018C8                          1080          
000018C8                          1081          *If the ea mode isn't equal to any of these, it is an invalid EA
000018C8  4EF9 00001EB0           1082          JMP     BADEACODE
000018CE                          1083  
000018CE                          1084  
000018CE                          1085  *Now we know this instruction is exactly RTS, lets set everything up for EA.
000018CE                          1086  IS_RTS
000018CE                          1087          *Verify bits 5-0 of this instruction. If its not equal to %11 0101, it is an
000018CE                          1088          *invalid op code        
000018CE  4282                    1089          CLR.L   D2
000018D0  3407                    1090          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000018D2  C47C 003F               1091          AND.W   #$003F,D2   *Mask out everything but bits 5-0
000018D6                          1092          
000018D6                          1093          *Bits 5-0 aren't equal to $35, bad op code
000018D6  B43C 0035               1094          CMP.B   #$35,D2
000018DA  6600 05C4               1095          BNE     BADOPCODE
000018DE                          1096  
000018DE                          1097          *Output 'RTS' to console...
000018DE  43F9 0000249A           1098          LEA     RTS,A1      *Loads RTS into address register A1
000018E4  103C 000E               1099          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018E8  4E4F                    1100          TRAP    #15         *Displays Message
000018EA                          1101                          
000018EA                          1102          *Should have a valid RTS op code. Note: No EA decoding is needed for RTS!        
000018EA  4EF8 136C               1103          JMP     GRAB_NEXT_OP
000018EE                          1104  
000018EE                          1105  
000018EE                          1106  *STARTS WITH 0101, SUBQ-------------------------------------
000018EE                          1107  BUCKET_0101
000018EE  =00000005               1108  BUCKET0101_BITS EQU $5
000018EE                          1109  
000018EE                          1110          *some code...
000018EE                          1111  
000018EE                          1112  
000018EE                          1113  *STARTS WITH 0110, BCC--------------------------------------
000018EE                          1114  BUCKET_0110
000018EE  =00000006               1115  BUCKET0110_BITS EQU $6
000018EE                          1116  
000018EE                          1117          *some code...
000018EE                          1118  
000018EE                          1119  
000018EE                          1120  *STARTS WITH 1000, DIVU-------------------------------------
000018EE                          1121  BUCKET_1000
000018EE  =00000008               1122  BUCKET1000_BITS EQU $8
000018EE                          1123  
000018EE                          1124          *some code...
000018EE                          1125  
000018EE                          1126  
000018EE                          1127  *STARTS WITH 1001, SUBA-------------------------------------
000018EE                          1128  BUCKET_1001
000018EE  =00000009               1129  BUCKET1001_BITS EQU $9
000018EE                          1130  
000018EE                          1131          *some code...
000018EE                          1132  
000018EE                          1133  
000018EE                          1134  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000018EE                          1135  BUCKET_1011
000018EE  =0000000B               1136  BUCKET1011_BITS EQU $B
000018EE                          1137  
000018EE                          1138          *some code...
000018EE                          1139  
000018EE                          1140  
000018EE                          1141  *STARTS WITH 1100, MULS(W) | AND----------------------------
000018EE                          1142  BUCKET_1100
000018EE  =0000000C               1143  BUCKET1100_BITS EQU $C
000018EE                          1144  
000018EE                          1145          *some code...
000018EE                          1146  
000018EE                          1147  
000018EE                          1148  *STARTS WITH 1101, ADD | ADDA-------------------------------
000018EE                          1149  BUCKET_1101
000018EE  =0000000D               1150  BUCKET1101_BITS EQU $D
000018EE                          1151  
000018EE                          1152          *some code...
000018EE                          1153  
000018EE                          1154  
000018EE                          1155  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000018EE                          1156  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000018EE                          1157  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000018EE                          1158  BUCKET_1110
000018EE  =0000000E               1159  BUCKET1110_BITS EQU $E     
000018EE                          1160  
000018EE                          1161          *some code...
000018EE                          1162  
000018EE                          1163  
000018EE                          1164  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000018EE                          1165  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000018EE  4EF9 00001EA0           1166          JMP     BADOPCODE  
000018F4                          1167          
000018F4                          1168  
000018F4                          1169  *-----------------------------------------------------------        
000018F4                          1170  * EA operation size decoding functionality for immediate data
000018F4                          1171  *-----------------------------------------------------------   
000018F4                          1172  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
000018F4                          1173  WrapperSizeImmediate
000018F4  4284                    1174          CLR.L   D4
000018F6                          1175          *Depending on the EA size, choose which size to decode
000018F6  B23C 0000               1176          CMP.B   #$00,D1
000018FA  6700 0014               1177          BEQ     ByteSizeImmediate
000018FE                          1178          
000018FE  B23C 0001               1179          CMP.B   #$01,D1
00001902  6700 002E               1180          BEQ     WordSizeImmediate
00001906                          1181  
00001906  B23C 0002               1182          CMP.B   #$02,D1
0000190A  6700 0048               1183          BEQ     LongSizeImmediate
0000190E                          1184          
0000190E                          1185  *Used to get back to what we were doing, after dealing with the specific size
0000190E                          1186  WrapperSizeImmediateEnd
0000190E  4E75                    1187          RTS
00001910                          1188          
00001910                          1189  ByteSizeImmediate
00001910  3818                    1190          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
00001912                          1191          
00001912                          1192          *Output '.B' to console...
00001912  43F9 000024A4           1193          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001918  103C 000E               1194          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000191C  4E4F                    1195          TRAP    #15         *Displays Message
0000191E                          1196          
0000191E                          1197          *Output '#$' just before the immediate data
0000191E  43F9 0000257B           1198          LEA     ShaBang,A1
00001924  103C 000E               1199          MOVE.B  #14,D0
00001928  4E4F                    1200          TRAP    #15  
0000192A                          1201          
0000192A                          1202          *output the immediate data to console with the hex-ascii converter
0000192A  4EB8 11E6               1203          JSR     HEXASCII
0000192E                          1204                  
0000192E  4EF8 190E               1205          JMP     WrapperSizeImmediateEnd
00001932                          1206                  
00001932                          1207  WordSizeImmediate
00001932  3818                    1208          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001934                          1209          
00001934                          1210          *Output '.W' to console...
00001934  43F9 000024AB           1211          LEA     WordSize,A1 *Loads WordSize into address register A1
0000193A  103C 000E               1212          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000193E  4E4F                    1213          TRAP    #15         *Displays Message
00001940                          1214          
00001940                          1215          *Output '#$' just before the immediate data
00001940  43F9 0000257B           1216          LEA     ShaBang,A1
00001946  103C 000E               1217          MOVE.B  #14,D0
0000194A  4E4F                    1218          TRAP    #15  
0000194C                          1219          
0000194C                          1220          *output the immediate data to console with the hex-ascii converter
0000194C  4EB8 11E6               1221          JSR     HEXASCII
00001950                          1222          
00001950  4EF8 190E               1223          JMP     WrapperSizeImmediateEnd
00001954                          1224                  
00001954                          1225  LongSizeImmediate
00001954  2818                    1226          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
00001956                          1227          
00001956                          1228          *Output '.L' to console...
00001956  43F9 000024B2           1229          LEA     LongSize,A1 *Loads LongSize into address register A1
0000195C  103C 000E               1230          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001960  4E4F                    1231          TRAP    #15         *Displays Message
00001962                          1232          
00001962                          1233          *Output '#$' just before the immediate data
00001962  43F9 0000257B           1234          LEA     ShaBang,A1
00001968  103C 000E               1235          MOVE.B  #14,D0
0000196C  4E4F                    1236          TRAP    #15  
0000196E                          1237          
0000196E                          1238          *output the immediate data to console with the hex-ascii converter
0000196E  4EB8 11E6               1239          JSR     HEXASCII
00001972                          1240          
00001972  4EF8 190E               1241          JMP     WrapperSizeImmediateEnd        
00001976                          1242  
00001976                          1243  
00001976                          1244  *-----------------------------------------------------------        
00001976                          1245  * EA operation size decoding functionality for non-immediate data. Used to figure out
00001976                          1246  * and output the size affix for a typical opcode.
00001976                          1247  *-----------------------------------------------------------   
00001976                          1248  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001976                          1249  WrapperSize
00001976  4284                    1250          CLR.L   D4
00001978                          1251          *Depending on the EA size, choose which size to decode
00001978  B23C 0000               1252          CMP.B   #$00,D1
0000197C  6700 0014               1253          BEQ     ByteSizeOp
00001980                          1254          
00001980  B23C 0001               1255          CMP.B   #$01,D1
00001984  6700 001C               1256          BEQ     WordSizeOp
00001988                          1257  
00001988  B23C 0002               1258          CMP.B   #$02,D1
0000198C  6700 0024               1259          BEQ     LongSizeOp
00001990                          1260          
00001990                          1261  *Used to get back to what we were doing, after dealing with the specific size
00001990                          1262  WrapperSizeEnd
00001990  4E75                    1263          RTS
00001992                          1264          
00001992                          1265  ByteSizeOp                
00001992                          1266          *Output '.B' to console...
00001992  43F9 000024A4           1267          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001998  103C 000E               1268          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000199C  4E4F                    1269          TRAP    #15         *Displays Message                
0000199E                          1270                  
0000199E  4EF8 1990               1271          JMP     WrapperSizeEnd
000019A2                          1272                  
000019A2                          1273  WordSizeOp
000019A2                          1274          *Output '.W' to console...
000019A2  43F9 000024AB           1275          LEA     WordSize,A1 *Loads WordSize into address register A1
000019A8  103C 000E               1276          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019AC  4E4F                    1277          TRAP    #15         *Displays Message               
000019AE                          1278          
000019AE  4EF8 1990               1279          JMP     WrapperSizeEnd
000019B2                          1280                  
000019B2                          1281  LongSizeOp      
000019B2                          1282          *Output '.L' to console...
000019B2  43F9 000024B2           1283          LEA     LongSize,A1 *Loads LongSize into address register A1
000019B8  103C 000E               1284          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019BC  4E4F                    1285          TRAP    #15         *Displays Message                
000019BE                          1286          
000019BE  4EF8 1990               1287          JMP     WrapperSizeEnd        
000019C2                          1288  
000019C2                          1289  
000019C2                          1290  *-----------------------------------------------------------        
000019C2                          1291  * BCHG Size decoding functionality
000019C2                          1292  *----------------------------------------------------------- 
000019C2                          1293  BCHGSizeHelper
000019C2                          1294          *Determine if the EA mode is a data register. If so, output '.L' to console...
000019C2  B43C 0000               1295          CMP.B   #$00,D2
000019C6  6700 000A               1296          BEQ     BCHGLongSize
000019CA                          1297          
000019CA                          1298          *If the EA mode isn't a data register, WE MUST output a '.B' to console...
000019CA  4EF9 000019E2           1299          JMP     BCHGByteSize
000019D0                          1300          
000019D0                          1301  *Used to get back to what we were doing, after dealing with the specific size
000019D0                          1302  BCHGSizeHelperEnd
000019D0  4E75                    1303          RTS  
000019D2                          1304          
000019D2                          1305  BCHGLongSize
000019D2                          1306          *Output '.L' to console...
000019D2  43F9 000024B2           1307          LEA     LongSize,A1 *Loads LongSize into address register A1
000019D8  103C 000E               1308          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019DC  4E4F                    1309          TRAP    #15         *Displays Message
000019DE                          1310  
000019DE  4EF8 19D0               1311          JMP     BCHGSizeHelperEnd
000019E2                          1312          
000019E2                          1313  BCHGByteSize
000019E2                          1314          *Output '.B' to console...
000019E2  43F9 000024A4           1315          LEA     ByteSize,A1 *Loads ByteSize into address register A1
000019E8  103C 000E               1316          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019EC  4E4F                    1317          TRAP    #15         *Displays Message   
000019EE                          1318          
000019EE  4EF8 19D0               1319          JMP     BCHGSizeHelperEnd
000019F2                          1320          
000019F2                          1321  *Output the immediate data for a BCHG(static). Data is always byte size.
000019F2                          1322  BCHGImmediate
000019F2  3818                    1323          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word        
000019F4                          1324          
000019F4                          1325          *Output '#$' just before the immediate data
000019F4  43F9 0000257B           1326          LEA     ShaBang,A1
000019FA  103C 000E               1327          MOVE.B  #14,D0
000019FE  4E4F                    1328          TRAP    #15  
00001A00                          1329          
00001A00                          1330          *output the immediate data to console with the hex-ascii converter
00001A00  4EB8 11E6               1331          JSR     HEXASCII
00001A04                          1332                  
00001A04  4E75                    1333          RTS        
00001A06                          1334  
00001A06                          1335  
00001A06                          1336  *-----------------------------------------------------------        
00001A06                          1337  * LEA Wrappers to conform to design of EA mode/register as destination operand. 
00001A06                          1338  * LEA is weird in that its EA mode/register is used as a source operand.
00001A06                          1339  *-----------------------------------------------------------        
00001A06                          1340  *This conforms LEA to the JSR requirement of AddrIndirectMode. JMPs back to LEA after the JSR.
00001A06                          1341  LEA_AddrIndirectWrapper
00001A06  4EB9 00001A3A           1342          JSR     AddrIndirectMode
00001A0C                          1343          
00001A0C  4EF8 180E               1344          JMP     EA_LEA_WrapperEnd
00001A10                          1345          
00001A10                          1346  *This conforms LEA to the JSR requirement of AddrAbsoluteMode. JMPs back to LEA after the JSR.
00001A10                          1347  LEA_AddrAbsoluteWrapper
00001A10  4EB9 00001A6A           1348          JSR     AddrAbsoluteMode
00001A16                          1349          
00001A16  4EF8 180E               1350          JMP     EA_LEA_WrapperEnd
00001A1A                          1351  
00001A1A                          1352  
00001A1A                          1353  *-----------------------------------------------------------        
00001A1A                          1354  * EA Mode/EA Register decoding functionality
00001A1A                          1355  *-----------------------------------------------------------        
00001A1A                          1356  DataRegMode
00001A1A                          1357          *Depending on the EA Register, output a different register number
00001A1A  4EB9 00001A7A           1358          JSR     WrapperDataReg        
00001A20                          1359          
00001A20                          1360          *if this was called for a destination decoding then we are done decoding this        
00001A20                          1361          *instruction, go get the next instruction
00001A20  BC3C 0001               1362          CMP.B   #$01,D6
00001A24  6600 F946               1363          BNE     GRAB_NEXT_OP
00001A28                          1364          
00001A28                          1365          *else this was a source decoding, rts back to we can keep decoding
00001A28  4E75                    1366          RTS
00001A2A                          1367  
00001A2A                          1368  AddrRegMode
00001A2A  4EB9 00001B3C           1369          JSR     WrapperAddrReg
00001A30                          1370          
00001A30                          1371          *if this was called for a destination decoding then we are done decoding this        
00001A30                          1372          *instruction, go get the next instruction
00001A30  BC3C 0001               1373          CMP.B   #$01,D6
00001A34  6600 F936               1374          BNE     GRAB_NEXT_OP
00001A38                          1375          
00001A38                          1376          *else this was a source decoding, rts back to we can keep decoding
00001A38  4E75                    1377          RTS
00001A3A                          1378  
00001A3A                          1379  AddrIndirectMode
00001A3A                          1380          *Depending on the EA Register, output a different register number
00001A3A  4EB9 00001BFE           1381          JSR     WrapperAddrIndirect
00001A40                          1382                          
00001A40                          1383          *if this was called for a destination decoding then we are done decoding this        
00001A40                          1384          *instruction, go get the next instruction
00001A40  BC3C 0001               1385          CMP.B   #$01,D6
00001A44  6600 F926               1386          BNE     GRAB_NEXT_OP
00001A48                          1387          
00001A48                          1388          *else this was a source decoding, rts back to we can keep decoding
00001A48  4E75                    1389          RTS
00001A4A                          1390  
00001A4A                          1391  AddrIndirectPostMode
00001A4A                          1392          *Depending on the EA Register, output a different register number
00001A4A  4EB9 00001CC0           1393          JSR     WrapperAddrIndirectPost
00001A50                          1394  
00001A50                          1395          *if this was called for a destination decoding then we are done decoding this        
00001A50                          1396          *instruction, go get the next instruction
00001A50  BC3C 0001               1397          CMP.B   #$01,D6
00001A54  6600 F916               1398          BNE     GRAB_NEXT_OP
00001A58                          1399          
00001A58                          1400          *else this was a source decoding, rts back to we can keep decoding
00001A58  4E75                    1401          RTS
00001A5A                          1402  
00001A5A                          1403  AddrIndirectPreMode
00001A5A                          1404          *Depending on the EA Register, output a different register number
00001A5A  4EB9 00001D82           1405          JSR     WrapperAddrIndirectPre
00001A60                          1406  
00001A60                          1407          *if this was called for a destination decoding then we are done decoding this        
00001A60                          1408          *instruction, go get the next instruction
00001A60  BC3C 0001               1409          CMP.B   #$01,D6
00001A64  6600 F906               1410          BNE     GRAB_NEXT_OP
00001A68                          1411          
00001A68                          1412          *else this was a source decoding, rts back to we can keep decoding
00001A68  4E75                    1413          RTS
00001A6A                          1414  
00001A6A                          1415  AddrAbsoluteMode
00001A6A                          1416          *Depending on the EA Register, output a different register number
00001A6A  4EB9 00001E44           1417          JSR     WrapperAddrAbsolute        
00001A70                          1418  
00001A70                          1419          *if this was called for a destination decoding then we are done decoding this        
00001A70                          1420          *instruction, go get the next instruction
00001A70  BC3C 0001               1421          CMP.B   #$01,D6
00001A74  6600 F8F6               1422          BNE     GRAB_NEXT_OP
00001A78                          1423          
00001A78                          1424          *else this was a source decoding, rts back to we can keep decoding
00001A78  4E75                    1425          RTS
00001A7A                          1426          
00001A7A                          1427  ImmediateDataMode
00001A7A                          1428          *some code        
00001A7A                          1429          
00001A7A                          1430          
00001A7A                          1431  *-----------------------------------------------------------        
00001A7A                          1432  * Output logic for all Data Registers (0-7)
00001A7A                          1433  *-----------------------------------------------------------
00001A7A                          1434  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001A7A                          1435  WrapperDataReg
00001A7A                          1436          *Depending on the EA destination register, output a different register number
00001A7A  B63C 0000               1437          CMP.B   #$00,D3
00001A7E  6700 003C               1438          BEQ     DataReg0
00001A82                          1439          
00001A82  B63C 0001               1440          CMP.B   #$01,D3
00001A86  6700 0044               1441          BEQ     DataReg1
00001A8A                          1442          
00001A8A  B63C 0002               1443          CMP.B   #$02,D3
00001A8E  6700 004C               1444          BEQ     DataReg2
00001A92                          1445          
00001A92  B63C 0003               1446          CMP.B   #$03,D3
00001A96  6700 0054               1447          BEQ     DataReg3
00001A9A                          1448          
00001A9A  B63C 0004               1449          CMP.B   #$04,D3
00001A9E  6700 005C               1450          BEQ     DataReg4
00001AA2                          1451          
00001AA2  B63C 0005               1452          CMP.B   #$05,D3
00001AA6  6700 0064               1453          BEQ     DataReg5
00001AAA                          1454          
00001AAA  B63C 0006               1455          CMP.B   #$06,D3
00001AAE  6700 006C               1456          BEQ     DataReg6
00001AB2                          1457          
00001AB2  B63C 0007               1458          CMP.B   #$07,D3
00001AB6  6700 0074               1459          BEQ     DataReg7        
00001ABA                          1460  
00001ABA                          1461  *Used to get back to 'DataRegMode', after dealing with the specific register
00001ABA                          1462  WrapperDataRegEnd
00001ABA  4E75                    1463          RTS
00001ABC                          1464  
00001ABC                          1465  DataReg0
00001ABC                          1466          *Output the specific data register...
00001ABC  43F9 000024B9           1467          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
00001AC2  103C 000E               1468          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001AC6  4E4F                    1469          TRAP    #15             *Displays Message   
00001AC8                          1470          
00001AC8  4EF8 1ABA               1471          JMP     WrapperDataRegEnd
00001ACC                          1472  
00001ACC                          1473  DataReg1
00001ACC  43F9 000024BC           1474          LEA     OutDataReg1,A1
00001AD2  103C 000E               1475          MOVE.B  #14,D0
00001AD6  4E4F                    1476          TRAP    #15
00001AD8                          1477          
00001AD8  4EF8 1ABA               1478          JMP     WrapperDataRegEnd
00001ADC                          1479  
00001ADC                          1480  DataReg2
00001ADC  43F9 000024BF           1481          LEA     OutDataReg2,A1
00001AE2  103C 000E               1482          MOVE.B  #14,D0
00001AE6  4E4F                    1483          TRAP    #15
00001AE8                          1484  
00001AE8  4EF8 1ABA               1485          JMP     WrapperDataRegEnd
00001AEC                          1486      
00001AEC                          1487  DataReg3
00001AEC  43F9 000024C2           1488          LEA     OutDataReg3,A1
00001AF2  103C 000E               1489          MOVE.B  #14,D0
00001AF6  4E4F                    1490          TRAP    #15
00001AF8                          1491  
00001AF8  4EF8 1ABA               1492          JMP     WrapperDataRegEnd
00001AFC                          1493          
00001AFC                          1494  DataReg4
00001AFC  43F9 000024C5           1495          LEA     OutDataReg4,A1
00001B02  103C 000E               1496          MOVE.B  #14,D0
00001B06  4E4F                    1497          TRAP    #15
00001B08                          1498  
00001B08  4EF8 1ABA               1499          JMP     WrapperDataRegEnd
00001B0C                          1500                 
00001B0C                          1501  DataReg5
00001B0C  43F9 000024C8           1502          LEA     OutDataReg5,A1
00001B12  103C 000E               1503          MOVE.B  #14,D0
00001B16  4E4F                    1504          TRAP    #15
00001B18                          1505  
00001B18  4EF8 1ABA               1506          JMP     WrapperDataRegEnd
00001B1C                          1507          
00001B1C                          1508  DataReg6
00001B1C  43F9 000024CB           1509          LEA     OutDataReg6,A1 A1
00001B22  103C 000E               1510          MOVE.B  #14,D0
00001B26  4E4F                    1511          TRAP    #15
00001B28                          1512  
00001B28  4EF8 1ABA               1513          JMP     WrapperDataRegEnd
00001B2C                          1514          
00001B2C                          1515  DataReg7
00001B2C  43F9 000024CE           1516          LEA     OutDataReg7,A1
00001B32  103C 000E               1517          MOVE.B  #14,D0
00001B36  4E4F                    1518          TRAP    #15
00001B38                          1519          
00001B38  4EF8 1ABA               1520          JMP     WrapperDataRegEnd
00001B3C                          1521  
00001B3C                          1522  
00001B3C                          1523  *-----------------------------------------------------------        
00001B3C                          1524  * Output logic for all Address Registers (0-7)
00001B3C                          1525  *-----------------------------------------------------------     
00001B3C                          1526  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001B3C                          1527  WrapperAddrReg
00001B3C                          1528          *Depending on the EA Register, output a different register number
00001B3C  B63C 0000               1529          CMP.B   #$00,D3
00001B40  6700 003C               1530          BEQ     AddrReg0
00001B44                          1531          
00001B44  B63C 0001               1532          CMP.B   #$01,D3
00001B48  6700 0044               1533          BEQ     AddrReg1
00001B4C                          1534          
00001B4C  B63C 0002               1535          CMP.B   #$02,D3
00001B50  6700 004C               1536          BEQ     AddrReg2
00001B54                          1537          
00001B54  B63C 0003               1538          CMP.B   #$03,D3
00001B58  6700 0054               1539          BEQ     AddrReg3
00001B5C                          1540          
00001B5C  B63C 0004               1541          CMP.B   #$04,D3
00001B60  6700 005C               1542          BEQ     AddrReg4
00001B64                          1543          
00001B64  B63C 0005               1544          CMP.B   #$05,D3
00001B68  6700 0064               1545          BEQ     AddrReg5
00001B6C                          1546          
00001B6C  B63C 0006               1547          CMP.B   #$06,D3
00001B70  6700 006C               1548          BEQ     AddrReg6
00001B74                          1549          
00001B74  B63C 0007               1550          CMP.B   #$07,D3
00001B78  6700 0074               1551          BEQ     AddrReg7
00001B7C                          1552  
00001B7C                          1553  *Used to get back to 'AddrRegMode', after dealing with the specific register
00001B7C                          1554  WrapperAddrRegEnd
00001B7C  4E75                    1555          RTS        
00001B7E                          1556  
00001B7E                          1557  AddrReg0
00001B7E                          1558          *Output the specific address indirect register...
00001B7E  43F9 000024D1           1559          LEA     OutAddrReg0,A1      *Loads AddrReg0 into address register A1
00001B84  103C 000E               1560          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001B88  4E4F                    1561          TRAP    #15                 *Displays Message        
00001B8A                          1562          
00001B8A  4EF8 1B7C               1563          JMP     WrapperAddrRegEnd
00001B8E                          1564  
00001B8E                          1565  AddrReg1
00001B8E  43F9 000024D4           1566          LEA     OutAddrReg1,A1
00001B94  103C 000E               1567          MOVE.B  #14,D0
00001B98  4E4F                    1568          TRAP    #15
00001B9A                          1569          
00001B9A  4EF8 1B7C               1570          JMP     WrapperAddrRegEnd
00001B9E                          1571  
00001B9E                          1572  AddrReg2
00001B9E  43F9 000024D7           1573          LEA     OutAddrReg2,A1
00001BA4  103C 000E               1574          MOVE.B  #14,D0
00001BA8  4E4F                    1575          TRAP    #15
00001BAA                          1576          
00001BAA  4EF8 1B7C               1577          JMP     WrapperAddrRegEnd
00001BAE                          1578  
00001BAE                          1579  AddrReg3
00001BAE  43F9 000024DA           1580          LEA     OutAddrReg3,A1
00001BB4  103C 000E               1581          MOVE.B  #14,D0
00001BB8  4E4F                    1582          TRAP    #15
00001BBA                          1583          
00001BBA  4EF8 1B7C               1584          JMP     WrapperAddrRegEnd
00001BBE                          1585  
00001BBE                          1586  AddrReg4
00001BBE  43F9 000024DD           1587          LEA     OutAddrReg4,A1
00001BC4  103C 000E               1588          MOVE.B  #14,D0
00001BC8  4E4F                    1589          TRAP    #15
00001BCA                          1590          
00001BCA  4EF8 1B7C               1591          JMP     WrapperAddrRegEnd
00001BCE                          1592  
00001BCE                          1593  AddrReg5
00001BCE  43F9 000024E0           1594          LEA     OutAddrReg5,A1
00001BD4  103C 000E               1595          MOVE.B  #14,D0
00001BD8  4E4F                    1596          TRAP    #15
00001BDA                          1597          
00001BDA  4EF8 1B7C               1598          JMP     WrapperAddrRegEnd
00001BDE                          1599  
00001BDE                          1600  AddrReg6
00001BDE  43F9 000024E3           1601          LEA     OutAddrReg6,A1
00001BE4  103C 000E               1602          MOVE.B  #14,D0
00001BE8  4E4F                    1603          TRAP    #15
00001BEA                          1604          
00001BEA  4EF8 1B7C               1605          JMP     WrapperAddrRegEnd
00001BEE                          1606  
00001BEE                          1607  AddrReg7
00001BEE  43F9 000024E6           1608          LEA     OutAddrReg7,A1
00001BF4  103C 000E               1609          MOVE.B  #14,D0
00001BF8  4E4F                    1610          TRAP    #15
00001BFA                          1611          
00001BFA  4EF8 1B7C               1612          JMP     WrapperAddrRegEnd
00001BFE                          1613  
00001BFE                          1614  
00001BFE                          1615  *-----------------------------------------------------------        
00001BFE                          1616  * Output logic for all Address Indirect Registers (0-7)
00001BFE                          1617  *-----------------------------------------------------------     
00001BFE                          1618  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001BFE                          1619  WrapperAddrIndirect
00001BFE                          1620          *Depending on the EA Register, output a different register number
00001BFE  B63C 0000               1621          CMP.B   #$00,D3
00001C02  6700 003C               1622          BEQ     AddrIndReg0
00001C06                          1623          
00001C06  B63C 0001               1624          CMP.B   #$01,D3
00001C0A  6700 0044               1625          BEQ     AddrIndReg1
00001C0E                          1626          
00001C0E  B63C 0002               1627          CMP.B   #$02,D3
00001C12  6700 004C               1628          BEQ     AddrIndReg2
00001C16                          1629          
00001C16  B63C 0003               1630          CMP.B   #$03,D3
00001C1A  6700 0054               1631          BEQ     AddrIndReg3
00001C1E                          1632          
00001C1E  B63C 0004               1633          CMP.B   #$04,D3
00001C22  6700 005C               1634          BEQ     AddrIndReg4
00001C26                          1635          
00001C26  B63C 0005               1636          CMP.B   #$05,D3
00001C2A  6700 0064               1637          BEQ     AddrIndReg5
00001C2E                          1638          
00001C2E  B63C 0006               1639          CMP.B   #$06,D3
00001C32  6700 006C               1640          BEQ     AddrIndReg6
00001C36                          1641          
00001C36  B63C 0007               1642          CMP.B   #$07,D3
00001C3A  6700 0074               1643          BEQ     AddrIndReg7
00001C3E                          1644  
00001C3E                          1645  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
00001C3E                          1646  WrapperAddrIndirectEnd
00001C3E  4E75                    1647          RTS        
00001C40                          1648  
00001C40                          1649  AddrIndReg0
00001C40                          1650          *Output the specific address indirect register...
00001C40  43F9 000024E9           1651          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001C46  103C 000E               1652          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001C4A  4E4F                    1653          TRAP    #15                 *Displays Message        
00001C4C                          1654          
00001C4C  4EF8 1C3E               1655          JMP     WrapperAddrIndirectEnd
00001C50                          1656  
00001C50                          1657  AddrIndReg1
00001C50  43F9 000024EE           1658          LEA     OutAddrIndReg1,A1
00001C56  103C 000E               1659          MOVE.B  #14,D0
00001C5A  4E4F                    1660          TRAP    #15
00001C5C                          1661          
00001C5C  4EF8 1C3E               1662          JMP     WrapperAddrIndirectEnd
00001C60                          1663  
00001C60                          1664  AddrIndReg2
00001C60  43F9 000024F3           1665          LEA     OutAddrIndReg2,A1
00001C66  103C 000E               1666          MOVE.B  #14,D0
00001C6A  4E4F                    1667          TRAP    #15
00001C6C                          1668          
00001C6C  4EF8 1C3E               1669          JMP     WrapperAddrIndirectEnd
00001C70                          1670  
00001C70                          1671  AddrIndReg3
00001C70  43F9 000024F8           1672          LEA     OutAddrIndReg3,A1
00001C76  103C 000E               1673          MOVE.B  #14,D0
00001C7A  4E4F                    1674          TRAP    #15
00001C7C                          1675          
00001C7C  4EF8 1C3E               1676          JMP     WrapperAddrIndirectEnd
00001C80                          1677  
00001C80                          1678  AddrIndReg4
00001C80  43F9 000024FD           1679          LEA     OutAddrIndReg4,A1
00001C86  103C 000E               1680          MOVE.B  #14,D0
00001C8A  4E4F                    1681          TRAP    #15
00001C8C                          1682          
00001C8C  4EF8 1C3E               1683          JMP     WrapperAddrIndirectEnd
00001C90                          1684  
00001C90                          1685  AddrIndReg5
00001C90  43F9 00002502           1686          LEA     OutAddrIndReg5,A1
00001C96  103C 000E               1687          MOVE.B  #14,D0
00001C9A  4E4F                    1688          TRAP    #15
00001C9C                          1689          
00001C9C  4EF8 1C3E               1690          JMP     WrapperAddrIndirectEnd
00001CA0                          1691  
00001CA0                          1692  AddrIndReg6
00001CA0  43F9 00002507           1693          LEA     OutAddrIndReg6,A1
00001CA6  103C 000E               1694          MOVE.B  #14,D0
00001CAA  4E4F                    1695          TRAP    #15
00001CAC                          1696          
00001CAC  4EF8 1C3E               1697          JMP     WrapperAddrIndirectEnd
00001CB0                          1698  
00001CB0                          1699  AddrIndReg7
00001CB0  43F9 0000250C           1700          LEA     OutAddrIndReg7,A1
00001CB6  103C 000E               1701          MOVE.B  #14,D0
00001CBA  4E4F                    1702          TRAP    #15
00001CBC                          1703          
00001CBC  4EF8 1C3E               1704          JMP     WrapperAddrIndirectEnd
00001CC0                          1705          
00001CC0                          1706          
00001CC0                          1707  *-----------------------------------------------------------        
00001CC0                          1708  * Output logic for all Address Indirect Post Increment Registers (0-7)
00001CC0                          1709  *-----------------------------------------------------------     
00001CC0                          1710  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001CC0                          1711  WrapperAddrIndirectPost
00001CC0                          1712          *Depending on the EA Register, output a different register number
00001CC0  B63C 0000               1713          CMP.B   #$00,D3
00001CC4  6700 003C               1714          BEQ     AddrIndPoReg0
00001CC8                          1715          
00001CC8  B63C 0001               1716          CMP.B   #$01,D3
00001CCC  6700 0044               1717          BEQ     AddrIndPoReg1
00001CD0                          1718          
00001CD0  B63C 0002               1719          CMP.B   #$02,D3
00001CD4  6700 004C               1720          BEQ     AddrIndPoReg2
00001CD8                          1721          
00001CD8  B63C 0003               1722          CMP.B   #$03,D3
00001CDC  6700 0054               1723          BEQ     AddrIndPoReg3
00001CE0                          1724          
00001CE0  B63C 0004               1725          CMP.B   #$04,D3
00001CE4  6700 005C               1726          BEQ     AddrIndPoReg4
00001CE8                          1727          
00001CE8  B63C 0005               1728          CMP.B   #$05,D3
00001CEC  6700 0064               1729          BEQ     AddrIndPoReg5
00001CF0                          1730          
00001CF0  B63C 0006               1731          CMP.B   #$06,D3
00001CF4  6700 006C               1732          BEQ     AddrIndPoReg6
00001CF8                          1733          
00001CF8  B63C 0007               1734          CMP.B   #$07,D3
00001CFC  6700 0074               1735          BEQ     AddrIndPoReg7
00001D00                          1736  
00001D00                          1737  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
00001D00                          1738  WrapperAddrIndirectPostEnd
00001D00  4E75                    1739          RTS        
00001D02                          1740  
00001D02                          1741  AddrIndPoReg0
00001D02                          1742          *Output the specific address indirect post register...
00001D02  43F9 00002511           1743          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001D08  103C 000E               1744          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001D0C  4E4F                    1745          TRAP    #15                 *Displays Message        
00001D0E                          1746          
00001D0E  4EF8 1D00               1747          JMP     WrapperAddrIndirectPostEnd
00001D12                          1748  
00001D12                          1749  AddrIndPoReg1
00001D12  43F9 00002517           1750          LEA     OutAddrIndPoReg1,A1
00001D18  103C 000E               1751          MOVE.B  #14,D0
00001D1C  4E4F                    1752          TRAP    #15
00001D1E                          1753          
00001D1E  4EF8 1D00               1754          JMP     WrapperAddrIndirectPostEnd
00001D22                          1755  
00001D22                          1756  AddrIndPoReg2
00001D22  43F9 0000251D           1757          LEA     OutAddrIndPoReg2,A1
00001D28  103C 000E               1758          MOVE.B  #14,D0
00001D2C  4E4F                    1759          TRAP    #15
00001D2E                          1760          
00001D2E  4EF8 1D00               1761          JMP     WrapperAddrIndirectPostEnd
00001D32                          1762  
00001D32                          1763  AddrIndPoReg3
00001D32  43F9 00002523           1764          LEA     OutAddrIndPoReg3,A1
00001D38  103C 000E               1765          MOVE.B  #14,D0
00001D3C  4E4F                    1766          TRAP    #15
00001D3E                          1767          
00001D3E  4EF8 1D00               1768          JMP     WrapperAddrIndirectPostEnd
00001D42                          1769  
00001D42                          1770  AddrIndPoReg4
00001D42  43F9 00002529           1771          LEA     OutAddrIndPoReg4,A1
00001D48  103C 000E               1772          MOVE.B  #14,D0
00001D4C  4E4F                    1773          TRAP    #15
00001D4E                          1774          
00001D4E  4EF8 1D00               1775          JMP     WrapperAddrIndirectPostEnd
00001D52                          1776  
00001D52                          1777  AddrIndPoReg5
00001D52  43F9 0000252F           1778          LEA     OutAddrIndPoReg5,A1
00001D58  103C 000E               1779          MOVE.B  #14,D0
00001D5C  4E4F                    1780          TRAP    #15
00001D5E                          1781          
00001D5E  4EF8 1D00               1782          JMP     WrapperAddrIndirectPostEnd
00001D62                          1783  
00001D62                          1784  AddrIndPoReg6
00001D62  43F9 00002535           1785          LEA     OutAddrIndPoReg6,A1
00001D68  103C 000E               1786          MOVE.B  #14,D0
00001D6C  4E4F                    1787          TRAP    #15
00001D6E                          1788          
00001D6E  4EF8 1D00               1789          JMP     WrapperAddrIndirectPostEnd
00001D72                          1790  
00001D72                          1791  AddrIndPoReg7
00001D72  43F9 0000253B           1792          LEA     OutAddrIndPoReg7,A1
00001D78  103C 000E               1793          MOVE.B  #14,D0
00001D7C  4E4F                    1794          TRAP    #15
00001D7E                          1795          
00001D7E  4EF8 1D00               1796          JMP     WrapperAddrIndirectPostEnd
00001D82                          1797  
00001D82                          1798  
00001D82                          1799  *-----------------------------------------------------------        
00001D82                          1800  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001D82                          1801  *-----------------------------------------------------------     
00001D82                          1802  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001D82                          1803  WrapperAddrIndirectPre
00001D82                          1804          *Depending on the EA Register, output a different register number
00001D82  B63C 0000               1805          CMP.B   #$00,D3
00001D86  6700 003C               1806          BEQ     AddrIndPrReg0
00001D8A                          1807          
00001D8A  B63C 0001               1808          CMP.B   #$01,D3
00001D8E  6700 0044               1809          BEQ     AddrIndPrReg1
00001D92                          1810          
00001D92  B63C 0002               1811          CMP.B   #$02,D3
00001D96  6700 004C               1812          BEQ     AddrIndPrReg2
00001D9A                          1813          
00001D9A  B63C 0003               1814          CMP.B   #$03,D3
00001D9E  6700 0054               1815          BEQ     AddrIndPrReg3
00001DA2                          1816          
00001DA2  B63C 0004               1817          CMP.B   #$04,D3
00001DA6  6700 005C               1818          BEQ     AddrIndPrReg4
00001DAA                          1819          
00001DAA  B63C 0005               1820          CMP.B   #$05,D3
00001DAE  6700 0064               1821          BEQ     AddrIndPrReg5
00001DB2                          1822          
00001DB2  B63C 0006               1823          CMP.B   #$06,D3
00001DB6  6700 006C               1824          BEQ     AddrIndPrReg6
00001DBA                          1825          
00001DBA  B63C 0007               1826          CMP.B   #$07,D3
00001DBE  6700 0074               1827          BEQ     AddrIndPrReg7
00001DC2                          1828  
00001DC2                          1829  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001DC2                          1830  WrapperAddrIndirectPreEnd
00001DC2  4E75                    1831          RTS        
00001DC4                          1832  
00001DC4                          1833  AddrIndPrReg0
00001DC4                          1834          *Output the specific address indirect post register...
00001DC4  43F9 00002541           1835          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001DCA  103C 000E               1836          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001DCE  4E4F                    1837          TRAP    #15                 *Displays Message        
00001DD0                          1838          
00001DD0  4EF8 1DC2               1839          JMP     WrapperAddrIndirectPreEnd
00001DD4                          1840  
00001DD4                          1841  AddrIndPrReg1
00001DD4  43F9 00002547           1842          LEA     OutAddrIndPrReg1,A1
00001DDA  103C 000E               1843          MOVE.B  #14,D0
00001DDE  4E4F                    1844          TRAP    #15
00001DE0                          1845          
00001DE0  4EF8 1DC2               1846          JMP     WrapperAddrIndirectPreEnd
00001DE4                          1847  
00001DE4                          1848  AddrIndPrReg2
00001DE4  43F9 0000254D           1849          LEA     OutAddrIndPrReg2,A1
00001DEA  103C 000E               1850          MOVE.B  #14,D0
00001DEE  4E4F                    1851          TRAP    #15
00001DF0                          1852          
00001DF0  4EF8 1DC2               1853          JMP     WrapperAddrIndirectPreEnd
00001DF4                          1854  
00001DF4                          1855  AddrIndPrReg3
00001DF4  43F9 00002553           1856          LEA     OutAddrIndPrReg3,A1
00001DFA  103C 000E               1857          MOVE.B  #14,D0
00001DFE  4E4F                    1858          TRAP    #15
00001E00                          1859          
00001E00  4EF8 1DC2               1860          JMP     WrapperAddrIndirectPreEnd
00001E04                          1861  
00001E04                          1862  AddrIndPrReg4
00001E04  43F9 00002559           1863          LEA     OutAddrIndPrReg4,A1
00001E0A  103C 000E               1864          MOVE.B  #14,D0
00001E0E  4E4F                    1865          TRAP    #15
00001E10                          1866          
00001E10  4EF8 1DC2               1867          JMP     WrapperAddrIndirectPreEnd
00001E14                          1868  
00001E14                          1869  AddrIndPrReg5
00001E14  43F9 0000255F           1870          LEA     OutAddrIndPrReg5,A1
00001E1A  103C 000E               1871          MOVE.B  #14,D0
00001E1E  4E4F                    1872          TRAP    #15
00001E20                          1873          
00001E20  4EF8 1DC2               1874          JMP     WrapperAddrIndirectPreEnd
00001E24                          1875  
00001E24                          1876  AddrIndPrReg6
00001E24  43F9 00002565           1877          LEA     OutAddrIndPrReg6,A1
00001E2A  103C 000E               1878          MOVE.B  #14,D0
00001E2E  4E4F                    1879          TRAP    #15
00001E30                          1880          
00001E30  4EF8 1DC2               1881          JMP     WrapperAddrIndirectPreEnd
00001E34                          1882  
00001E34                          1883  AddrIndPrReg7
00001E34  43F9 0000256B           1884          LEA     OutAddrIndPrReg7,A1
00001E3A  103C 000E               1885          MOVE.B  #14,D0
00001E3E  4E4F                    1886          TRAP    #15
00001E40                          1887          
00001E40  4EF8 1DC2               1888          JMP     WrapperAddrIndirectPreEnd
00001E44                          1889  
00001E44                          1890  
00001E44                          1891  *-----------------------------------------------------------        
00001E44                          1892  * Output logic for absolute memory addressing (0-7)
00001E44                          1893  *-----------------------------------------------------------     
00001E44                          1894  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001E44                          1895  WrapperAddrAbsolute
00001E44  4284                    1896          CLR.L   D4
00001E46                          1897          *Depending on the EA Register, choose which size to decode
00001E46  B63C 0000               1898          CMP.B   #$00,D3
00001E4A  6700 000C               1899          BEQ     WordSizeAbsolute
00001E4E                          1900  
00001E4E  B63C 0001               1901          CMP.B   #$01,D3
00001E52  6700 0028               1902          BEQ     LongSizeAbsolute
00001E56                          1903          
00001E56                          1904  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001E56                          1905  WrapperAddrAbsoluteEnd
00001E56  4E75                    1906          RTS
00001E58                          1907  
00001E58                          1908  WordSizeAbsolute        
00001E58  3818                    1909          MOVE.W  (A0)+,D4    *read in next word, data is that word        
00001E5A                          1910              
00001E5A                          1911          *Output ',$' just after source operand
00001E5A  43F9 0000257E           1912          LEA     Bang,A1
00001E60  103C 000E               1913          MOVE.B  #14,D0
00001E64  4E4F                    1914          TRAP    #15
00001E66                          1915              
00001E66                          1916          *Push D1 into stack, in case something was using it
00001E66  48E7 4000               1917          MOVEM.L D1,-(SP)
00001E6A                          1918          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001E6A  4281                    1919          CLR.L   D1
00001E6C  123C 0001               1920          MOVE.B  #$01,D1
00001E70                          1921              
00001E70                          1922          *output the absolute mem address to console with the hex-ascii converter
00001E70  4EB8 11E6               1923          JSR     HEXASCII
00001E74  4CDF 0002               1924          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001E78                          1925          
00001E78  4EF8 1E56               1926          JMP     WrapperAddrAbsoluteEnd
00001E7C                          1927  
00001E7C                          1928  LongSizeAbsolute
00001E7C  2818                    1929          MOVE.L  (A0)+,D4    *read in next long, data is that long                
00001E7E                          1930                  
00001E7E                          1931          *Output ',$' just after source operand
00001E7E  43F9 0000257E           1932          LEA     Bang,A1
00001E84  103C 000E               1933          MOVE.B  #14,D0
00001E88  4E4F                    1934          TRAP    #15  
00001E8A                          1935          
00001E8A                          1936          *Push D1 into stack, in case something was using it
00001E8A  48E7 4000               1937          MOVEM.L D1,-(SP)
00001E8E                          1938          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001E8E  4281                    1939          CLR.L   D1
00001E90  123C 0010               1940          MOVE.B  #$10,D1
00001E94                          1941              
00001E94                          1942          *output the absolute mem address to console with the hex-ascii converter
00001E94  4EB8 11E6               1943          JSR     HEXASCII
00001E98  4CDF 0002               1944          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001E9C                          1945          
00001E9C  4EF8 1E56               1946          JMP     WrapperAddrAbsoluteEnd
00001EA0                          1947          
00001EA0                          1948  
00001EA0                          1949  *-----------------------------------------------------------        
00001EA0                          1950  * Current handling of bad op/ea codes. Should be revisited.
00001EA0                          1951  *----------------------------------------------------------- 
00001EA0                          1952  BADOPCODE
00001EA0                          1953          *We found a bad op code, output some error to the screen, jump to the 
00001EA0                          1954          *next instruction in memory.
00001EA0                          1955          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001EA0                          1956          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001EA0                          1957          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001EA0                          1958          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001EA0                          1959          *i/o and error message code...
00001EA0  43F9 00002587           1960          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001EA6  103C 000E               1961          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001EAA  4E4F                    1962          TRAP    #15         *Displays Message
00001EAC  4EF8 136C               1963          JMP     GRAB_NEXT_OP
00001EB0                          1964                  
00001EB0                          1965  BADEACODE
00001EB0                          1966          *We found a bad ea code, output some error to the screen, jump to the
00001EB0                          1967          *next instruction in memory.
00001EB0                          1968          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001EB0                          1969          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001EB0  43F9 00002580           1970          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001EB6  103C 000E               1971          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001EBA  4E4F                    1972          TRAP    #15         *Displays Message
00001EBC  4EF8 136C               1973          JMP     GRAB_NEXT_OP
00001EC0                          1974          
00001EC0                          1975          
00001EC0                          1976  *-----------------------------------------------------------        
00001EC0                          1977  * End of Disassembler
00001EC0                          1978  *-----------------------------------------------------------    
00001EC0                          1979  
00001EC0  4E72 2700               1980  DONE    STOP    #$2700  *What does this do? Why was it added?
00001EC4                          1981  
00001EC4  103C 0009               1982  THEEND  MOVE.B  #9,D0
00001EC8  4E4F                    1983          TRAP    #15             Halt Simulator        
00001ECA                          1984          
00001ECA                          1985       
00001ECA                          1986  *-----------------------------------------------------------        
00001ECA                          1987  * Output stuff
00001ECA                          1988  *-----------------------------------------------------------     
00001ECA  =0000000D               1989  CR      EQU     $0D             ASCII code for Carriage Return
00001ECA  =0000000A               1990  LF      EQU     $0A             ASCII code for Line Feed
00001ECA= 2D 2D 2D 2D 2D 2D ...   1991  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001F09= 7C 7C 20 20 20 20 ...   1992              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001F48= 2D 2D 2D 2D 2D 2D ...   1993              DC.B    '-------------------------------------------------------------',CR,LF
00001F87= 2A 2A 2A 2A 2A 2A ...   1994              DC.B    '*************************************************************',CR,LF
00001FC6= 2A 2A 2A 2A 2A 2A ...   1995              DC.B    '*************************************************************',CR,LF
00002005= 2A 2A 2A 2A 2A 2A ...   1996              DC.B    '******           ***        ***           ****    ***********',CR,LF
00002044= 2A 2A 2A 2A 2A 2A ...   1997              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00002083= 2A 2A 2A 2A 2A 2A ...   1998              DC.B    '**********    ******        *******   ******        *********',CR,LF
000020C2= 2A 2A 2A 2A 2A 2A ...   1999              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00002101= 2A 2A 2A 2A 2A 2A ...   2000              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00002140= 2A 2A 2A 2A 2A 2A ...   2001              DC.B    '*************************************************************',CR,LF
0000217F= 2A 2A 2A 2A 2A 2A ...   2002              DC.B    '*************************************************************',CR,LF
000021BE= 2A 20 20 20 20 20 ...   2003              DC.B    '*                                                           *',CR,LF
000021FD= 2A 20 41 75 74 68 ...   2004              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
0000223C= 2A 20 20 20 20 20 ...   2005              DC.B    '*                                                           *',CR,LF
0000227B= 2A 2A 2A 2A 2A 2A ...   2006              DC.B    '*************************************************************',CR,LF,CR,LF
000022BC= 53 74 61 72 74 69 ...   2007              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
000022D9                          2008              
000022D9= 57 6F 75 6C 64 20 ...   2009  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
0000230A                          2010  
0000230A= 20 0D 0A                2011  GETSTRTADDR DC.B    ' ',CR,LF
0000230D= 50 6C 65 61 73 65 ...   2012              DC.B    'Please type in your starting address request: ',0
0000233C                          2013              
0000233C= 20 0D 0A                2014  GETENDADDR  DC.B    ' ',CR,LF
0000233F= 50 6C 65 61 73 65 ...   2015              DC.B    'Please type in your ending address request: ',0
0000236C                          2016              
0000236C= 20 0D 0A                2017  QUES_CONT   DC.B    ' ',CR,LF
0000236F= 57 6F 75 6C 64 20 ...   2018              DC.B    'Would you like to continue (Y/N)? ',0
00002392                          2019              
00002392= 20 0D 0A                2020  QUIT_MSG    DC.B    ' ',CR,LF
00002395= 57 6F 75 6C 64 20 ...   2021              DC.B    'Would you like to quit (Y/N)? ',0
000023B4                          2022  
000023B4                          2023  *****************************************************
000023B4                          2024  * I/O storages - assuming users knows what to do.
000023B4                          2025  *****************************************************
000023B4                          2026  CMD_HLD     DS.B    30
000023D2                          2027  CMD_SZ      DS.B    30
000023F0                          2028  STADDR      DS.B    10
000023FA                          2029  STADDRSZ    DS.B    10
00002404                          2030  PROGST      DS.L    1
00002408                          2031  ENDADDR     DS.B    10
00002412                          2032  ENDADDRSZ   DS.B    10
0000241C                          2033  PROGEND     DS.L    1
00002420                          2034  CONT        DS.B    30
0000243E                          2035  *****************************************************
0000243E                          2036  
0000243E                          2037  *Table for 0-9 && A-F
0000243E= 30 00                   2038  PRNT0   DC.B    '0',0
00002440= 31 00                   2039  PRNT1   DC.B    '1',0
00002442= 32 00                   2040  PRNT2   DC.B    '2',0
00002444= 33 00                   2041  PRNT3   DC.B    '3',0
00002446= 34 00                   2042  PRNT4   DC.B    '4',0
00002448= 35 00                   2043  PRNT5   DC.B    '5',0
0000244A= 36 00                   2044  PRNT6   DC.B    '6',0
0000244C= 37 00                   2045  PRNT7   DC.B    '7',0
0000244E= 38 00                   2046  PRNT8   DC.B    '8',0
00002450= 39 00                   2047  PRNT9   DC.B    '9',0
00002452= 41 00                   2048  PRNTA   DC.B    'A',0
00002454= 42 00                   2049  PRNTB   DC.B    'B',0
00002456= 43 00                   2050  PRNTC   DC.B    'C',0
00002458= 44 00                   2051  PRNTD   DC.B    'D',0
0000245A= 45 00                   2052  PRNTE   DC.B    'E',0
0000245C= 46 00                   2053  PRNTF   DC.B    'F',0
0000245E                          2054  
0000245E                          2055  *output for all OPCODEs
0000245E                          2056  *Bucket 0000
0000245E= 41 44 44 49 00          2057  ADDI    DC.B    'ADDI',0
00002463= 41 4E 44 49 00          2058  ANDI    DC.B    'ANDI',0
00002468= 45 4F 52 49 00          2059  EORI    DC.B    'EORI',0
0000246D= 42 43 48 47 00          2060  BCHG    DC.B    'BCHG',0
00002472= 43 4D 50 49 00          2061  CMPI    DC.B    'CMPI',0
00002477                          2062  *Bucket 0100
00002477= 4D 4F 56 45 4D 00       2063  MOVEM   DC.B    'MOVEM',0
0000247D= 4D 55 4C 53 00          2064  MULS    DC.B    'MULS',0
00002482= 4C 45 41 20 20 20 ...   2065  LEA     DC.B    'LEA      ',0   *Need spaces here since LEA has no size
0000248C= 43 4C 52 00             2066  CLR     DC.B    'CLR',0
00002490= 4A 53 52 20 20 20 ...   2067  JSR     DC.B    'JSR      ',0   *Need spaces here since JSR has no size
0000249A= 52 54 53 20 20 20 ...   2068  RTS     DC.B    'RTS      ',0   *Need spaces here since RTS has no size
000024A4                          2069  
000024A4                          2070  *output for the size of the operation
000024A4= 2E 42 20 20 20 20 00    2071  ByteSize    DC.B    '.B    ',0
000024AB= 2E 57 20 20 20 20 00    2072  WordSize    DC.B    '.W    ',0
000024B2= 2E 4C 20 20 20 20 00    2073  LongSize    DC.B    '.L    ',0
000024B9                          2074  
000024B9                          2075  *output for all data registers (0-7)
000024B9= 44 30 00                2076  OutDataReg0 DC.B    'D0',0
000024BC= 44 31 00                2077  OutDataReg1 DC.B    'D1',0
000024BF= 44 32 00                2078  OutDataReg2 DC.B    'D2',0
000024C2= 44 33 00                2079  OutDataReg3 DC.B    'D3',0
000024C5= 44 34 00                2080  OutDataReg4 DC.B    'D4',0
000024C8= 44 35 00                2081  OutDataReg5 DC.B    'D5',0
000024CB= 44 36 00                2082  OutDataReg6 DC.B    'D6',0
000024CE= 44 37 00                2083  OutDataReg7 DC.B    'D7',0
000024D1                          2084  
000024D1                          2085  *output for all address registers (0-7)
000024D1= 41 30 00                2086  OutAddrReg0 DC.B    'A0',0
000024D4= 41 31 00                2087  OutAddrReg1 DC.B    'A1',0
000024D7= 41 32 00                2088  OutAddrReg2 DC.B    'A2',0
000024DA= 41 33 00                2089  OutAddrReg3 DC.B    'A3',0
000024DD= 41 34 00                2090  OutAddrReg4 DC.B    'A4',0
000024E0= 41 35 00                2091  OutAddrReg5 DC.B    'A5',0
000024E3= 41 36 00                2092  OutAddrReg6 DC.B    'A6',0
000024E6= 41 37 00                2093  OutAddrReg7 DC.B    'A7',0
000024E9                          2094          
000024E9                          2095  *output for all address indirect registers (0-7)
000024E9= 28 41 30 29 00          2096  OutAddrIndReg0  DC.B    '(A0)',0
000024EE= 28 41 31 29 00          2097  OutAddrIndReg1  DC.B    '(A1)',0
000024F3= 28 41 32 29 00          2098  OutAddrIndReg2  DC.B    '(A2)',0
000024F8= 28 41 33 29 00          2099  OutAddrIndReg3  DC.B    '(A3)',0
000024FD= 28 41 34 29 00          2100  OutAddrIndReg4  DC.B    '(A4)',0
00002502= 28 41 35 29 00          2101  OutAddrIndReg5  DC.B    '(A5)',0
00002507= 28 41 36 29 00          2102  OutAddrIndReg6  DC.B    '(A6)',0
0000250C= 28 41 37 29 00          2103  OutAddrIndReg7  DC.B    '(A7)',0
00002511                          2104  
00002511                          2105  *output for all address indirect post registers (0-7)
00002511= 28 41 30 29 2B 00       2106  OutAddrIndPoReg0    DC.B    '(A0)+',0
00002517= 28 41 31 29 2B 00       2107  OutAddrIndPoReg1    DC.B    '(A1)+',0
0000251D= 28 41 32 29 2B 00       2108  OutAddrIndPoReg2    DC.B    '(A2)+',0
00002523= 28 41 33 29 2B 00       2109  OutAddrIndPoReg3    DC.B    '(A3)+',0
00002529= 28 41 34 29 2B 00       2110  OutAddrIndPoReg4    DC.B    '(A4)+',0
0000252F= 28 41 35 29 2B 00       2111  OutAddrIndPoReg5    DC.B    '(A5)+',0
00002535= 28 41 36 29 2B 00       2112  OutAddrIndPoReg6    DC.B    '(A6)+',0
0000253B= 28 41 37 29 2B 00       2113  OutAddrIndPoReg7    DC.B    '(A7)+',0
00002541                          2114  
00002541                          2115  *output for all address indirect pre registers (0-7)
00002541= 2D 28 41 30 29 00       2116  OutAddrIndPrReg0    DC.B    '-(A0)',0
00002547= 2D 28 41 31 29 00       2117  OutAddrIndPrReg1    DC.B    '-(A1)',0
0000254D= 2D 28 41 32 29 00       2118  OutAddrIndPrReg2    DC.B    '-(A2)',0
00002553= 2D 28 41 33 29 00       2119  OutAddrIndPrReg3    DC.B    '-(A3)',0
00002559= 2D 28 41 34 29 00       2120  OutAddrIndPrReg4    DC.B    '-(A4)',0
0000255F= 2D 28 41 35 29 00       2121  OutAddrIndPrReg5    DC.B    '-(A5)',0
00002565= 2D 28 41 36 29 00       2122  OutAddrIndPrReg6    DC.B    '-(A6)',0
0000256B= 2D 28 41 37 29 00       2123  OutAddrIndPrReg7    DC.B    '-(A7)',0
00002571                          2124  
00002571                          2125  *output for a tab only (4 spaces)
00002571= 20 20 20 20 00          2126  Tab DC.B    '    ',0
00002576                          2127  
00002576                          2128  *output for a comma only
00002576= 2C 00                   2129  Comma   DC.B    ',',0
00002578                          2130  
00002578                          2131  *output for a new line only
00002578= 0D 0A 00                2132  NewLine DC.B    CR,LF,0
0000257B                          2133  
0000257B                          2134  *output for a '#$' and '$' only
0000257B= 23 24 00                2135  ShaBang DC.B    '#$',0
0000257E= 24 00                   2136  Bang    DC.B    '$',0
00002580                          2137  
00002580                          2138  *current output for error messages
00002580= 42 41 44 20 45 41 00    2139  BADEAMSG    DC.B    'BAD EA',0
00002587= 42 41 44 20 4F 50 00    2140  BADOPMSG    DC.B    'BAD OP',0
0000258E= 49 6D 70 72 6F 70 ...   2141  INV_MSG     DC.B    'Improper command.',CR,LF,0
000025A2= 49 6E 76 61 6C 69 ...   2142  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
000025BB= 49 6E 76 61 6C 69 ...   2143  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
000025D2                          2144  
000025D2                          2145          
000025D2                          2146          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                245E
ADDRABSOLUTEMODE    1A6A
ADDRINDIRECTMODE    1A3A
ADDRINDIRECTPOSTMODE  1A4A
ADDRINDIRECTPREMODE  1A5A
ADDRINDPOREG0       1D02
ADDRINDPOREG1       1D12
ADDRINDPOREG2       1D22
ADDRINDPOREG3       1D32
ADDRINDPOREG4       1D42
ADDRINDPOREG5       1D52
ADDRINDPOREG6       1D62
ADDRINDPOREG7       1D72
ADDRINDPRREG0       1DC4
ADDRINDPRREG1       1DD4
ADDRINDPRREG2       1DE4
ADDRINDPRREG3       1DF4
ADDRINDPRREG4       1E04
ADDRINDPRREG5       1E14
ADDRINDPRREG6       1E24
ADDRINDPRREG7       1E34
ADDRINDREG0         1C40
ADDRINDREG1         1C50
ADDRINDREG2         1C60
ADDRINDREG3         1C70
ADDRINDREG4         1C80
ADDRINDREG5         1C90
ADDRINDREG6         1CA0
ADDRINDREG7         1CB0
ADDRREG0            1B7E
ADDRREG1            1B8E
ADDRREG2            1B9E
ADDRREG3            1BAE
ADDRREG4            1BBE
ADDRREG5            1BCE
ADDRREG6            1BDE
ADDRREG7            1BEE
ADDRREGMODE         1A2A
ANDI                2463
ASCIIHEX            1174
ASCIIHEX1           1178
BADEACODE           1EB0
BADEAMSG            2580
BADOPCODE           1EA0
BADOPMSG            2587
BANG                257E
BCHG                246D
BCHGBYTESIZE        19E2
BCHGIMMEDIATE       19F2
BCHGLONGSIZE        19D2
BCHGSIZEHELPER      19C2
BCHGSIZEHELPEREND   19D0
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         141A
BUCKET_0001         1768
BUCKET_0010         1768
BUCKET_0011         1768
BUCKET_0100         1768
BUCKET_0101         18EE
BUCKET_0110         18EE
BUCKET_1000         18EE
BUCKET_1001         18EE
BUCKET_1011         18EE
BUCKET_1100         18EE
BUCKET_1101         18EE
BUCKET_1110         18EE
BYTESIZE            24A4
BYTESIZEIMMEDIATE   1910
BYTESIZEOP          1992
CHECK               11EA
CHECKEND1           10FA
CHECKSTRT1          10E4
CHECK_LOWN          112C
CHECK_LOWY          111A
CHECK_N             13F4
CHECK_UPN           1124
CHECK_UPY           1110
CHECK_Y             13E6
CHNG_SZB            121C
CHNG_SZL            1202
CHNG_SZW            1236
CLR                 248C
CMD_HLD             23B4
CMD_SZ              23D2
CMPI                2472
COMMA               2576
CONT                2420
CONT_Q              13B4
CONV_LOL            11D4
CONV_LOOP           1250
CONV_NUM            11C0
CONV_UPL            11CA
CR                  D
DATAREG0            1ABC
DATAREG1            1ACC
DATAREG2            1ADC
DATAREG3            1AEC
DATAREG4            1AFC
DATAREG5            1B0C
DATAREG6            1B1C
DATAREG7            1B2C
DATAREGMODE         1A1A
DONE                1EC0
EA_ADDI             14A6
EA_ANDI             151C
EA_BCHG_D           1614
EA_BCHG_S           16AC
EA_CLR              1862
EA_CMPI             1728
EA_EORI             1592
EA_JSR              18B8
EA_LEA              17F6
EA_LEA_WRAPPEREND   180E
EA_MOVEM_MEMTOREG   17B4
EA_MOVEM_REGTOMEM   17B4
ENDADDR             2408
ENDADDRSZ           2412
EORI                2468
EXITSUB             11E0
EXIT_CONV           12D6
GETENDADDR          233C
GETSTRTADDR         230A
GET_END             108C
GET_STRT            103E
GRAB_NEXT_OP        136C
HEXASCII            11E6
HEXASCIIREG         11FE
IMMEDIATEDATAMODE   1A7A
INV2                1404
INVALID1            1134
INVENDMSG           25BB
INVSTRTMSG          25A2
INV_END1            1160
INV_MSG             258E
INV_STRT1           114C
IS_ADDI             1470
IS_ANDI             14E6
IS_BCHG_D           15D2
IS_BCHG_S           1670
IS_CLR              182C
IS_CMPI             16F2
IS_EORI             155C
IS_JSR              1896
IS_LEA              17B4
IS_MOVEM_MEMTOREG   17B4
IS_MOVEM_REGTOMEM   17B4
IS_RTS              18CE
JSR                 2490
LEA                 2482
LEA_ADDRABSOLUTEWRAPPER  1A10
LEA_ADDRINDIRECTWRAPPER  1A06
LF                  A
LONGSIZE            24B2
LONGSIZEABSOLUTE    1E7C
LONGSIZEIMMEDIATE   1954
LONGSIZEOP          19B2
LOOP_1              1014
LOOP_B              1220
LOOP_L              1206
LOOP_W              123A
MAX_LINE            F
MESSAGE             1ECA
MOVEM               2477
MULS                247D
NEWLINE             2578
NUM_0               12E4
NUM_1               12EC
NUM_2               12F4
NUM_3               12FC
NUM_4               1304
NUM_5               130C
NUM_6               1314
NUM_7               131C
NUM_8               1324
NUM_9               132C
NUM_A               1334
NUM_B               133C
NUM_C               1344
NUM_D               134C
NUM_E               1354
NUM_F               135C
OUTADDRINDPOREG0    2511
OUTADDRINDPOREG1    2517
OUTADDRINDPOREG2    251D
OUTADDRINDPOREG3    2523
OUTADDRINDPOREG4    2529
OUTADDRINDPOREG5    252F
OUTADDRINDPOREG6    2535
OUTADDRINDPOREG7    253B
OUTADDRINDPRREG0    2541
OUTADDRINDPRREG1    2547
OUTADDRINDPRREG2    254D
OUTADDRINDPRREG3    2553
OUTADDRINDPRREG4    2559
OUTADDRINDPRREG5    255F
OUTADDRINDPRREG6    2565
OUTADDRINDPRREG7    256B
OUTADDRINDREG0      24E9
OUTADDRINDREG1      24EE
OUTADDRINDREG2      24F3
OUTADDRINDREG3      24F8
OUTADDRINDREG4      24FD
OUTADDRINDREG5      2502
OUTADDRINDREG6      2507
OUTADDRINDREG7      250C
OUTADDRREG0         24D1
OUTADDRREG1         24D4
OUTADDRREG2         24D7
OUTADDRREG3         24DA
OUTADDRREG4         24DD
OUTADDRREG5         24E0
OUTADDRREG6         24E3
OUTADDRREG7         24E6
OUTDATAREG0         24B9
OUTDATAREG1         24BC
OUTDATAREG2         24BF
OUTDATAREG3         24C2
OUTDATAREG4         24C5
OUTDATAREG5         24C8
OUTDATAREG6         24CB
OUTDATAREG7         24CE
PRINT_NUM           12DC
PRNT0               243E
PRNT1               2440
PRNT2               2442
PRNT3               2444
PRNT4               2446
PRNT5               2448
PRNT6               244A
PRNT7               244C
PRNT8               244E
PRNT9               2450
PRNTA               2452
PRNTB               2454
PRNTC               2456
PRNTD               2458
PRNTE               245A
PRNTF               245C
PROGEND             241C
PROGST              2404
QUES_CONT           236C
QUIT_MSG            2392
RTS                 249A
SHABANG             257B
STACK               7000
STADDR              23F0
STADDRSZ            23FA
START               1000
STARTASSEM          22D9
ST_ADDR             7FC6
ST_BAD              11DE
TAB                 2571
THEEND              1EC4
WORDSIZE            24AB
WORDSIZEABSOLUTE    1E58
WORDSIZEIMMEDIATE   1932
WORDSIZEOP          19A2
WRAPPERADDRABSOLUTE  1E44
WRAPPERADDRABSOLUTEEND  1E56
WRAPPERADDRINDIRECT  1BFE
WRAPPERADDRINDIRECTEND  1C3E
WRAPPERADDRINDIRECTPOST  1CC0
WRAPPERADDRINDIRECTPOSTEND  1D00
WRAPPERADDRINDIRECTPRE  1D82
WRAPPERADDRINDIRECTPREEND  1DC2
WRAPPERADDRREG      1B3C
WRAPPERADDRREGEND   1B7C
WRAPPERDATAREG      1A7A
WRAPPERDATAREGEND   1ABA
WRAPPERSIZE         1976
WRAPPERSIZEEND      1990
WRAPPERSIZEIMMEDIATE  18F4
WRAPPERSIZEIMMEDIATEEND  190E
