00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 11:50:16 PM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/14/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. After specifying
00000000                             7  * where the program to be disassembled is located, this program will disassemble
00000000                             8  * instructions of that program, and output the contents to console.
00000000                             9  *
00000000                            10  * For use with the EASy68K Emulator. To run, open this program in the emulator.
00000000                            11  * Hit 'F9' to execute. In the execution window, open the test input file, and press
00000000                            12  * 'F9' to run the program.
00000000                            13  *
00000000                            14  * This program will not disassemble every 68k instruction, only a subset of instructions
00000000                            15  * that we have currently implemented. See corresponding documentation for more details.
00000000                            16  *-------------------------------------------------------------
00000000  =00007FC6                 17  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 18  STACK       EQU $7000   *Stack location
00000000  =00000020                 19  MAX_LINE    EQU 32      *Maximum number of instructions that can be displayed
00001000                            20  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 21              LEA stack,SP
00001004  3C3C 0020                 22              MOVE    #MAX_LINE,D6
00001008                            23              
00001008                            24  
00001008                            25  *-----------------------------------------------------------
00001008                            26  * Start of I/O
00001008                            27  *-----------------------------------------------------------            
00001008  43F9 00001F94             28              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 29              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      30              TRAP    #15         *Displays Message
00001014                            31          
00001014  303C 0000                 32  loop_1      MOVE    #0,D0
00001018  363C 0000                 33              MOVE    #0,D3       
0000101C  43F9 000023A3             34              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
00001022  103C 000D                 35              MOVE.B  #13,D0
00001026  4E4F                      36              TRAP    #15    
00001028  303C 0002                 37              MOVE    #2,D0
0000102C  43F9 0000247E             38              LEA     CMD_HLD,A1  *Store the command in a buffer
00001032  4E4F                      39              TRAP    #15
00001034  0C01 0001                 40              CMPI.B  #01,D1
00001038  6600 00FE                 41              BNE     INVALID1
0000103C  4EB9 00001114             42              JSR     CHECK_UPY
00001042                            43              
00001042                            44              
00001042                            45  *-----------------------------------------------------------
00001042                            46  * I/O: Check Start Address
00001042                            47  *
00001042                            48  * Make sure that start address starts after allocated 
00001042                            49  * memory addresses. Else, it will print out a message 
00001042                            50  * saying that requested address is invalid & prompts the
00001042                            51  * user again for the starting address.
00001042                            52  *-----------------------------------------------------------
00001042  43F9 000023D4             53  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001048  103C 000E                 54              MOVE.B  #14,D0
0000104C  4E4F                      55              TRAP    #15
0000104E  43F9 000024BA             56              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001054  3239 000024C4             57              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
0000105A  303C 0002                 58              MOVE    #2,D0           *Get start address
0000105E  4E4F                      59              TRAP    #15
00001060  4EB9 000010E8             60              JSR     CHECKSTRT1
00001066  4287                      61              CLR.L   D7
00001068  4EB9 00001178             62              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106E  0C03 0001                 63              CMPI.B  #01,D3      *Check if there was a bad start
00001072  6700 00DC                 64              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001076  0C87 00007FC6             65              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
0000107C  6D00 00D2                 66              BLT     INV_STRT1   *Asks for another start address if invalid
00001080  0C87 00FFFFFE             67              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001086  6C00 00C8                 68              BGE     INV_STRT1
0000108A  23C7 000024CE             69              MOVE.L  D7,PROGST
00001090                            70  
00001090  43F9 00002406             71  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001096  103C 000E                 72              MOVE.B  #14,D0
0000109A  4E4F                      73              TRAP    #15
0000109C  43F9 000024D2             74              LEA     ENDADDR,A1      *Buffer to hold end address
000010A2  3239 000024DC             75              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A8  303C 0002                 76              MOVE    #2,D0
000010AC  4E4F                      77              TRAP    #15
000010AE  4EB9 000010FE             78              JSR     CHECKEND1
000010B4  4287                      79              CLR.L   D7
000010B6  4EB9 00001178             80              JSR     ASCIIHEX
000010BC  0C03 0001                 81              CMPI.B  #01,D3
000010C0  6700 00A2                 82              BEQ     INV_END1
000010C4  0C87 000024CE             83              CMPI.L  #PROGST,D7
000010CA  6D00 0098                 84              BLT     INV_END1
000010CE  0C87 00FFFFFF             85              CMPI.L  #$00FFFFFF,D7
000010D4  6C00 008E                 86              BGE     INV_END1
000010D8  23C7 000024E6             87              MOVE.L  D7,PROGEND
000010DE  2079 000024CE             88              MOVEA.L PROGST,A0
000010E4  6000 029A                 89              BRA     GRAB_NEXT_OP            
000010E8                            90                          
000010E8  0C81 00000008             91  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EE  6E00 0060                 92              BGT     INV_STRT1
000010F2  0C81 00000000             93              CMPI.L  #00,D1
000010F8  6300 0056                 94              BLS     INV_STRT1
000010FC  4E75                      95              RTS         
000010FE                            96              
000010FE  0C81 00000008             97  CHECKEND1   CMPI.L  #08,D1
00001104  6E00 005E                 98              BGT     INV_END1
00001108  0C81 00000000             99              CMPI.L  #00,D1
0000110E  6300 0054                100              BLS     INV_END1
00001112  4E75                     101              RTS
00001114                           102  
00001114                           103  
00001114                           104  *-----------------------------------------------------------
00001114                           105  * I/O: Input check for Y, y, N, n
00001114                           106  *-----------------------------------------------------------
00001114  0C11 0059                107  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001118  6600 0004                108              BNE     CHECK_LOWY
0000111C  4E75                     109              RTS
0000111E  0C11 0079                110  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
00001122  6600 0004                111              BNE     CHECK_UPN
00001126  4E75                     112              RTS
00001128  0C11 004E                113  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
0000112C  6700 0E5C                114              BEQ     DONE
00001130                           115              
00001130  0C11 006E                116  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001134  6700 0E54                117              BEQ     DONE
00001138                           118              
00001138  163C 0000                119  INVALID1    MOVE.B  #0,D3       *Reset bad flag
0000113C  303C 0000                120              MOVE    #0,D0       *Prints invalid command msg if not found
00001140  43F9 00002657            121              LEA     INV_MSG,A1
00001146  303C 000E                122              MOVE    #14,D0
0000114A  4E4F                     123              TRAP    #15
0000114C  6000 FEC6                124              BRA     loop_1
00001150                           125              
00001150  43F9 0000266B            126  INV_STRT1   LEA     INVSTRTMSG,A1
00001156  103C 000E                127              MOVE.B  #14,D0
0000115A  4E4F                     128              TRAP    #15
0000115C  163C 0000                129              MOVE.B  #00,D3      *Reset flag
00001160  6000 FEE0                130              BRA     GET_STRT        
00001164                           131              
00001164  43F9 00002684            132  INV_END1    LEA     INVENDMSG,A1
0000116A  103C 000E                133              MOVE.B  #14,D0
0000116E  4E4F                     134              TRAP    #15
00001170  163C 0000                135              MOVE.B  #00,D3      *Reset flag
00001174  6000 FF1A                136              BRA     GET_END
00001178                           137              
00001178                           138              
00001178                           139  *-----------------------------------------------------------
00001178                           140  * ASCII to Hex converter
00001178                           141  *
00001178                           142  * Checks and converts the ASCII value to the hex equivalent
00001178                           143  *-----------------------------------------------------------
00001178  48E7 6000                144  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
0000117C  0C01 0000                145  ASCIIHEX1   CMPI.B  #00,D1      *See if done
00001180  6700 0062                146              BEQ     exitSub     *Exit subroutine 
00001184  5301                     147              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001186  E99F                     148              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001188  1419                     149              MOVE.B  (A1)+,D2    *Takes the first char
0000118A  0C02 0024                150              CMPI.B  #$24,D2     *See if the first char is $
0000118E  67EC                     151              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
00001190  0C02 0030                152              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001194  6D00 004C                153              BLT     st_bad      *Put error message
00001198  0C02 0039                154              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
0000119C  6F00 0026                155              BLE     CONV_NUM    *Convert to number, if so
000011A0  0C02 0041                156              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A4  6D00 003C                157              BLT     st_bad      *Put error message
000011A8  0C02 0046                158              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011AC  6F00 0020                159              BLE     CONV_UpL    *Convert to hex
000011B0  0C02 0061                160              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B4  6D00 002C                161              BLT     st_bad
000011B8  0C02 0066                162              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011BC  6F00 001A                163              BLE     CONV_LoL    
000011C0  6E00 0020                164              BGT     st_bad      *Puts error message for anything greater than f value
000011C4                           165              
000011C4  0402 0030                166  CONV_NUM    SUBI.B  #$30,D2
000011C8  8E02                     167              OR.B    D2,D7
000011CA  4EF8 117C                168              JMP     ASCIIHEX1
000011CE  0402 0037                169  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011D2  8E02                     170              OR.B    D2,D7
000011D4  4EF8 117C                171              JMP     ASCIIHEX1
000011D8  0402 0057                172  CONV_LoL    SUBI.B  #$57,D2
000011DC  8E02                     173              OR.B    D2,D7
000011DE  4EF8 117C                174              JMP     ASCIIHEX1   
000011E2                           175  
000011E2  5203                     176  st_bad      ADDI.B  #01,D3
000011E4  4CDF 0006                177  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E8  4E75                     178              RTS
000011EA                           179              
000011EA                           180              
000011EA                           181  *-----------------------------------------------------------
000011EA                           182  * Hex to ASCII converter
000011EA                           183  *-----------------------------------------------------------
000011EA  48E7 4C00                184  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EE  0C01 0000                185  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011F2  6700 002C                186              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F6  B27C 0001                187              CMP.W   #01,D1          
000011FA  6700 003E                188              BEQ     CHNG_SZW
000011FE  6000 0006                189              BRA     CHNG_SZL        
00001202                           190  
00001202  48E7 4C00                191  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001206  123C 0008                192  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
0000120A  0C01 0000                193  LOOP_L      CMPI.B  #00,D1
0000120E  6700 00CA                194              BEQ     EXIT_CONV
00001212  5301                     195              SUBI.B  #01,D1
00001214  E99C                     196              ROL.L   #4,D4           * Shift it for next bit
00001216  2A04                     197              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001218  4EB9 00001254            198              JSR     CONV_LOOP
0000121E  60EA                     199              BRA     LOOP_L      
00001220                           200  
00001220  123C 0002                201  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001224  0C01 0000                202  LOOP_B      CMPI.B  #00,D1
00001228  6700 00B0                203              BEQ     EXIT_CONV
0000122C  5301                     204              SUBI.B  #01,D1
0000122E  E91C                     205              ROL.B   #4,D4           * Shift it for next bit
00001230  2A04                     206              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001232  4EB9 00001254            207              JSR     CONV_LOOP
00001238  60EA                     208              BRA     LOOP_B
0000123A                           209              
0000123A  123C 0004                210  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123E  0C01 0000                211  LOOP_W      CMPI.B  #00,D1
00001242  6700 0096                212              BEQ     EXIT_CONV
00001246  5301                     213              SUBI.B  #01,D1
00001248  E95C                     214              ROL.W   #4,D4           * Shift it for next bit
0000124A  2A04                     215              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000124C  4EB9 00001254            216              JSR     CONV_LOOP
00001252  60EA                     217              BRA     LOOP_W
00001254                           218  
00001254  0285 0000000F            219  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
0000125A  0C05 0000                220              CMPI.B  #$0,D5
0000125E  6700 0088                221              BEQ     NUM_0
00001262  0C05 0001                222              CMPI.B  #$1,D5
00001266  6700 0088                223              BEQ     NUM_1
0000126A  0C05 0002                224              CMPI.B  #$2,D5
0000126E  6700 0088                225              BEQ     NUM_2
00001272  0C05 0003                226              CMPI.B  #$3,D5
00001276  6700 0088                227              BEQ     NUM_3
0000127A  0C05 0004                228              CMPI.B  #$4,D5
0000127E  6700 0088                229              BEQ     NUM_4
00001282  0C05 0005                230              CMPI.B  #$5,D5
00001286  6700 0088                231              BEQ     NUM_5
0000128A  0C05 0006                232              CMPI.B  #$6,D5
0000128E  6700 0088                233              BEQ     NUM_6
00001292  0C05 0007                234              CMPI.B  #$7,D5
00001296  6700 0088                235              BEQ     NUM_7
0000129A  0C05 0008                236              CMPI.B  #$8,D5
0000129E  6700 0088                237              BEQ     NUM_8
000012A2  0C05 0009                238              CMPI.B  #$9,D5
000012A6  6700 0088                239              BEQ     NUM_9
000012AA  0C05 000A                240              CMPI.B  #$A,D5
000012AE  6700 0088                241              BEQ     NUM_A
000012B2  0C05 000B                242              CMPI.B  #$B,D5
000012B6  6700 0088                243              BEQ     NUM_B
000012BA  0C05 000C                244              CMPI.B  #$C,D5
000012BE  6700 0088                245              BEQ     NUM_C
000012C2  0C05 000D                246              CMPI.B  #$D,D5
000012C6  6700 0088                247              BEQ     NUM_D
000012CA  0C05 000E                248              CMPI.B  #$E,D5
000012CE  6700 0088                249              BEQ     NUM_E
000012D2  0C05 000F                250              CMPI.B  #$F,D5
000012D6  6700 0088                251              BEQ     NUM_F
000012DA                           252              
000012DA  4CDF 0032                253  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DE  4E75                     254              RTS
000012E0                           255              
000012E0  303C 000E                256  PRINT_NUM   MOVE    #14,D0
000012E4  4E4F                     257              TRAP    #15
000012E6  4E75                     258              RTS
000012E8  43F9 00002508            259  NUM_0       LEA     PRNT0,A1
000012EE  60F0                     260              BRA     PRINT_NUM
000012F0  43F9 0000250A            261  NUM_1       LEA     PRNT1,A1
000012F6  60E8                     262              BRA     PRINT_NUM
000012F8  43F9 0000250C            263  NUM_2       LEA     PRNT2,A1
000012FE  60E0                     264              BRA     PRINT_NUM
00001300  43F9 0000250E            265  NUM_3       LEA     PRNT3,A1
00001306  60D8                     266              BRA     PRINT_NUM
00001308  43F9 00002510            267  NUM_4       LEA     PRNT4,A1
0000130E  60D0                     268              BRA     PRINT_NUM
00001310  43F9 00002512            269  NUM_5       LEA     PRNT5,A1
00001316  60C8                     270              BRA     PRINT_NUM
00001318  43F9 00002514            271  NUM_6       LEA     PRNT6,A1
0000131E  60C0                     272              BRA     PRINT_NUM
00001320  43F9 00002516            273  NUM_7       LEA     PRNT7,A1
00001326  60B8                     274              BRA     PRINT_NUM
00001328  43F9 00002518            275  NUM_8       LEA     PRNT8,A1
0000132E  60B0                     276              BRA     PRINT_NUM
00001330  43F9 0000251A            277  NUM_9       LEA     PRNT9,A1
00001336  60A8                     278              BRA     PRINT_NUM
00001338  43F9 0000251C            279  NUM_A       LEA     PRNTA,A1
0000133E  60A0                     280              BRA     PRINT_NUM
00001340  43F9 0000251E            281  NUM_B       LEA     PRNTB,A1
00001346  6098                     282              BRA     PRINT_NUM
00001348  43F9 00002520            283  NUM_C       LEA     PRNTC,A1
0000134E  6090                     284              BRA     PRINT_NUM
00001350  43F9 00002522            285  NUM_D       LEA     PRNTD,A1
00001356  6088                     286              BRA     PRINT_NUM
00001358  43F9 00002524            287  NUM_E       LEA     PRNTE,A1
0000135E  6080                     288              BRA     PRINT_NUM
00001360  43F9 00002526            289  NUM_F       LEA     PRNTF,A1
00001366  6000 FF78                290              BRA     PRINT_NUM
0000136A                           291  
0000136A                           292  
0000136A                           293  *-----------------------------------------------------------        
0000136A                           294  * Start of Disassembler
0000136A                           295  *-----------------------------------------------------------
0000136A  4286                     296  CLR_D6  CLR.L   D6
0000136C  3C3C 0020                297          MOVE    #MAX_LINE,D6
00001370  43F9 00002641            298          LEA     NewLine,A1  *Loads NewLine into address register A1
00001376  103C 000E                299          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000137A  4E4F                     300          TRAP    #15         *Displays Message
0000137C  6000 FC96                301          BRA     loop_1
00001380                           302          
00001380                           303  GRAB_NEXT_OP
00001380                           304          *Check and see if A0 == end of test address. If so, we need to end.
00001380  2E08                     305          MOVE.L  A0,D7
00001382  2479 000024E6            306          MOVEA.L PROGEND,A2
00001388  BE8A                     307          CMP.L   A2,D7       * Check and see if A0 == end of test address. 
0000138A  6CDE                     308          BGE     CLR_D6      * Ask user if they want to do the disassembler again
0000138C  0C86 00000002            309          CMPI.L  #02,D6      * Check if max line of instructions output on console is reached
00001392  6700 0032                310          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
00001396  5306                     311  CONT_OP SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
00001398                           312  
00001398                           313          *Output a newline to console...        
00001398  43F9 00002641            314          LEA     NewLine,A1  *Loads NewLine into address register A1
0000139E  103C 000E                315          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000013A2  4E4F                     316          TRAP    #15         *Displays Message
000013A4                           317  
000013A4                           318          *Output the address of this instruction to console...
000013A4  2808                     319          MOVE.L  A0,D4
000013A6  4EB8 1202                320          JSR     HEXASCIIREG
000013AA                           321          
000013AA                           322          *Output a tab (4 spaces) to console, just after the address...
000013AA  43F9 0000263A            323          LEA     Tab,A1  *Loads Tab into address register A1
000013B0  103C 000E                324          MOVE.B  #14,D0  *Moves the number 14 into data register D0
000013B4  4E4F                     325          TRAP    #15     *Displays Message
000013B6                           326          
000013B6                           327          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
000013B6                           328          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
000013B6                           329          *data that may be associated with the instruction.
000013B6                           330          *Post increment addr, A0 will point to the start of next instruction or will 
000013B6                           331          *point to the start of any immed/abso data with this current instruction
000013B6  4280                     332          CLR.L   D0
000013B8  3018                     333          MOVE.W  (A0)+,D0
000013BA                           334          *Copy the word data we just moved into D0 into D7. We are copying this data
000013BA                           335          *So we always have a copy of the WHOLE instruction somewhere
000013BA  4287                     336          CLR.L   D7
000013BC  3E00                     337          MOVE.W  D0,D7
000013BE                           338          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000013BE                           339          *four bits of the instruction. Once we have just the first four bits, we can
000013BE                           340          *begin to see which 'bucket'/category this instruction falls into. 
000013BE  E048                     341          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013C0  E848                     342          LSR.W   #$04,D0
000013C2                           343          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013C2                           344          *list of buckets until we find which one this instruction falls into.
000013C2  6000 006C                345          BRA     BUCKET_0000     * Start with 0000
000013C6                           346  
000013C6                           347  
000013C6                           348  *-----------------------------------------------------------        
000013C6                           349  * Question Prompts
000013C6                           350  *-----------------------------------------------------------        
000013C6  43F9 00002436            351  CONT_Q      LEA     QUES_CONT,A1
000013CC  303C 000E                352              MOVE    #14,D0
000013D0  4E4F                     353              TRAP    #15
000013D2  43F9 000024EA            354              LEA     CONT,A1     *Need to store Y/N
000013D8  303C 0002                355              MOVE    #2,D0
000013DC  4E4F                     356              TRAP    #15
000013DE  0C01 0001                357              CMPI.B  #01,D1
000013E2  6600 FD54                358              BNE     INVALID1
000013E6  0C39 0059 000024EA       359              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013EE  6600 000A                360              BNE     CHECK_Y
000013F2  4286                     361              CLR.L   D6
000013F4  3C3C 0020                362              MOVE    #MAX_LINE,D6    *Resets counter
000013F8  609C                     363              BRA     CONT_OP
000013FA  0C11 0079                364  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
000013FE  6600 000A                365              BNE     CHECK_N
00001402  4286                     366              CLR.L   D6
00001404  3C3C 0020                367              MOVE    #MAX_LINE,D6    *Resets counter
00001408  608C                     368              BRA     CONT_OP
0000140A  0C11 004E                369  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
0000140E  6700 FC04                370              BEQ     loop_1
00001412  0C11 006E                371              CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001416  6700 FBFC                372              BEQ     loop_1      
0000141A                           373  
0000141A  163C 0000                374  INV2        MOVE.B  #0,D3       *Reset bad flag
0000141E  303C 0000                375              MOVE    #0,D0       *Prints invalid command msg if not found
00001422  43F9 00002657            376              LEA     INV_MSG,A1
00001428  303C 000E                377              MOVE    #14,D0
0000142C  4E4F                     378              TRAP    #15
0000142E  6096                     379              BRA     CONT_Q
00001430                           380  
00001430                           381  
00001430                           382  *-----------------------------------------------------------        
00001430                           383  * Bucket 0000:
00001430                           384  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
00001430                           385  *                   BCHG(dynamic) | BCHG (static) | CMPI----
00001430                           386  *-----------------------------------------------------------
00001430                           387  BUCKET_0000
00001430  =00000000                388  BUCKET0000_BITS EQU $0
00001430  4281                     389          CLR.L   D1
00001432                           390          *Load the first 4 bits (really a byte) of BUCKET0000 into D1
00001432  123C 0000                391          MOVE.B  #BUCKET0000_BITS,D1
00001436                           392          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0000. 
00001436                           393          *If equal, continue decoding. If not, branch to next bucket.
00001436  B200                     394          CMP.B   D0,D1
00001438  6600 0344                395          BNE     BUCKET_0001
0000143C                           396  
0000143C                           397          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
0000143C                           398          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
0000143C  3007                     399          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
0000143E  0800 0008                400          BTST.L  #$08,D0
00001442  6600 01A4                401          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to IS_BCHG_D
00001446                           402          
00001446                           403          *Now we can check bits 11-8 in the instruction and branch to different op-codes
00001446                           404          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
00001446  E048                     405          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001448  0880 0004                406          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
0000144C  0880 0005                407          BCLR.L  #$05,D0
00001450  0880 0006                408          BCLR.L  #$06,D0
00001454  0880 0007                409          BCLR.L  #$07,D0
00001458                           410          
00001458                           411          *Perform compares with these 4 bits to see which specific instruction it is.
00001458  B03C 0006                412          CMP.B   #$06,D0 *Is this an ADDI?
0000145C  6700 0028                413          BEQ     IS_ADDI
00001460  B03C 0002                414          CMP.B   #$02,D0 *Is this an ANDI?
00001464  6700 0096                415          BEQ     IS_ANDI
00001468  B03C 000A                416          CMP.B   #$0A,D0 *Is this an EORI?
0000146C  6700 0104                417          BEQ     IS_EORI
00001470  B03C 0008                418          CMP.B   #$08,D0 *Is this a BCHG(static)?
00001474  6700 0210                419          BEQ     IS_BCHG_S
00001478  B03C 000C                420          CMP.B   #$0C,D0 *Is this a CMPI?
0000147C  6700 028A                421          BEQ     IS_CMPI
00001480                           422          
00001480                           423          *If we get through all of the compares without finding the specific instruction,
00001480                           424          *then this instruction is either not in our list of OP CODES to decode, or is an
00001480                           425          *invalid instruction/syntax.
00001480  4EF9 00001F6A            426          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
00001486                           427          
00001486                           428          
00001486                           429  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
00001486                           430  IS_ADDI
00001486                           431          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001486                           432          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001486  4281                     433          CLR.L   D1
00001488  3207                     434          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000148A  C27C 00C0                435          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000148E  EC09                     436          LSR.B   #$06,D1     *Shift the size bits into LSB
00001490                           437          
00001490  B23C 0003                438          CMP.B   #$03,D1     *Compare the size bits to $3
00001494  6700 0AD4                439          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001498                           440          
00001498                           441          *Output 'ADDI' to console...
00001498  43F9 00002528            442          LEA     ADDI,A1     *Loads ADDI into address register A1
0000149E  103C 000E                443          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014A2  4E4F                     444          TRAP    #15         *Displays Message
000014A4                           445          
000014A4                           446          
000014A4                           447          *Should have a valid ADDI op code. Set data up for EA.
000014A4                           448          
000014A4                           449          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014A4  4282                     450          CLR.L   D2
000014A6  3407                     451          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014A8  C47C 0038                452          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000014AC  E60A                     453          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000014AE                           454                  
000014AE                           455          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000014AE  4283                     456          CLR.L   D3
000014B0  3607                     457          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000014B2  C67C 0007                458          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000014B6                           459          
000014B6  4EF9 000014BC            460          JMP     EA_ADDI
000014BC                           461  
000014BC                           462  EA_ADDI
000014BC                           463          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
000014BC                           464          *and D3 holds the EA register.
000014BC                           465          
000014BC                           466          *Determine how much data to read in, depending on the size of the operation
000014BC                           467          *output the size of the operation and the immediate data to console
000014BC  4EB9 000019C0            468          JSR     WrapperSizeImmediate
000014C2                           469          
000014C2                           470          *manually output a comma here...
000014C2  43F9 0000263F            471          LEA     Comma,A1        *Loads Comma into address register A1
000014C8  103C 000E                472          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014CC  4E4F                     473          TRAP    #15             *Displays Message        
000014CE                           474          
000014CE                           475          *Determine which EA mode and thus Register/Mem Address this instruction used
000014CE  B43C 0000                476          CMP.B   #$00,D2
000014D2  6700 0610                477          BEQ     DataRegMode *If EA mode is a data register, output that
000014D6                           478          
000014D6  B43C 0002                479          CMP.B   #$02,D2
000014DA  6700 0628                480          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014DE                           481          
000014DE  B43C 0003                482          CMP.B   #$03,D2
000014E2  6700 0630                483          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014E6                           484          
000014E6  B43C 0004                485          CMP.B   #$04,D2
000014EA  6700 0638                486          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014EE                           487          
000014EE  B43C 0007                488          CMP.B   #$07,D2
000014F2  6700 0640                489          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014F6                           490          
000014F6                           491          *If the ea mode isn't equal to any of these, it is an invalid EA
000014F6  4EF9 00001F7A            492          JMP     BADEACODE                               
000014FC                           493          
000014FC                           494  
000014FC                           495  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000014FC                           496  IS_ANDI
000014FC                           497          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014FC                           498          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014FC  4281                     499          CLR.L   D1
000014FE  3207                     500          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001500  C27C 00C0                501          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001504  EC09                     502          LSR.B   #$06,D1     *Shift the size bits into LSB
00001506                           503          
00001506  B23C 0003                504          CMP.B   #$03,D1     *Compare the size bits to $3
0000150A  6700 0A5E                505          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000150E                           506          
0000150E                           507          *Output 'ANDI' to console...
0000150E  43F9 0000252D            508          LEA     ANDI,A1     *Loads ANDI into address register A1
00001514  103C 000E                509          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001518  4E4F                     510          TRAP    #15         *Displays Message
0000151A                           511          
0000151A                           512          
0000151A                           513          *Should have a valid ANDI op code. Set data up for EA.
0000151A                           514          
0000151A                           515          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000151A  4282                     516          CLR.L   D2
0000151C  3407                     517          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000151E  C47C 0038                518          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001522  E60A                     519          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001524                           520                  
00001524                           521          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001524  4283                     522          CLR.L   D3
00001526  3607                     523          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001528  C67C 0007                524          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000152C                           525          
0000152C  4EF9 00001532            526          JMP     EA_ANDI
00001532                           527  
00001532                           528  EA_ANDI
00001532                           529          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
00001532                           530          *and D3 holds the EA register.
00001532                           531          
00001532                           532          *Determine how much data to read in, depending on the size of the operation
00001532                           533          *output the size of the operation and the immediate data to console
00001532  4EB9 000019C0            534          JSR     WrapperSizeImmediate
00001538                           535          
00001538                           536          *manually output a comma here...
00001538  43F9 0000263F            537          LEA     Comma,A1        *Loads Comma into address register A1
0000153E  103C 000E                538          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001542  4E4F                     539          TRAP    #15             *Displays Message        
00001544                           540          
00001544                           541          *Determine which EA mode and thus Register/Mem Address this instruction used
00001544  B43C 0000                542          CMP.B   #$00,D2
00001548  6700 059A                543          BEQ     DataRegMode *If EA mode is a data register, output that
0000154C                           544          
0000154C  B43C 0002                545          CMP.B   #$02,D2
00001550  6700 05B2                546          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001554                           547          
00001554  B43C 0003                548          CMP.B   #$03,D2
00001558  6700 05BA                549          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000155C                           550          
0000155C  B43C 0004                551          CMP.B   #$04,D2
00001560  6700 05C2                552          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001564                           553          
00001564  B43C 0007                554          CMP.B   #$07,D2
00001568  6700 05CA                555          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000156C                           556          
0000156C                           557          *If the ea mode isn't equal to any of these, it is an invalid EA
0000156C  4EF9 00001F7A            558          JMP     BADEACODE
00001572                           559          
00001572                           560  
00001572                           561  *Now we know this instruction is exactly EORI, lets set everything up for EA.
00001572                           562  IS_EORI
00001572                           563          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001572                           564          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001572  4281                     565          CLR.L   D1
00001574  3207                     566          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001576  C27C 00C0                567          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000157A  EC09                     568          LSR.B   #$06,D1     *Shift the size bits into LSB
0000157C                           569          
0000157C  B23C 0003                570          CMP.B   #$03,D1     *Compare the size bits to $3
00001580  6700 09E8                571          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001584                           572          
00001584                           573          *Output 'EORI' to console...
00001584  43F9 00002532            574          LEA     EORI,A1     *Loads EORI into address register A1
0000158A  103C 000E                575          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000158E  4E4F                     576          TRAP    #15         *Displays Message
00001590                           577          
00001590                           578          
00001590                           579          *Should have a valid EORI op code. Set data up for EA.
00001590                           580          
00001590                           581          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001590  4282                     582          CLR.L   D2
00001592  3407                     583          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001594  C47C 0038                584          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001598  E60A                     585          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000159A                           586                  
0000159A                           587          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000159A  4283                     588          CLR.L   D3
0000159C  3607                     589          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000159E  C67C 0007                590          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000015A2                           591          
000015A2  4EF9 000015A8            592          JMP     EA_EORI
000015A8                           593  
000015A8                           594  EA_EORI
000015A8                           595          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
000015A8                           596          *and D3 holds the EA register.
000015A8                           597          
000015A8                           598          *Determine how much data to read in, depending on the size of the operation
000015A8                           599          *output the size of the operation and the immediate data to console
000015A8  4EB9 000019C0            600          JSR     WrapperSizeImmediate
000015AE                           601          
000015AE                           602          *manually output a comma here...
000015AE  43F9 0000263F            603          LEA     Comma,A1        *Loads Comma into address register A1
000015B4  103C 000E                604          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015B8  4E4F                     605          TRAP    #15             *Displays Message        
000015BA                           606          
000015BA                           607          *Determine which EA mode and thus Register/Mem Address this instruction used
000015BA  B43C 0000                608          CMP.B   #$00,D2
000015BE  6700 0524                609          BEQ     DataRegMode *If EA mode is a data register, output that
000015C2                           610          
000015C2  B43C 0002                611          CMP.B   #$02,D2
000015C6  6700 053C                612          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015CA                           613          
000015CA  B43C 0003                614          CMP.B   #$03,D2
000015CE  6700 0544                615          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015D2                           616          
000015D2  B43C 0004                617          CMP.B   #$04,D2
000015D6  6700 054C                618          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015DA                           619          
000015DA  B43C 0007                620          CMP.B   #$07,D2
000015DE  6700 0554                621          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015E2                           622          
000015E2                           623          *If the ea mode isn't equal to any of these, it is an invalid EA
000015E2  4EF9 00001F7A            624          JMP     BADEACODE
000015E8                           625  
000015E8                           626  
000015E8                           627  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015E8                           628  *everything up for EA, if is a legit instruction.
000015E8                           629  IS_BCHG_D
000015E8                           630          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015E8                           631          *invalid, branch to BADOPCODE
000015E8  3007                     632          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015EA  0800 0007                633          BTST.L  #$07,D0
000015EE  6600 097A                634          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015F2  0800 0006                635          BTST.L  #$06,D0
000015F6  6700 0972                636          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000015FA                           637          
000015FA                           638          *Output 'BCHG' to console...
000015FA  43F9 00002537            639          LEA     BCHG,A1         *Loads BCHG into address register A1
00001600  103C 000E                640          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001604  4E4F                     641          TRAP    #15             *Displays Message
00001606                           642                  
00001606                           643                  
00001606                           644          *Should have a valid BCHG op code. Set data up for EA.
00001606                           645  
00001606                           646          *Set D1 to the EA source register located in bits 11-9 of the instruction
00001606  4281                     647          CLR.L   D1
00001608  3207                     648          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000160A  C27C 0E00                649          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
0000160E  E049                     650          LSR.W   #$08,D1     *Shift the EA source register bits into LSB
00001610  E249                     651          LSR.W   #$01,D1
00001612                           652  
00001612                           653          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001612  4282                     654          CLR.L   D2
00001614  3407                     655          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001616  C47C 0038                656          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000161A  E60A                     657          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000161C                           658                  
0000161C                           659          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000161C  4283                     660          CLR.L   D3
0000161E  3607                     661          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001620  C67C 0007                662          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001624                           663  
00001624  4EF9 0000162A            664          JMP     EA_BCHG_D
0000162A                           665  
0000162A                           666  EA_BCHG_D
0000162A                           667          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
0000162A                           668          *D2 holds the EA mode, and D3 holds the EA register.
0000162A                           669          
0000162A                           670          *Determine the size of this BCHG instruction. Output the correct size...
0000162A  4EB9 00001A8C            671          JSR     BCHGSizeHelper
00001630                           672          
00001630                           673          *output the source register to console, flag D6 with a 1 so we come back...
00001630  48E7 0200                674          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
00001634  48E7 1000                675          MOVEM.L D3,-(SP)    *Push EA destination register into stack            
00001638  1C3C 0001                676          MOVE.B  #$01,D6     *Flag D6
0000163C  1601                     677          MOVE.B  D1,D3       *Move source register into D3
0000163E  4EB9 00001AE4            678          JSR     DataRegMode
00001644  4CDF 0008                679          MOVEM.L (SP)+,D3    *Pull destination register back into D3
00001648  4CDF 0040                680          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
0000164C                           681          
0000164C                           682          *manually output a comma here...
0000164C  43F9 0000263F            683          LEA     Comma,A1        *Loads Comma into address register A1
00001652  103C 000E                684          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001656  4E4F                     685          TRAP    #15             *Displays Message
00001658                           686          
00001658                           687          *Determine which EA mode and thus Register/Mem Address this instruction used
00001658  B43C 0000                688          CMP.B   #$00,D2
0000165C  6700 0486                689          BEQ     DataRegMode *If EA mode is a data register, output that
00001660                           690          
00001660  B43C 0002                691          CMP.B   #$02,D2
00001664  6700 049E                692          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001668                           693          
00001668  B43C 0003                694          CMP.B   #$03,D2
0000166C  6700 04A6                695          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001670                           696          
00001670  B43C 0004                697          CMP.B   #$04,D2
00001674  6700 04AE                698          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001678                           699          
00001678  B43C 0007                700          CMP.B   #$07,D2
0000167C  6700 04B6                701          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001680                           702          
00001680                           703          *If the ea mode isn't equal to any of these, it is an invalid EA
00001680  4EF9 00001F7A            704          JMP     BADEACODE
00001686                           705  
00001686                           706  
00001686                           707  *Found a possible BCHG(static) instruction. Verify its bit integrity and then set up
00001686                           708  *everything up for EA, if is a legit instruction.
00001686                           709  IS_BCHG_S
00001686                           710          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
00001686                           711          *invalid, branch to BADOPCODE
00001686  3007                     712          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
00001688  0800 0007                713          BTST.L  #$07,D0
0000168C  6600 08DC                714          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
00001690  0800 0006                715          BTST.L  #$06,D0
00001694  6700 08D4                716          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
00001698                           717          
00001698                           718          *Output 'BCHG' to console...
00001698  43F9 00002537            719          LEA     BCHG,A1         *Loads BCHG into address register A1
0000169E  103C 000E                720          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016A2  4E4F                     721          TRAP    #15             *Displays Message
000016A4                           722          
000016A4                           723          
000016A4                           724          *Should have a valid BCHG op code. Set data up for EA.
000016A4                           725          
000016A4                           726          *Move #$00 into D1, BCHG_S's immediate data is always in byte size
000016A4  4281                     727          CLR.L   D1
000016A6  323C 0000                728          MOVE.W  #$00,D1
000016AA                           729  
000016AA                           730          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000016AA  4282                     731          CLR.L   D2
000016AC  3407                     732          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000016AE  C47C 0038                733          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000016B2  E60A                     734          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000016B4                           735                  
000016B4                           736          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000016B4  4283                     737          CLR.L   D3
000016B6  3607                     738          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000016B8  C67C 0007                739          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000016BC                           740  
000016BC  4EF9 000016C2            741          JMP     EA_BCHG_S
000016C2                           742  
000016C2                           743  EA_BCHG_S
000016C2                           744          *Decode the ea bits of BCHG(static). Assuming D2 holds the EA mode, and 
000016C2                           745          *D3 holds the EA register.
000016C2                           746          
000016C2                           747          *Determine the size of this BCHG instruction. Output the correct size...
000016C2  4EB9 00001A8C            748          JSR     BCHGSizeHelper                
000016C8                           749          
000016C8                           750          *output the immediate data of this operation to console (always byte)...
000016C8  4EB9 00001ABC            751          JSR     BCHGImmediate
000016CE                           752          
000016CE                           753          *manually output a comma here...
000016CE  43F9 0000263F            754          LEA     Comma,A1        *Loads Comma into address register A1
000016D4  103C 000E                755          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016D8  4E4F                     756          TRAP    #15             *Displays Message
000016DA                           757          
000016DA                           758          *Determine which EA mode and thus Register/Mem Address this instruction used
000016DA  B43C 0000                759          CMP.B   #$00,D2
000016DE  6700 0404                760          BEQ     DataRegMode *If EA mode is a data register, output that
000016E2                           761          
000016E2  B43C 0002                762          CMP.B   #$02,D2
000016E6  6700 041C                763          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016EA                           764          
000016EA  B43C 0003                765          CMP.B   #$03,D2
000016EE  6700 0424                766          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016F2                           767          
000016F2  B43C 0004                768          CMP.B   #$04,D2
000016F6  6700 042C                769          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000016FA                           770          
000016FA  B43C 0007                771          CMP.B   #$07,D2
000016FE  6700 0434                772          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001702                           773          
00001702                           774          *If the ea mode isn't equal to any of these, it is an invalid EA
00001702  4EF9 00001F7A            775          JMP     BADEACODE
00001708                           776  
00001708                           777  
00001708                           778  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
00001708                           779  IS_CMPI
00001708                           780          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001708                           781          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001708  4281                     782          CLR.L   D1
0000170A  3207                     783          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000170C  C27C 00C0                784          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001710  EC09                     785          LSR.B   #$06,D1     *Shift the size bits into LSB
00001712                           786          
00001712  B23C 0003                787          CMP.B   #$03,D1     *Compare the size bits to $3
00001716  6700 0852                788          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000171A                           789          
0000171A                           790          *Output 'CMPI' to console...
0000171A  43F9 0000253C            791          LEA     CMPI,A1     *Loads CMPI into address register A1
00001720  103C 000E                792          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001724  4E4F                     793          TRAP    #15         *Displays Message
00001726                           794          
00001726                           795          
00001726                           796          *Should have a valid CMPI op code. Set data up for EA.
00001726                           797          
00001726                           798          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001726  4282                     799          CLR.L   D2
00001728  3407                     800          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000172A  C47C 0038                801          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000172E  E60A                     802          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001730                           803                  
00001730                           804          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001730  4283                     805          CLR.L   D3
00001732  3607                     806          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001734  C67C 0007                807          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001738                           808          
00001738  4EF9 0000173E            809          JMP     EA_CMPI
0000173E                           810  
0000173E                           811  EA_CMPI
0000173E                           812          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
0000173E                           813          *and D3 holds the EA register.
0000173E                           814          
0000173E                           815          *Determine how much data to read in, depending on the size of the operation
0000173E                           816          *output the size of the operation and the immediate data to console
0000173E  4EB9 000019C0            817          JSR     WrapperSizeImmediate
00001744                           818          
00001744                           819          *manually output a comma here...
00001744  43F9 0000263F            820          LEA     Comma,A1        *Loads Comma into address register A1
0000174A  103C 000E                821          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000174E  4E4F                     822          TRAP    #15             *Displays Message
00001750                           823          
00001750                           824          *Determine which EA mode and thus Register/Mem Address this instruction used
00001750  B43C 0000                825          CMP.B   #$00,D2
00001754  6700 038E                826          BEQ     DataRegMode *If EA mode is a data register, output that
00001758                           827          
00001758  B43C 0002                828          CMP.B   #$02,D2
0000175C  6700 03A6                829          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001760                           830          
00001760  B43C 0003                831          CMP.B   #$03,D2
00001764  6700 03AE                832          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001768                           833          
00001768  B43C 0004                834          CMP.B   #$04,D2
0000176C  6700 03B6                835          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001770                           836          
00001770  B43C 0007                837          CMP.B   #$07,D2
00001774  6700 03BE                838          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001778                           839          
00001778                           840          *If the ea mode isn't equal to any of these, it is an invalid EA
00001778  4EF9 00001F7A            841          JMP     BADEACODE
0000177E                           842        
0000177E                           843    
0000177E                           844  *STARTS WITH 0001, MOVE.B-----------------------------------
0000177E                           845  BUCKET_0001
0000177E  =00000001                846  BUCKET0001_BITS EQU $1
0000177E                           847          
0000177E                           848          *some code...
0000177E                           849  
0000177E                           850  
0000177E                           851  *STARTS WITH 0010, MOVE.L-----------------------------------
0000177E                           852  BUCKET_0010
0000177E  =00000002                853  BUCKET0010_BITS EQU $2
0000177E                           854  
0000177E                           855          *some code...
0000177E                           856  
0000177E                           857  
0000177E                           858  *STARTS WITH 0011, MOVE.W-----------------------------------
0000177E                           859  BUCKET_0011
0000177E  =00000003                860  BUCKET0011_BITS EQU $3
0000177E                           861  
0000177E                           862          *some code...
0000177E                           863  
0000177E                           864  
0000177E                           865  *-----------------------------------------------------------        
0000177E                           866  * Bucket 0100:
0000177E                           867  * STARTS WITH 0100, MOVEM | MULS(L)-------------------------
0000177E                           868  *                   LEA | CLR | JSR | RTS-------------------
0000177E                           869  *-----------------------------------------------------------
0000177E                           870  BUCKET_0100
0000177E  =00000004                871  BUCKET0100_BITS EQU $4
0000177E  4281                     872          CLR.L   D1
00001780                           873          *Load the first 4 bits (really a byte) of BUCKET0100 into D1
00001780  123C 0004                874          MOVE.B  #BUCKET0100_BITS,D1
00001784                           875          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0100. 
00001784                           876          *If equal, continue decoding. If not, branch to next bucket.
00001784  B200                     877          CMP.B   D0,D1
00001786  6600 017C                878          BNE     BUCKET_0101
0000178A                           879  
0000178A                           880          *Test the 8th bit in this instruction, if it is 1, then it is an LEA 
0000178A                           881          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1.
0000178A  3007                     882          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
0000178C  0800 0008                883          BTST.L  #$08,D0
00001790  6600 0038                884          BNE     IS_LEA  *If the zbit was 0 (the 8th bit is 1), branch to IS_LEA
00001794                           885  
00001794                           886          *JSR/RTS in this bucket can only be determined by only bits 11-6
00001794  C07C 0FC0                887          AND.W   #$0FC0,D0   *Mask out everything but bits 11-6
00001798  EC48                     888          LSR.W   #$06,D0     *Move bits 11-6 into LSB position
0000179A                           889          
0000179A                           890          *Check bits 11-6 in the instruction and branch to different either JSR or RTS 
0000179A                           891          *depending on what the bits equal
0000179A  B03C 003A                892          CMP.B   #$3A,D0 *Is this a JSR?
0000179E  6700 010C                893          BEQ     IS_JSR
000017A2  B03C 0039                894          CMP.B   #$39,D0 *Is this a RTS?
000017A6  6700 013C                895          BEQ     IS_RTS
000017AA                           896  
000017AA                           897          *Now we can use only bits 11-8 and branch to different op-codes only needing these
000017AA                           898          *four bits to be unambiguous
000017AA  E448                     899          LSR.W   #$02,D0 *Shift the 7-6 bits out, leaving only 11-8
000017AC  B03C 0008                900          CMP.B   #$08,D0 *Is this a MOVEM(RegToMem)?
000017B0  6700 0018                901          BEQ     IS_MOVEM_RegToMem
000017B4  B03C 000C                902          CMP.B   #$0C,D0 *Is this a MOVEM(MemToReg)?
000017B8  6700 0010                903          BEQ     IS_MOVEM_MemToReg
000017BC  B03C 0002                904          CMP.B   #$02,D0 *Is this a CLR?
000017C0  6700 0080                905          BEQ     IS_CLR
000017C4                           906          
000017C4                           907          *If we get through all of the compares without finding the specific instruction,
000017C4                           908          *then this instruction is either not in our list of OP CODES to decode, or is an
000017C4                           909          *invalid instruction/syntax.
000017C4  4EF9 00001F6A            910          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000017CA                           911  
000017CA                           912  
000017CA                           913  *Now we know this instruction is exactly MOVEM(RegToMem), lets set everything up for EA.
000017CA                           914  IS_MOVEM_RegToMem
000017CA                           915  
000017CA                           916  EA_MOVEM_RegToMem
000017CA                           917  
000017CA                           918  
000017CA                           919  *Now we know this instruction is exactly MOVEM(MemToReg), lets set everything up for EA.
000017CA                           920  IS_MOVEM_MemToReg
000017CA                           921  
000017CA                           922  EA_MOVEM_MemToReg
000017CA                           923  
000017CA                           924  
000017CA                           925  *Now we know this instruction is exactly LEA, lets set everything up for EA.
000017CA                           926  IS_LEA
000017CA                           927          *Check bits 7 and 6, these should be 1 and 1. If not, this instruction is
000017CA                           928          *invalid, branch to BADOPCODE
000017CA  3007                     929          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000017CC  0800 0007                930          BTST.L  #$07,D0
000017D0  6700 0798                931          BEQ     BADOPCODE  *If the zbit was 1 (the 7th bit is 0), branch to BADOPCODE
000017D4  0800 0006                932          BTST.L  #$06,D0
000017D8  6700 0790                933          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000017DC                           934          
000017DC                           935          *Output 'LEA' to console...
000017DC  43F9 0000254C            936          LEA     LEA,A1         *Loads LEA into address register A1
000017E2  103C 000E                937          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000017E6  4E4F                     938          TRAP    #15             *Displays Message
000017E8                           939          
000017E8                           940          
000017E8                           941          *Should have a valid LEA op code. Set data up for EA.      
000017E8                           942          
000017E8                           943          *Set D1 to the EA destination register located in bits 11-9 of the instruction
000017E8  4281                     944          CLR.L   D1
000017EA  3207                     945          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000017EC  C27C 0E00                946          AND.W   #$0E00,D1   *Mask out everything but the EA destination register bits
000017F0  E049                     947          LSR.W   #$08,D1     *Shift the EA destination register bits into LSB
000017F2  E249                     948          LSR.W   #$01,D1
000017F4                           949  
000017F4                           950          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000017F4  4282                     951          CLR.L   D2
000017F6  3407                     952          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000017F8  C47C 0038                953          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000017FC  E60A                     954          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000017FE                           955                  
000017FE                           956          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000017FE  4283                     957          CLR.L   D3
00001800  3607                     958          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001802  C67C 0007                959          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001806                           960  
00001806  4EF9 0000180C            961          JMP     EA_LEA       
0000180C                           962  
0000180C                           963  EA_LEA
0000180C                           964          *Decode the ea bits of LEA. Assuming D1 holds the destination register, D2 holds the
0000180C                           965          *EA mode, and D3 holds the EA register.
0000180C                           966          
0000180C                           967          *Determine which EA mode and thus Register/Mem Address this instruction used
0000180C  48E7 0200                968          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
00001810  1C3C 0001                969          MOVE.B  #$01,D6     *Flag D6 so that we come back
00001814                           970          
00001814  B43C 0002                971          CMP.B   #$02,D2
00001818  6700 02B6                972          BEQ     LEA_AddrIndirectWrapper *If EA mode is an addr indirect, output that
0000181C                           973          
0000181C  B43C 0007                974          CMP.B   #$07,D2
00001820  6700 02B8                975          BEQ     LEA_AddrAbsoluteWrapper *If EA mode is an addr absolute word/long, output that
00001824                           976  
00001824                           977  EA_LEA_WrapperEnd        
00001824  4CDF 0040                978          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001828                           979                  
00001828                           980          *manually output a comma here...
00001828  43F9 0000263F            981          LEA     Comma,A1        *Loads Comma into address register A1
0000182E  103C 000E                982          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001832  4E4F                     983          TRAP    #15             *Displays Message
00001834                           984          
00001834                           985          *output the destination address register to console
00001834                           986          *Overwrite the EA register with destination register (no longer need D3 at this point)
00001834  1601                     987          MOVE.B  D1,D3
00001836  4EB9 00001AF4            988          JSR     AddrRegMode
0000183C                           989          
0000183C                           990          *If the ea mode isn't equal to any of these, it is an invalid EA
0000183C  4EF9 00001F7A            991          JMP     BADEACODE
00001842                           992          
00001842                           993          
00001842                           994  *Now we know this instruction is exactly CLR, lets set everything up for EA.
00001842                           995  IS_CLR
00001842                           996          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001842                           997          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001842  4281                     998          CLR.L   D1
00001844  3207                     999          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001846  C27C 00C0               1000          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000184A  EC09                    1001          LSR.B   #$06,D1     *Shift the size bits into LSB
0000184C                          1002          
0000184C  B23C 0003               1003          CMP.B   #$03,D1     *Compare the size bits to $3
00001850  6700 0718               1004          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001854                          1005          
00001854                          1006          *Output 'CLR' to console...
00001854  43F9 00002556           1007          LEA     CLR,A1      *Loads CLR into address register A1
0000185A  103C 000E               1008          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000185E  4E4F                    1009          TRAP    #15         *Displays Message
00001860                          1010          
00001860                          1011          
00001860                          1012          *Should have a valid CLR op code. Set data up for EA.
00001860                          1013          
00001860                          1014          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001860  4282                    1015          CLR.L   D2
00001862  3407                    1016          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001864  C47C 0038               1017          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001868  E60A                    1018          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000186A                          1019                  
0000186A                          1020          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000186A  4283                    1021          CLR.L   D3
0000186C  3607                    1022          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000186E  C67C 0007               1023          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001872                          1024          
00001872  4EF9 00001878           1025          JMP     EA_CLR
00001878                          1026  
00001878                          1027  EA_CLR
00001878                          1028          *Decode the ea bits of CLR. Assuming D1 holds the size, D2 holds the EA mode,
00001878                          1029          *and D3 holds the EA register.
00001878                          1030          
00001878                          1031          *output the size of the operation to console
00001878  4EB9 00001A42           1032          JSR     WrapperSize       
0000187E                          1033          
0000187E                          1034          *Determine which EA mode and thus Register/Mem Address this instruction used
0000187E  B43C 0000               1035          CMP.B   #$00,D2
00001882  6700 0260               1036          BEQ     DataRegMode *If EA mode is a data register, output that
00001886                          1037          
00001886  B43C 0002               1038          CMP.B   #$02,D2
0000188A  6700 0278               1039          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000188E                          1040          
0000188E  B43C 0003               1041          CMP.B   #$03,D2
00001892  6700 0280               1042          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001896                          1043          
00001896  B43C 0004               1044          CMP.B   #$04,D2
0000189A  6700 0288               1045          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000189E                          1046          
0000189E  B43C 0007               1047          CMP.B   #$07,D2
000018A2  6700 0290               1048          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000018A6                          1049          
000018A6                          1050          *If the ea mode isn't equal to any of these, it is an invalid EA
000018A6  4EF9 00001F7A           1051          JMP     BADEACODE
000018AC                          1052  
000018AC                          1053  
000018AC                          1054  *Now we know this instruction is exactly JSR, lets set everything up for EA.
000018AC                          1055  IS_JSR        
000018AC                          1056          *Output 'JSR' to console...
000018AC  43F9 0000255A           1057          LEA     JSR,A1      *Loads JSR into address register A1
000018B2  103C 000E               1058          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018B6  4E4F                    1059          TRAP    #15         *Displays Message
000018B8                          1060          
000018B8                          1061          
000018B8                          1062          *Should have a valid JSR op code. Set data up for EA.
000018B8                          1063          
000018B8                          1064          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000018B8  4282                    1065          CLR.L   D2
000018BA  3407                    1066          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000018BC  C47C 0038               1067          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000018C0  E60A                    1068          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000018C2                          1069                  
000018C2                          1070          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000018C2  4283                    1071          CLR.L   D3
000018C4  3607                    1072          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000018C6  C67C 0007               1073          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000018CA                          1074          
000018CA  4EF8 1878               1075          JMP     EA_CLR
000018CE                          1076  
000018CE                          1077  EA_JSR
000018CE                          1078          *Decode the ea bits of JSR. Assuming D1 holds the size, D2 holds the EA mode,
000018CE                          1079          *and D3 holds the EA register.               
000018CE                          1080          
000018CE                          1081          *Determine which EA mode and thus Register/Mem Address this instruction used        
000018CE  B43C 0002               1082          CMP.B   #$02,D2
000018D2  6700 0230               1083          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000018D6                          1084                         
000018D6  B43C 0007               1085          CMP.B   #$07,D2
000018DA  6700 0258               1086          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000018DE                          1087          
000018DE                          1088          *If the ea mode isn't equal to any of these, it is an invalid EA
000018DE  4EF9 00001F7A           1089          JMP     BADEACODE
000018E4                          1090  
000018E4                          1091  
000018E4                          1092  *Now we know this instruction is exactly RTS, lets set everything up for EA.
000018E4                          1093  IS_RTS
000018E4                          1094          *Verify bits 5-0 of this instruction. If its not equal to %11 0101, it is an
000018E4                          1095          *invalid op code        
000018E4  4282                    1096          CLR.L   D2
000018E6  3407                    1097          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000018E8  C47C 003F               1098          AND.W   #$003F,D2   *Mask out everything but bits 5-0
000018EC                          1099          
000018EC                          1100          *Bits 5-0 aren't equal to $35, bad op code
000018EC  B43C 0035               1101          CMP.B   #$35,D2
000018F0  6600 0678               1102          BNE     BADOPCODE
000018F4                          1103  
000018F4                          1104          *Output 'RTS' to console...
000018F4  43F9 00002564           1105          LEA     RTS,A1      *Loads RTS into address register A1
000018FA  103C 000E               1106          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018FE  4E4F                    1107          TRAP    #15         *Displays Message
00001900                          1108                          
00001900                          1109          *Should have a valid RTS op code. Note: No EA decoding is needed for RTS!        
00001900  4EF8 1380               1110          JMP     GRAB_NEXT_OP
00001904                          1111  
00001904                          1112  
00001904                          1113  *STARTS WITH 0101, SUBQ-------------------------------------
00001904                          1114  BUCKET_0101
00001904  =00000005               1115  BUCKET0101_BITS EQU $5
00001904  4281                    1116          CLR.L   D1
00001906                          1117          *Load the first 4 bits (really a byte) of BUCKET0101 into D1
00001906  123C 0005               1118          MOVE.B  #BUCKET0101_BITS,D1
0000190A                          1119          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0101. 
0000190A                          1120          *If equal, continue decoding. If not, branch to next bucket.
0000190A  B200                    1121          CMP.B   D0,D1
0000190C  6600 00AC               1122          BNE     BUCKET_0110
00001910                          1123  
00001910                          1124          *Test the 8th bit in this instruction, if it is 1, then it is a SUBQ 
00001910                          1125          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1.
00001910  3007                    1126          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001912  0800 0008               1127          BTST.L  #$08,D0
00001916  6600 0008               1128          BNE     IS_SUBQ *If the zbit was 0 (the 8th bit is 1), branch to IS_LEA
0000191A                          1129          
0000191A                          1130          *If we get through all of the compares without finding the specific instruction,
0000191A                          1131          *then this instruction is either not in our list of OP CODES to decode, or is an
0000191A                          1132          *invalid instruction/syntax.
0000191A  4EF9 00001F6A           1133          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
00001920                          1134  
00001920                          1135  
00001920                          1136  IS_SUBQ
00001920                          1137          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001920                          1138          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001920  4281                    1139          CLR.L   D1
00001922  3207                    1140          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001924  C27C 00C0               1141          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001928  EC09                    1142          LSR.B   #$06,D1     *Shift the size bits into LSB
0000192A                          1143          
0000192A  B23C 0003               1144          CMP.B   #$03,D1     *Compare the size bits to $3
0000192E  6700 063A               1145          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)                        
00001932                          1146          
00001932                          1147          *Output 'SUBQ' to console...
00001932  43F9 00002568           1148          LEA     SUBQ,A1         *Loads SUBQ into address register A1
00001938  103C 000E               1149          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000193C  4E4F                    1150          TRAP    #15             *Displays Message
0000193E                          1151                  
0000193E                          1152                  
0000193E                          1153          *Should have a valid SUBQ op code. Set data up for EA.
0000193E                          1154  
0000193E                          1155          *Set D4 to the immediate data located in bits 11-9 of the instruction
0000193E  4284                    1156          CLR.L   D4
00001940  3807                    1157          MOVE.W  D7,D4       *Move the WHOLE instruction to D0
00001942  C87C 0E00               1158          AND.W   #$0E00,D4   *Mask out everything but the immediate data bits
00001946  E04C                    1159          LSR.W   #$08,D4     *Shift the immediate data bits into LSB
00001948  E24C                    1160          LSR.W   #$01,D4
0000194A                          1161  
0000194A                          1162          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000194A  4282                    1163          CLR.L   D2
0000194C  3407                    1164          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000194E  C47C 0038               1165          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001952  E60A                    1166          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001954                          1167                  
00001954                          1168          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001954  4283                    1169          CLR.L   D3
00001956  3607                    1170          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001958  C67C 0007               1171          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000195C                          1172  
0000195C  4EF9 00001962           1173          JMP     EA_SUBQ
00001962                          1174  
00001962                          1175  EA_SUBQ
00001962                          1176          *Decode the ea bits of SUBQ. Assuming D4 holds the immediate data D1 holds the size, 
00001962                          1177          *D2 holds the EA mode, and D3 holds the EA register.                    
00001962                          1178      
00001962                          1179          *output the size of the operation to console
00001962  4EB9 00001A42           1180          JSR     WrapperSize
00001968                          1181              
00001968                          1182          *Output '#$' just before the immediate data
00001968  43F9 00002644           1183          LEA     ShaBang,A1
0000196E  103C 000E               1184          MOVE.B  #14,D0
00001972  4E4F                    1185          TRAP    #15            
00001974                          1186              
00001974                          1187          *output the immediate data for this instruction with the hex-ascii converter
00001974  4EB8 11EA               1188          JSR     HEXASCII
00001978                          1189                          
00001978                          1190          *manually output a comma here...
00001978  43F9 0000263F           1191          LEA     Comma,A1        *Loads Comma into address register A1
0000197E  103C 000E               1192          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001982  4E4F                    1193          TRAP    #15             *Displays Message
00001984                          1194          
00001984                          1195          *Determine which EA mode and thus Register/Mem Address this instruction used
00001984  B43C 0000               1196          CMP.B   #$00,D2
00001988  6700 015A               1197          BEQ     DataRegMode *If EA mode is a data register, output that
0000198C                          1198          
0000198C  B43C 0001               1199          CMP.B   #$01,D2
00001990  6700 0162               1200          BEQ     AddrRegMode *If EA mode is an address register, output that
00001994                          1201          
00001994  B43C 0002               1202          CMP.B   #$02,D2
00001998  6700 016A               1203          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000199C                          1204          
0000199C  B43C 0003               1205          CMP.B   #$03,D2
000019A0  6700 0172               1206          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000019A4                          1207          
000019A4  B43C 0004               1208          CMP.B   #$04,D2
000019A8  6700 017A               1209          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000019AC                          1210          
000019AC  B43C 0007               1211          CMP.B   #$07,D2
000019B0  6700 0182               1212          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000019B4                          1213          
000019B4                          1214          *If the ea mode isn't equal to any of these, it is an invalid EA
000019B4  4EF9 00001F7A           1215          JMP     BADEACODE
000019BA                          1216  
000019BA                          1217  
000019BA                          1218  *STARTS WITH 0110, BCC--------------------------------------
000019BA                          1219  BUCKET_0110
000019BA  =00000006               1220  BUCKET0110_BITS EQU $6
000019BA                          1221  
000019BA                          1222          *some code...
000019BA                          1223  
000019BA                          1224  
000019BA                          1225  *STARTS WITH 1000, DIVU-------------------------------------
000019BA                          1226  BUCKET_1000
000019BA  =00000008               1227  BUCKET1000_BITS EQU $8
000019BA                          1228  
000019BA                          1229          *some code...
000019BA                          1230  
000019BA                          1231  
000019BA                          1232  *STARTS WITH 1001, SUBA-------------------------------------
000019BA                          1233  BUCKET_1001
000019BA  =00000009               1234  BUCKET1001_BITS EQU $9
000019BA                          1235  
000019BA                          1236          *some code...
000019BA                          1237  
000019BA                          1238  
000019BA                          1239  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000019BA                          1240  BUCKET_1011
000019BA  =0000000B               1241  BUCKET1011_BITS EQU $B
000019BA                          1242  
000019BA                          1243          *some code...
000019BA                          1244  
000019BA                          1245  
000019BA                          1246  *STARTS WITH 1100, MULS(W) | AND----------------------------
000019BA                          1247  BUCKET_1100
000019BA  =0000000C               1248  BUCKET1100_BITS EQU $C
000019BA                          1249  
000019BA                          1250          *some code...
000019BA                          1251  
000019BA                          1252  
000019BA                          1253  *STARTS WITH 1101, ADD | ADDA-------------------------------
000019BA                          1254  BUCKET_1101
000019BA  =0000000D               1255  BUCKET1101_BITS EQU $D
000019BA                          1256  
000019BA                          1257          *some code...
000019BA                          1258  
000019BA                          1259  
000019BA                          1260  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000019BA                          1261  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000019BA                          1262  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000019BA                          1263  BUCKET_1110
000019BA  =0000000E               1264  BUCKET1110_BITS EQU $E     
000019BA                          1265  
000019BA                          1266          *some code...
000019BA                          1267  
000019BA                          1268  
000019BA                          1269  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000019BA                          1270  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000019BA  4EF9 00001F6A           1271          JMP     BADOPCODE  
000019C0                          1272  
000019C0                          1273  
000019C0                          1274  *-----------------------------------------------------------        
000019C0                          1275  * EA operation size decoding functionality for immediate data
000019C0                          1276  *-----------------------------------------------------------   
000019C0                          1277  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
000019C0                          1278  WrapperSizeImmediate
000019C0  4284                    1279          CLR.L   D4
000019C2                          1280          *Depending on the EA size, choose which size to decode
000019C2  B23C 0000               1281          CMP.B   #$00,D1
000019C6  6700 0014               1282          BEQ     ByteSizeImmediate
000019CA                          1283          
000019CA  B23C 0001               1284          CMP.B   #$01,D1
000019CE  6700 002E               1285          BEQ     WordSizeImmediate
000019D2                          1286  
000019D2  B23C 0002               1287          CMP.B   #$02,D1
000019D6  6700 0048               1288          BEQ     LongSizeImmediate
000019DA                          1289          
000019DA                          1290  *Used to get back to what we were doing, after dealing with the specific size
000019DA                          1291  WrapperSizeImmediateEnd
000019DA  4E75                    1292          RTS
000019DC                          1293          
000019DC                          1294  ByteSizeImmediate
000019DC  3818                    1295          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
000019DE                          1296          
000019DE                          1297          *Output '.B' to console...
000019DE  43F9 0000256D           1298          LEA     ByteSize,A1 *Loads ByteSize into address register A1
000019E4  103C 000E               1299          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019E8  4E4F                    1300          TRAP    #15         *Displays Message
000019EA                          1301          
000019EA                          1302          *Output '#$' just before the immediate data
000019EA  43F9 00002644           1303          LEA     ShaBang,A1
000019F0  103C 000E               1304          MOVE.B  #14,D0
000019F4  4E4F                    1305          TRAP    #15  
000019F6                          1306          
000019F6                          1307          *output the immediate data to console with the hex-ascii converter
000019F6  4EB8 11EA               1308          JSR     HEXASCII
000019FA                          1309                  
000019FA  4EF8 19DA               1310          JMP     WrapperSizeImmediateEnd
000019FE                          1311                  
000019FE                          1312  WordSizeImmediate
000019FE  3818                    1313          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001A00                          1314          
00001A00                          1315          *Output '.W' to console...
00001A00  43F9 00002574           1316          LEA     WordSize,A1 *Loads WordSize into address register A1
00001A06  103C 000E               1317          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A0A  4E4F                    1318          TRAP    #15         *Displays Message
00001A0C                          1319          
00001A0C                          1320          *Output '#$' just before the immediate data
00001A0C  43F9 00002644           1321          LEA     ShaBang,A1
00001A12  103C 000E               1322          MOVE.B  #14,D0
00001A16  4E4F                    1323          TRAP    #15  
00001A18                          1324          
00001A18                          1325          *output the immediate data to console with the hex-ascii converter
00001A18  4EB8 11EA               1326          JSR     HEXASCII
00001A1C                          1327          
00001A1C  4EF8 19DA               1328          JMP     WrapperSizeImmediateEnd
00001A20                          1329                  
00001A20                          1330  LongSizeImmediate
00001A20  2818                    1331          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
00001A22                          1332          
00001A22                          1333          *Output '.L' to console...
00001A22  43F9 0000257B           1334          LEA     LongSize,A1 *Loads LongSize into address register A1
00001A28  103C 000E               1335          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A2C  4E4F                    1336          TRAP    #15         *Displays Message
00001A2E                          1337          
00001A2E                          1338          *Output '#$' just before the immediate data
00001A2E  43F9 00002644           1339          LEA     ShaBang,A1
00001A34  103C 000E               1340          MOVE.B  #14,D0
00001A38  4E4F                    1341          TRAP    #15  
00001A3A                          1342          
00001A3A                          1343          *output the immediate data to console with the hex-ascii converter
00001A3A  4EB8 11EA               1344          JSR     HEXASCII
00001A3E                          1345          
00001A3E  4EF8 19DA               1346          JMP     WrapperSizeImmediateEnd        
00001A42                          1347  
00001A42                          1348  
00001A42                          1349  *-----------------------------------------------------------        
00001A42                          1350  * EA operation size decoding functionality for non-immediate data. Used to figure out
00001A42                          1351  * and output the size affix for a typical opcode.
00001A42                          1352  *-----------------------------------------------------------   
00001A42                          1353  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001A42                          1354  WrapperSize
00001A42                          1355          *Depending on the EA size, choose which size to decode
00001A42  B23C 0000               1356          CMP.B   #$00,D1
00001A46  6700 0014               1357          BEQ     ByteSizeOp
00001A4A                          1358          
00001A4A  B23C 0001               1359          CMP.B   #$01,D1
00001A4E  6700 001C               1360          BEQ     WordSizeOp
00001A52                          1361  
00001A52  B23C 0002               1362          CMP.B   #$02,D1
00001A56  6700 0024               1363          BEQ     LongSizeOp
00001A5A                          1364          
00001A5A                          1365  *Used to get back to what we were doing, after dealing with the specific size
00001A5A                          1366  WrapperSizeEnd
00001A5A  4E75                    1367          RTS
00001A5C                          1368          
00001A5C                          1369  ByteSizeOp                
00001A5C                          1370          *Output '.B' to console...
00001A5C  43F9 0000256D           1371          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001A62  103C 000E               1372          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A66  4E4F                    1373          TRAP    #15         *Displays Message                
00001A68                          1374                  
00001A68  4EF8 1A5A               1375          JMP     WrapperSizeEnd
00001A6C                          1376                  
00001A6C                          1377  WordSizeOp
00001A6C                          1378          *Output '.W' to console...
00001A6C  43F9 00002574           1379          LEA     WordSize,A1 *Loads WordSize into address register A1
00001A72  103C 000E               1380          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A76  4E4F                    1381          TRAP    #15         *Displays Message               
00001A78                          1382          
00001A78  4EF8 1A5A               1383          JMP     WrapperSizeEnd
00001A7C                          1384                  
00001A7C                          1385  LongSizeOp      
00001A7C                          1386          *Output '.L' to console...
00001A7C  43F9 0000257B           1387          LEA     LongSize,A1 *Loads LongSize into address register A1
00001A82  103C 000E               1388          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A86  4E4F                    1389          TRAP    #15         *Displays Message                
00001A88                          1390          
00001A88  4EF8 1A5A               1391          JMP     WrapperSizeEnd        
00001A8C                          1392  
00001A8C                          1393  
00001A8C                          1394  *-----------------------------------------------------------        
00001A8C                          1395  * BCHG Size decoding functionality
00001A8C                          1396  *----------------------------------------------------------- 
00001A8C                          1397  BCHGSizeHelper
00001A8C                          1398          *Determine if the EA mode is a data register. If so, output '.L' to console...
00001A8C  B43C 0000               1399          CMP.B   #$00,D2
00001A90  6700 000A               1400          BEQ     BCHGLongSize
00001A94                          1401          
00001A94                          1402          *If the EA mode isn't a data register, WE MUST output a '.B' to console...
00001A94  4EF9 00001AAC           1403          JMP     BCHGByteSize
00001A9A                          1404          
00001A9A                          1405  *Used to get back to what we were doing, after dealing with the specific size
00001A9A                          1406  BCHGSizeHelperEnd
00001A9A  4E75                    1407          RTS  
00001A9C                          1408          
00001A9C                          1409  BCHGLongSize
00001A9C                          1410          *Output '.L' to console...
00001A9C  43F9 0000257B           1411          LEA     LongSize,A1 *Loads LongSize into address register A1
00001AA2  103C 000E               1412          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001AA6  4E4F                    1413          TRAP    #15         *Displays Message
00001AA8                          1414  
00001AA8  4EF8 1A9A               1415          JMP     BCHGSizeHelperEnd
00001AAC                          1416          
00001AAC                          1417  BCHGByteSize
00001AAC                          1418          *Output '.B' to console...
00001AAC  43F9 0000256D           1419          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001AB2  103C 000E               1420          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001AB6  4E4F                    1421          TRAP    #15         *Displays Message   
00001AB8                          1422          
00001AB8  4EF8 1A9A               1423          JMP     BCHGSizeHelperEnd
00001ABC                          1424          
00001ABC                          1425  *Output the immediate data for a BCHG(static). Data is always byte size.
00001ABC                          1426  BCHGImmediate
00001ABC  3818                    1427          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word        
00001ABE                          1428          
00001ABE                          1429          *Output '#$' just before the immediate data
00001ABE  43F9 00002644           1430          LEA     ShaBang,A1
00001AC4  103C 000E               1431          MOVE.B  #14,D0
00001AC8  4E4F                    1432          TRAP    #15  
00001ACA                          1433          
00001ACA                          1434          *output the immediate data to console with the hex-ascii converter
00001ACA  4EB8 11EA               1435          JSR     HEXASCII
00001ACE                          1436                  
00001ACE  4E75                    1437          RTS        
00001AD0                          1438  
00001AD0                          1439  
00001AD0                          1440  *-----------------------------------------------------------        
00001AD0                          1441  * LEA Wrappers to conform to design of EA mode/register as destination operand. 
00001AD0                          1442  * LEA is weird in that its EA mode/register is used as a source operand.
00001AD0                          1443  *-----------------------------------------------------------        
00001AD0                          1444  *This conforms LEA to the JSR requirement of AddrIndirectMode. JMPs back to LEA after the JSR.
00001AD0                          1445  LEA_AddrIndirectWrapper
00001AD0  4EB9 00001B04           1446          JSR     AddrIndirectMode
00001AD6                          1447          
00001AD6  4EF8 1824               1448          JMP     EA_LEA_WrapperEnd
00001ADA                          1449          
00001ADA                          1450  *This conforms LEA to the JSR requirement of AddrAbsoluteMode. JMPs back to LEA after the JSR.
00001ADA                          1451  LEA_AddrAbsoluteWrapper
00001ADA  4EB9 00001B34           1452          JSR     AddrAbsoluteMode
00001AE0                          1453          
00001AE0  4EF8 1824               1454          JMP     EA_LEA_WrapperEnd
00001AE4                          1455  
00001AE4                          1456  
00001AE4                          1457  *-----------------------------------------------------------        
00001AE4                          1458  * EA Mode/EA Register decoding functionality
00001AE4                          1459  *-----------------------------------------------------------        
00001AE4                          1460  DataRegMode
00001AE4                          1461          *Depending on the EA Register, output a different register number
00001AE4  4EB9 00001B44           1462          JSR     WrapperDataReg        
00001AEA                          1463          
00001AEA                          1464          *if this was called for a destination decoding then we are done decoding this        
00001AEA                          1465          *instruction, go get the next instruction
00001AEA  BC3C 0001               1466          CMP.B   #$01,D6
00001AEE  6600 F890               1467          BNE     GRAB_NEXT_OP
00001AF2                          1468          
00001AF2                          1469          *else this was a source decoding, rts back to we can keep decoding
00001AF2  4E75                    1470          RTS
00001AF4                          1471  
00001AF4                          1472  AddrRegMode
00001AF4  4EB9 00001C06           1473          JSR     WrapperAddrReg
00001AFA                          1474          
00001AFA                          1475          *if this was called for a destination decoding then we are done decoding this        
00001AFA                          1476          *instruction, go get the next instruction
00001AFA  BC3C 0001               1477          CMP.B   #$01,D6
00001AFE  6600 F880               1478          BNE     GRAB_NEXT_OP
00001B02                          1479          
00001B02                          1480          *else this was a source decoding, rts back to we can keep decoding
00001B02  4E75                    1481          RTS
00001B04                          1482  
00001B04                          1483  AddrIndirectMode
00001B04                          1484          *Depending on the EA Register, output a different register number
00001B04  4EB9 00001CC8           1485          JSR     WrapperAddrIndirect
00001B0A                          1486                          
00001B0A                          1487          *if this was called for a destination decoding then we are done decoding this        
00001B0A                          1488          *instruction, go get the next instruction
00001B0A  BC3C 0001               1489          CMP.B   #$01,D6
00001B0E  6600 F870               1490          BNE     GRAB_NEXT_OP
00001B12                          1491          
00001B12                          1492          *else this was a source decoding, rts back to we can keep decoding
00001B12  4E75                    1493          RTS
00001B14                          1494  
00001B14                          1495  AddrIndirectPostMode
00001B14                          1496          *Depending on the EA Register, output a different register number
00001B14  4EB9 00001D8A           1497          JSR     WrapperAddrIndirectPost
00001B1A                          1498  
00001B1A                          1499          *if this was called for a destination decoding then we are done decoding this        
00001B1A                          1500          *instruction, go get the next instruction
00001B1A  BC3C 0001               1501          CMP.B   #$01,D6
00001B1E  6600 F860               1502          BNE     GRAB_NEXT_OP
00001B22                          1503          
00001B22                          1504          *else this was a source decoding, rts back to we can keep decoding
00001B22  4E75                    1505          RTS
00001B24                          1506  
00001B24                          1507  AddrIndirectPreMode
00001B24                          1508          *Depending on the EA Register, output a different register number
00001B24  4EB9 00001E4C           1509          JSR     WrapperAddrIndirectPre
00001B2A                          1510  
00001B2A                          1511          *if this was called for a destination decoding then we are done decoding this        
00001B2A                          1512          *instruction, go get the next instruction
00001B2A  BC3C 0001               1513          CMP.B   #$01,D6
00001B2E  6600 F850               1514          BNE     GRAB_NEXT_OP
00001B32                          1515          
00001B32                          1516          *else this was a source decoding, rts back to we can keep decoding
00001B32  4E75                    1517          RTS
00001B34                          1518  
00001B34                          1519  AddrAbsoluteMode
00001B34                          1520          *Depending on the EA Register, output a different register number
00001B34  4EB9 00001F0E           1521          JSR     WrapperAddrAbsolute        
00001B3A                          1522  
00001B3A                          1523          *if this was called for a destination decoding then we are done decoding this        
00001B3A                          1524          *instruction, go get the next instruction
00001B3A  BC3C 0001               1525          CMP.B   #$01,D6
00001B3E  6600 F840               1526          BNE     GRAB_NEXT_OP
00001B42                          1527          
00001B42                          1528          *else this was a source decoding, rts back to we can keep decoding
00001B42  4E75                    1529          RTS
00001B44                          1530          
00001B44                          1531  ImmediateDataMode
00001B44                          1532          *some code        
00001B44                          1533          
00001B44                          1534          
00001B44                          1535  *-----------------------------------------------------------        
00001B44                          1536  * Output logic for all Data Registers (0-7)
00001B44                          1537  *-----------------------------------------------------------
00001B44                          1538  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001B44                          1539  WrapperDataReg
00001B44                          1540          *Depending on the EA destination register, output a different register number
00001B44  B63C 0000               1541          CMP.B   #$00,D3
00001B48  6700 003C               1542          BEQ     DataReg0
00001B4C                          1543          
00001B4C  B63C 0001               1544          CMP.B   #$01,D3
00001B50  6700 0044               1545          BEQ     DataReg1
00001B54                          1546          
00001B54  B63C 0002               1547          CMP.B   #$02,D3
00001B58  6700 004C               1548          BEQ     DataReg2
00001B5C                          1549          
00001B5C  B63C 0003               1550          CMP.B   #$03,D3
00001B60  6700 0054               1551          BEQ     DataReg3
00001B64                          1552          
00001B64  B63C 0004               1553          CMP.B   #$04,D3
00001B68  6700 005C               1554          BEQ     DataReg4
00001B6C                          1555          
00001B6C  B63C 0005               1556          CMP.B   #$05,D3
00001B70  6700 0064               1557          BEQ     DataReg5
00001B74                          1558          
00001B74  B63C 0006               1559          CMP.B   #$06,D3
00001B78  6700 006C               1560          BEQ     DataReg6
00001B7C                          1561          
00001B7C  B63C 0007               1562          CMP.B   #$07,D3
00001B80  6700 0074               1563          BEQ     DataReg7        
00001B84                          1564  
00001B84                          1565  *Used to get back to 'DataRegMode', after dealing with the specific register
00001B84                          1566  WrapperDataRegEnd
00001B84  4E75                    1567          RTS
00001B86                          1568  
00001B86                          1569  DataReg0
00001B86                          1570          *Output the specific data register...
00001B86  43F9 00002582           1571          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
00001B8C  103C 000E               1572          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001B90  4E4F                    1573          TRAP    #15             *Displays Message   
00001B92                          1574          
00001B92  4EF8 1B84               1575          JMP     WrapperDataRegEnd
00001B96                          1576  
00001B96                          1577  DataReg1
00001B96  43F9 00002585           1578          LEA     OutDataReg1,A1
00001B9C  103C 000E               1579          MOVE.B  #14,D0
00001BA0  4E4F                    1580          TRAP    #15
00001BA2                          1581          
00001BA2  4EF8 1B84               1582          JMP     WrapperDataRegEnd
00001BA6                          1583  
00001BA6                          1584  DataReg2
00001BA6  43F9 00002588           1585          LEA     OutDataReg2,A1
00001BAC  103C 000E               1586          MOVE.B  #14,D0
00001BB0  4E4F                    1587          TRAP    #15
00001BB2                          1588  
00001BB2  4EF8 1B84               1589          JMP     WrapperDataRegEnd
00001BB6                          1590      
00001BB6                          1591  DataReg3
00001BB6  43F9 0000258B           1592          LEA     OutDataReg3,A1
00001BBC  103C 000E               1593          MOVE.B  #14,D0
00001BC0  4E4F                    1594          TRAP    #15
00001BC2                          1595  
00001BC2  4EF8 1B84               1596          JMP     WrapperDataRegEnd
00001BC6                          1597          
00001BC6                          1598  DataReg4
00001BC6  43F9 0000258E           1599          LEA     OutDataReg4,A1
00001BCC  103C 000E               1600          MOVE.B  #14,D0
00001BD0  4E4F                    1601          TRAP    #15
00001BD2                          1602  
00001BD2  4EF8 1B84               1603          JMP     WrapperDataRegEnd
00001BD6                          1604                 
00001BD6                          1605  DataReg5
00001BD6  43F9 00002591           1606          LEA     OutDataReg5,A1
00001BDC  103C 000E               1607          MOVE.B  #14,D0
00001BE0  4E4F                    1608          TRAP    #15
00001BE2                          1609  
00001BE2  4EF8 1B84               1610          JMP     WrapperDataRegEnd
00001BE6                          1611          
00001BE6                          1612  DataReg6
00001BE6  43F9 00002594           1613          LEA     OutDataReg6,A1 A1
00001BEC  103C 000E               1614          MOVE.B  #14,D0
00001BF0  4E4F                    1615          TRAP    #15
00001BF2                          1616  
00001BF2  4EF8 1B84               1617          JMP     WrapperDataRegEnd
00001BF6                          1618          
00001BF6                          1619  DataReg7
00001BF6  43F9 00002597           1620          LEA     OutDataReg7,A1
00001BFC  103C 000E               1621          MOVE.B  #14,D0
00001C00  4E4F                    1622          TRAP    #15
00001C02                          1623          
00001C02  4EF8 1B84               1624          JMP     WrapperDataRegEnd
00001C06                          1625  
00001C06                          1626  
00001C06                          1627  *-----------------------------------------------------------        
00001C06                          1628  * Output logic for all Address Registers (0-7)
00001C06                          1629  *-----------------------------------------------------------     
00001C06                          1630  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001C06                          1631  WrapperAddrReg
00001C06                          1632          *Depending on the EA Register, output a different register number
00001C06  B63C 0000               1633          CMP.B   #$00,D3
00001C0A  6700 003C               1634          BEQ     AddrReg0
00001C0E                          1635          
00001C0E  B63C 0001               1636          CMP.B   #$01,D3
00001C12  6700 0044               1637          BEQ     AddrReg1
00001C16                          1638          
00001C16  B63C 0002               1639          CMP.B   #$02,D3
00001C1A  6700 004C               1640          BEQ     AddrReg2
00001C1E                          1641          
00001C1E  B63C 0003               1642          CMP.B   #$03,D3
00001C22  6700 0054               1643          BEQ     AddrReg3
00001C26                          1644          
00001C26  B63C 0004               1645          CMP.B   #$04,D3
00001C2A  6700 005C               1646          BEQ     AddrReg4
00001C2E                          1647          
00001C2E  B63C 0005               1648          CMP.B   #$05,D3
00001C32  6700 0064               1649          BEQ     AddrReg5
00001C36                          1650          
00001C36  B63C 0006               1651          CMP.B   #$06,D3
00001C3A  6700 006C               1652          BEQ     AddrReg6
00001C3E                          1653          
00001C3E  B63C 0007               1654          CMP.B   #$07,D3
00001C42  6700 0074               1655          BEQ     AddrReg7
00001C46                          1656  
00001C46                          1657  *Used to get back to 'AddrRegMode', after dealing with the specific register
00001C46                          1658  WrapperAddrRegEnd
00001C46  4E75                    1659          RTS        
00001C48                          1660  
00001C48                          1661  AddrReg0
00001C48                          1662          *Output the specific address indirect register...
00001C48  43F9 0000259A           1663          LEA     OutAddrReg0,A1      *Loads AddrReg0 into address register A1
00001C4E  103C 000E               1664          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001C52  4E4F                    1665          TRAP    #15                 *Displays Message        
00001C54                          1666          
00001C54  4EF8 1C46               1667          JMP     WrapperAddrRegEnd
00001C58                          1668  
00001C58                          1669  AddrReg1
00001C58  43F9 0000259D           1670          LEA     OutAddrReg1,A1
00001C5E  103C 000E               1671          MOVE.B  #14,D0
00001C62  4E4F                    1672          TRAP    #15
00001C64                          1673          
00001C64  4EF8 1C46               1674          JMP     WrapperAddrRegEnd
00001C68                          1675  
00001C68                          1676  AddrReg2
00001C68  43F9 000025A0           1677          LEA     OutAddrReg2,A1
00001C6E  103C 000E               1678          MOVE.B  #14,D0
00001C72  4E4F                    1679          TRAP    #15
00001C74                          1680          
00001C74  4EF8 1C46               1681          JMP     WrapperAddrRegEnd
00001C78                          1682  
00001C78                          1683  AddrReg3
00001C78  43F9 000025A3           1684          LEA     OutAddrReg3,A1
00001C7E  103C 000E               1685          MOVE.B  #14,D0
00001C82  4E4F                    1686          TRAP    #15
00001C84                          1687          
00001C84  4EF8 1C46               1688          JMP     WrapperAddrRegEnd
00001C88                          1689  
00001C88                          1690  AddrReg4
00001C88  43F9 000025A6           1691          LEA     OutAddrReg4,A1
00001C8E  103C 000E               1692          MOVE.B  #14,D0
00001C92  4E4F                    1693          TRAP    #15
00001C94                          1694          
00001C94  4EF8 1C46               1695          JMP     WrapperAddrRegEnd
00001C98                          1696  
00001C98                          1697  AddrReg5
00001C98  43F9 000025A9           1698          LEA     OutAddrReg5,A1
00001C9E  103C 000E               1699          MOVE.B  #14,D0
00001CA2  4E4F                    1700          TRAP    #15
00001CA4                          1701          
00001CA4  4EF8 1C46               1702          JMP     WrapperAddrRegEnd
00001CA8                          1703  
00001CA8                          1704  AddrReg6
00001CA8  43F9 000025AC           1705          LEA     OutAddrReg6,A1
00001CAE  103C 000E               1706          MOVE.B  #14,D0
00001CB2  4E4F                    1707          TRAP    #15
00001CB4                          1708          
00001CB4  4EF8 1C46               1709          JMP     WrapperAddrRegEnd
00001CB8                          1710  
00001CB8                          1711  AddrReg7
00001CB8  43F9 000025AF           1712          LEA     OutAddrReg7,A1
00001CBE  103C 000E               1713          MOVE.B  #14,D0
00001CC2  4E4F                    1714          TRAP    #15
00001CC4                          1715          
00001CC4  4EF8 1C46               1716          JMP     WrapperAddrRegEnd
00001CC8                          1717  
00001CC8                          1718  
00001CC8                          1719  *-----------------------------------------------------------        
00001CC8                          1720  * Output logic for all Address Indirect Registers (0-7)
00001CC8                          1721  *-----------------------------------------------------------     
00001CC8                          1722  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001CC8                          1723  WrapperAddrIndirect
00001CC8                          1724          *Depending on the EA Register, output a different register number
00001CC8  B63C 0000               1725          CMP.B   #$00,D3
00001CCC  6700 003C               1726          BEQ     AddrIndReg0
00001CD0                          1727          
00001CD0  B63C 0001               1728          CMP.B   #$01,D3
00001CD4  6700 0044               1729          BEQ     AddrIndReg1
00001CD8                          1730          
00001CD8  B63C 0002               1731          CMP.B   #$02,D3
00001CDC  6700 004C               1732          BEQ     AddrIndReg2
00001CE0                          1733          
00001CE0  B63C 0003               1734          CMP.B   #$03,D3
00001CE4  6700 0054               1735          BEQ     AddrIndReg3
00001CE8                          1736          
00001CE8  B63C 0004               1737          CMP.B   #$04,D3
00001CEC  6700 005C               1738          BEQ     AddrIndReg4
00001CF0                          1739          
00001CF0  B63C 0005               1740          CMP.B   #$05,D3
00001CF4  6700 0064               1741          BEQ     AddrIndReg5
00001CF8                          1742          
00001CF8  B63C 0006               1743          CMP.B   #$06,D3
00001CFC  6700 006C               1744          BEQ     AddrIndReg6
00001D00                          1745          
00001D00  B63C 0007               1746          CMP.B   #$07,D3
00001D04  6700 0074               1747          BEQ     AddrIndReg7
00001D08                          1748  
00001D08                          1749  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
00001D08                          1750  WrapperAddrIndirectEnd
00001D08  4E75                    1751          RTS        
00001D0A                          1752  
00001D0A                          1753  AddrIndReg0
00001D0A                          1754          *Output the specific address indirect register...
00001D0A  43F9 000025B2           1755          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001D10  103C 000E               1756          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001D14  4E4F                    1757          TRAP    #15                 *Displays Message        
00001D16                          1758          
00001D16  4EF8 1D08               1759          JMP     WrapperAddrIndirectEnd
00001D1A                          1760  
00001D1A                          1761  AddrIndReg1
00001D1A  43F9 000025B7           1762          LEA     OutAddrIndReg1,A1
00001D20  103C 000E               1763          MOVE.B  #14,D0
00001D24  4E4F                    1764          TRAP    #15
00001D26                          1765          
00001D26  4EF8 1D08               1766          JMP     WrapperAddrIndirectEnd
00001D2A                          1767  
00001D2A                          1768  AddrIndReg2
00001D2A  43F9 000025BC           1769          LEA     OutAddrIndReg2,A1
00001D30  103C 000E               1770          MOVE.B  #14,D0
00001D34  4E4F                    1771          TRAP    #15
00001D36                          1772          
00001D36  4EF8 1D08               1773          JMP     WrapperAddrIndirectEnd
00001D3A                          1774  
00001D3A                          1775  AddrIndReg3
00001D3A  43F9 000025C1           1776          LEA     OutAddrIndReg3,A1
00001D40  103C 000E               1777          MOVE.B  #14,D0
00001D44  4E4F                    1778          TRAP    #15
00001D46                          1779          
00001D46  4EF8 1D08               1780          JMP     WrapperAddrIndirectEnd
00001D4A                          1781  
00001D4A                          1782  AddrIndReg4
00001D4A  43F9 000025C6           1783          LEA     OutAddrIndReg4,A1
00001D50  103C 000E               1784          MOVE.B  #14,D0
00001D54  4E4F                    1785          TRAP    #15
00001D56                          1786          
00001D56  4EF8 1D08               1787          JMP     WrapperAddrIndirectEnd
00001D5A                          1788  
00001D5A                          1789  AddrIndReg5
00001D5A  43F9 000025CB           1790          LEA     OutAddrIndReg5,A1
00001D60  103C 000E               1791          MOVE.B  #14,D0
00001D64  4E4F                    1792          TRAP    #15
00001D66                          1793          
00001D66  4EF8 1D08               1794          JMP     WrapperAddrIndirectEnd
00001D6A                          1795  
00001D6A                          1796  AddrIndReg6
00001D6A  43F9 000025D0           1797          LEA     OutAddrIndReg6,A1
00001D70  103C 000E               1798          MOVE.B  #14,D0
00001D74  4E4F                    1799          TRAP    #15
00001D76                          1800          
00001D76  4EF8 1D08               1801          JMP     WrapperAddrIndirectEnd
00001D7A                          1802  
00001D7A                          1803  AddrIndReg7
00001D7A  43F9 000025D5           1804          LEA     OutAddrIndReg7,A1
00001D80  103C 000E               1805          MOVE.B  #14,D0
00001D84  4E4F                    1806          TRAP    #15
00001D86                          1807          
00001D86  4EF8 1D08               1808          JMP     WrapperAddrIndirectEnd
00001D8A                          1809          
00001D8A                          1810          
00001D8A                          1811  *-----------------------------------------------------------        
00001D8A                          1812  * Output logic for all Address Indirect Post Increment Registers (0-7)
00001D8A                          1813  *-----------------------------------------------------------     
00001D8A                          1814  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001D8A                          1815  WrapperAddrIndirectPost
00001D8A                          1816          *Depending on the EA Register, output a different register number
00001D8A  B63C 0000               1817          CMP.B   #$00,D3
00001D8E  6700 003C               1818          BEQ     AddrIndPoReg0
00001D92                          1819          
00001D92  B63C 0001               1820          CMP.B   #$01,D3
00001D96  6700 0044               1821          BEQ     AddrIndPoReg1
00001D9A                          1822          
00001D9A  B63C 0002               1823          CMP.B   #$02,D3
00001D9E  6700 004C               1824          BEQ     AddrIndPoReg2
00001DA2                          1825          
00001DA2  B63C 0003               1826          CMP.B   #$03,D3
00001DA6  6700 0054               1827          BEQ     AddrIndPoReg3
00001DAA                          1828          
00001DAA  B63C 0004               1829          CMP.B   #$04,D3
00001DAE  6700 005C               1830          BEQ     AddrIndPoReg4
00001DB2                          1831          
00001DB2  B63C 0005               1832          CMP.B   #$05,D3
00001DB6  6700 0064               1833          BEQ     AddrIndPoReg5
00001DBA                          1834          
00001DBA  B63C 0006               1835          CMP.B   #$06,D3
00001DBE  6700 006C               1836          BEQ     AddrIndPoReg6
00001DC2                          1837          
00001DC2  B63C 0007               1838          CMP.B   #$07,D3
00001DC6  6700 0074               1839          BEQ     AddrIndPoReg7
00001DCA                          1840  
00001DCA                          1841  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
00001DCA                          1842  WrapperAddrIndirectPostEnd
00001DCA  4E75                    1843          RTS        
00001DCC                          1844  
00001DCC                          1845  AddrIndPoReg0
00001DCC                          1846          *Output the specific address indirect post register...
00001DCC  43F9 000025DA           1847          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001DD2  103C 000E               1848          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001DD6  4E4F                    1849          TRAP    #15                 *Displays Message        
00001DD8                          1850          
00001DD8  4EF8 1DCA               1851          JMP     WrapperAddrIndirectPostEnd
00001DDC                          1852  
00001DDC                          1853  AddrIndPoReg1
00001DDC  43F9 000025E0           1854          LEA     OutAddrIndPoReg1,A1
00001DE2  103C 000E               1855          MOVE.B  #14,D0
00001DE6  4E4F                    1856          TRAP    #15
00001DE8                          1857          
00001DE8  4EF8 1DCA               1858          JMP     WrapperAddrIndirectPostEnd
00001DEC                          1859  
00001DEC                          1860  AddrIndPoReg2
00001DEC  43F9 000025E6           1861          LEA     OutAddrIndPoReg2,A1
00001DF2  103C 000E               1862          MOVE.B  #14,D0
00001DF6  4E4F                    1863          TRAP    #15
00001DF8                          1864          
00001DF8  4EF8 1DCA               1865          JMP     WrapperAddrIndirectPostEnd
00001DFC                          1866  
00001DFC                          1867  AddrIndPoReg3
00001DFC  43F9 000025EC           1868          LEA     OutAddrIndPoReg3,A1
00001E02  103C 000E               1869          MOVE.B  #14,D0
00001E06  4E4F                    1870          TRAP    #15
00001E08                          1871          
00001E08  4EF8 1DCA               1872          JMP     WrapperAddrIndirectPostEnd
00001E0C                          1873  
00001E0C                          1874  AddrIndPoReg4
00001E0C  43F9 000025F2           1875          LEA     OutAddrIndPoReg4,A1
00001E12  103C 000E               1876          MOVE.B  #14,D0
00001E16  4E4F                    1877          TRAP    #15
00001E18                          1878          
00001E18  4EF8 1DCA               1879          JMP     WrapperAddrIndirectPostEnd
00001E1C                          1880  
00001E1C                          1881  AddrIndPoReg5
00001E1C  43F9 000025F8           1882          LEA     OutAddrIndPoReg5,A1
00001E22  103C 000E               1883          MOVE.B  #14,D0
00001E26  4E4F                    1884          TRAP    #15
00001E28                          1885          
00001E28  4EF8 1DCA               1886          JMP     WrapperAddrIndirectPostEnd
00001E2C                          1887  
00001E2C                          1888  AddrIndPoReg6
00001E2C  43F9 000025FE           1889          LEA     OutAddrIndPoReg6,A1
00001E32  103C 000E               1890          MOVE.B  #14,D0
00001E36  4E4F                    1891          TRAP    #15
00001E38                          1892          
00001E38  4EF8 1DCA               1893          JMP     WrapperAddrIndirectPostEnd
00001E3C                          1894  
00001E3C                          1895  AddrIndPoReg7
00001E3C  43F9 00002604           1896          LEA     OutAddrIndPoReg7,A1
00001E42  103C 000E               1897          MOVE.B  #14,D0
00001E46  4E4F                    1898          TRAP    #15
00001E48                          1899          
00001E48  4EF8 1DCA               1900          JMP     WrapperAddrIndirectPostEnd
00001E4C                          1901  
00001E4C                          1902  
00001E4C                          1903  *-----------------------------------------------------------        
00001E4C                          1904  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001E4C                          1905  *-----------------------------------------------------------     
00001E4C                          1906  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001E4C                          1907  WrapperAddrIndirectPre
00001E4C                          1908          *Depending on the EA Register, output a different register number
00001E4C  B63C 0000               1909          CMP.B   #$00,D3
00001E50  6700 003C               1910          BEQ     AddrIndPrReg0
00001E54                          1911          
00001E54  B63C 0001               1912          CMP.B   #$01,D3
00001E58  6700 0044               1913          BEQ     AddrIndPrReg1
00001E5C                          1914          
00001E5C  B63C 0002               1915          CMP.B   #$02,D3
00001E60  6700 004C               1916          BEQ     AddrIndPrReg2
00001E64                          1917          
00001E64  B63C 0003               1918          CMP.B   #$03,D3
00001E68  6700 0054               1919          BEQ     AddrIndPrReg3
00001E6C                          1920          
00001E6C  B63C 0004               1921          CMP.B   #$04,D3
00001E70  6700 005C               1922          BEQ     AddrIndPrReg4
00001E74                          1923          
00001E74  B63C 0005               1924          CMP.B   #$05,D3
00001E78  6700 0064               1925          BEQ     AddrIndPrReg5
00001E7C                          1926          
00001E7C  B63C 0006               1927          CMP.B   #$06,D3
00001E80  6700 006C               1928          BEQ     AddrIndPrReg6
00001E84                          1929          
00001E84  B63C 0007               1930          CMP.B   #$07,D3
00001E88  6700 0074               1931          BEQ     AddrIndPrReg7
00001E8C                          1932  
00001E8C                          1933  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001E8C                          1934  WrapperAddrIndirectPreEnd
00001E8C  4E75                    1935          RTS        
00001E8E                          1936  
00001E8E                          1937  AddrIndPrReg0
00001E8E                          1938          *Output the specific address indirect post register...
00001E8E  43F9 0000260A           1939          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001E94  103C 000E               1940          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001E98  4E4F                    1941          TRAP    #15                 *Displays Message        
00001E9A                          1942          
00001E9A  4EF8 1E8C               1943          JMP     WrapperAddrIndirectPreEnd
00001E9E                          1944  
00001E9E                          1945  AddrIndPrReg1
00001E9E  43F9 00002610           1946          LEA     OutAddrIndPrReg1,A1
00001EA4  103C 000E               1947          MOVE.B  #14,D0
00001EA8  4E4F                    1948          TRAP    #15
00001EAA                          1949          
00001EAA  4EF8 1E8C               1950          JMP     WrapperAddrIndirectPreEnd
00001EAE                          1951  
00001EAE                          1952  AddrIndPrReg2
00001EAE  43F9 00002616           1953          LEA     OutAddrIndPrReg2,A1
00001EB4  103C 000E               1954          MOVE.B  #14,D0
00001EB8  4E4F                    1955          TRAP    #15
00001EBA                          1956          
00001EBA  4EF8 1E8C               1957          JMP     WrapperAddrIndirectPreEnd
00001EBE                          1958  
00001EBE                          1959  AddrIndPrReg3
00001EBE  43F9 0000261C           1960          LEA     OutAddrIndPrReg3,A1
00001EC4  103C 000E               1961          MOVE.B  #14,D0
00001EC8  4E4F                    1962          TRAP    #15
00001ECA                          1963          
00001ECA  4EF8 1E8C               1964          JMP     WrapperAddrIndirectPreEnd
00001ECE                          1965  
00001ECE                          1966  AddrIndPrReg4
00001ECE  43F9 00002622           1967          LEA     OutAddrIndPrReg4,A1
00001ED4  103C 000E               1968          MOVE.B  #14,D0
00001ED8  4E4F                    1969          TRAP    #15
00001EDA                          1970          
00001EDA  4EF8 1E8C               1971          JMP     WrapperAddrIndirectPreEnd
00001EDE                          1972  
00001EDE                          1973  AddrIndPrReg5
00001EDE  43F9 00002628           1974          LEA     OutAddrIndPrReg5,A1
00001EE4  103C 000E               1975          MOVE.B  #14,D0
00001EE8  4E4F                    1976          TRAP    #15
00001EEA                          1977          
00001EEA  4EF8 1E8C               1978          JMP     WrapperAddrIndirectPreEnd
00001EEE                          1979  
00001EEE                          1980  AddrIndPrReg6
00001EEE  43F9 0000262E           1981          LEA     OutAddrIndPrReg6,A1
00001EF4  103C 000E               1982          MOVE.B  #14,D0
00001EF8  4E4F                    1983          TRAP    #15
00001EFA                          1984          
00001EFA  4EF8 1E8C               1985          JMP     WrapperAddrIndirectPreEnd
00001EFE                          1986  
00001EFE                          1987  AddrIndPrReg7
00001EFE  43F9 00002634           1988          LEA     OutAddrIndPrReg7,A1
00001F04  103C 000E               1989          MOVE.B  #14,D0
00001F08  4E4F                    1990          TRAP    #15
00001F0A                          1991          
00001F0A  4EF8 1E8C               1992          JMP     WrapperAddrIndirectPreEnd
00001F0E                          1993  
00001F0E                          1994  
00001F0E                          1995  *-----------------------------------------------------------        
00001F0E                          1996  * Output logic for absolute memory addressing (0-7)
00001F0E                          1997  *-----------------------------------------------------------     
00001F0E                          1998  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001F0E                          1999  WrapperAddrAbsolute
00001F0E  4284                    2000          CLR.L   D4
00001F10                          2001          *Depending on the EA Register, choose which size to decode
00001F10  B63C 0000               2002          CMP.B   #$00,D3
00001F14  6700 000C               2003          BEQ     WordSizeAbsolute
00001F18                          2004  
00001F18  B63C 0001               2005          CMP.B   #$01,D3
00001F1C  6700 0028               2006          BEQ     LongSizeAbsolute
00001F20                          2007          
00001F20                          2008  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001F20                          2009  WrapperAddrAbsoluteEnd
00001F20  4E75                    2010          RTS
00001F22                          2011  
00001F22                          2012  WordSizeAbsolute        
00001F22  3818                    2013          MOVE.W  (A0)+,D4    *read in next word, data is that word        
00001F24                          2014              
00001F24                          2015          *Output ',$' just after source operand
00001F24  43F9 00002647           2016          LEA     Bang,A1
00001F2A  103C 000E               2017          MOVE.B  #14,D0
00001F2E  4E4F                    2018          TRAP    #15
00001F30                          2019              
00001F30                          2020          *Push D1 into stack, in case something was using it
00001F30  48E7 4000               2021          MOVEM.L D1,-(SP)
00001F34                          2022          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001F34  4281                    2023          CLR.L   D1
00001F36  123C 0001               2024          MOVE.B  #$01,D1
00001F3A                          2025              
00001F3A                          2026          *output the absolute mem address to console with the hex-ascii converter
00001F3A  4EB8 11EA               2027          JSR     HEXASCII
00001F3E  4CDF 0002               2028          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001F42                          2029          
00001F42  4EF8 1F20               2030          JMP     WrapperAddrAbsoluteEnd
00001F46                          2031  
00001F46                          2032  LongSizeAbsolute
00001F46  2818                    2033          MOVE.L  (A0)+,D4    *read in next long, data is that long                
00001F48                          2034                  
00001F48                          2035          *Output ',$' just after source operand
00001F48  43F9 00002647           2036          LEA     Bang,A1
00001F4E  103C 000E               2037          MOVE.B  #14,D0
00001F52  4E4F                    2038          TRAP    #15  
00001F54                          2039          
00001F54                          2040          *Push D1 into stack, in case something was using it
00001F54  48E7 4000               2041          MOVEM.L D1,-(SP)
00001F58                          2042          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001F58  4281                    2043          CLR.L   D1
00001F5A  123C 0010               2044          MOVE.B  #$10,D1
00001F5E                          2045              
00001F5E                          2046          *output the absolute mem address to console with the hex-ascii converter
00001F5E  4EB8 11EA               2047          JSR     HEXASCII
00001F62  4CDF 0002               2048          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001F66                          2049          
00001F66  4EF8 1F20               2050          JMP     WrapperAddrAbsoluteEnd
00001F6A                          2051          
00001F6A                          2052  
00001F6A                          2053  *-----------------------------------------------------------        
00001F6A                          2054  * Current handling of bad op/ea codes. Should be revisited.
00001F6A                          2055  *----------------------------------------------------------- 
00001F6A                          2056  BADOPCODE
00001F6A                          2057          *We found a bad op code, output some error to the screen, jump to the 
00001F6A                          2058          *next instruction in memory.
00001F6A                          2059          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001F6A                          2060          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001F6A                          2061          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001F6A                          2062          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001F6A                          2063          *i/o and error message code...
00001F6A  43F9 00002650           2064          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001F70  103C 000E               2065          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001F74  4E4F                    2066          TRAP    #15         *Displays Message
00001F76  4EF8 1380               2067          JMP     GRAB_NEXT_OP
00001F7A                          2068                  
00001F7A                          2069  BADEACODE
00001F7A                          2070          *We found a bad ea code, output some error to the screen, jump to the
00001F7A                          2071          *next instruction in memory.
00001F7A                          2072          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001F7A                          2073          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001F7A  43F9 00002649           2074          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001F80  103C 000E               2075          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001F84  4E4F                    2076          TRAP    #15         *Displays Message
00001F86  4EF8 1380               2077          JMP     GRAB_NEXT_OP
00001F8A                          2078          
00001F8A                          2079          
00001F8A                          2080  *-----------------------------------------------------------        
00001F8A                          2081  * End of Disassembler
00001F8A                          2082  *-----------------------------------------------------------    
00001F8A                          2083  
00001F8A  4E72 2700               2084  DONE    STOP    #$2700  *What does this do? Why was it added?
00001F8E                          2085  
00001F8E  103C 0009               2086  THEEND  MOVE.B  #9,D0
00001F92  4E4F                    2087          TRAP    #15             Halt Simulator        
00001F94                          2088          
00001F94                          2089       
00001F94                          2090  *-----------------------------------------------------------        
00001F94                          2091  * Output stuff
00001F94                          2092  *-----------------------------------------------------------     
00001F94  =0000000D               2093  CR      EQU     $0D             ASCII code for Carriage Return
00001F94  =0000000A               2094  LF      EQU     $0A             ASCII code for Line Feed
00001F94= 2D 2D 2D 2D 2D 2D ...   2095  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001FD3= 7C 7C 20 20 20 20 ...   2096              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00002012= 2D 2D 2D 2D 2D 2D ...   2097              DC.B    '-------------------------------------------------------------',CR,LF
00002051= 2A 2A 2A 2A 2A 2A ...   2098              DC.B    '*************************************************************',CR,LF
00002090= 2A 2A 2A 2A 2A 2A ...   2099              DC.B    '*************************************************************',CR,LF
000020CF= 2A 2A 2A 2A 2A 2A ...   2100              DC.B    '******           ***        ***           ****    ***********',CR,LF
0000210E= 2A 2A 2A 2A 2A 2A ...   2101              DC.B    '************    ****   ************   *******  **  **********',CR,LF
0000214D= 2A 2A 2A 2A 2A 2A ...   2102              DC.B    '**********    ******        *******   ******        *********',CR,LF
0000218C= 2A 2A 2A 2A 2A 2A ...   2103              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
000021CB= 2A 2A 2A 2A 2A 2A ...   2104              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
0000220A= 2A 2A 2A 2A 2A 2A ...   2105              DC.B    '*************************************************************',CR,LF
00002249= 2A 2A 2A 2A 2A 2A ...   2106              DC.B    '*************************************************************',CR,LF
00002288= 2A 20 20 20 20 20 ...   2107              DC.B    '*                                                           *',CR,LF
000022C7= 2A 20 41 75 74 68 ...   2108              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00002306= 2A 20 20 20 20 20 ...   2109              DC.B    '*                                                           *',CR,LF
00002345= 2A 2A 2A 2A 2A 2A ...   2110              DC.B    '*************************************************************',CR,LF,CR,LF
00002386= 53 74 61 72 74 69 ...   2111              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
000023A3                          2112              
000023A3= 57 6F 75 6C 64 20 ...   2113  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
000023D4                          2114  
000023D4= 20 0D 0A                2115  GETSTRTADDR DC.B    ' ',CR,LF
000023D7= 50 6C 65 61 73 65 ...   2116              DC.B    'Please type in your starting address request: ',0
00002406                          2117              
00002406= 20 0D 0A                2118  GETENDADDR  DC.B    ' ',CR,LF
00002409= 50 6C 65 61 73 65 ...   2119              DC.B    'Please type in your ending address request: ',0
00002436                          2120              
00002436= 20 0D 0A                2121  QUES_CONT   DC.B    ' ',CR,LF
00002439= 57 6F 75 6C 64 20 ...   2122              DC.B    'Would you like to continue (Y/N)? ',0
0000245C                          2123              
0000245C= 20 0D 0A                2124  QUIT_MSG    DC.B    ' ',CR,LF
0000245F= 57 6F 75 6C 64 20 ...   2125              DC.B    'Would you like to quit (Y/N)? ',0
0000247E                          2126  
0000247E                          2127  *****************************************************
0000247E                          2128  * I/O storages - assuming users knows what to do.
0000247E                          2129  *****************************************************
0000247E                          2130  CMD_HLD     DS.B    30
0000249C                          2131  CMD_SZ      DS.B    30
000024BA                          2132  STADDR      DS.B    10
000024C4                          2133  STADDRSZ    DS.B    10
000024CE                          2134  PROGST      DS.L    1
000024D2                          2135  ENDADDR     DS.B    10
000024DC                          2136  ENDADDRSZ   DS.B    10
000024E6                          2137  PROGEND     DS.L    1
000024EA                          2138  CONT        DS.B    30
00002508                          2139  *****************************************************
00002508                          2140  
00002508                          2141  *Table for 0-9 && A-F
00002508= 30 00                   2142  PRNT0   DC.B    '0',0
0000250A= 31 00                   2143  PRNT1   DC.B    '1',0
0000250C= 32 00                   2144  PRNT2   DC.B    '2',0
0000250E= 33 00                   2145  PRNT3   DC.B    '3',0
00002510= 34 00                   2146  PRNT4   DC.B    '4',0
00002512= 35 00                   2147  PRNT5   DC.B    '5',0
00002514= 36 00                   2148  PRNT6   DC.B    '6',0
00002516= 37 00                   2149  PRNT7   DC.B    '7',0
00002518= 38 00                   2150  PRNT8   DC.B    '8',0
0000251A= 39 00                   2151  PRNT9   DC.B    '9',0
0000251C= 41 00                   2152  PRNTA   DC.B    'A',0
0000251E= 42 00                   2153  PRNTB   DC.B    'B',0
00002520= 43 00                   2154  PRNTC   DC.B    'C',0
00002522= 44 00                   2155  PRNTD   DC.B    'D',0
00002524= 45 00                   2156  PRNTE   DC.B    'E',0
00002526= 46 00                   2157  PRNTF   DC.B    'F',0
00002528                          2158  
00002528                          2159  *output for all OPCODEs
00002528                          2160  *Bucket 0000
00002528= 41 44 44 49 00          2161  ADDI    DC.B    'ADDI',0
0000252D= 41 4E 44 49 00          2162  ANDI    DC.B    'ANDI',0
00002532= 45 4F 52 49 00          2163  EORI    DC.B    'EORI',0
00002537= 42 43 48 47 00          2164  BCHG    DC.B    'BCHG',0
0000253C= 43 4D 50 49 00          2165  CMPI    DC.B    'CMPI',0
00002541                          2166  *Bucket 0100
00002541= 4D 4F 56 45 4D 00       2167  MOVEM   DC.B    'MOVEM',0
00002547= 4D 55 4C 53 00          2168  MULS    DC.B    'MULS',0
0000254C= 4C 45 41 20 20 20 ...   2169  LEA     DC.B    'LEA      ',0   *Need spaces here since LEA has no size
00002556= 43 4C 52 00             2170  CLR     DC.B    'CLR',0
0000255A= 4A 53 52 20 20 20 ...   2171  JSR     DC.B    'JSR      ',0   *Need spaces here since JSR has no size
00002564= 52 54 53 00             2172  RTS     DC.B    'RTS',0
00002568                          2173  *Bucket 0101
00002568= 53 55 42 51 00          2174  SUBQ    DC.B    'SUBQ',0
0000256D                          2175  
0000256D                          2176  *output for the size of the operation
0000256D= 2E 42 20 20 20 20 00    2177  ByteSize    DC.B    '.B    ',0
00002574= 2E 57 20 20 20 20 00    2178  WordSize    DC.B    '.W    ',0
0000257B= 2E 4C 20 20 20 20 00    2179  LongSize    DC.B    '.L    ',0
00002582                          2180  
00002582                          2181  *output for all data registers (0-7)
00002582= 44 30 00                2182  OutDataReg0 DC.B    'D0',0
00002585= 44 31 00                2183  OutDataReg1 DC.B    'D1',0
00002588= 44 32 00                2184  OutDataReg2 DC.B    'D2',0
0000258B= 44 33 00                2185  OutDataReg3 DC.B    'D3',0
0000258E= 44 34 00                2186  OutDataReg4 DC.B    'D4',0
00002591= 44 35 00                2187  OutDataReg5 DC.B    'D5',0
00002594= 44 36 00                2188  OutDataReg6 DC.B    'D6',0
00002597= 44 37 00                2189  OutDataReg7 DC.B    'D7',0
0000259A                          2190  
0000259A                          2191  *output for all address registers (0-7)
0000259A= 41 30 00                2192  OutAddrReg0 DC.B    'A0',0
0000259D= 41 31 00                2193  OutAddrReg1 DC.B    'A1',0
000025A0= 41 32 00                2194  OutAddrReg2 DC.B    'A2',0
000025A3= 41 33 00                2195  OutAddrReg3 DC.B    'A3',0
000025A6= 41 34 00                2196  OutAddrReg4 DC.B    'A4',0
000025A9= 41 35 00                2197  OutAddrReg5 DC.B    'A5',0
000025AC= 41 36 00                2198  OutAddrReg6 DC.B    'A6',0
000025AF= 41 37 00                2199  OutAddrReg7 DC.B    'A7',0
000025B2                          2200          
000025B2                          2201  *output for all address indirect registers (0-7)
000025B2= 28 41 30 29 00          2202  OutAddrIndReg0  DC.B    '(A0)',0
000025B7= 28 41 31 29 00          2203  OutAddrIndReg1  DC.B    '(A1)',0
000025BC= 28 41 32 29 00          2204  OutAddrIndReg2  DC.B    '(A2)',0
000025C1= 28 41 33 29 00          2205  OutAddrIndReg3  DC.B    '(A3)',0
000025C6= 28 41 34 29 00          2206  OutAddrIndReg4  DC.B    '(A4)',0
000025CB= 28 41 35 29 00          2207  OutAddrIndReg5  DC.B    '(A5)',0
000025D0= 28 41 36 29 00          2208  OutAddrIndReg6  DC.B    '(A6)',0
000025D5= 28 41 37 29 00          2209  OutAddrIndReg7  DC.B    '(A7)',0
000025DA                          2210  
000025DA                          2211  *output for all address indirect post registers (0-7)
000025DA= 28 41 30 29 2B 00       2212  OutAddrIndPoReg0    DC.B    '(A0)+',0
000025E0= 28 41 31 29 2B 00       2213  OutAddrIndPoReg1    DC.B    '(A1)+',0
000025E6= 28 41 32 29 2B 00       2214  OutAddrIndPoReg2    DC.B    '(A2)+',0
000025EC= 28 41 33 29 2B 00       2215  OutAddrIndPoReg3    DC.B    '(A3)+',0
000025F2= 28 41 34 29 2B 00       2216  OutAddrIndPoReg4    DC.B    '(A4)+',0
000025F8= 28 41 35 29 2B 00       2217  OutAddrIndPoReg5    DC.B    '(A5)+',0
000025FE= 28 41 36 29 2B 00       2218  OutAddrIndPoReg6    DC.B    '(A6)+',0
00002604= 28 41 37 29 2B 00       2219  OutAddrIndPoReg7    DC.B    '(A7)+',0
0000260A                          2220  
0000260A                          2221  *output for all address indirect pre registers (0-7)
0000260A= 2D 28 41 30 29 00       2222  OutAddrIndPrReg0    DC.B    '-(A0)',0
00002610= 2D 28 41 31 29 00       2223  OutAddrIndPrReg1    DC.B    '-(A1)',0
00002616= 2D 28 41 32 29 00       2224  OutAddrIndPrReg2    DC.B    '-(A2)',0
0000261C= 2D 28 41 33 29 00       2225  OutAddrIndPrReg3    DC.B    '-(A3)',0
00002622= 2D 28 41 34 29 00       2226  OutAddrIndPrReg4    DC.B    '-(A4)',0
00002628= 2D 28 41 35 29 00       2227  OutAddrIndPrReg5    DC.B    '-(A5)',0
0000262E= 2D 28 41 36 29 00       2228  OutAddrIndPrReg6    DC.B    '-(A6)',0
00002634= 2D 28 41 37 29 00       2229  OutAddrIndPrReg7    DC.B    '-(A7)',0
0000263A                          2230  
0000263A                          2231  *output for a tab only (4 spaces)
0000263A= 20 20 20 20 00          2232  Tab DC.B    '    ',0
0000263F                          2233  
0000263F                          2234  *output for a comma only
0000263F= 2C 00                   2235  Comma   DC.B    ',',0
00002641                          2236  
00002641                          2237  *output for a new line only
00002641= 0D 0A 00                2238  NewLine DC.B    CR,LF,0
00002644                          2239  
00002644                          2240  *output for a '#$' and '$' only
00002644= 23 24 00                2241  ShaBang DC.B    '#$',0
00002647= 24 00                   2242  Bang    DC.B    '$',0
00002649                          2243  
00002649                          2244  *current output for error messages
00002649= 42 41 44 20 45 41 00    2245  BADEAMSG    DC.B    'BAD EA',0
00002650= 42 41 44 20 4F 50 00    2246  BADOPMSG    DC.B    'BAD OP',0
00002657= 49 6D 70 72 6F 70 ...   2247  INV_MSG     DC.B    'Improper command.',CR,LF,0
0000266B= 49 6E 76 61 6C 69 ...   2248  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
00002684= 49 6E 76 61 6C 69 ...   2249  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
0000269B                          2250  
0000269B                          2251          
0000269B                          2252          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                2528
ADDRABSOLUTEMODE    1B34
ADDRINDIRECTMODE    1B04
ADDRINDIRECTPOSTMODE  1B14
ADDRINDIRECTPREMODE  1B24
ADDRINDPOREG0       1DCC
ADDRINDPOREG1       1DDC
ADDRINDPOREG2       1DEC
ADDRINDPOREG3       1DFC
ADDRINDPOREG4       1E0C
ADDRINDPOREG5       1E1C
ADDRINDPOREG6       1E2C
ADDRINDPOREG7       1E3C
ADDRINDPRREG0       1E8E
ADDRINDPRREG1       1E9E
ADDRINDPRREG2       1EAE
ADDRINDPRREG3       1EBE
ADDRINDPRREG4       1ECE
ADDRINDPRREG5       1EDE
ADDRINDPRREG6       1EEE
ADDRINDPRREG7       1EFE
ADDRINDREG0         1D0A
ADDRINDREG1         1D1A
ADDRINDREG2         1D2A
ADDRINDREG3         1D3A
ADDRINDREG4         1D4A
ADDRINDREG5         1D5A
ADDRINDREG6         1D6A
ADDRINDREG7         1D7A
ADDRREG0            1C48
ADDRREG1            1C58
ADDRREG2            1C68
ADDRREG3            1C78
ADDRREG4            1C88
ADDRREG5            1C98
ADDRREG6            1CA8
ADDRREG7            1CB8
ADDRREGMODE         1AF4
ANDI                252D
ASCIIHEX            1178
ASCIIHEX1           117C
BADEACODE           1F7A
BADEAMSG            2649
BADOPCODE           1F6A
BADOPMSG            2650
BANG                2647
BCHG                2537
BCHGBYTESIZE        1AAC
BCHGIMMEDIATE       1ABC
BCHGLONGSIZE        1A9C
BCHGSIZEHELPER      1A8C
BCHGSIZEHELPEREND   1A9A
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         1430
BUCKET_0001         177E
BUCKET_0010         177E
BUCKET_0011         177E
BUCKET_0100         177E
BUCKET_0101         1904
BUCKET_0110         19BA
BUCKET_1000         19BA
BUCKET_1001         19BA
BUCKET_1011         19BA
BUCKET_1100         19BA
BUCKET_1101         19BA
BUCKET_1110         19BA
BYTESIZE            256D
BYTESIZEIMMEDIATE   19DC
BYTESIZEOP          1A5C
CHECK               11EE
CHECKEND1           10FE
CHECKSTRT1          10E8
CHECK_LOWN          1130
CHECK_LOWY          111E
CHECK_N             140A
CHECK_UPN           1128
CHECK_UPY           1114
CHECK_Y             13FA
CHNG_SZB            1220
CHNG_SZL            1206
CHNG_SZW            123A
CLR                 2556
CLR_D6              136A
CMD_HLD             247E
CMD_SZ              249C
CMPI                253C
COMMA               263F
CONT                24EA
CONT_OP             1396
CONT_Q              13C6
CONV_LOL            11D8
CONV_LOOP           1254
CONV_NUM            11C4
CONV_UPL            11CE
CR                  D
DATAREG0            1B86
DATAREG1            1B96
DATAREG2            1BA6
DATAREG3            1BB6
DATAREG4            1BC6
DATAREG5            1BD6
DATAREG6            1BE6
DATAREG7            1BF6
DATAREGMODE         1AE4
DONE                1F8A
EA_ADDI             14BC
EA_ANDI             1532
EA_BCHG_D           162A
EA_BCHG_S           16C2
EA_CLR              1878
EA_CMPI             173E
EA_EORI             15A8
EA_JSR              18CE
EA_LEA              180C
EA_LEA_WRAPPEREND   1824
EA_MOVEM_MEMTOREG   17CA
EA_MOVEM_REGTOMEM   17CA
EA_SUBQ             1962
ENDADDR             24D2
ENDADDRSZ           24DC
EORI                2532
EXITSUB             11E4
EXIT_CONV           12DA
GETENDADDR          2406
GETSTRTADDR         23D4
GET_END             1090
GET_STRT            1042
GRAB_NEXT_OP        1380
HEXASCII            11EA
HEXASCIIREG         1202
IMMEDIATEDATAMODE   1B44
INV2                141A
INVALID1            1138
INVENDMSG           2684
INVSTRTMSG          266B
INV_END1            1164
INV_MSG             2657
INV_STRT1           1150
IS_ADDI             1486
IS_ANDI             14FC
IS_BCHG_D           15E8
IS_BCHG_S           1686
IS_CLR              1842
IS_CMPI             1708
IS_EORI             1572
IS_JSR              18AC
IS_LEA              17CA
IS_MOVEM_MEMTOREG   17CA
IS_MOVEM_REGTOMEM   17CA
IS_RTS              18E4
IS_SUBQ             1920
JSR                 255A
LEA                 254C
LEA_ADDRABSOLUTEWRAPPER  1ADA
LEA_ADDRINDIRECTWRAPPER  1AD0
LF                  A
LONGSIZE            257B
LONGSIZEABSOLUTE    1F46
LONGSIZEIMMEDIATE   1A20
LONGSIZEOP          1A7C
LOOP_1              1014
LOOP_B              1224
LOOP_L              120A
LOOP_W              123E
MAX_LINE            20
MESSAGE             1F94
MOVEM               2541
MULS                2547
NEWLINE             2641
NUM_0               12E8
NUM_1               12F0
NUM_2               12F8
NUM_3               1300
NUM_4               1308
NUM_5               1310
NUM_6               1318
NUM_7               1320
NUM_8               1328
NUM_9               1330
NUM_A               1338
NUM_B               1340
NUM_C               1348
NUM_D               1350
NUM_E               1358
NUM_F               1360
OUTADDRINDPOREG0    25DA
OUTADDRINDPOREG1    25E0
OUTADDRINDPOREG2    25E6
OUTADDRINDPOREG3    25EC
OUTADDRINDPOREG4    25F2
OUTADDRINDPOREG5    25F8
OUTADDRINDPOREG6    25FE
OUTADDRINDPOREG7    2604
OUTADDRINDPRREG0    260A
OUTADDRINDPRREG1    2610
OUTADDRINDPRREG2    2616
OUTADDRINDPRREG3    261C
OUTADDRINDPRREG4    2622
OUTADDRINDPRREG5    2628
OUTADDRINDPRREG6    262E
OUTADDRINDPRREG7    2634
OUTADDRINDREG0      25B2
OUTADDRINDREG1      25B7
OUTADDRINDREG2      25BC
OUTADDRINDREG3      25C1
OUTADDRINDREG4      25C6
OUTADDRINDREG5      25CB
OUTADDRINDREG6      25D0
OUTADDRINDREG7      25D5
OUTADDRREG0         259A
OUTADDRREG1         259D
OUTADDRREG2         25A0
OUTADDRREG3         25A3
OUTADDRREG4         25A6
OUTADDRREG5         25A9
OUTADDRREG6         25AC
OUTADDRREG7         25AF
OUTDATAREG0         2582
OUTDATAREG1         2585
OUTDATAREG2         2588
OUTDATAREG3         258B
OUTDATAREG4         258E
OUTDATAREG5         2591
OUTDATAREG6         2594
OUTDATAREG7         2597
PRINT_NUM           12E0
PRNT0               2508
PRNT1               250A
PRNT2               250C
PRNT3               250E
PRNT4               2510
PRNT5               2512
PRNT6               2514
PRNT7               2516
PRNT8               2518
PRNT9               251A
PRNTA               251C
PRNTB               251E
PRNTC               2520
PRNTD               2522
PRNTE               2524
PRNTF               2526
PROGEND             24E6
PROGST              24CE
QUES_CONT           2436
QUIT_MSG            245C
RTS                 2564
SHABANG             2644
STACK               7000
STADDR              24BA
STADDRSZ            24C4
START               1000
STARTASSEM          23A3
ST_ADDR             7FC6
ST_BAD              11E2
SUBQ                2568
TAB                 263A
THEEND              1F8E
WORDSIZE            2574
WORDSIZEABSOLUTE    1F22
WORDSIZEIMMEDIATE   19FE
WORDSIZEOP          1A6C
WRAPPERADDRABSOLUTE  1F0E
WRAPPERADDRABSOLUTEEND  1F20
WRAPPERADDRINDIRECT  1CC8
WRAPPERADDRINDIRECTEND  1D08
WRAPPERADDRINDIRECTPOST  1D8A
WRAPPERADDRINDIRECTPOSTEND  1DCA
WRAPPERADDRINDIRECTPRE  1E4C
WRAPPERADDRINDIRECTPREEND  1E8C
WRAPPERADDRREG      1C06
WRAPPERADDRREGEND   1C46
WRAPPERDATAREG      1B44
WRAPPERDATAREGEND   1B84
WRAPPERSIZE         1A42
WRAPPERSIZEEND      1A5A
WRAPPERSIZEIMMEDIATE  19C0
WRAPPERSIZEIMMEDIATEEND  19DA
