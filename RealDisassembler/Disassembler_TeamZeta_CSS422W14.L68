00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.0
Created On: 3/14/2014 1:39:34 AM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/11/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC6                  9  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00001000                            11  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 12              LEA stack,SP
00001004                            13  
00001004                            14  
00001004                            15  *-----------------------------------------------------------
00001004                            16  * Start of I/O
00001004                            17  *-----------------------------------------------------------            
00001004  43F9 000019F0             18              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100A  103C 000E                 19              MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000100E  4E4F                      20              TRAP    #15         *Displays Message
00001010                            21          
00001010  303C 0000                 22  loop_1      MOVE    #0,D0       
00001014  43F9 00001DFF             23              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101A  103C 000E                 24              MOVE.B  #14,D0
0000101E  4E4F                      25              TRAP    #15    
00001020  303C 0002                 26              MOVE    #2,D0
00001024  43F9 00001EB4             27              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102A  4E4F                      28              TRAP    #15
0000102C  0C01 0001                 29              CMPI.B  #01,D1
00001030  6600 00F2                 30              BNE     INVALID1
00001034  6000 00CE                 31              BRA     CHECK_UPY
00001038                            32  *-----------------------------------------------------------
00001038                            33  *
00001038                            34  * I/O: Check Start Address
00001038                            35  *
00001038                            36  * Make sure that start address starts after allocated 
00001038                            37  * memory addresses. Else, it will print out a message 
00001038                            38  * saying that requested address is invalid & prompts the
00001038                            39  * user again for the starting address.
00001038                            40  *-----------------------------------------------------------
00001038  43F9 00001E30             41  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
0000103E  103C 000E                 42              MOVE.B  #14,D0
00001042  4E4F                      43              TRAP    #15
00001044  43F9 00001EF0             44              LEA     STADDR,A1   *Need to change where it can hold the start/end address
0000104A  3239 00001EFA             45              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001050  303C 0002                 46              MOVE    #2,D0           *Get start address
00001054  4E4F                      47              TRAP    #15
00001056  4EB9 000010D8             48              JSR     CHECKSTRT1
0000105C  4287                      49              CLR.L   D7
0000105E  4EB9 00001164             50              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
00001064  0C03 0001                 51              CMPI.B  #01,D3      *Check if there was a bad start
00001068  6700 00D2                 52              BEQ     INV_STRT1   *Prints error message if there was a bad start
0000106C  0C87 00007FC6             53              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001072  6D00 00C8                 54              BLT     INV_STRT1   *Asks for another start address if invalid
00001076  0C87 00FFFFFE             55              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
0000107C  6C00 00BE                 56              BGE     INV_STRT1
00001080  23C7 00001F04             57              MOVE.L  D7,PROGST
00001086                            58  
00001086  43F9 00001E62             59  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
0000108C  103C 000E                 60              MOVE.B  #14,D0
00001090  4E4F                      61              TRAP    #15
00001092  43F9 00001F08             62              LEA     ENDADDR,A1      *Buffer to hold end address
00001098  3239 00001F12             63              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
0000109E  303C 0002                 64              MOVE    #2,D0
000010A2  4E4F                      65              TRAP    #15
000010A4  4EB9 000010EE             66              JSR     CHECKEND1
000010AA  4287                      67              CLR.L   D7
000010AC  4EB9 00001164             68              JSR     ASCIIHEX
000010B2  0C03 0001                 69              CMPI.B  #01,D3
000010B6  6700 0098                 70              BEQ     INV_END1
000010BA  0C87 00001F04             71              CMPI.L  #PROGST,D7
000010C0  6D00 008E                 72              BLT     INV_END1
000010C4  0C87 00FFFFFF             73              CMPI.L  #$00FFFFFF,D7
000010CA  6C00 0084                 74              BGE     INV_END1
000010CE  2079 00001F04             75              MOVEA.L PROGST,A0
000010D4  6000 0286                 76              BRA     GRAB_NEXT_OP            
000010D8                            77                          
000010D8  0C81 00000008             78  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010DE  6E00 005C                 79              BGT     INV_STRT1
000010E2  0C81 00000000             80              CMPI.L  #00,D1
000010E8  6300 0052                 81              BLS     INV_STRT1
000010EC  4E75                      82              RTS         
000010EE                            83              
000010EE  0C81 00000008             84  CHECKEND1   CMPI.L  #08,D1
000010F4  6E00 005A                 85              BGT     INV_END1
000010F8  0C81 00000000             86              CMPI.L  #00,D1
000010FE  6300 0050                 87              BLS     INV_END1
00001102  4E75                      88              RTS
00001104                            89  
00001104                            90  *-----------------------------------------------------------
00001104                            91  * I/O: Input check for Y, y, N, n
00001104                            92  *-----------------------------------------------------------
00001104  0C11 0059                 93  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001108  6700 FF2E                 94              BEQ     GET_STRT
0000110C                            95              
0000110C  0C11 0079                 96  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
00001110  6700 FF26                 97              BEQ     GET_STRT
00001114                            98              
00001114  0C11 004E                 99  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001118  6700 08CC                100              BEQ     DONE
0000111C                           101              
0000111C  0C11 006E                102  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001120  6700 08C4                103              BEQ     DONE
00001124                           104              
00001124  163C 0000                105  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001128  303C 0000                106              MOVE    #0,D0       *Prints invalid command msg if not found
0000112C  43F9 0000209C            107              LEA     INV_MSG,A1
00001132  303C 000E                108              MOVE    #14,D0
00001136  4E4F                     109              TRAP    #15
00001138  6000 FED6                110              BRA     loop_1
0000113C                           111              
0000113C  43F9 000020B0            112  INV_STRT1   LEA     INVSTRTMSG,A1
00001142  103C 000E                113              MOVE.B  #14,D0
00001146  4E4F                     114              TRAP    #15
00001148  163C 0000                115              MOVE.B  #00,D3      *Reset flag
0000114C  6000 FEEA                116              BRA     GET_STRT        
00001150                           117              
00001150  43F9 000020C9            118  INV_END1    LEA     INVENDMSG,A1
00001156  103C 000E                119              MOVE.B  #14,D0
0000115A  4E4F                     120              TRAP    #15
0000115C  163C 0000                121              MOVE.B  #00,D3      *Reset flag
00001160  6000 FF24                122              BRA     GET_END
00001164                           123              
00001164                           124  *-----------------------------------------------------------
00001164                           125  * ASCII to Hex converter
00001164                           126  *
00001164                           127  * Checks and converts the ASCII value to the hex equivalent
00001164                           128  *-----------------------------------------------------------
00001164  48E7 6000                129  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001168  0C01 0000                130  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000116C  6700 0062                131              BEQ     exitSub     *Exit subroutine 
00001170  5301                     132              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001172  E99F                     133              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001174  1419                     134              MOVE.B  (A1)+,D2    *Takes the first char
00001176  0C02 0024                135              CMPI.B  #$24,D2     *See if the first char is $
0000117A  67EC                     136              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000117C  0C02 0030                137              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001180  6D00 004C                138              BLT     st_bad      *Put error message
00001184  0C02 0039                139              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001188  6F00 0026                140              BLE     CONV_NUM    *Convert to number, if so
0000118C  0C02 0041                141              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
00001190  6D00 003C                142              BLT     st_bad      *Put error message
00001194  0C02 0046                143              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
00001198  6F00 0020                144              BLE     CONV_UpL    *Convert to hex
0000119C  0C02 0061                145              CMPI.B  #$61,D2     *Checks for non-valid chars
000011A0  6D00 002C                146              BLT     st_bad
000011A4  0C02 0066                147              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011A8  6F00 001A                148              BLE     CONV_LoL    
000011AC  6E00 0020                149              BGT     st_bad      *Puts error message for anything greater than f value
000011B0                           150              
000011B0  0402 0030                151  CONV_NUM    SUBI.B  #$30,D2
000011B4  8E02                     152              OR.B    D2,D7
000011B6  4EF8 1168                153              JMP     ASCIIHEX1
000011BA  0402 0037                154  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011BE  8E02                     155              OR.B    D2,D7
000011C0  4EF8 1168                156              JMP     ASCIIHEX1
000011C4  0402 0057                157  CONV_LoL    SUBI.B  #$57,D2
000011C8  8E02                     158              OR.B    D2,D7
000011CA  4EF8 1168                159              JMP     ASCIIHEX1   
000011CE                           160  
000011CE  5203                     161  st_bad      ADDI.B  #01,D3
000011D0  4CDF 0006                162  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011D4  4E75                     163              RTS
000011D6                           164              
000011D6                           165  *-----------------------------------------------------------
000011D6                           166  * Hex to ASCII converter
000011D6                           167  *-----------------------------------------------------------
000011D6  48E7 4C00                168  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011DA  0C01 0000                169  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011DE  6700 002C                170              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011E2  B27C 0001                171              CMP.W   #01,D1          
000011E6  6700 003E                172              BEQ     CHNG_SZW
000011EA  6000 0006                173              BRA     CHNG_SZL        
000011EE                           174  
000011EE  48E7 4C00                175  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011F2  123C 0008                176  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
000011F6  0C01 0000                177  LOOP_L      CMPI.B  #00,D1
000011FA  6700 00CA                178              BEQ     EXIT_CONV
000011FE  5301                     179              SUBI.B  #01,D1
00001200  E99C                     180              ROL.L   #4,D4           * Shift it for next bit
00001202  2A04                     181              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001204  4EB9 00001240            182              JSR     CONV_LOOP
0000120A  60EA                     183              BRA     LOOP_L      
0000120C                           184  
0000120C  123C 0002                185  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001210  0C01 0000                186  LOOP_B      CMPI.B  #00,D1
00001214  6700 00B0                187              BEQ     EXIT_CONV
00001218  5301                     188              SUBI.B  #01,D1
0000121A  E91C                     189              ROL.B   #4,D4           * Shift it for next bit
0000121C  2A04                     190              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000121E  4EB9 00001240            191              JSR     CONV_LOOP
00001224  60EA                     192              BRA     LOOP_B
00001226                           193              
00001226  123C 0004                194  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000122A  0C01 0000                195  LOOP_W      CMPI.B  #00,D1
0000122E  6700 0096                196              BEQ     EXIT_CONV
00001232  5301                     197              SUBI.B  #01,D1
00001234  E95C                     198              ROL.W   #4,D4           * Shift it for next bit
00001236  2A04                     199              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001238  4EB9 00001240            200              JSR     CONV_LOOP
0000123E  60EA                     201              BRA     LOOP_W
00001240                           202  
00001240  0285 0000000F            203  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001246  0C05 0000                204              CMPI.B  #$0,D5
0000124A  6700 0088                205              BEQ     NUM_0
0000124E  0C05 0001                206              CMPI.B  #$1,D5
00001252  6700 0088                207              BEQ     NUM_1
00001256  0C05 0002                208              CMPI.B  #$2,D5
0000125A  6700 0088                209              BEQ     NUM_2
0000125E  0C05 0003                210              CMPI.B  #$3,D5
00001262  6700 0088                211              BEQ     NUM_3
00001266  0C05 0004                212              CMPI.B  #$4,D5
0000126A  6700 0088                213              BEQ     NUM_4
0000126E  0C05 0005                214              CMPI.B  #$5,D5
00001272  6700 0088                215              BEQ     NUM_5
00001276  0C05 0006                216              CMPI.B  #$6,D5
0000127A  6700 0088                217              BEQ     NUM_6
0000127E  0C05 0007                218              CMPI.B  #$7,D5
00001282  6700 0088                219              BEQ     NUM_7
00001286  0C05 0008                220              CMPI.B  #$8,D5
0000128A  6700 0088                221              BEQ     NUM_8
0000128E  0C05 0009                222              CMPI.B  #$9,D5
00001292  6700 0088                223              BEQ     NUM_9
00001296  0C05 000A                224              CMPI.B  #$A,D5
0000129A  6700 0088                225              BEQ     NUM_A
0000129E  0C05 000B                226              CMPI.B  #$B,D5
000012A2  6700 0088                227              BEQ     NUM_B
000012A6  0C05 000C                228              CMPI.B  #$C,D5
000012AA  6700 0088                229              BEQ     NUM_C
000012AE  0C05 000D                230              CMPI.B  #$D,D5
000012B2  6700 0088                231              BEQ     NUM_D
000012B6  0C05 000E                232              CMPI.B  #$E,D5
000012BA  6700 0088                233              BEQ     NUM_E
000012BE  0C05 000F                234              CMPI.B  #$F,D5
000012C2  6700 0088                235              BEQ     NUM_F
000012C6                           236              
000012C6  4CDF 0032                237  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012CA  4E75                     238              RTS
000012CC                           239              
000012CC  303C 000E                240  PRINT_NUM   MOVE    #14,D0
000012D0  4E4F                     241              TRAP    #15
000012D2  4E75                     242              RTS
000012D4  43F9 00001F20            243  NUM_0       LEA     PRNT0,A1
000012DA  60F0                     244              BRA     PRINT_NUM
000012DC  43F9 00001F22            245  NUM_1       LEA     PRNT1,A1
000012E2  60E8                     246              BRA     PRINT_NUM
000012E4  43F9 00001F24            247  NUM_2       LEA     PRNT2,A1
000012EA  60E0                     248              BRA     PRINT_NUM
000012EC  43F9 00001F26            249  NUM_3       LEA     PRNT3,A1
000012F2  60D8                     250              BRA     PRINT_NUM
000012F4  43F9 00001F28            251  NUM_4       LEA     PRNT4,A1
000012FA  60D0                     252              BRA     PRINT_NUM
000012FC  43F9 00001F2A            253  NUM_5       LEA     PRNT5,A1
00001302  60C8                     254              BRA     PRINT_NUM
00001304  43F9 00001F2C            255  NUM_6       LEA     PRNT6,A1
0000130A  60C0                     256              BRA     PRINT_NUM
0000130C  43F9 00001F2E            257  NUM_7       LEA     PRNT7,A1
00001312  60B8                     258              BRA     PRINT_NUM
00001314  43F9 00001F30            259  NUM_8       LEA     PRNT8,A1
0000131A  60B0                     260              BRA     PRINT_NUM
0000131C  43F9 00001F32            261  NUM_9       LEA     PRNT9,A1
00001322  60A8                     262              BRA     PRINT_NUM
00001324  43F9 00001F34            263  NUM_A       LEA     PRNTA,A1
0000132A  60A0                     264              BRA     PRINT_NUM
0000132C  43F9 00001F36            265  NUM_B       LEA     PRNTB,A1
00001332  6098                     266              BRA     PRINT_NUM
00001334  43F9 00001F38            267  NUM_C       LEA     PRNTC,A1
0000133A  6090                     268              BRA     PRINT_NUM
0000133C  43F9 00001F3A            269  NUM_D       LEA     PRNTD,A1
00001342  6088                     270              BRA     PRINT_NUM
00001344  43F9 00001F3C            271  NUM_E       LEA     PRNTE,A1
0000134A  6080                     272              BRA     PRINT_NUM
0000134C  43F9 00001F3E            273  NUM_F       LEA     PRNTF,A1
00001352  6000 FF78                274              BRA     PRINT_NUM
00001356                           275  
00001356                           276  *-----------------------------------------------------------        
00001356                           277  * Start of Disassembler
00001356                           278  *-----------------------------------------------------------
00001356                           279          *FOR DEBUGGING ONLY!!!
00001356  207C 00007FC6            280          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000135C                           281          
0000135C                           282  GRAB_NEXT_OP
0000135C                           283          *Need a check here to see if A0 == end of test address
0000135C                           284          *if so, go to end.
0000135C                           285          
0000135C                           286          
0000135C                           287          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
0000135C                           288          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
0000135C                           289          *data that may be associated with the instruction.
0000135C                           290          *Post increment addr, A0 will point to the start of next instruction or will 
0000135C                           291          *point to the start of any immed/abso data with this current instruction
0000135C  4280                     292          CLR.L   D0
0000135E  3018                     293          MOVE.W  (A0)+,D0
00001360                           294          *Copy the word data we just moved into D0 into D7. We are copying this data
00001360                           295          *So we always have a copy of the WHOLE instruction somewhere
00001360  4287                     296          CLR.L   D7
00001362  3E00                     297          MOVE.W  D0,D7
00001364                           298          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
00001364                           299          *four bits of the instruction. Once we have just the first four bits, we can
00001364                           300          *begin to see which 'bucket'/category this instruction falls into. 
00001364  E048                     301          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
00001366  E848                     302          LSR.W   #$04,D0
00001368                           303          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
00001368                           304          *list of buckets until we find which one this instruction falls into.
00001368                           305  
00001368                           306  
00001368                           307  *-----------------------------------------------------------        
00001368                           308  * Bucket 0000:
00001368                           309  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
00001368                           310  *                   BCHG(dynamic) | BCHG (static) | CMPI----
00001368                           311  *-----------------------------------------------------------
00001368                           312  BUCKET_0000
00001368  =00000000                313  BUCKET0000_BITS EQU $0
00001368  4281                     314          CLR.L   D1
0000136A                           315          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000136A  123C 0000                316          MOVE.B  #BUCKET0000_BITS,D1
0000136E                           317          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
0000136E                           318          *If equal, continue decoding. If not, branch to next bucket.
0000136E  B200                     319          CMP.B   D0,D1
00001370  6600 023A                320          BNE     BUCKET_0001
00001374                           321  
00001374                           322          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001374                           323          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001374  3007                     324          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001376  0800 0008                325          BTST.L  #$08,D0
0000137A  6600 0180                326          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
0000137E                           327          
0000137E                           328          *Now we can check bits 11-8 in the instruction and branch to different op-codes
0000137E                           329          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
0000137E  E048                     330          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001380  0880 0004                331          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001384  0880 0005                332          BCLR.L  #$05,D0
00001388  0880 0006                333          BCLR.L  #$06,D0
0000138C  0880 0007                334          BCLR.L  #$07,D0
00001390                           335          
00001390                           336          *Perform compares with these 4 bits to see which specific instruction it is.
00001390  B03C 0006                337          CMP.B   #$06,D0 *Is this an ADDI?
00001394  6700 0028                338          BEQ     IS_ADDI
00001398  B03C 0002                339          CMP.B   #$02,D0 *Is this an ANDI?
0000139C  6700 008A                340          BEQ     IS_ANDI
000013A0  B03C 000A                341          CMP.B   #$0A,D0 *Is this an EORI?
000013A4  6700 00EC                342          BEQ     IS_EORI
000013A8  B03C 0008                343          CMP.B   #$08,D0 *Is this a BCHG(static)?
000013AC  6700 0178                344          BEQ     IS_BCHG_S
000013B0  B03C 000C                345          CMP.B   #$0C,D0 *Is this a CMPI?
000013B4  6700 018C                346          BEQ     IS_CMPI
000013B8                           347          
000013B8                           348          *If we get through all of the compares without finding the specific instruction,
000013B8                           349          *then this instruction is either not in our list of OP CODES to decode, or is an
000013B8                           350          *invalid instruction/syntax.
000013B8  4EF9 000019C6            351          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000013BE                           352          
000013BE                           353          
000013BE                           354  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
000013BE                           355  IS_ADDI
000013BE                           356          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000013BE                           357          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000013BE  4281                     358          CLR.L   D1
000013C0  3207                     359          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000013C2  C27C 00C0                360          AND.W   #$00C0,D1   *Mask out everything but the size bits
000013C6  EC09                     361          LSR.B   #$06,D1     *Shift the size bits into LSB
000013C8                           362          
000013C8  B23C 0003                363          CMP.B   #$03,D1     *Compare the size bits to $3
000013CC  6700 05F8                364          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000013D0                           365          
000013D0                           366          *Output 'ADDI' to console...
000013D0  43F9 00001F40            367          LEA     ADDI,A1     *Loads ADDI into address register A1
000013D6  103C 000E                368          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000013DA  4E4F                     369          TRAP    #15         *Displays Message
000013DC                           370          
000013DC                           371          
000013DC                           372          *Should have a valid ADDI op code. Set data up for EA.
000013DC                           373          
000013DC                           374          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000013DC  4282                     375          CLR.L   D2
000013DE  3407                     376          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000013E0  C47C 003C                377          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000013E4  E60A                     378          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000013E6                           379                  
000013E6                           380          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000013E6  4283                     381          CLR.L   D3
000013E8  3607                     382          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000013EA  C67C 0007                383          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000013EE                           384          
000013EE  4EF9 000013F4            385          JMP     EA_ADDI
000013F4                           386  
000013F4                           387  EA_ADDI
000013F4                           388          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
000013F4                           389          *and D3 holds the EA register.
000013F4                           390          
000013F4                           391          *Determine how much data to read in, depending on the size of the operation
000013F4                           392          *output the size of the operation and the immediate data to console
000013F4  4EB9 000015B2            393          JSR     WrapperSizeImmediate
000013FA                           394          
000013FA                           395          *Determine which EA mode and thus Register/Mem Address this instruction used
000013FA  B43C 0000                396          CMP.B   #$00,D2
000013FE  6700 0234                397          BEQ     DataRegMode *If EA mode is a data register, output that
00001402                           398          
00001402  B43C 0002                399          CMP.B   #$02,D2
00001406  6700 0236                400          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000140A                           401          
0000140A  B43C 0003                402          CMP.B   #$03,D2
0000140E  6700 0238                403          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001412                           404          
00001412  B43C 0004                405          CMP.B   #$04,D2
00001416  6700 023A                406          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000141A                           407          
0000141A  B43C 0007                408          CMP.B   #$07,D2
0000141E  6700 023C                409          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001422                           410          
00001422                           411          *If the ea mode isn't equal to any of these, it is an invalid EA
00001422  4EF9 000019D6            412          JMP     BADEACODE                               
00001428                           413          
00001428                           414  
00001428                           415  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
00001428                           416  IS_ANDI
00001428                           417          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001428                           418          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001428  4281                     419          CLR.L   D1
0000142A  3207                     420          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000142C  C27C 00C0                421          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001430  EC09                     422          LSR.B   #$06,D1     *Shift the size bits into LSB
00001432                           423          
00001432  B23C 0003                424          CMP.B   #$03,D1     *Compare the size bits to $3
00001436  6700 058E                425          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000143A                           426          
0000143A                           427          *Output 'ANDI' to console...
0000143A  43F9 00001F45            428          LEA     ANDI,A1     *Loads ANDI into address register A1
00001440  103C 000E                429          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001444  4E4F                     430          TRAP    #15         *Displays Message
00001446                           431          
00001446                           432          
00001446                           433          *Should have a valid ANDI op code. Set data up for EA.
00001446                           434          
00001446                           435          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001446  4282                     436          CLR.L   D2
00001448  3407                     437          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000144A  C47C 003C                438          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
0000144E  E60A                     439          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001450                           440                  
00001450                           441          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001450  4283                     442          CLR.L   D3
00001452  3607                     443          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001454  C67C 0007                444          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001458                           445          
00001458  4EF9 0000145E            446          JMP     EA_ANDI
0000145E                           447  
0000145E                           448  EA_ANDI
0000145E                           449          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
0000145E                           450          *and D3 holds the EA register.
0000145E                           451          
0000145E                           452          *Determine how much data to read in, depending on the size of the operation
0000145E                           453          *output the size of the operation and the immediate data to console
0000145E  4EB9 000015B2            454          JSR     WrapperSizeImmediate
00001464                           455          
00001464                           456          *Determine which EA mode and thus Register/Mem Address this instruction used
00001464  B43C 0000                457          CMP.B   #$00,D2
00001468  6700 01CA                458          BEQ     DataRegMode *If EA mode is a data register, output that
0000146C                           459          
0000146C  B43C 0002                460          CMP.B   #$02,D2
00001470  6700 01CC                461          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001474                           462          
00001474  B43C 0003                463          CMP.B   #$03,D2
00001478  6700 01CE                464          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000147C                           465          
0000147C  B43C 0004                466          CMP.B   #$04,D2
00001480  6700 01D0                467          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001484                           468          
00001484  B43C 0007                469          CMP.B   #$07,D2
00001488  6700 01D2                470          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000148C                           471          
0000148C                           472          *If the ea mode isn't equal to any of these, it is an invalid EA
0000148C  4EF9 000019D6            473          JMP     BADEACODE
00001492                           474          
00001492                           475  
00001492                           476  *Now we know this instruction is exactly EORI, lets set everything up for EA.
00001492                           477  IS_EORI
00001492                           478          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001492                           479          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001492  4281                     480          CLR.L   D1
00001494  3207                     481          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001496  C27C 00C0                482          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000149A  EC09                     483          LSR.B   #$06,D1     *Shift the size bits into LSB
0000149C                           484          
0000149C  B23C 0003                485          CMP.B   #$03,D1     *Compare the size bits to $3
000014A0  6700 0524                486          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014A4                           487          
000014A4                           488          *Output 'EORI' to console...
000014A4  43F9 00001F4A            489          LEA     EORI,A1     *Loads EORI into address register A1
000014AA  103C 000E                490          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014AE  4E4F                     491          TRAP    #15         *Displays Message
000014B0                           492          
000014B0                           493          
000014B0                           494          *Should have a valid EORI op code. Set data up for EA.
000014B0                           495          
000014B0                           496          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014B0  4282                     497          CLR.L   D2
000014B2  3407                     498          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014B4  C47C 003C                499          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000014B8  E60A                     500          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000014BA                           501                  
000014BA                           502          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000014BA  4283                     503          CLR.L   D3
000014BC  3607                     504          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000014BE  C67C 0007                505          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000014C2                           506          
000014C2  4EF9 000014C8            507          JMP     EA_EORI
000014C8                           508  
000014C8                           509  EA_EORI
000014C8                           510          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
000014C8                           511          *and D3 holds the EA register.
000014C8                           512          
000014C8                           513          *Determine how much data to read in, depending on the size of the operation
000014C8                           514          *output the size of the operation and the immediate data to console
000014C8  4EB9 000015B2            515          JSR     WrapperSizeImmediate
000014CE                           516          
000014CE                           517          *Determine which EA mode and thus Register/Mem Address this instruction used
000014CE  B43C 0000                518          CMP.B   #$00,D2
000014D2  6700 0160                519          BEQ     DataRegMode *If EA mode is a data register, output that
000014D6                           520          
000014D6  B43C 0002                521          CMP.B   #$02,D2
000014DA  6700 0162                522          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014DE                           523          
000014DE  B43C 0003                524          CMP.B   #$03,D2
000014E2  6700 0164                525          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014E6                           526          
000014E6  B43C 0004                527          CMP.B   #$04,D2
000014EA  6700 0166                528          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014EE                           529          
000014EE  B43C 0007                530          CMP.B   #$07,D2
000014F2  6700 0168                531          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014F6                           532          
000014F6                           533          *If the ea mode isn't equal to any of these, it is an invalid EA
000014F6  4EF9 000019D6            534          JMP     BADEACODE
000014FC                           535  
000014FC                           536  
000014FC                           537  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000014FC                           538  * everything up for EA if is a legit instruction.
000014FC                           539  IS_BCHG_D
000014FC                           540          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000014FC                           541          *invalid, branch to BADOPCODE
000014FC  3007                     542          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000014FE  0800 0007                543          BTST.L  #$07,D0
00001502  6600 04C2                544          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
00001506  0800 0006                545          BTST.L  #$06,D0
0000150A  6700 04BA                546          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
0000150E                           547          
0000150E                           548          *Output 'BCHG' to console...
0000150E  43F9 00001F4F            549          LEA     BCHG,A1         *Loads BCHG into address register A1
00001514  103C 000E                550          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001518  4E4F                     551          TRAP    #15             *Displays Message
0000151A                           552                  
0000151A                           553                  
0000151A                           554          *Should have a valid BCHG op code. Set data up for EA.
0000151A                           555  
0000151A                           556  *        *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000151A                           557  *        CLR.L   D2
0000151A                           558  *        MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000151A                           559  *        AND.W   #$003C,D2   *Mask out everything but the EA mode bits
0000151A                           560  *        LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000151A                           561  *                
0000151A                           562  *        *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000151A                           563  *        CLR.L   D3
0000151A                           564  *        MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000151A                           565  *        AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000151A                           566  
0000151A  4EF9 00001520            567          JMP     EA_BCHG_D
00001520                           568  
00001520                           569  EA_BCHG_D
00001520  4EF9 000019EA            570          JMP     THEEND  *For now just end
00001526                           571  
00001526                           572  
00001526                           573  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
00001526                           574  IS_BCHG_S
00001526                           575          *TODO:Verify bits
00001526                           576  
00001526                           577          *Output 'BCHG' to console...
00001526  43F9 00001F4F            578          LEA     BCHG,A1 *Loads FNDBCHG_S into address register A1
0000152C  103C 000E                579          MOVE.B  #14,D0  *Moves the number 14 into data register D0
00001530  4E4F                     580          TRAP    #15     *Displays Message
00001532                           581          
00001532                           582          *Should have a valid BCHG_S op code. Set data up for EA.
00001532                           583          *TODO:
00001532  163C 000E                584          MOVE.B  #14,D3
00001536  4EF9 0000153C            585          JMP     EA_BCHG_S
0000153C                           586  
0000153C                           587  EA_BCHG_S
0000153C  4EF9 000019EA            588          JMP     THEEND  *For now just end
00001542                           589  
00001542                           590  
00001542                           591  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
00001542                           592  IS_CMPI
00001542                           593          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001542                           594          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001542  4281                     595          CLR.L   D1
00001544  3207                     596          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001546  C27C 00C0                597          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000154A  EC09                     598          LSR.B   #$06,D1     *Shift the size bits into LSB
0000154C                           599          
0000154C  B23C 0003                600          CMP.B   #$03,D1     *Compare the size bits to $3
00001550  6700 0474                601          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001554                           602          
00001554                           603          *Output 'CMPI' to console...
00001554  43F9 00001F54            604          LEA     CMPI,A1     *Loads CMPI into address register A1
0000155A  103C 000E                605          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000155E  4E4F                     606          TRAP    #15         *Displays Message
00001560                           607          
00001560                           608          
00001560                           609          *Should have a valid CMPI op code. Set data up for EA.
00001560                           610          
00001560                           611          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001560  4282                     612          CLR.L   D2
00001562  3407                     613          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001564  C47C 003C                614          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001568  E60A                     615          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000156A                           616                  
0000156A                           617          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000156A  4283                     618          CLR.L   D3
0000156C  3607                     619          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000156E  C67C 0007                620          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001572                           621          
00001572  4EF9 00001578            622          JMP     EA_CMPI
00001578                           623  
00001578                           624  EA_CMPI
00001578                           625          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
00001578                           626          *and D3 holds the EA register.
00001578                           627          
00001578                           628          *Determine how much data to read in, depending on the size of the operation
00001578                           629          *output the size of the operation and the immediate data to console
00001578  4EB9 000015B2            630          JSR     WrapperSizeImmediate
0000157E                           631          
0000157E                           632          *Determine which EA mode and thus Register/Mem Address this instruction used
0000157E  B43C 0000                633          CMP.B   #$00,D2
00001582  6700 00B0                634          BEQ     DataRegMode *If EA mode is a data register, output that
00001586                           635          
00001586  B43C 0002                636          CMP.B   #$02,D2
0000158A  6700 00B2                637          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000158E                           638          
0000158E  B43C 0003                639          CMP.B   #$03,D2
00001592  6700 00B4                640          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001596                           641          
00001596  B43C 0004                642          CMP.B   #$04,D2
0000159A  6700 00B6                643          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000159E                           644          
0000159E  B43C 0007                645          CMP.B   #$07,D2
000015A2  6700 00B8                646          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015A6                           647          
000015A6                           648          *If the ea mode isn't equal to any of these, it is an invalid EA
000015A6  4EF9 000019D6            649          JMP     BADEACODE
000015AC                           650  
000015AC                           651          
000015AC                           652  *STARTS WITH 0001, MOVE.B-----------------------------------
000015AC                           653  BUCKET_0001
000015AC  =00000001                654  BUCKET0001_BITS EQU $1
000015AC                           655          
000015AC                           656          *some code...
000015AC                           657  
000015AC                           658  
000015AC                           659  *STARTS WITH 0010, MOVE.L-----------------------------------
000015AC                           660  BUCKET_0010
000015AC  =00000002                661  BUCKET0010_BITS EQU $2
000015AC                           662  
000015AC                           663          *some code...
000015AC                           664  
000015AC                           665  
000015AC                           666  *STARTS WITH 0011, MOVE.W-----------------------------------
000015AC                           667  BUCKET_0011
000015AC  =00000003                668  BUCKET0011_BITS EQU $3
000015AC                           669  
000015AC                           670          *some code...
000015AC                           671  
000015AC                           672  
000015AC                           673  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
000015AC                           674  BUCKET_0100
000015AC  =00000004                675  BUCKET0100_BITS EQU $4
000015AC                           676  
000015AC                           677          *some code...
000015AC                           678  
000015AC                           679  
000015AC                           680  *STARTS WITH 0101, SUBQ-------------------------------------
000015AC                           681  BUCKET_0101
000015AC  =00000005                682  BUCKET0101_BITS EQU $5
000015AC                           683  
000015AC                           684          *some code...
000015AC                           685  
000015AC                           686  
000015AC                           687  *STARTS WITH 0110, BCC--------------------------------------
000015AC                           688  BUCKET_0110
000015AC  =00000006                689  BUCKET0110_BITS EQU $6
000015AC                           690  
000015AC                           691          *some code...
000015AC                           692  
000015AC                           693  
000015AC                           694  *STARTS WITH 1000, DIVU-------------------------------------
000015AC                           695  BUCKET_1000
000015AC  =00000008                696  BUCKET1000_BITS EQU $8
000015AC                           697  
000015AC                           698          *some code...
000015AC                           699  
000015AC                           700  
000015AC                           701  *STARTS WITH 1001, SUBA-------------------------------------
000015AC                           702  BUCKET_1001
000015AC  =00000009                703  BUCKET1001_BITS EQU $9
000015AC                           704  
000015AC                           705          *some code...
000015AC                           706  
000015AC                           707  
000015AC                           708  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000015AC                           709  BUCKET_1011
000015AC  =0000000B                710  BUCKET1011_BITS EQU $B
000015AC                           711  
000015AC                           712          *some code...
000015AC                           713  
000015AC                           714  
000015AC                           715  *STARTS WITH 1100, MULS(W) | AND----------------------------
000015AC                           716  BUCKET_1100
000015AC  =0000000C                717  BUCKET1100_BITS EQU $C
000015AC                           718  
000015AC                           719          *some code...
000015AC                           720  
000015AC                           721  
000015AC                           722  *STARTS WITH 1101, ADD | ADDA-------------------------------
000015AC                           723  BUCKET_1101
000015AC  =0000000D                724  BUCKET1101_BITS EQU $D
000015AC                           725  
000015AC                           726          *some code...
000015AC                           727  
000015AC                           728  
000015AC                           729  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000015AC                           730  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000015AC                           731  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000015AC                           732  BUCKET_1110
000015AC  =0000000E                733  BUCKET1110_BITS EQU $E     
000015AC                           734  
000015AC                           735          *some code...
000015AC                           736  
000015AC                           737  
000015AC                           738  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000015AC                           739  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000015AC  4EF9 000019C6            740          JMP     BADOPCODE  
000015B2                           741          
000015B2                           742  
000015B2                           743  *-----------------------------------------------------------        
000015B2                           744  * EA operation size decoding functionality
000015B2                           745  *-----------------------------------------------------------   
000015B2                           746  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
000015B2                           747  WrapperSizeImmediate
000015B2  4284                     748          CLR.L   D4
000015B4                           749          *Depending on the EA Register, choose which size to decode
000015B4  B23C 0000                750          CMP.B   #$00,D1
000015B8  6700 0014                751          BEQ     ByteSizeImmediate
000015BC                           752          
000015BC  B23C 0001                753          CMP.B   #$01,D1
000015C0  6700 002E                754          BEQ     WordSizeImmediate
000015C4                           755  
000015C4  B23C 0002                756          CMP.B   #$02,D1
000015C8  6700 0048                757          BEQ     LongSizeImmediate
000015CC                           758          
000015CC                           759  *Used to get back to what we were doing, after dealing with the specific size
000015CC                           760  WrapperSizeImmediateEnd
000015CC  4E75                     761          RTS
000015CE                           762          
000015CE                           763  ByteSizeImmediate
000015CE  3818                     764          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
000015D0                           765          
000015D0                           766          *Output '.B' to console...
000015D0  43F9 00001F59            767          LEA     ByteSize,A1 *Loads ByteSize into address register A1
000015D6  103C 000E                768          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000015DA  4E4F                     769          TRAP    #15         *Displays Message
000015DC                           770          
000015DC                           771          *Output '#$' just before the immediate data
000015DC  43F9 00002071            772          LEA     ShaBang,A1
000015E2  103C 000E                773          MOVE.B  #14,D0
000015E6  4E4F                     774          TRAP    #15  
000015E8                           775          
000015E8                           776          *output the immediate data to console with the hex-ascii converter
000015E8  4EB8 11D6                777          JSR     HEXASCII
000015EC                           778                  
000015EC  4EF8 15CC                779          JMP     WrapperSizeImmediateEnd
000015F0                           780                  
000015F0                           781  WordSizeImmediate
000015F0  3818                     782          MOVE.W  (A0)+,D4    *read in next word, data is that word
000015F2                           783          
000015F2                           784          *Output '.W' to console...
000015F2  43F9 00001F60            785          LEA     WordSize,A1 *Loads WordSize into address register A1
000015F8  103C 000E                786          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000015FC  4E4F                     787          TRAP    #15         *Displays Message
000015FE                           788          
000015FE                           789          *Output '#$' just before the immediate data
000015FE  43F9 00002071            790          LEA     ShaBang,A1
00001604  103C 000E                791          MOVE.B  #14,D0
00001608  4E4F                     792          TRAP    #15  
0000160A                           793          
0000160A                           794          *output the immediate data to console with the hex-ascii converter
0000160A  4EB8 11D6                795          JSR     HEXASCII
0000160E                           796          
0000160E  4EF8 15CC                797          JMP     WrapperSizeImmediateEnd
00001612                           798                  
00001612                           799  LongSizeImmediate
00001612  2818                     800          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
00001614                           801          
00001614                           802          *Output '.L' to console...
00001614  43F9 00001F67            803          LEA     LongSize,A1 *Loads LongSize into address register A1
0000161A  103C 000E                804          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000161E  4E4F                     805          TRAP    #15         *Displays Message
00001620                           806          
00001620                           807          *Output '#$' just before the immediate data
00001620  43F9 00002071            808          LEA     ShaBang,A1
00001626  103C 000E                809          MOVE.B  #14,D0
0000162A  4E4F                     810          TRAP    #15  
0000162C                           811          
0000162C                           812          *output the immediate data to console with the hex-ascii converter
0000162C  4EB8 11D6                813          JSR     HEXASCII
00001630                           814          
00001630  4EF8 15CC                815          JMP     WrapperSizeImmediateEnd
00001634                           816  
00001634                           817  
00001634                           818  *-----------------------------------------------------------        
00001634                           819  * EA Mode/EA Register decoding functionality
00001634                           820  *-----------------------------------------------------------        
00001634                           821  DataRegMode
00001634                           822          *Depending on the EA Register, output a different register number
00001634  4EB9 00001666            823          JSR     WrapperDataReg
0000163A                           824          
0000163A                           825          *need to read some flag, if this was called from a source EA decoding then jmp to 
0000163A                           826          *some wrapper (i'll define later)
0000163A                           827          
0000163A                           828          *else this was a destination EA decoding, we can just go get the next instruction
0000163A                           829          *since there is no more decoding to do for the current instruction
0000163A  4EF8 135C                830          JMP     GRAB_NEXT_OP
0000163E                           831  
0000163E                           832  AddrDirectMode
0000163E                           833          *some code...
0000163E                           834  
0000163E                           835  AddrIndirectMode
0000163E                           836          *Depending on the EA Register, output a different register number
0000163E  4EB9 00001728            837          JSR     WrapperAddrIndirect
00001644                           838                          
00001644                           839          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001644                           840          *some wrapper (i'll define later)
00001644                           841          
00001644                           842          *else this was a destination EA decoding, we can just go get the next instruction
00001644                           843          *since there is no more decoding to do for the current instruction
00001644  4EF8 135C                844          JMP     GRAB_NEXT_OP
00001648                           845  
00001648                           846  AddrIndirectPostMode
00001648                           847          *Depending on the EA Register, output a different register number
00001648  4EB9 000017EA            848          JSR     WrapperAddrIndirectPost
0000164E                           849  
0000164E                           850          *need to read some flag, if this was called from a source EA decoding then jmp to 
0000164E                           851          *some wrapper (i'll define later)
0000164E                           852          
0000164E                           853          *else this was a destination EA decoding, we can just go get the next instruction
0000164E                           854          *since there is no more decoding to do for the current instruction
0000164E  4EF8 135C                855          JMP     GRAB_NEXT_OP
00001652                           856  
00001652                           857  AddrIndirectPreMode
00001652                           858          *Depending on the EA Register, output a different register number
00001652  4EB9 000018AC            859          JSR     WrapperAddrIndirectPre
00001658                           860  
00001658                           861          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001658                           862          *some wrapper (i'll define later)
00001658                           863          
00001658                           864          *else this was a destination EA decoding, we can just go get the next instruction
00001658                           865          *since there is no more decoding to do for the current instruction
00001658  4EF8 135C                866          JMP     GRAB_NEXT_OP
0000165C                           867  
0000165C                           868  AddrAbsoluteMode
0000165C                           869          *Depending on the EA Register, output a different register number
0000165C  4EB9 0000196E            870          JSR     WrapperAddrAbsolute        
00001662                           871  
00001662                           872          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001662                           873          *some wrapper (i'll define later)
00001662                           874          
00001662                           875          *else this was a destination EA decoding, we can just go get the next instruction
00001662                           876          *since there is no more decoding to do for the current instruction
00001662  4EF8 135C                877          JMP     GRAB_NEXT_OP
00001666                           878          
00001666                           879  ImmediateDataMode
00001666                           880          *some code      
00001666                           881  
00001666                           882  
00001666                           883  *-----------------------------------------------------------        
00001666                           884  * Output logic for all Data Registers (0-7)
00001666                           885  *-----------------------------------------------------------     
00001666                           886  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001666                           887  WrapperDataReg
00001666                           888          *Depending on the EA Register, output a different register number
00001666  B63C 0000                889          CMP.B   #$00,D3
0000166A  6700 003C                890          BEQ     DataReg0
0000166E                           891          
0000166E  B63C 0001                892          CMP.B   #$01,D3
00001672  6700 0044                893          BEQ     DataReg1
00001676                           894          
00001676  B63C 0002                895          CMP.B   #$02,D3
0000167A  6700 004C                896          BEQ     DataReg2
0000167E                           897          
0000167E  B63C 0003                898          CMP.B   #$03,D3
00001682  6700 0054                899          BEQ     DataReg3
00001686                           900          
00001686  B63C 0004                901          CMP.B   #$04,D3
0000168A  6700 005C                902          BEQ     DataReg4
0000168E                           903          
0000168E  B63C 0005                904          CMP.B   #$05,D3
00001692  6700 0064                905          BEQ     DataReg5
00001696                           906          
00001696  B63C 0006                907          CMP.B   #$06,D3
0000169A  6700 006C                908          BEQ     DataReg6
0000169E                           909          
0000169E  B63C 0007                910          CMP.B   #$07,D3
000016A2  6700 0074                911          BEQ     DataReg7        
000016A6                           912  
000016A6                           913  *Used to get back to 'DataRegMode', after dealing with the specific register
000016A6                           914  WrapperDataRegEnd
000016A6  4E75                     915          RTS
000016A8                           916  
000016A8                           917  DataReg0
000016A8                           918          *Output the specific data register...
000016A8  43F9 00001F6E            919          LEA     OutDataReg0,A1  *Loads DataReg0 into address register A1
000016AE  103C 000E                920          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016B2  4E4F                     921          TRAP    #15             *Displays Message   
000016B4                           922          
000016B4  4EF8 16A6                923          JMP     WrapperDataRegEnd
000016B8                           924  
000016B8                           925  DataReg1
000016B8  43F9 00001F74            926          LEA     OutDataReg1,A1
000016BE  103C 000E                927          MOVE.B  #14,D0
000016C2  4E4F                     928          TRAP    #15
000016C4                           929          
000016C4  4EF8 16A6                930          JMP     WrapperDataRegEnd
000016C8                           931  
000016C8                           932  DataReg2
000016C8  43F9 00001F7A            933          LEA     OutDataReg2,A1
000016CE  103C 000E                934          MOVE.B  #14,D0
000016D2  4E4F                     935          TRAP    #15
000016D4                           936  
000016D4  4EF8 16A6                937          JMP     WrapperDataRegEnd
000016D8                           938      
000016D8                           939  DataReg3
000016D8  43F9 00001F80            940          LEA     OutDataReg3,A1
000016DE  103C 000E                941          MOVE.B  #14,D0
000016E2  4E4F                     942          TRAP    #15
000016E4                           943  
000016E4  4EF8 16A6                944          JMP     WrapperDataRegEnd
000016E8                           945          
000016E8                           946  DataReg4
000016E8  43F9 00001F86            947          LEA     OutDataReg4,A1
000016EE  103C 000E                948          MOVE.B  #14,D0
000016F2  4E4F                     949          TRAP    #15
000016F4                           950  
000016F4  4EF8 16A6                951          JMP     WrapperDataRegEnd
000016F8                           952                 
000016F8                           953  DataReg5
000016F8  43F9 00001F8C            954          LEA     OutDataReg5,A1
000016FE  103C 000E                955          MOVE.B  #14,D0
00001702  4E4F                     956          TRAP    #15
00001704                           957  
00001704  4EF8 16A6                958          JMP     WrapperDataRegEnd
00001708                           959          
00001708                           960  DataReg6
00001708  43F9 00001F92            961          LEA     OutDataReg6,A1 A1
0000170E  103C 000E                962          MOVE.B  #14,D0
00001712  4E4F                     963          TRAP    #15
00001714                           964  
00001714  4EF8 16A6                965          JMP     WrapperDataRegEnd
00001718                           966          
00001718                           967  DataReg7
00001718  43F9 00001F98            968          LEA     OutDataReg7,A1
0000171E  103C 000E                969          MOVE.B  #14,D0
00001722  4E4F                     970          TRAP    #15
00001724                           971          
00001724  4EF8 16A6                972          JMP     WrapperDataRegEnd
00001728                           973  
00001728                           974  
00001728                           975  *-----------------------------------------------------------        
00001728                           976  * Output logic for all Address Indirect Registers (0-7)
00001728                           977  *-----------------------------------------------------------     
00001728                           978  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001728                           979  WrapperAddrIndirect
00001728                           980          *Depending on the EA Register, output a different register number
00001728  B63C 0000                981          CMP.B   #$00,D3
0000172C  6700 003C                982          BEQ     AddrIndReg0
00001730                           983          
00001730  B63C 0001                984          CMP.B   #$01,D3
00001734  6700 0044                985          BEQ     AddrIndReg1
00001738                           986          
00001738  B63C 0002                987          CMP.B   #$02,D3
0000173C  6700 004C                988          BEQ     AddrIndReg2
00001740                           989          
00001740  B63C 0003                990          CMP.B   #$03,D3
00001744  6700 0054                991          BEQ     AddrIndReg3
00001748                           992          
00001748  B63C 0004                993          CMP.B   #$04,D3
0000174C  6700 005C                994          BEQ     AddrIndReg4
00001750                           995          
00001750  B63C 0005                996          CMP.B   #$05,D3
00001754  6700 0064                997          BEQ     AddrIndReg5
00001758                           998          
00001758  B63C 0006                999          CMP.B   #$06,D3
0000175C  6700 006C               1000          BEQ     AddrIndReg6
00001760                          1001          
00001760  B63C 0007               1002          CMP.B   #$07,D3
00001764  6700 0074               1003          BEQ     AddrIndReg7
00001768                          1004  
00001768                          1005  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
00001768                          1006  WrapperAddrIndirectEnd
00001768  4E75                    1007          RTS        
0000176A                          1008  
0000176A                          1009  AddrIndReg0
0000176A                          1010          *Output the specific address indirect register...
0000176A  43F9 00001F9E           1011          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001770  103C 000E               1012          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001774  4E4F                    1013          TRAP    #15                 *Displays Message        
00001776                          1014          
00001776  4EF8 1768               1015          JMP     WrapperAddrIndirectEnd
0000177A                          1016  
0000177A                          1017  AddrIndReg1
0000177A  43F9 00001FA6           1018          LEA     OutAddrIndReg1,A1
00001780  103C 000E               1019          MOVE.B  #14,D0
00001784  4E4F                    1020          TRAP    #15
00001786                          1021          
00001786  4EF8 1768               1022          JMP     WrapperAddrIndirectEnd
0000178A                          1023  
0000178A                          1024  AddrIndReg2
0000178A  43F9 00001FAE           1025          LEA     OutAddrIndReg2,A1
00001790  103C 000E               1026          MOVE.B  #14,D0
00001794  4E4F                    1027          TRAP    #15
00001796                          1028          
00001796  4EF8 1768               1029          JMP     WrapperAddrIndirectEnd
0000179A                          1030  
0000179A                          1031  AddrIndReg3
0000179A  43F9 00001FB6           1032          LEA     OutAddrIndReg3,A1
000017A0  103C 000E               1033          MOVE.B  #14,D0
000017A4  4E4F                    1034          TRAP    #15
000017A6                          1035          
000017A6  4EF8 1768               1036          JMP     WrapperAddrIndirectEnd
000017AA                          1037  
000017AA                          1038  AddrIndReg4
000017AA  43F9 00001FBE           1039          LEA     OutAddrIndReg4,A1
000017B0  103C 000E               1040          MOVE.B  #14,D0
000017B4  4E4F                    1041          TRAP    #15
000017B6                          1042          
000017B6  4EF8 1768               1043          JMP     WrapperAddrIndirectEnd
000017BA                          1044  
000017BA                          1045  AddrIndReg5
000017BA  43F9 00001FC6           1046          LEA     OutAddrIndReg5,A1
000017C0  103C 000E               1047          MOVE.B  #14,D0
000017C4  4E4F                    1048          TRAP    #15
000017C6                          1049          
000017C6  4EF8 1768               1050          JMP     WrapperAddrIndirectEnd
000017CA                          1051  
000017CA                          1052  AddrIndReg6
000017CA  43F9 00001FCE           1053          LEA     OutAddrIndReg6,A1
000017D0  103C 000E               1054          MOVE.B  #14,D0
000017D4  4E4F                    1055          TRAP    #15
000017D6                          1056          
000017D6  4EF8 1768               1057          JMP     WrapperAddrIndirectEnd
000017DA                          1058  
000017DA                          1059  AddrIndReg7
000017DA  43F9 00001FD6           1060          LEA     OutAddrIndReg7,A1
000017E0  103C 000E               1061          MOVE.B  #14,D0
000017E4  4E4F                    1062          TRAP    #15
000017E6                          1063          
000017E6  4EF8 1768               1064          JMP     WrapperAddrIndirectEnd
000017EA                          1065          
000017EA                          1066          
000017EA                          1067  *-----------------------------------------------------------        
000017EA                          1068  * Output logic for all Address Indirect Post Increment Registers (0-7)
000017EA                          1069  *-----------------------------------------------------------     
000017EA                          1070  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000017EA                          1071  WrapperAddrIndirectPost
000017EA                          1072          *Depending on the EA Register, output a different register number
000017EA  B63C 0000               1073          CMP.B   #$00,D3
000017EE  6700 003C               1074          BEQ     AddrIndPoReg0
000017F2                          1075          
000017F2  B63C 0001               1076          CMP.B   #$01,D3
000017F6  6700 0044               1077          BEQ     AddrIndPoReg1
000017FA                          1078          
000017FA  B63C 0002               1079          CMP.B   #$02,D3
000017FE  6700 004C               1080          BEQ     AddrIndPoReg2
00001802                          1081          
00001802  B63C 0003               1082          CMP.B   #$03,D3
00001806  6700 0054               1083          BEQ     AddrIndPoReg3
0000180A                          1084          
0000180A  B63C 0004               1085          CMP.B   #$04,D3
0000180E  6700 005C               1086          BEQ     AddrIndPoReg4
00001812                          1087          
00001812  B63C 0005               1088          CMP.B   #$05,D3
00001816  6700 0064               1089          BEQ     AddrIndPoReg5
0000181A                          1090          
0000181A  B63C 0006               1091          CMP.B   #$06,D3
0000181E  6700 006C               1092          BEQ     AddrIndPoReg6
00001822                          1093          
00001822  B63C 0007               1094          CMP.B   #$07,D3
00001826  6700 0074               1095          BEQ     AddrIndPoReg7
0000182A                          1096  
0000182A                          1097  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
0000182A                          1098  WrapperAddrIndirectPostEnd
0000182A  4E75                    1099          RTS        
0000182C                          1100  
0000182C                          1101  AddrIndPoReg0
0000182C                          1102          *Output the specific address indirect post register...
0000182C  43F9 00001FDE           1103          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001832  103C 000E               1104          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001836  4E4F                    1105          TRAP    #15                 *Displays Message        
00001838                          1106          
00001838  4EF8 182A               1107          JMP     WrapperAddrIndirectPostEnd
0000183C                          1108  
0000183C                          1109  AddrIndPoReg1
0000183C  43F9 00001FE7           1110          LEA     OutAddrIndPoReg1,A1
00001842  103C 000E               1111          MOVE.B  #14,D0
00001846  4E4F                    1112          TRAP    #15
00001848                          1113          
00001848  4EF8 182A               1114          JMP     WrapperAddrIndirectPostEnd
0000184C                          1115  
0000184C                          1116  AddrIndPoReg2
0000184C  43F9 00001FF0           1117          LEA     OutAddrIndPoReg2,A1
00001852  103C 000E               1118          MOVE.B  #14,D0
00001856  4E4F                    1119          TRAP    #15
00001858                          1120          
00001858  4EF8 182A               1121          JMP     WrapperAddrIndirectPostEnd
0000185C                          1122  
0000185C                          1123  AddrIndPoReg3
0000185C  43F9 00001FF9           1124          LEA     OutAddrIndPoReg3,A1
00001862  103C 000E               1125          MOVE.B  #14,D0
00001866  4E4F                    1126          TRAP    #15
00001868                          1127          
00001868  4EF8 182A               1128          JMP     WrapperAddrIndirectPostEnd
0000186C                          1129  
0000186C                          1130  AddrIndPoReg4
0000186C  43F9 00002002           1131          LEA     OutAddrIndPoReg4,A1
00001872  103C 000E               1132          MOVE.B  #14,D0
00001876  4E4F                    1133          TRAP    #15
00001878                          1134          
00001878  4EF8 182A               1135          JMP     WrapperAddrIndirectPostEnd
0000187C                          1136  
0000187C                          1137  AddrIndPoReg5
0000187C  43F9 0000200B           1138          LEA     OutAddrIndPoReg5,A1
00001882  103C 000E               1139          MOVE.B  #14,D0
00001886  4E4F                    1140          TRAP    #15
00001888                          1141          
00001888  4EF8 182A               1142          JMP     WrapperAddrIndirectPostEnd
0000188C                          1143  
0000188C                          1144  AddrIndPoReg6
0000188C  43F9 00002014           1145          LEA     OutAddrIndPoReg6,A1
00001892  103C 000E               1146          MOVE.B  #14,D0
00001896  4E4F                    1147          TRAP    #15
00001898                          1148          
00001898  4EF8 182A               1149          JMP     WrapperAddrIndirectPostEnd
0000189C                          1150  
0000189C                          1151  AddrIndPoReg7
0000189C  43F9 0000201D           1152          LEA     OutAddrIndPoReg7,A1
000018A2  103C 000E               1153          MOVE.B  #14,D0
000018A6  4E4F                    1154          TRAP    #15
000018A8                          1155          
000018A8  4EF8 182A               1156          JMP     WrapperAddrIndirectPostEnd
000018AC                          1157  
000018AC                          1158  
000018AC                          1159  *-----------------------------------------------------------        
000018AC                          1160  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
000018AC                          1161  *-----------------------------------------------------------     
000018AC                          1162  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000018AC                          1163  WrapperAddrIndirectPre
000018AC                          1164          *Depending on the EA Register, output a different register number
000018AC  B63C 0000               1165          CMP.B   #$00,D3
000018B0  6700 003C               1166          BEQ     AddrIndPrReg0
000018B4                          1167          
000018B4  B63C 0001               1168          CMP.B   #$01,D3
000018B8  6700 0044               1169          BEQ     AddrIndPrReg1
000018BC                          1170          
000018BC  B63C 0002               1171          CMP.B   #$02,D3
000018C0  6700 004C               1172          BEQ     AddrIndPrReg2
000018C4                          1173          
000018C4  B63C 0003               1174          CMP.B   #$03,D3
000018C8  6700 0054               1175          BEQ     AddrIndPrReg3
000018CC                          1176          
000018CC  B63C 0004               1177          CMP.B   #$04,D3
000018D0  6700 005C               1178          BEQ     AddrIndPrReg4
000018D4                          1179          
000018D4  B63C 0005               1180          CMP.B   #$05,D3
000018D8  6700 0064               1181          BEQ     AddrIndPrReg5
000018DC                          1182          
000018DC  B63C 0006               1183          CMP.B   #$06,D3
000018E0  6700 006C               1184          BEQ     AddrIndPrReg6
000018E4                          1185          
000018E4  B63C 0007               1186          CMP.B   #$07,D3
000018E8  6700 0074               1187          BEQ     AddrIndPrReg7
000018EC                          1188  
000018EC                          1189  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
000018EC                          1190  WrapperAddrIndirectPreEnd
000018EC  4E75                    1191          RTS        
000018EE                          1192  
000018EE                          1193  AddrIndPrReg0
000018EE                          1194          *Output the specific address indirect post register...
000018EE  43F9 00002026           1195          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
000018F4  103C 000E               1196          MOVE.B  #14,D0              *Moves the number 14 into data register D0
000018F8  4E4F                    1197          TRAP    #15                 *Displays Message        
000018FA                          1198          
000018FA  4EF8 18EC               1199          JMP     WrapperAddrIndirectPreEnd
000018FE                          1200  
000018FE                          1201  AddrIndPrReg1
000018FE  43F9 0000202F           1202          LEA     OutAddrIndPrReg1,A1
00001904  103C 000E               1203          MOVE.B  #14,D0
00001908  4E4F                    1204          TRAP    #15
0000190A                          1205          
0000190A  4EF8 18EC               1206          JMP     WrapperAddrIndirectPreEnd
0000190E                          1207  
0000190E                          1208  AddrIndPrReg2
0000190E  43F9 00002038           1209          LEA     OutAddrIndPrReg2,A1
00001914  103C 000E               1210          MOVE.B  #14,D0
00001918  4E4F                    1211          TRAP    #15
0000191A                          1212          
0000191A  4EF8 18EC               1213          JMP     WrapperAddrIndirectPreEnd
0000191E                          1214  
0000191E                          1215  AddrIndPrReg3
0000191E  43F9 00002041           1216          LEA     OutAddrIndPrReg3,A1
00001924  103C 000E               1217          MOVE.B  #14,D0
00001928  4E4F                    1218          TRAP    #15
0000192A                          1219          
0000192A  4EF8 18EC               1220          JMP     WrapperAddrIndirectPreEnd
0000192E                          1221  
0000192E                          1222  AddrIndPrReg4
0000192E  43F9 0000204A           1223          LEA     OutAddrIndPrReg4,A1
00001934  103C 000E               1224          MOVE.B  #14,D0
00001938  4E4F                    1225          TRAP    #15
0000193A                          1226          
0000193A  4EF8 18EC               1227          JMP     WrapperAddrIndirectPreEnd
0000193E                          1228  
0000193E                          1229  AddrIndPrReg5
0000193E  43F9 00002053           1230          LEA     OutAddrIndPrReg5,A1
00001944  103C 000E               1231          MOVE.B  #14,D0
00001948  4E4F                    1232          TRAP    #15
0000194A                          1233          
0000194A  4EF8 18EC               1234          JMP     WrapperAddrIndirectPreEnd
0000194E                          1235  
0000194E                          1236  AddrIndPrReg6
0000194E  43F9 0000205C           1237          LEA     OutAddrIndPrReg6,A1
00001954  103C 000E               1238          MOVE.B  #14,D0
00001958  4E4F                    1239          TRAP    #15
0000195A                          1240          
0000195A  4EF8 18EC               1241          JMP     WrapperAddrIndirectPreEnd
0000195E                          1242  
0000195E                          1243  AddrIndPrReg7
0000195E  43F9 00002065           1244          LEA     OutAddrIndPrReg7,A1
00001964  103C 000E               1245          MOVE.B  #14,D0
00001968  4E4F                    1246          TRAP    #15
0000196A                          1247          
0000196A  4EF8 18EC               1248          JMP     WrapperAddrIndirectPreEnd
0000196E                          1249  
0000196E                          1250  
0000196E                          1251  *-----------------------------------------------------------        
0000196E                          1252  * Output logic for absolute memory addressing (0-7)
0000196E                          1253  *-----------------------------------------------------------     
0000196E                          1254  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
0000196E                          1255  WrapperAddrAbsolute
0000196E  4284                    1256          CLR.L   D4
00001970                          1257          *Depending on the EA Register, choose which size to decode
00001970  B63C 0000               1258          CMP.B   #$00,D3
00001974  6700 000C               1259          BEQ     WordSizeAbsolute
00001978                          1260  
00001978  B63C 0001               1261          CMP.B   #$01,D3
0000197C  6700 0026               1262          BEQ     LongSizeAbsolute
00001980                          1263          
00001980                          1264  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001980                          1265  WrapperAddrAbsoluteEnd
00001980  4E75                    1266          RTS
00001982                          1267  
00001982                          1268  WordSizeAbsolute        
00001982  3818                    1269          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001984                          1270              
00001984                          1271          *Output ',$' just after source operand
00001984  43F9 00002074           1272          LEA     Bang,A1
0000198A  103C 000E               1273          MOVE.B  #14,D0
0000198E  4E4F                    1274          TRAP    #15
00001990                          1275              
00001990                          1276          *output the absolute mem address to console with the hex-ascii converter
00001990  4EB8 11D6               1277          JSR     HEXASCII
00001994                          1278          
00001994                          1279          *Print a new line, since this should be the last piece of data for an instruction
00001994  43F9 0000206E           1280          LEA     NewLine,A1
0000199A  103C 000E               1281          MOVE.B  #14,D0
0000199E  4E4F                    1282          TRAP    #15
000019A0                          1283          
000019A0  4EF8 1980               1284          JMP     WrapperAddrAbsoluteEnd
000019A4                          1285  
000019A4                          1286  LongSizeAbsolute
000019A4  2818                    1287          MOVE.L  (A0)+,D4    *read in next long, data is that long
000019A6                          1288                  
000019A6                          1289          *Output ',$' just after source operand
000019A6  43F9 00002074           1290          LEA     Bang,A1
000019AC  103C 000E               1291          MOVE.B  #14,D0
000019B0  4E4F                    1292          TRAP    #15  
000019B2                          1293          
000019B2                          1294          *output the absolute mem address to console with the hex-ascii converter
000019B2  4EB8 11D6               1295          JSR     HEXASCII
000019B6                          1296          
000019B6                          1297          *Print a new line, since this should be the last piece of data for an instruction
000019B6  43F9 0000206E           1298          LEA     NewLine,A1
000019BC  103C 000E               1299          MOVE.B  #14,D0
000019C0  4E4F                    1300          TRAP    #15
000019C2                          1301  
000019C2  4EF8 1980               1302          JMP     WrapperAddrAbsoluteEnd
000019C6                          1303          
000019C6                          1304  
000019C6                          1305  *-----------------------------------------------------------        
000019C6                          1306  * Current handling of bad op/ea codes. Should be revisited.
000019C6                          1307  *----------------------------------------------------------- 
000019C6                          1308  BADOPCODE
000019C6                          1309          *We found a bad op code, output some error to the screen, jump to the 
000019C6                          1310          *next instruction in memory.
000019C6                          1311          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
000019C6                          1312          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
000019C6                          1313          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
000019C6                          1314          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
000019C6                          1315          *i/o and error message code...
000019C6  43F9 00002087           1316          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
000019CC  103C 000E               1317          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019D0  4E4F                    1318          TRAP    #15         *Displays Message
000019D2  4EF8 135C               1319          JMP     GRAB_NEXT_OP
000019D6                          1320                  
000019D6                          1321  BADEACODE
000019D6                          1322          *We found a bad ea code, output some error to the screen, jump to the
000019D6                          1323          *next instruction in memory.
000019D6                          1324          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
000019D6                          1325          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
000019D6  43F9 00002077           1326          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
000019DC  103C 000E               1327          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019E0  4E4F                    1328          TRAP    #15         *Displays Message
000019E2  4EF8 135C               1329          JMP     GRAB_NEXT_OP
000019E6                          1330          
000019E6                          1331          
000019E6                          1332  *-----------------------------------------------------------        
000019E6                          1333  * End of Disassembler
000019E6                          1334  *-----------------------------------------------------------    
000019E6                          1335  
000019E6  4E72 2700               1336  DONE    STOP    #$2700  *What does this do? Why was it added?
000019EA                          1337  
000019EA  103C 0009               1338  THEEND  MOVE.B  #9,D0
000019EE  4E4F                    1339          TRAP    #15             Halt Simulator        
000019F0                          1340          
000019F0                          1341       
000019F0                          1342  *-----------------------------------------------------------        
000019F0                          1343  * Output stuff
000019F0                          1344  *-----------------------------------------------------------     
000019F0  =0000000D               1345  CR      EQU     $0D             ASCII code for Carriage Return
000019F0  =0000000A               1346  LF      EQU     $0A             ASCII code for Line Feed
000019F0= 2D 2D 2D 2D 2D 2D ...   1347  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001A2F= 7C 7C 20 20 20 20 ...   1348              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001A6E= 2D 2D 2D 2D 2D 2D ...   1349              DC.B    '-------------------------------------------------------------',CR,LF
00001AAD= 2A 2A 2A 2A 2A 2A ...   1350              DC.B    '*************************************************************',CR,LF
00001AEC= 2A 2A 2A 2A 2A 2A ...   1351              DC.B    '*************************************************************',CR,LF
00001B2B= 2A 2A 2A 2A 2A 2A ...   1352              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001B6A= 2A 2A 2A 2A 2A 2A ...   1353              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001BA9= 2A 2A 2A 2A 2A 2A ...   1354              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001BE8= 2A 2A 2A 2A 2A 2A ...   1355              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001C27= 2A 2A 2A 2A 2A 2A ...   1356              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001C66= 2A 2A 2A 2A 2A 2A ...   1357              DC.B    '*************************************************************',CR,LF
00001CA5= 2A 2A 2A 2A 2A 2A ...   1358              DC.B    '*************************************************************',CR,LF
00001CE4= 2A 20 20 20 20 20 ...   1359              DC.B    '*                                                           *',CR,LF
00001D23= 2A 20 41 75 74 68 ...   1360              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001D62= 2A 20 20 20 20 20 ...   1361              DC.B    '*                                                           *',CR,LF
00001DA1= 2A 2A 2A 2A 2A 2A ...   1362              DC.B    '*************************************************************',CR,LF,CR,LF
00001DE2= 53 74 61 72 74 69 ...   1363              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001DFF                          1364              
00001DFF= 57 6F 75 6C 64 20 ...   1365  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001E30                          1366  
00001E30= 20 0D 0A                1367  GETSTRTADDR DC.B    ' ',CR,LF
00001E33= 50 6C 65 61 73 65 ...   1368              DC.B    'Please type in your starting address request: ',0
00001E62                          1369              
00001E62= 20 0D 0A                1370  GETENDADDR  DC.B    ' ',CR,LF
00001E65= 50 6C 65 61 73 65 ...   1371              DC.B    'Please type in your ending address request: ',0
00001E92                          1372              
00001E92= 20 0D 0A                1373  QUIT_MSG    DC.B    ' ',CR,LF
00001E95= 57 6F 75 6C 64 20 ...   1374              DC.B    'Would you like to quit (Y/N)? ',0
00001EB4                          1375  
00001EB4                          1376  *****************************************************
00001EB4                          1377  * I/O storages - assuming users knows what to do.
00001EB4                          1378  *****************************************************
00001EB4                          1379  CMD_HLD     DS.B    30
00001ED2                          1380  CMD_SZ      DS.B    30
00001EF0                          1381  STADDR      DS.B    10
00001EFA                          1382  STADDRSZ    DS.B    10
00001F04                          1383  PROGST      DS.L    1
00001F08                          1384  ENDADDR     DS.B    10
00001F12                          1385  ENDADDRSZ   DS.B    10
00001F1C                          1386  PROGEND     DS.L    1
00001F20                          1387  *****************************************************
00001F20                          1388  
00001F20                          1389  *Table for 0-9 && A-F
00001F20= 30 00                   1390  PRNT0   DC.B    '0',0
00001F22= 31 00                   1391  PRNT1   DC.B    '1',0
00001F24= 32 00                   1392  PRNT2   DC.B    '2',0
00001F26= 33 00                   1393  PRNT3   DC.B    '3',0
00001F28= 34 00                   1394  PRNT4   DC.B    '4',0
00001F2A= 35 00                   1395  PRNT5   DC.B    '5',0
00001F2C= 36 00                   1396  PRNT6   DC.B    '6',0
00001F2E= 37 00                   1397  PRNT7   DC.B    '7',0
00001F30= 38 00                   1398  PRNT8   DC.B    '8',0
00001F32= 39 00                   1399  PRNT9   DC.B    '9',0
00001F34= 41 00                   1400  PRNTA   DC.B    'A',0
00001F36= 42 00                   1401  PRNTB   DC.B    'B',0
00001F38= 43 00                   1402  PRNTC   DC.B    'C',0
00001F3A= 44 00                   1403  PRNTD   DC.B    'D',0
00001F3C= 45 00                   1404  PRNTE   DC.B    'E',0
00001F3E= 46 00                   1405  PRNTF   DC.B    'F',0
00001F40                          1406  
00001F40                          1407  *output for all OPCODEs
00001F40= 41 44 44 49 00          1408  ADDI    DC.B    'ADDI',0
00001F45= 41 4E 44 49 00          1409  ANDI    DC.B    'ANDI',0
00001F4A= 45 4F 52 49 00          1410  EORI    DC.B    'EORI',0
00001F4F= 42 43 48 47 00          1411  BCHG    DC.B    'BCHG',0
00001F54= 43 4D 50 49 00          1412  CMPI    DC.B    'CMPI',0
00001F59                          1413  
00001F59                          1414  *output for the size of the operation
00001F59= 2E 42 20 20 20 20 00    1415  ByteSize    DC.B    '.B    ',0
00001F60= 2E 57 20 20 20 20 00    1416  WordSize    DC.B    '.W    ',0
00001F67= 2E 4C 20 20 20 20 00    1417  LongSize    DC.B    '.L    ',0
00001F6E                          1418  
00001F6E                          1419  *output for all data registers (0-7)
00001F6E= 2C 44 30 0D 0A 00       1420  OutDataReg0 DC.B    ',D0',CR,LF,0
00001F74= 2C 44 31 0D 0A 00       1421  OutDataReg1 DC.B    ',D1',CR,LF,0
00001F7A= 2C 44 32 0D 0A 00       1422  OutDataReg2 DC.B    ',D2',CR,LF,0
00001F80= 2C 44 33 0D 0A 00       1423  OutDataReg3 DC.B    ',D3',CR,LF,0
00001F86= 2C 44 34 0D 0A 00       1424  OutDataReg4 DC.B    ',D4',CR,LF,0
00001F8C= 2C 44 35 0D 0A 00       1425  OutDataReg5 DC.B    ',D5',CR,LF,0
00001F92= 2C 44 36 0D 0A 00       1426  OutDataReg6 DC.B    ',D6',CR,LF,0
00001F98= 2C 44 37 0D 0A 00       1427  OutDataReg7 DC.B    ',D7',CR,LF,0
00001F9E                          1428  
00001F9E                          1429  *output for all address indirect registers (0-7)
00001F9E= 2C 28 41 30 29 0D ...   1430  OutAddrIndReg0  DC.B    ',(A0)',CR,LF,0
00001FA6= 2C 28 41 31 29 0D ...   1431  OutAddrIndReg1  DC.B    ',(A1)',CR,LF,0
00001FAE= 2C 28 41 32 29 0D ...   1432  OutAddrIndReg2  DC.B    ',(A2)',CR,LF,0
00001FB6= 2C 28 41 33 29 0D ...   1433  OutAddrIndReg3  DC.B    ',(A3)',CR,LF,0
00001FBE= 2C 28 41 34 29 0D ...   1434  OutAddrIndReg4  DC.B    ',(A4)',CR,LF,0
00001FC6= 2C 28 41 35 29 0D ...   1435  OutAddrIndReg5  DC.B    ',(A5)',CR,LF,0
00001FCE= 2C 28 41 36 29 0D ...   1436  OutAddrIndReg6  DC.B    ',(A6)',CR,LF,0
00001FD6= 2C 28 41 37 29 0D ...   1437  OutAddrIndReg7  DC.B    ',(A7)',CR,LF,0
00001FDE                          1438  
00001FDE                          1439  *output for all address indirect post registers (0-7)
00001FDE= 2C 28 41 30 29 2B ...   1440  OutAddrIndPoReg0    DC.B    ',(A0)+',CR,LF,0
00001FE7= 2C 28 41 31 29 2B ...   1441  OutAddrIndPoReg1    DC.B    ',(A1)+',CR,LF,0
00001FF0= 2C 28 41 32 29 2B ...   1442  OutAddrIndPoReg2    DC.B    ',(A2)+',CR,LF,0
00001FF9= 2C 28 41 33 29 2B ...   1443  OutAddrIndPoReg3    DC.B    ',(A3)+',CR,LF,0
00002002= 2C 28 41 34 29 2B ...   1444  OutAddrIndPoReg4    DC.B    ',(A4)+',CR,LF,0
0000200B= 2C 28 41 35 29 2B ...   1445  OutAddrIndPoReg5    DC.B    ',(A5)+',CR,LF,0
00002014= 2C 28 41 36 29 2B ...   1446  OutAddrIndPoReg6    DC.B    ',(A6)+',CR,LF,0
0000201D= 2C 28 41 37 29 2B ...   1447  OutAddrIndPoReg7    DC.B    ',(A7)+',CR,LF,0
00002026                          1448  
00002026                          1449  *output for all address indirect pre registers (0-7)
00002026= 2C 2D 28 41 30 29 ...   1450  OutAddrIndPrReg0    DC.B    ',-(A0)',CR,LF,0
0000202F= 2C 2D 28 41 31 29 ...   1451  OutAddrIndPrReg1    DC.B    ',-(A1)',CR,LF,0
00002038= 2C 2D 28 41 32 29 ...   1452  OutAddrIndPrReg2    DC.B    ',-(A2)',CR,LF,0
00002041= 2C 2D 28 41 33 29 ...   1453  OutAddrIndPrReg3    DC.B    ',-(A3)',CR,LF,0
0000204A= 2C 2D 28 41 34 29 ...   1454  OutAddrIndPrReg4    DC.B    ',-(A4)',CR,LF,0
00002053= 2C 2D 28 41 35 29 ...   1455  OutAddrIndPrReg5    DC.B    ',-(A5)',CR,LF,0
0000205C= 2C 2D 28 41 36 29 ...   1456  OutAddrIndPrReg6    DC.B    ',-(A6)',CR,LF,0
00002065= 2C 2D 28 41 37 29 ...   1457  OutAddrIndPrReg7    DC.B    ',-(A7)',CR,LF,0
0000206E                          1458  
0000206E                          1459  *output for a new line only
0000206E= 0D 0A 00                1460  NewLine DC.B    CR,LF,0
00002071                          1461  
00002071                          1462  *output for a '#$' and ',$' only
00002071= 23 24 00                1463  ShaBang DC.B    '#$',0
00002074= 2C 24 00                1464  Bang    DC.B    ',$',0
00002077                          1465  
00002077                          1466  *current output for error messages
00002077= 42 41 44 20 45 41 ...   1467  BADEAMSG    DC.B    'BAD EA, WHY?!',CR,LF,0
00002087= 42 41 44 20 4F 50 ...   1468  BADOPMSG    DC.B    'BAD OP CODE, WHY?!',CR,LF,0
0000209C= 49 6D 70 72 6F 70 ...   1469  INV_MSG     DC.B    'Improper command.',CR,LF,0
000020B0= 49 6E 76 61 6C 69 ...   1470  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
000020C9= 49 6E 76 61 6C 69 ...   1471  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
000020E0                          1472  
000020E0                          1473          
000020E0                          1474          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                1F40
ADDRABSOLUTEMODE    165C
ADDRDIRECTMODE      163E
ADDRINDIRECTMODE    163E
ADDRINDIRECTPOSTMODE  1648
ADDRINDIRECTPREMODE  1652
ADDRINDPOREG0       182C
ADDRINDPOREG1       183C
ADDRINDPOREG2       184C
ADDRINDPOREG3       185C
ADDRINDPOREG4       186C
ADDRINDPOREG5       187C
ADDRINDPOREG6       188C
ADDRINDPOREG7       189C
ADDRINDPRREG0       18EE
ADDRINDPRREG1       18FE
ADDRINDPRREG2       190E
ADDRINDPRREG3       191E
ADDRINDPRREG4       192E
ADDRINDPRREG5       193E
ADDRINDPRREG6       194E
ADDRINDPRREG7       195E
ADDRINDREG0         176A
ADDRINDREG1         177A
ADDRINDREG2         178A
ADDRINDREG3         179A
ADDRINDREG4         17AA
ADDRINDREG5         17BA
ADDRINDREG6         17CA
ADDRINDREG7         17DA
ANDI                1F45
ASCIIHEX            1164
ASCIIHEX1           1168
BADEACODE           19D6
BADEAMSG            2077
BADOPCODE           19C6
BADOPMSG            2087
BANG                2074
BCHG                1F4F
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         1368
BUCKET_0001         15AC
BUCKET_0010         15AC
BUCKET_0011         15AC
BUCKET_0100         15AC
BUCKET_0101         15AC
BUCKET_0110         15AC
BUCKET_1000         15AC
BUCKET_1001         15AC
BUCKET_1011         15AC
BUCKET_1100         15AC
BUCKET_1101         15AC
BUCKET_1110         15AC
BYTESIZE            1F59
BYTESIZEIMMEDIATE   15CE
CHECK               11DA
CHECKEND1           10EE
CHECKSTRT1          10D8
CHECK_LOWN          111C
CHECK_LOWY          110C
CHECK_UPN           1114
CHECK_UPY           1104
CHNG_SZB            120C
CHNG_SZL            11F2
CHNG_SZW            1226
CMD_HLD             1EB4
CMD_SZ              1ED2
CMPI                1F54
CONV_LOL            11C4
CONV_LOOP           1240
CONV_NUM            11B0
CONV_UPL            11BA
CR                  D
DATAREG0            16A8
DATAREG1            16B8
DATAREG2            16C8
DATAREG3            16D8
DATAREG4            16E8
DATAREG5            16F8
DATAREG6            1708
DATAREG7            1718
DATAREGMODE         1634
DONE                19E6
EA_ADDI             13F4
EA_ANDI             145E
EA_BCHG_D           1520
EA_BCHG_S           153C
EA_CMPI             1578
EA_EORI             14C8
ENDADDR             1F08
ENDADDRSZ           1F12
EORI                1F4A
EXITSUB             11D0
EXIT_CONV           12C6
GETENDADDR          1E62
GETSTRTADDR         1E30
GET_END             1086
GET_STRT            1038
GRAB_NEXT_OP        135C
HEXASCII            11D6
HEXASCIIREG         11EE
IMMEDIATEDATAMODE   1666
INVALID1            1124
INVENDMSG           20C9
INVSTRTMSG          20B0
INV_END1            1150
INV_MSG             209C
INV_STRT1           113C
IS_ADDI             13BE
IS_ANDI             1428
IS_BCHG_D           14FC
IS_BCHG_S           1526
IS_CMPI             1542
IS_EORI             1492
LF                  A
LONGSIZE            1F67
LONGSIZEABSOLUTE    19A4
LONGSIZEIMMEDIATE   1612
LOOP_1              1010
LOOP_B              1210
LOOP_L              11F6
LOOP_W              122A
MESSAGE             19F0
NEWLINE             206E
NUM_0               12D4
NUM_1               12DC
NUM_2               12E4
NUM_3               12EC
NUM_4               12F4
NUM_5               12FC
NUM_6               1304
NUM_7               130C
NUM_8               1314
NUM_9               131C
NUM_A               1324
NUM_B               132C
NUM_C               1334
NUM_D               133C
NUM_E               1344
NUM_F               134C
OUTADDRINDPOREG0    1FDE
OUTADDRINDPOREG1    1FE7
OUTADDRINDPOREG2    1FF0
OUTADDRINDPOREG3    1FF9
OUTADDRINDPOREG4    2002
OUTADDRINDPOREG5    200B
OUTADDRINDPOREG6    2014
OUTADDRINDPOREG7    201D
OUTADDRINDPRREG0    2026
OUTADDRINDPRREG1    202F
OUTADDRINDPRREG2    2038
OUTADDRINDPRREG3    2041
OUTADDRINDPRREG4    204A
OUTADDRINDPRREG5    2053
OUTADDRINDPRREG6    205C
OUTADDRINDPRREG7    2065
OUTADDRINDREG0      1F9E
OUTADDRINDREG1      1FA6
OUTADDRINDREG2      1FAE
OUTADDRINDREG3      1FB6
OUTADDRINDREG4      1FBE
OUTADDRINDREG5      1FC6
OUTADDRINDREG6      1FCE
OUTADDRINDREG7      1FD6
OUTDATAREG0         1F6E
OUTDATAREG1         1F74
OUTDATAREG2         1F7A
OUTDATAREG3         1F80
OUTDATAREG4         1F86
OUTDATAREG5         1F8C
OUTDATAREG6         1F92
OUTDATAREG7         1F98
PRINT_NUM           12CC
PRNT0               1F20
PRNT1               1F22
PRNT2               1F24
PRNT3               1F26
PRNT4               1F28
PRNT5               1F2A
PRNT6               1F2C
PRNT7               1F2E
PRNT8               1F30
PRNT9               1F32
PRNTA               1F34
PRNTB               1F36
PRNTC               1F38
PRNTD               1F3A
PRNTE               1F3C
PRNTF               1F3E
PROGEND             1F1C
PROGST              1F04
QUIT_MSG            1E92
SHABANG             2071
STACK               7000
STADDR              1EF0
STADDRSZ            1EFA
START               1000
STARTASSEM          1DFF
ST_ADDR             7FC6
ST_BAD              11CE
THEEND              19EA
WORDSIZE            1F60
WORDSIZEABSOLUTE    1982
WORDSIZEIMMEDIATE   15F0
WRAPPERADDRABSOLUTE  196E
WRAPPERADDRABSOLUTEEND  1980
WRAPPERADDRINDIRECT  1728
WRAPPERADDRINDIRECTEND  1768
WRAPPERADDRINDIRECTPOST  17EA
WRAPPERADDRINDIRECTPOSTEND  182A
WRAPPERADDRINDIRECTPRE  18AC
WRAPPERADDRINDIRECTPREEND  18EC
WRAPPERDATAREG      1666
WRAPPERDATAREGEND   16A6
WRAPPERSIZEIMMEDIATE  15B2
WRAPPERSIZEIMMEDIATEEND  15CC
