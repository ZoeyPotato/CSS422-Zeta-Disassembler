00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 2:02:26 AM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/11/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC6                  9  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00001000                            11  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 12              LEA stack,SP
00001004                            13  
00001004                            14  
00001004                            15  *-----------------------------------------------------------
00001004                            16  * Start of I/O
00001004                            17  *-----------------------------------------------------------            
00001004  43F9 00001A94             18              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100A  103C 000E                 19              MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000100E  4E4F                      20              TRAP    #15         *Displays Message
00001010                            21          
00001010  303C 0000                 22  loop_1      MOVE    #0,D0       
00001014  43F9 00001EA3             23              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101A  103C 000E                 24              MOVE.B  #14,D0
0000101E  4E4F                      25              TRAP    #15    
00001020  303C 0002                 26              MOVE    #2,D0
00001024  43F9 00001F58             27              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102A  4E4F                      28              TRAP    #15
0000102C  0C01 0001                 29              CMPI.B  #01,D1
00001030  6600 00F2                 30              BNE     INVALID1
00001034  6000 00CE                 31              BRA     CHECK_UPY
00001038                            32  *-----------------------------------------------------------
00001038                            33  *
00001038                            34  * I/O: Check Start Address
00001038                            35  *
00001038                            36  * Make sure that start address starts after allocated 
00001038                            37  * memory addresses. Else, it will print out a message 
00001038                            38  * saying that requested address is invalid & prompts the
00001038                            39  * user again for the starting address.
00001038                            40  *-----------------------------------------------------------
00001038  43F9 00001ED4             41  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
0000103E  103C 000E                 42              MOVE.B  #14,D0
00001042  4E4F                      43              TRAP    #15
00001044  43F9 00001F94             44              LEA     STADDR,A1   *Need to change where it can hold the start/end address
0000104A  3239 00001F9E             45              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001050  303C 0002                 46              MOVE    #2,D0           *Get start address
00001054  4E4F                      47              TRAP    #15
00001056  4EB9 000010D8             48              JSR     CHECKSTRT1
0000105C  4287                      49              CLR.L   D7
0000105E  4EB9 00001164             50              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
00001064  0C03 0001                 51              CMPI.B  #01,D3      *Check if there was a bad start
00001068  6700 00D2                 52              BEQ     INV_STRT1   *Prints error message if there was a bad start
0000106C  0C87 00007FC6             53              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001072  6D00 00C8                 54              BLT     INV_STRT1   *Asks for another start address if invalid
00001076  0C87 00FFFFFE             55              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
0000107C  6C00 00BE                 56              BGE     INV_STRT1
00001080  23C7 00001FA8             57              MOVE.L  D7,PROGST
00001086                            58  
00001086  43F9 00001F06             59  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
0000108C  103C 000E                 60              MOVE.B  #14,D0
00001090  4E4F                      61              TRAP    #15
00001092  43F9 00001FAC             62              LEA     ENDADDR,A1      *Buffer to hold end address
00001098  3239 00001FB6             63              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
0000109E  303C 0002                 64              MOVE    #2,D0
000010A2  4E4F                      65              TRAP    #15
000010A4  4EB9 000010EE             66              JSR     CHECKEND1
000010AA  4287                      67              CLR.L   D7
000010AC  4EB9 00001164             68              JSR     ASCIIHEX
000010B2  0C03 0001                 69              CMPI.B  #01,D3
000010B6  6700 0098                 70              BEQ     INV_END1
000010BA  0C87 00001FA8             71              CMPI.L  #PROGST,D7
000010C0  6D00 008E                 72              BLT     INV_END1
000010C4  0C87 00FFFFFF             73              CMPI.L  #$00FFFFFF,D7
000010CA  6C00 0084                 74              BGE     INV_END1
000010CE  2079 00001FA8             75              MOVEA.L PROGST,A0
000010D4  6000 0286                 76              BRA     GRAB_NEXT_OP            
000010D8                            77                          
000010D8  0C81 00000008             78  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010DE  6E00 005C                 79              BGT     INV_STRT1
000010E2  0C81 00000000             80              CMPI.L  #00,D1
000010E8  6300 0052                 81              BLS     INV_STRT1
000010EC  4E75                      82              RTS         
000010EE                            83              
000010EE  0C81 00000008             84  CHECKEND1   CMPI.L  #08,D1
000010F4  6E00 005A                 85              BGT     INV_END1
000010F8  0C81 00000000             86              CMPI.L  #00,D1
000010FE  6300 0050                 87              BLS     INV_END1
00001102  4E75                      88              RTS
00001104                            89  
00001104                            90  *-----------------------------------------------------------
00001104                            91  * I/O: Input check for Y, y, N, n
00001104                            92  *-----------------------------------------------------------
00001104  0C11 0059                 93  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001108  6700 FF2E                 94              BEQ     GET_STRT
0000110C                            95              
0000110C  0C11 0079                 96  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
00001110  6700 FF26                 97              BEQ     GET_STRT
00001114                            98              
00001114  0C11 004E                 99  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001118  6700 0970                100              BEQ     DONE
0000111C                           101              
0000111C  0C11 006E                102  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001120  6700 0968                103              BEQ     DONE
00001124                           104              
00001124  163C 0000                105  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001128  303C 0000                106              MOVE    #0,D0       *Prints invalid command msg if not found
0000112C  43F9 00002121            107              LEA     INV_MSG,A1
00001132  303C 000E                108              MOVE    #14,D0
00001136  4E4F                     109              TRAP    #15
00001138  6000 FED6                110              BRA     loop_1
0000113C                           111              
0000113C  43F9 00002135            112  INV_STRT1   LEA     INVSTRTMSG,A1
00001142  103C 000E                113              MOVE.B  #14,D0
00001146  4E4F                     114              TRAP    #15
00001148  163C 0000                115              MOVE.B  #00,D3      *Reset flag
0000114C  6000 FEEA                116              BRA     GET_STRT        
00001150                           117              
00001150  43F9 0000214E            118  INV_END1    LEA     INVENDMSG,A1
00001156  103C 000E                119              MOVE.B  #14,D0
0000115A  4E4F                     120              TRAP    #15
0000115C  163C 0000                121              MOVE.B  #00,D3      *Reset flag
00001160  6000 FF24                122              BRA     GET_END
00001164                           123              
00001164                           124  *-----------------------------------------------------------
00001164                           125  * ASCII to Hex converter
00001164                           126  *
00001164                           127  * Checks and converts the ASCII value to the hex equivalent
00001164                           128  *-----------------------------------------------------------
00001164  48E7 6000                129  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001168  0C01 0000                130  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000116C  6700 0062                131              BEQ     exitSub     *Exit subroutine 
00001170  5301                     132              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001172  E99F                     133              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001174  1419                     134              MOVE.B  (A1)+,D2    *Takes the first char
00001176  0C02 0024                135              CMPI.B  #$24,D2     *See if the first char is $
0000117A  67EC                     136              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000117C  0C02 0030                137              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001180  6D00 004C                138              BLT     st_bad      *Put error message
00001184  0C02 0039                139              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001188  6F00 0026                140              BLE     CONV_NUM    *Convert to number, if so
0000118C  0C02 0041                141              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
00001190  6D00 003C                142              BLT     st_bad      *Put error message
00001194  0C02 0046                143              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
00001198  6F00 0020                144              BLE     CONV_UpL    *Convert to hex
0000119C  0C02 0061                145              CMPI.B  #$61,D2     *Checks for non-valid chars
000011A0  6D00 002C                146              BLT     st_bad
000011A4  0C02 0066                147              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011A8  6F00 001A                148              BLE     CONV_LoL    
000011AC  6E00 0020                149              BGT     st_bad      *Puts error message for anything greater than f value
000011B0                           150              
000011B0  0402 0030                151  CONV_NUM    SUBI.B  #$30,D2
000011B4  8E02                     152              OR.B    D2,D7
000011B6  4EF8 1168                153              JMP     ASCIIHEX1
000011BA  0402 0037                154  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011BE  8E02                     155              OR.B    D2,D7
000011C0  4EF8 1168                156              JMP     ASCIIHEX1
000011C4  0402 0057                157  CONV_LoL    SUBI.B  #$57,D2
000011C8  8E02                     158              OR.B    D2,D7
000011CA  4EF8 1168                159              JMP     ASCIIHEX1   
000011CE                           160  
000011CE  5203                     161  st_bad      ADDI.B  #01,D3
000011D0  4CDF 0006                162  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011D4  4E75                     163              RTS
000011D6                           164              
000011D6                           165  *-----------------------------------------------------------
000011D6                           166  * Hex to ASCII converter
000011D6                           167  *-----------------------------------------------------------
000011D6  48E7 4C00                168  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011DA  0C01 0000                169  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011DE  6700 002C                170              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011E2  B27C 0001                171              CMP.W   #01,D1          
000011E6  6700 003E                172              BEQ     CHNG_SZW
000011EA  6000 0006                173              BRA     CHNG_SZL        
000011EE                           174  
000011EE  48E7 4C00                175  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011F2  123C 0008                176  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
000011F6  0C01 0000                177  LOOP_L      CMPI.B  #00,D1
000011FA  6700 00CA                178              BEQ     EXIT_CONV
000011FE  5301                     179              SUBI.B  #01,D1
00001200  E99C                     180              ROL.L   #4,D4           * Shift it for next bit
00001202  2A04                     181              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001204  4EB9 00001240            182              JSR     CONV_LOOP
0000120A  60EA                     183              BRA     LOOP_L      
0000120C                           184  
0000120C  123C 0002                185  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001210  0C01 0000                186  LOOP_B      CMPI.B  #00,D1
00001214  6700 00B0                187              BEQ     EXIT_CONV
00001218  5301                     188              SUBI.B  #01,D1
0000121A  E91C                     189              ROL.B   #4,D4           * Shift it for next bit
0000121C  2A04                     190              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000121E  4EB9 00001240            191              JSR     CONV_LOOP
00001224  60EA                     192              BRA     LOOP_B
00001226                           193              
00001226  123C 0004                194  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000122A  0C01 0000                195  LOOP_W      CMPI.B  #00,D1
0000122E  6700 0096                196              BEQ     EXIT_CONV
00001232  5301                     197              SUBI.B  #01,D1
00001234  E95C                     198              ROL.W   #4,D4           * Shift it for next bit
00001236  2A04                     199              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001238  4EB9 00001240            200              JSR     CONV_LOOP
0000123E  60EA                     201              BRA     LOOP_W
00001240                           202  
00001240  0285 0000000F            203  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001246  0C05 0000                204              CMPI.B  #$0,D5
0000124A  6700 0088                205              BEQ     NUM_0
0000124E  0C05 0001                206              CMPI.B  #$1,D5
00001252  6700 0088                207              BEQ     NUM_1
00001256  0C05 0002                208              CMPI.B  #$2,D5
0000125A  6700 0088                209              BEQ     NUM_2
0000125E  0C05 0003                210              CMPI.B  #$3,D5
00001262  6700 0088                211              BEQ     NUM_3
00001266  0C05 0004                212              CMPI.B  #$4,D5
0000126A  6700 0088                213              BEQ     NUM_4
0000126E  0C05 0005                214              CMPI.B  #$5,D5
00001272  6700 0088                215              BEQ     NUM_5
00001276  0C05 0006                216              CMPI.B  #$6,D5
0000127A  6700 0088                217              BEQ     NUM_6
0000127E  0C05 0007                218              CMPI.B  #$7,D5
00001282  6700 0088                219              BEQ     NUM_7
00001286  0C05 0008                220              CMPI.B  #$8,D5
0000128A  6700 0088                221              BEQ     NUM_8
0000128E  0C05 0009                222              CMPI.B  #$9,D5
00001292  6700 0088                223              BEQ     NUM_9
00001296  0C05 000A                224              CMPI.B  #$A,D5
0000129A  6700 0088                225              BEQ     NUM_A
0000129E  0C05 000B                226              CMPI.B  #$B,D5
000012A2  6700 0088                227              BEQ     NUM_B
000012A6  0C05 000C                228              CMPI.B  #$C,D5
000012AA  6700 0088                229              BEQ     NUM_C
000012AE  0C05 000D                230              CMPI.B  #$D,D5
000012B2  6700 0088                231              BEQ     NUM_D
000012B6  0C05 000E                232              CMPI.B  #$E,D5
000012BA  6700 0088                233              BEQ     NUM_E
000012BE  0C05 000F                234              CMPI.B  #$F,D5
000012C2  6700 0088                235              BEQ     NUM_F
000012C6                           236              
000012C6  4CDF 0032                237  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012CA  4E75                     238              RTS
000012CC                           239              
000012CC  303C 000E                240  PRINT_NUM   MOVE    #14,D0
000012D0  4E4F                     241              TRAP    #15
000012D2  4E75                     242              RTS
000012D4  43F9 00001FC4            243  NUM_0       LEA     PRNT0,A1
000012DA  60F0                     244              BRA     PRINT_NUM
000012DC  43F9 00001FC6            245  NUM_1       LEA     PRNT1,A1
000012E2  60E8                     246              BRA     PRINT_NUM
000012E4  43F9 00001FC8            247  NUM_2       LEA     PRNT2,A1
000012EA  60E0                     248              BRA     PRINT_NUM
000012EC  43F9 00001FCA            249  NUM_3       LEA     PRNT3,A1
000012F2  60D8                     250              BRA     PRINT_NUM
000012F4  43F9 00001FCC            251  NUM_4       LEA     PRNT4,A1
000012FA  60D0                     252              BRA     PRINT_NUM
000012FC  43F9 00001FCE            253  NUM_5       LEA     PRNT5,A1
00001302  60C8                     254              BRA     PRINT_NUM
00001304  43F9 00001FD0            255  NUM_6       LEA     PRNT6,A1
0000130A  60C0                     256              BRA     PRINT_NUM
0000130C  43F9 00001FD2            257  NUM_7       LEA     PRNT7,A1
00001312  60B8                     258              BRA     PRINT_NUM
00001314  43F9 00001FD4            259  NUM_8       LEA     PRNT8,A1
0000131A  60B0                     260              BRA     PRINT_NUM
0000131C  43F9 00001FD6            261  NUM_9       LEA     PRNT9,A1
00001322  60A8                     262              BRA     PRINT_NUM
00001324  43F9 00001FD8            263  NUM_A       LEA     PRNTA,A1
0000132A  60A0                     264              BRA     PRINT_NUM
0000132C  43F9 00001FDA            265  NUM_B       LEA     PRNTB,A1
00001332  6098                     266              BRA     PRINT_NUM
00001334  43F9 00001FDC            267  NUM_C       LEA     PRNTC,A1
0000133A  6090                     268              BRA     PRINT_NUM
0000133C  43F9 00001FDE            269  NUM_D       LEA     PRNTD,A1
00001342  6088                     270              BRA     PRINT_NUM
00001344  43F9 00001FE0            271  NUM_E       LEA     PRNTE,A1
0000134A  6080                     272              BRA     PRINT_NUM
0000134C  43F9 00001FE2            273  NUM_F       LEA     PRNTF,A1
00001352  6000 FF78                274              BRA     PRINT_NUM
00001356                           275  
00001356                           276  *-----------------------------------------------------------        
00001356                           277  * Start of Disassembler
00001356                           278  *-----------------------------------------------------------
00001356                           279          *FOR DEBUGGING ONLY!!!
00001356  207C 00007FC6            280          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000135C                           281          
0000135C                           282  GRAB_NEXT_OP
0000135C                           283          *Need a check here to see if A0 == end of test address
0000135C                           284          *if so, go to end.
0000135C                           285          
0000135C                           286          
0000135C                           287          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
0000135C                           288          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
0000135C                           289          *data that may be associated with the instruction.
0000135C                           290          *Post increment addr, A0 will point to the start of next instruction or will 
0000135C                           291          *point to the start of any immed/abso data with this current instruction
0000135C  4280                     292          CLR.L   D0
0000135E  3018                     293          MOVE.W  (A0)+,D0
00001360                           294          *Copy the word data we just moved into D0 into D7. We are copying this data
00001360                           295          *So we always have a copy of the WHOLE instruction somewhere
00001360  4287                     296          CLR.L   D7
00001362  3E00                     297          MOVE.W  D0,D7
00001364                           298          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
00001364                           299          *four bits of the instruction. Once we have just the first four bits, we can
00001364                           300          *begin to see which 'bucket'/category this instruction falls into. 
00001364  E048                     301          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
00001366  E848                     302          LSR.W   #$04,D0
00001368                           303          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
00001368                           304          *list of buckets until we find which one this instruction falls into.
00001368                           305  
00001368                           306  
00001368                           307  *-----------------------------------------------------------        
00001368                           308  * Bucket 0000:
00001368                           309  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
00001368                           310  *                   BCHG(dynamic) | BCHG (static) | CMPI----
00001368                           311  *-----------------------------------------------------------
00001368                           312  BUCKET_0000
00001368  =00000000                313  BUCKET0000_BITS EQU $0
00001368  4281                     314          CLR.L   D1
0000136A                           315          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000136A  123C 0000                316          MOVE.B  #BUCKET0000_BITS,D1
0000136E                           317          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
0000136E                           318          *If equal, continue decoding. If not, branch to next bucket.
0000136E  B200                     319          CMP.B   D0,D1
00001370  6600 02C6                320          BNE     BUCKET_0001
00001374                           321  
00001374                           322          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001374                           323          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001374  3007                     324          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001376  0800 0008                325          BTST.L  #$08,D0
0000137A  6600 01A4                326          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
0000137E                           327          
0000137E                           328          *Now we can check bits 11-8 in the instruction and branch to different op-codes
0000137E                           329          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
0000137E  E048                     330          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001380  0880 0004                331          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001384  0880 0005                332          BCLR.L  #$05,D0
00001388  0880 0006                333          BCLR.L  #$06,D0
0000138C  0880 0007                334          BCLR.L  #$07,D0
00001390                           335          
00001390                           336          *Perform compares with these 4 bits to see which specific instruction it is.
00001390  B03C 0006                337          CMP.B   #$06,D0 *Is this an ADDI?
00001394  6700 0028                338          BEQ     IS_ADDI
00001398  B03C 0002                339          CMP.B   #$02,D0 *Is this an ANDI?
0000139C  6700 0096                340          BEQ     IS_ANDI
000013A0  B03C 000A                341          CMP.B   #$0A,D0 *Is this an EORI?
000013A4  6700 0104                342          BEQ     IS_EORI
000013A8  B03C 0008                343          CMP.B   #$08,D0 *Is this a BCHG(static)?
000013AC  6700 01F8                344          BEQ     IS_BCHG_S
000013B0  B03C 000C                345          CMP.B   #$0C,D0 *Is this a CMPI?
000013B4  6700 020C                346          BEQ     IS_CMPI
000013B8                           347          
000013B8                           348          *If we get through all of the compares without finding the specific instruction,
000013B8                           349          *then this instruction is either not in our list of OP CODES to decode, or is an
000013B8                           350          *invalid instruction/syntax.
000013B8  4EF9 00001A6A            351          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000013BE                           352          
000013BE                           353          
000013BE                           354  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
000013BE                           355  IS_ADDI
000013BE                           356          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000013BE                           357          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000013BE  4281                     358          CLR.L   D1
000013C0  3207                     359          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000013C2  C27C 00C0                360          AND.W   #$00C0,D1   *Mask out everything but the size bits
000013C6  EC09                     361          LSR.B   #$06,D1     *Shift the size bits into LSB
000013C8                           362          
000013C8  B23C 0003                363          CMP.B   #$03,D1     *Compare the size bits to $3
000013CC  6700 069C                364          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000013D0                           365          
000013D0                           366          *Output 'ADDI' to console...
000013D0  43F9 00001FE4            367          LEA     ADDI,A1     *Loads ADDI into address register A1
000013D6  103C 000E                368          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000013DA  4E4F                     369          TRAP    #15         *Displays Message
000013DC                           370          
000013DC                           371          
000013DC                           372          *Should have a valid ADDI op code. Set data up for EA.
000013DC                           373          
000013DC                           374          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000013DC  4282                     375          CLR.L   D2
000013DE  3407                     376          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000013E0  C47C 003C                377          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000013E4  E60A                     378          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000013E6                           379                  
000013E6                           380          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000013E6  4283                     381          CLR.L   D3
000013E8  3607                     382          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000013EA  C67C 0007                383          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000013EE                           384          
000013EE  4EF9 000013F4            385          JMP     EA_ADDI
000013F4                           386  
000013F4                           387  EA_ADDI
000013F4                           388          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
000013F4                           389          *and D3 holds the EA register.
000013F4                           390          
000013F4                           391          *Determine how much data to read in, depending on the size of the operation
000013F4                           392          *output the size of the operation and the immediate data to console
000013F4  4EB9 0000163E            393          JSR     WrapperSizeImmediate
000013FA                           394          
000013FA                           395          *manually output a comma here...
000013FA  43F9 000020F2            396          LEA     Comma,A1        *Loads Comma into address register A1
00001400  103C 000E                397          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001404  4E4F                     398          TRAP    #15             *Displays Message        
00001406                           399          
00001406                           400          *Determine which EA mode and thus Register/Mem Address this instruction used
00001406  B43C 0000                401          CMP.B   #$00,D2
0000140A  6700 02B4                402          BEQ     DataRegMode *If EA mode is a data register, output that
0000140E                           403          
0000140E  B43C 0002                404          CMP.B   #$02,D2
00001412  6700 02BC                405          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001416                           406          
00001416  B43C 0003                407          CMP.B   #$03,D2
0000141A  6700 02C4                408          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000141E                           409          
0000141E  B43C 0004                410          CMP.B   #$04,D2
00001422  6700 02C6                411          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001426                           412          
00001426  B43C 0007                413          CMP.B   #$07,D2
0000142A  6700 02C8                414          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000142E                           415          
0000142E                           416          *If the ea mode isn't equal to any of these, it is an invalid EA
0000142E  4EF9 00001A7A            417          JMP     BADEACODE                               
00001434                           418          
00001434                           419  
00001434                           420  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
00001434                           421  IS_ANDI
00001434                           422          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001434                           423          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001434  4281                     424          CLR.L   D1
00001436  3207                     425          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001438  C27C 00C0                426          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000143C  EC09                     427          LSR.B   #$06,D1     *Shift the size bits into LSB
0000143E                           428          
0000143E  B23C 0003                429          CMP.B   #$03,D1     *Compare the size bits to $3
00001442  6700 0626                430          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001446                           431          
00001446                           432          *Output 'ANDI' to console...
00001446  43F9 00001FE9            433          LEA     ANDI,A1     *Loads ANDI into address register A1
0000144C  103C 000E                434          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001450  4E4F                     435          TRAP    #15         *Displays Message
00001452                           436          
00001452                           437          
00001452                           438          *Should have a valid ANDI op code. Set data up for EA.
00001452                           439          
00001452                           440          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001452  4282                     441          CLR.L   D2
00001454  3407                     442          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001456  C47C 003C                443          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
0000145A  E60A                     444          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000145C                           445                  
0000145C                           446          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000145C  4283                     447          CLR.L   D3
0000145E  3607                     448          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001460  C67C 0007                449          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001464                           450          
00001464  4EF9 0000146A            451          JMP     EA_ANDI
0000146A                           452  
0000146A                           453  EA_ANDI
0000146A                           454          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
0000146A                           455          *and D3 holds the EA register.
0000146A                           456          
0000146A                           457          *Determine how much data to read in, depending on the size of the operation
0000146A                           458          *output the size of the operation and the immediate data to console
0000146A  4EB9 0000163E            459          JSR     WrapperSizeImmediate
00001470                           460          
00001470                           461          *manually output a comma here...
00001470  43F9 000020F2            462          LEA     Comma,A1        *Loads Comma into address register A1
00001476  103C 000E                463          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000147A  4E4F                     464          TRAP    #15             *Displays Message        
0000147C                           465          
0000147C                           466          *Determine which EA mode and thus Register/Mem Address this instruction used
0000147C  B43C 0000                467          CMP.B   #$00,D2
00001480  6700 023E                468          BEQ     DataRegMode *If EA mode is a data register, output that
00001484                           469          
00001484  B43C 0002                470          CMP.B   #$02,D2
00001488  6700 0246                471          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000148C                           472          
0000148C  B43C 0003                473          CMP.B   #$03,D2
00001490  6700 024E                474          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001494                           475          
00001494  B43C 0004                476          CMP.B   #$04,D2
00001498  6700 0250                477          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000149C                           478          
0000149C  B43C 0007                479          CMP.B   #$07,D2
000014A0  6700 0252                480          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014A4                           481          
000014A4                           482          *If the ea mode isn't equal to any of these, it is an invalid EA
000014A4  4EF9 00001A7A            483          JMP     BADEACODE
000014AA                           484          
000014AA                           485  
000014AA                           486  *Now we know this instruction is exactly EORI, lets set everything up for EA.
000014AA                           487  IS_EORI
000014AA                           488          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014AA                           489          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014AA  4281                     490          CLR.L   D1
000014AC  3207                     491          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014AE  C27C 00C0                492          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014B2  EC09                     493          LSR.B   #$06,D1     *Shift the size bits into LSB
000014B4                           494          
000014B4  B23C 0003                495          CMP.B   #$03,D1     *Compare the size bits to $3
000014B8  6700 05B0                496          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014BC                           497          
000014BC                           498          *Output 'EORI' to console...
000014BC  43F9 00001FEE            499          LEA     EORI,A1     *Loads EORI into address register A1
000014C2  103C 000E                500          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014C6  4E4F                     501          TRAP    #15         *Displays Message
000014C8                           502          
000014C8                           503          
000014C8                           504          *Should have a valid EORI op code. Set data up for EA.
000014C8                           505          
000014C8                           506          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014C8  4282                     507          CLR.L   D2
000014CA  3407                     508          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014CC  C47C 003C                509          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000014D0  E60A                     510          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000014D2                           511                  
000014D2                           512          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000014D2  4283                     513          CLR.L   D3
000014D4  3607                     514          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000014D6  C67C 0007                515          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000014DA                           516          
000014DA  4EF9 000014E0            517          JMP     EA_EORI
000014E0                           518  
000014E0                           519  EA_EORI
000014E0                           520          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
000014E0                           521          *and D3 holds the EA register.
000014E0                           522          
000014E0                           523          *Determine how much data to read in, depending on the size of the operation
000014E0                           524          *output the size of the operation and the immediate data to console
000014E0  4EB9 0000163E            525          JSR     WrapperSizeImmediate
000014E6                           526          
000014E6                           527          *manually output a comma here...
000014E6  43F9 000020F2            528          LEA     Comma,A1        *Loads Comma into address register A1
000014EC  103C 000E                529          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014F0  4E4F                     530          TRAP    #15             *Displays Message        
000014F2                           531          
000014F2                           532          *Determine which EA mode and thus Register/Mem Address this instruction used
000014F2  B43C 0000                533          CMP.B   #$00,D2
000014F6  6700 01C8                534          BEQ     DataRegMode *If EA mode is a data register, output that
000014FA                           535          
000014FA  B43C 0002                536          CMP.B   #$02,D2
000014FE  6700 01D0                537          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001502                           538          
00001502  B43C 0003                539          CMP.B   #$03,D2
00001506  6700 01D8                540          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000150A                           541          
0000150A  B43C 0004                542          CMP.B   #$04,D2
0000150E  6700 01DA                543          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001512                           544          
00001512  B43C 0007                545          CMP.B   #$07,D2
00001516  6700 01DC                546          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000151A                           547          
0000151A                           548          *If the ea mode isn't equal to any of these, it is an invalid EA
0000151A  4EF9 00001A7A            549          JMP     BADEACODE
00001520                           550  
00001520                           551  
00001520                           552  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
00001520                           553  * everything up for EA if is a legit instruction.
00001520                           554  IS_BCHG_D
00001520                           555          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
00001520                           556          *invalid, branch to BADOPCODE
00001520  3007                     557          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
00001522  0800 0007                558          BTST.L  #$07,D0
00001526  6600 0542                559          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
0000152A  0800 0006                560          BTST.L  #$06,D0
0000152E  6700 053A                561          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
00001532                           562          
00001532                           563          *Output 'BCHG' to console...
00001532  43F9 00001FF3            564          LEA     BCHG,A1         *Loads BCHG into address register A1
00001538  103C 000E                565          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000153C  4E4F                     566          TRAP    #15             *Displays Message
0000153E                           567                  
0000153E                           568                  
0000153E                           569          *Should have a valid BCHG op code. Set data up for EA.
0000153E                           570  
0000153E                           571          *Set D1 to the EA source register located in bits 11-9 of the instruction
0000153E  4281                     572          CLR.L   D1
00001540  3207                     573          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001542  C27C 0E00                574          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
00001546  E009                     575          LSR.B   #$08,D1     *Shift the EA source register bits into LSB
00001548  E209                     576          LSR.B   #$01,D1
0000154A                           577  
0000154A                           578          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000154A  4282                     579          CLR.L   D2
0000154C  3407                     580          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000154E  C47C 003C                581          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001552  E60A                     582          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001554                           583                  
00001554                           584          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001554  4283                     585          CLR.L   D3
00001556  3607                     586          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001558  C67C 0007                587          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000155C                           588  
0000155C  4EF9 00001562            589          JMP     EA_BCHG_D
00001562                           590  
00001562                           591  EA_BCHG_D
00001562                           592          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001562                           593          *D2 holds the EA mode, and D3 holds the EA register.
00001562                           594          
00001562                           595          *output the source register to console, flag D6 with a 1 so we come back...
00001562  1C3C 0001                596          MOVE.B  #$01,D6
00001566  4EB9 000016C0            597          JSR     DataRegMode
0000156C                           598          
0000156C                           599          *manually output a comma here...
0000156C  43F9 000020F2            600          LEA     Comma,A1        *Loads Comma into address register A1
00001572  103C 000E                601          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001576  4E4F                     602          TRAP    #15             *Displays Message
00001578                           603          
00001578                           604          *Determine which EA mode and thus Register/Mem Address this instruction used
00001578  B43C 0000                605          CMP.B   #$00,D2
0000157C  6700 0142                606          BEQ     DataRegMode *If EA mode is a data register, output that
00001580                           607          
00001580  B43C 0002                608          CMP.B   #$02,D2
00001584  6700 014A                609          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001588                           610          
00001588  B43C 0003                611          CMP.B   #$03,D2
0000158C  6700 0152                612          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001590                           613          
00001590  B43C 0004                614          CMP.B   #$04,D2
00001594  6700 0154                615          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001598                           616          
00001598  B43C 0007                617          CMP.B   #$07,D2
0000159C  6700 0156                618          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015A0                           619          
000015A0                           620          *If the ea mode isn't equal to any of these, it is an invalid EA
000015A0  4EF9 00001A7A            621          JMP     BADEACODE
000015A6                           622  
000015A6                           623  
000015A6                           624  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
000015A6                           625  IS_BCHG_S
000015A6                           626          *TODO:Verify bits
000015A6                           627  
000015A6                           628          *Output 'BCHG' to console...
000015A6  43F9 00001FF3            629          LEA     BCHG,A1 *Loads FNDBCHG_S into address register A1
000015AC  103C 000E                630          MOVE.B  #14,D0  *Moves the number 14 into data register D0
000015B0  4E4F                     631          TRAP    #15     *Displays Message
000015B2                           632          
000015B2                           633          *Should have a valid BCHG_S op code. Set data up for EA.
000015B2                           634          *TODO:
000015B2  163C 000E                635          MOVE.B  #14,D3
000015B6  4EF9 000015BC            636          JMP     EA_BCHG_S
000015BC                           637  
000015BC                           638  EA_BCHG_S
000015BC  4EF9 00001A8E            639          JMP     THEEND  *For now just end
000015C2                           640  
000015C2                           641  
000015C2                           642  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000015C2                           643  IS_CMPI
000015C2                           644          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000015C2                           645          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000015C2  4281                     646          CLR.L   D1
000015C4  3207                     647          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015C6  C27C 00C0                648          AND.W   #$00C0,D1   *Mask out everything but the size bits
000015CA  EC09                     649          LSR.B   #$06,D1     *Shift the size bits into LSB
000015CC                           650          
000015CC  B23C 0003                651          CMP.B   #$03,D1     *Compare the size bits to $3
000015D0  6700 0498                652          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000015D4                           653          
000015D4                           654          *Output 'CMPI' to console...
000015D4  43F9 00001FF8            655          LEA     CMPI,A1     *Loads CMPI into address register A1
000015DA  103C 000E                656          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000015DE  4E4F                     657          TRAP    #15         *Displays Message
000015E0                           658          
000015E0                           659          
000015E0                           660          *Should have a valid CMPI op code. Set data up for EA.
000015E0                           661          
000015E0                           662          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015E0  4282                     663          CLR.L   D2
000015E2  3407                     664          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000015E4  C47C 003C                665          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000015E8  E60A                     666          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000015EA                           667                  
000015EA                           668          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000015EA  4283                     669          CLR.L   D3
000015EC  3607                     670          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000015EE  C67C 0007                671          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000015F2                           672          
000015F2  4EF9 000015F8            673          JMP     EA_CMPI
000015F8                           674  
000015F8                           675  EA_CMPI
000015F8                           676          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
000015F8                           677          *and D3 holds the EA register.
000015F8                           678          
000015F8                           679          *Determine how much data to read in, depending on the size of the operation
000015F8                           680          *output the size of the operation and the immediate data to console
000015F8  4EB9 0000163E            681          JSR     WrapperSizeImmediate
000015FE                           682          
000015FE                           683          *manually output a comma here...
000015FE  43F9 000020F2            684          LEA     Comma,A1        *Loads Comma into address register A1
00001604  103C 000E                685          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001608  4E4F                     686          TRAP    #15             *Displays Message
0000160A                           687          
0000160A                           688          *Determine which EA mode and thus Register/Mem Address this instruction used
0000160A  B43C 0000                689          CMP.B   #$00,D2
0000160E  6700 00B0                690          BEQ     DataRegMode *If EA mode is a data register, output that
00001612                           691          
00001612  B43C 0002                692          CMP.B   #$02,D2
00001616  6700 00B8                693          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000161A                           694          
0000161A  B43C 0003                695          CMP.B   #$03,D2
0000161E  6700 00C0                696          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001622                           697          
00001622  B43C 0004                698          CMP.B   #$04,D2
00001626  6700 00C2                699          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000162A                           700          
0000162A  B43C 0007                701          CMP.B   #$07,D2
0000162E  6700 00C4                702          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001632                           703          
00001632                           704          *If the ea mode isn't equal to any of these, it is an invalid EA
00001632  4EF9 00001A7A            705          JMP     BADEACODE
00001638                           706  
00001638                           707          
00001638                           708  *STARTS WITH 0001, MOVE.B-----------------------------------
00001638                           709  BUCKET_0001
00001638  =00000001                710  BUCKET0001_BITS EQU $1
00001638                           711          
00001638                           712          *some code...
00001638                           713  
00001638                           714  
00001638                           715  *STARTS WITH 0010, MOVE.L-----------------------------------
00001638                           716  BUCKET_0010
00001638  =00000002                717  BUCKET0010_BITS EQU $2
00001638                           718  
00001638                           719          *some code...
00001638                           720  
00001638                           721  
00001638                           722  *STARTS WITH 0011, MOVE.W-----------------------------------
00001638                           723  BUCKET_0011
00001638  =00000003                724  BUCKET0011_BITS EQU $3
00001638                           725  
00001638                           726          *some code...
00001638                           727  
00001638                           728  
00001638                           729  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
00001638                           730  BUCKET_0100
00001638  =00000004                731  BUCKET0100_BITS EQU $4
00001638                           732  
00001638                           733          *some code...
00001638                           734  
00001638                           735  
00001638                           736  *STARTS WITH 0101, SUBQ-------------------------------------
00001638                           737  BUCKET_0101
00001638  =00000005                738  BUCKET0101_BITS EQU $5
00001638                           739  
00001638                           740          *some code...
00001638                           741  
00001638                           742  
00001638                           743  *STARTS WITH 0110, BCC--------------------------------------
00001638                           744  BUCKET_0110
00001638  =00000006                745  BUCKET0110_BITS EQU $6
00001638                           746  
00001638                           747          *some code...
00001638                           748  
00001638                           749  
00001638                           750  *STARTS WITH 1000, DIVU-------------------------------------
00001638                           751  BUCKET_1000
00001638  =00000008                752  BUCKET1000_BITS EQU $8
00001638                           753  
00001638                           754          *some code...
00001638                           755  
00001638                           756  
00001638                           757  *STARTS WITH 1001, SUBA-------------------------------------
00001638                           758  BUCKET_1001
00001638  =00000009                759  BUCKET1001_BITS EQU $9
00001638                           760  
00001638                           761          *some code...
00001638                           762  
00001638                           763  
00001638                           764  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
00001638                           765  BUCKET_1011
00001638  =0000000B                766  BUCKET1011_BITS EQU $B
00001638                           767  
00001638                           768          *some code...
00001638                           769  
00001638                           770  
00001638                           771  *STARTS WITH 1100, MULS(W) | AND----------------------------
00001638                           772  BUCKET_1100
00001638  =0000000C                773  BUCKET1100_BITS EQU $C
00001638                           774  
00001638                           775          *some code...
00001638                           776  
00001638                           777  
00001638                           778  *STARTS WITH 1101, ADD | ADDA-------------------------------
00001638                           779  BUCKET_1101
00001638  =0000000D                780  BUCKET1101_BITS EQU $D
00001638                           781  
00001638                           782          *some code...
00001638                           783  
00001638                           784  
00001638                           785  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
00001638                           786  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
00001638                           787  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
00001638                           788  BUCKET_1110
00001638  =0000000E                789  BUCKET1110_BITS EQU $E     
00001638                           790  
00001638                           791          *some code...
00001638                           792  
00001638                           793  
00001638                           794  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
00001638                           795  *for this disassembler, jump to BADOPCODE and let I/O take care of it
00001638  4EF9 00001A6A            796          JMP     BADOPCODE  
0000163E                           797          
0000163E                           798  
0000163E                           799  *-----------------------------------------------------------        
0000163E                           800  * EA operation size decoding functionality
0000163E                           801  *-----------------------------------------------------------   
0000163E                           802  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
0000163E                           803  WrapperSizeImmediate
0000163E  4284                     804          CLR.L   D4
00001640                           805          *Depending on the EA Register, choose which size to decode
00001640  B23C 0000                806          CMP.B   #$00,D1
00001644  6700 0014                807          BEQ     ByteSizeImmediate
00001648                           808          
00001648  B23C 0001                809          CMP.B   #$01,D1
0000164C  6700 002E                810          BEQ     WordSizeImmediate
00001650                           811  
00001650  B23C 0002                812          CMP.B   #$02,D1
00001654  6700 0048                813          BEQ     LongSizeImmediate
00001658                           814          
00001658                           815  *Used to get back to what we were doing, after dealing with the specific size
00001658                           816  WrapperSizeImmediateEnd
00001658  4E75                     817          RTS
0000165A                           818          
0000165A                           819  ByteSizeImmediate
0000165A  3818                     820          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
0000165C                           821          
0000165C                           822          *Output '.B' to console...
0000165C  43F9 00001FFD            823          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001662  103C 000E                824          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001666  4E4F                     825          TRAP    #15         *Displays Message
00001668                           826          
00001668                           827          *Output '#$' just before the immediate data
00001668  43F9 000020F7            828          LEA     ShaBang,A1
0000166E  103C 000E                829          MOVE.B  #14,D0
00001672  4E4F                     830          TRAP    #15  
00001674                           831          
00001674                           832          *output the immediate data to console with the hex-ascii converter
00001674  4EB8 11D6                833          JSR     HEXASCII
00001678                           834                  
00001678  4EF8 1658                835          JMP     WrapperSizeImmediateEnd
0000167C                           836                  
0000167C                           837  WordSizeImmediate
0000167C  3818                     838          MOVE.W  (A0)+,D4    *read in next word, data is that word
0000167E                           839          
0000167E                           840          *Output '.W' to console...
0000167E  43F9 00002004            841          LEA     WordSize,A1 *Loads WordSize into address register A1
00001684  103C 000E                842          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001688  4E4F                     843          TRAP    #15         *Displays Message
0000168A                           844          
0000168A                           845          *Output '#$' just before the immediate data
0000168A  43F9 000020F7            846          LEA     ShaBang,A1
00001690  103C 000E                847          MOVE.B  #14,D0
00001694  4E4F                     848          TRAP    #15  
00001696                           849          
00001696                           850          *output the immediate data to console with the hex-ascii converter
00001696  4EB8 11D6                851          JSR     HEXASCII
0000169A                           852          
0000169A  4EF8 1658                853          JMP     WrapperSizeImmediateEnd
0000169E                           854                  
0000169E                           855  LongSizeImmediate
0000169E  2818                     856          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
000016A0                           857          
000016A0                           858          *Output '.L' to console...
000016A0  43F9 0000200B            859          LEA     LongSize,A1 *Loads LongSize into address register A1
000016A6  103C 000E                860          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000016AA  4E4F                     861          TRAP    #15         *Displays Message
000016AC                           862          
000016AC                           863          *Output '#$' just before the immediate data
000016AC  43F9 000020F7            864          LEA     ShaBang,A1
000016B2  103C 000E                865          MOVE.B  #14,D0
000016B6  4E4F                     866          TRAP    #15  
000016B8                           867          
000016B8                           868          *output the immediate data to console with the hex-ascii converter
000016B8  4EB8 11D6                869          JSR     HEXASCII
000016BC                           870          
000016BC  4EF8 1658                871          JMP     WrapperSizeImmediateEnd
000016C0                           872  
000016C0                           873  
000016C0                           874  *-----------------------------------------------------------        
000016C0                           875  * EA Mode/EA Register decoding functionality
000016C0                           876  *-----------------------------------------------------------        
000016C0                           877  DataRegMode
000016C0                           878          *Depending on the EA Register, output a different register number
000016C0  4EB9 000016FE            879          JSR     WrapperDataReg        
000016C6                           880          
000016C6                           881          *if this was called for a destination decoding then we are done decoding this        
000016C6                           882          *instruction, go get the next instruction
000016C6  BC3C 0001                883          CMP.B   #$01,D6
000016CA  6600 FC90                884          BNE     GRAB_NEXT_OP
000016CE                           885          
000016CE                           886          *else this was a source decoding, rts back to we can keep decoding
000016CE  4E75                     887          RTS
000016D0                           888  
000016D0                           889  AddrDirectMode
000016D0                           890          *some code...
000016D0                           891  
000016D0                           892  AddrIndirectMode
000016D0                           893          *Depending on the EA Register, output a different register number
000016D0  4EB9 000017C0            894          JSR     WrapperAddrIndirect
000016D6                           895                          
000016D6                           896          *if this was called for a destination decoding then we are done decoding this        
000016D6                           897          *instruction, go get the next instruction
000016D6  BC3C 0001                898          CMP.B   #$01,D6
000016DA  6600 FC80                899          BNE     GRAB_NEXT_OP
000016DE                           900          
000016DE                           901          *else this was a source decoding, rts back to we can keep decoding
000016DE  4E75                     902          RTS
000016E0                           903  
000016E0                           904  AddrIndirectPostMode
000016E0                           905          *Depending on the EA Register, output a different register number
000016E0  4EB9 00001882            906          JSR     WrapperAddrIndirectPost
000016E6                           907  
000016E6                           908          *need to read some flag, if this was called from a source EA decoding then jmp to 
000016E6                           909          *some wrapper (i'll define later)
000016E6                           910          
000016E6                           911          *else this was a destination EA decoding, we can just go get the next instruction
000016E6                           912          *since there is no more decoding to do for the current instruction
000016E6  4EF8 135C                913          JMP     GRAB_NEXT_OP
000016EA                           914  
000016EA                           915  AddrIndirectPreMode
000016EA                           916          *Depending on the EA Register, output a different register number
000016EA  4EB9 00001944            917          JSR     WrapperAddrIndirectPre
000016F0                           918  
000016F0                           919          *need to read some flag, if this was called from a source EA decoding then jmp to 
000016F0                           920          *some wrapper (i'll define later)
000016F0                           921          
000016F0                           922          *else this was a destination EA decoding, we can just go get the next instruction
000016F0                           923          *since there is no more decoding to do for the current instruction
000016F0  4EF8 135C                924          JMP     GRAB_NEXT_OP
000016F4                           925  
000016F4                           926  AddrAbsoluteMode
000016F4                           927          *Depending on the EA Register, output a different register number
000016F4  4EB9 00001A06            928          JSR     WrapperAddrAbsolute        
000016FA                           929  
000016FA                           930          *need to read some flag, if this was called from a source EA decoding then jmp to 
000016FA                           931          *some wrapper (i'll define later)
000016FA                           932          
000016FA                           933          *else this was a destination EA decoding, we can just go get the next instruction
000016FA                           934          *since there is no more decoding to do for the current instruction
000016FA  4EF8 135C                935          JMP     GRAB_NEXT_OP
000016FE                           936          
000016FE                           937  ImmediateDataMode
000016FE                           938          *some code        
000016FE                           939          
000016FE                           940          
000016FE                           941  *-----------------------------------------------------------        
000016FE                           942  * Output logic for all Data Registers (0-7)
000016FE                           943  *-----------------------------------------------------------
000016FE                           944  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000016FE                           945  WrapperDataReg
000016FE                           946          *Depending on the EA destination register, output a different register number
000016FE  B63C 0000                947          CMP.B   #$00,D3
00001702  6700 003C                948          BEQ     DataReg0
00001706                           949          
00001706  B63C 0001                950          CMP.B   #$01,D3
0000170A  6700 0044                951          BEQ     DataReg1
0000170E                           952          
0000170E  B63C 0002                953          CMP.B   #$02,D3
00001712  6700 004C                954          BEQ     DataReg2
00001716                           955          
00001716  B63C 0003                956          CMP.B   #$03,D3
0000171A  6700 0054                957          BEQ     DataReg3
0000171E                           958          
0000171E  B63C 0004                959          CMP.B   #$04,D3
00001722  6700 005C                960          BEQ     DataReg4
00001726                           961          
00001726  B63C 0005                962          CMP.B   #$05,D3
0000172A  6700 0064                963          BEQ     DataReg5
0000172E                           964          
0000172E  B63C 0006                965          CMP.B   #$06,D3
00001732  6700 006C                966          BEQ     DataReg6
00001736                           967          
00001736  B63C 0007                968          CMP.B   #$07,D3
0000173A  6700 0074                969          BEQ     DataReg7        
0000173E                           970  
0000173E                           971  *Used to get back to 'DataRegMode', after dealing with the specific register
0000173E                           972  WrapperDataRegEnd
0000173E  4E75                     973          RTS
00001740                           974  
00001740                           975  DataReg0
00001740                           976          *Output the specific data register...
00001740  43F9 00002012            977          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
00001746  103C 000E                978          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000174A  4E4F                     979          TRAP    #15             *Displays Message   
0000174C                           980          
0000174C  4EF8 173E                981          JMP     WrapperDataRegEnd
00001750                           982  
00001750                           983  DataReg1
00001750  43F9 00002017            984          LEA     OutDataReg1,A1
00001756  103C 000E                985          MOVE.B  #14,D0
0000175A  4E4F                     986          TRAP    #15
0000175C                           987          
0000175C  4EF8 173E                988          JMP     WrapperDataRegEnd
00001760                           989  
00001760                           990  DataReg2
00001760  43F9 0000201C            991          LEA     OutDataReg2,A1
00001766  103C 000E                992          MOVE.B  #14,D0
0000176A  4E4F                     993          TRAP    #15
0000176C                           994  
0000176C  4EF8 173E                995          JMP     WrapperDataRegEnd
00001770                           996      
00001770                           997  DataReg3
00001770  43F9 00002021            998          LEA     OutDataReg3,A1
00001776  103C 000E                999          MOVE.B  #14,D0
0000177A  4E4F                    1000          TRAP    #15
0000177C                          1001  
0000177C  4EF8 173E               1002          JMP     WrapperDataRegEnd
00001780                          1003          
00001780                          1004  DataReg4
00001780  43F9 00002026           1005          LEA     OutDataReg4,A1
00001786  103C 000E               1006          MOVE.B  #14,D0
0000178A  4E4F                    1007          TRAP    #15
0000178C                          1008  
0000178C  4EF8 173E               1009          JMP     WrapperDataRegEnd
00001790                          1010                 
00001790                          1011  DataReg5
00001790  43F9 0000202B           1012          LEA     OutDataReg5,A1
00001796  103C 000E               1013          MOVE.B  #14,D0
0000179A  4E4F                    1014          TRAP    #15
0000179C                          1015  
0000179C  4EF8 173E               1016          JMP     WrapperDataRegEnd
000017A0                          1017          
000017A0                          1018  DataReg6
000017A0  43F9 00002030           1019          LEA     OutDataReg6,A1 A1
000017A6  103C 000E               1020          MOVE.B  #14,D0
000017AA  4E4F                    1021          TRAP    #15
000017AC                          1022  
000017AC  4EF8 173E               1023          JMP     WrapperDataRegEnd
000017B0                          1024          
000017B0                          1025  DataReg7
000017B0  43F9 00002035           1026          LEA     OutDataReg7,A1
000017B6  103C 000E               1027          MOVE.B  #14,D0
000017BA  4E4F                    1028          TRAP    #15
000017BC                          1029          
000017BC  4EF8 173E               1030          JMP     WrapperDataRegEnd
000017C0                          1031  
000017C0                          1032  
000017C0                          1033  *-----------------------------------------------------------        
000017C0                          1034  * Output logic for all Address Indirect Registers (0-7)
000017C0                          1035  *-----------------------------------------------------------     
000017C0                          1036  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000017C0                          1037  WrapperAddrIndirect
000017C0                          1038          *Depending on the EA Register, output a different register number
000017C0  B63C 0000               1039          CMP.B   #$00,D3
000017C4  6700 003C               1040          BEQ     AddrIndReg0
000017C8                          1041          
000017C8  B63C 0001               1042          CMP.B   #$01,D3
000017CC  6700 0044               1043          BEQ     AddrIndReg1
000017D0                          1044          
000017D0  B63C 0002               1045          CMP.B   #$02,D3
000017D4  6700 004C               1046          BEQ     AddrIndReg2
000017D8                          1047          
000017D8  B63C 0003               1048          CMP.B   #$03,D3
000017DC  6700 0054               1049          BEQ     AddrIndReg3
000017E0                          1050          
000017E0  B63C 0004               1051          CMP.B   #$04,D3
000017E4  6700 005C               1052          BEQ     AddrIndReg4
000017E8                          1053          
000017E8  B63C 0005               1054          CMP.B   #$05,D3
000017EC  6700 0064               1055          BEQ     AddrIndReg5
000017F0                          1056          
000017F0  B63C 0006               1057          CMP.B   #$06,D3
000017F4  6700 006C               1058          BEQ     AddrIndReg6
000017F8                          1059          
000017F8  B63C 0007               1060          CMP.B   #$07,D3
000017FC  6700 0074               1061          BEQ     AddrIndReg7
00001800                          1062  
00001800                          1063  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
00001800                          1064  WrapperAddrIndirectEnd
00001800  4E75                    1065          RTS        
00001802                          1066  
00001802                          1067  AddrIndReg0
00001802                          1068          *Output the specific address indirect register...
00001802  43F9 0000203A           1069          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001808  103C 000E               1070          MOVE.B  #14,D0              *Moves the number 14 into data register D0
0000180C  4E4F                    1071          TRAP    #15                 *Displays Message        
0000180E                          1072          
0000180E  4EF8 1800               1073          JMP     WrapperAddrIndirectEnd
00001812                          1074  
00001812                          1075  AddrIndReg1
00001812  43F9 00002041           1076          LEA     OutAddrIndReg1,A1
00001818  103C 000E               1077          MOVE.B  #14,D0
0000181C  4E4F                    1078          TRAP    #15
0000181E                          1079          
0000181E  4EF8 1800               1080          JMP     WrapperAddrIndirectEnd
00001822                          1081  
00001822                          1082  AddrIndReg2
00001822  43F9 00002048           1083          LEA     OutAddrIndReg2,A1
00001828  103C 000E               1084          MOVE.B  #14,D0
0000182C  4E4F                    1085          TRAP    #15
0000182E                          1086          
0000182E  4EF8 1800               1087          JMP     WrapperAddrIndirectEnd
00001832                          1088  
00001832                          1089  AddrIndReg3
00001832  43F9 0000204F           1090          LEA     OutAddrIndReg3,A1
00001838  103C 000E               1091          MOVE.B  #14,D0
0000183C  4E4F                    1092          TRAP    #15
0000183E                          1093          
0000183E  4EF8 1800               1094          JMP     WrapperAddrIndirectEnd
00001842                          1095  
00001842                          1096  AddrIndReg4
00001842  43F9 00002056           1097          LEA     OutAddrIndReg4,A1
00001848  103C 000E               1098          MOVE.B  #14,D0
0000184C  4E4F                    1099          TRAP    #15
0000184E                          1100          
0000184E  4EF8 1800               1101          JMP     WrapperAddrIndirectEnd
00001852                          1102  
00001852                          1103  AddrIndReg5
00001852  43F9 0000205D           1104          LEA     OutAddrIndReg5,A1
00001858  103C 000E               1105          MOVE.B  #14,D0
0000185C  4E4F                    1106          TRAP    #15
0000185E                          1107          
0000185E  4EF8 1800               1108          JMP     WrapperAddrIndirectEnd
00001862                          1109  
00001862                          1110  AddrIndReg6
00001862  43F9 00002064           1111          LEA     OutAddrIndReg6,A1
00001868  103C 000E               1112          MOVE.B  #14,D0
0000186C  4E4F                    1113          TRAP    #15
0000186E                          1114          
0000186E  4EF8 1800               1115          JMP     WrapperAddrIndirectEnd
00001872                          1116  
00001872                          1117  AddrIndReg7
00001872  43F9 0000206B           1118          LEA     OutAddrIndReg7,A1
00001878  103C 000E               1119          MOVE.B  #14,D0
0000187C  4E4F                    1120          TRAP    #15
0000187E                          1121          
0000187E  4EF8 1800               1122          JMP     WrapperAddrIndirectEnd
00001882                          1123          
00001882                          1124          
00001882                          1125  *-----------------------------------------------------------        
00001882                          1126  * Output logic for all Address Indirect Post Increment Registers (0-7)
00001882                          1127  *-----------------------------------------------------------     
00001882                          1128  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001882                          1129  WrapperAddrIndirectPost
00001882                          1130          *Depending on the EA Register, output a different register number
00001882  B63C 0000               1131          CMP.B   #$00,D3
00001886  6700 003C               1132          BEQ     AddrIndPoReg0
0000188A                          1133          
0000188A  B63C 0001               1134          CMP.B   #$01,D3
0000188E  6700 0044               1135          BEQ     AddrIndPoReg1
00001892                          1136          
00001892  B63C 0002               1137          CMP.B   #$02,D3
00001896  6700 004C               1138          BEQ     AddrIndPoReg2
0000189A                          1139          
0000189A  B63C 0003               1140          CMP.B   #$03,D3
0000189E  6700 0054               1141          BEQ     AddrIndPoReg3
000018A2                          1142          
000018A2  B63C 0004               1143          CMP.B   #$04,D3
000018A6  6700 005C               1144          BEQ     AddrIndPoReg4
000018AA                          1145          
000018AA  B63C 0005               1146          CMP.B   #$05,D3
000018AE  6700 0064               1147          BEQ     AddrIndPoReg5
000018B2                          1148          
000018B2  B63C 0006               1149          CMP.B   #$06,D3
000018B6  6700 006C               1150          BEQ     AddrIndPoReg6
000018BA                          1151          
000018BA  B63C 0007               1152          CMP.B   #$07,D3
000018BE  6700 0074               1153          BEQ     AddrIndPoReg7
000018C2                          1154  
000018C2                          1155  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
000018C2                          1156  WrapperAddrIndirectPostEnd
000018C2  4E75                    1157          RTS        
000018C4                          1158  
000018C4                          1159  AddrIndPoReg0
000018C4                          1160          *Output the specific address indirect post register...
000018C4  43F9 00002072           1161          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
000018CA  103C 000E               1162          MOVE.B  #14,D0              *Moves the number 14 into data register D0
000018CE  4E4F                    1163          TRAP    #15                 *Displays Message        
000018D0                          1164          
000018D0  4EF8 18C2               1165          JMP     WrapperAddrIndirectPostEnd
000018D4                          1166  
000018D4                          1167  AddrIndPoReg1
000018D4  43F9 0000207A           1168          LEA     OutAddrIndPoReg1,A1
000018DA  103C 000E               1169          MOVE.B  #14,D0
000018DE  4E4F                    1170          TRAP    #15
000018E0                          1171          
000018E0  4EF8 18C2               1172          JMP     WrapperAddrIndirectPostEnd
000018E4                          1173  
000018E4                          1174  AddrIndPoReg2
000018E4  43F9 00002082           1175          LEA     OutAddrIndPoReg2,A1
000018EA  103C 000E               1176          MOVE.B  #14,D0
000018EE  4E4F                    1177          TRAP    #15
000018F0                          1178          
000018F0  4EF8 18C2               1179          JMP     WrapperAddrIndirectPostEnd
000018F4                          1180  
000018F4                          1181  AddrIndPoReg3
000018F4  43F9 0000208A           1182          LEA     OutAddrIndPoReg3,A1
000018FA  103C 000E               1183          MOVE.B  #14,D0
000018FE  4E4F                    1184          TRAP    #15
00001900                          1185          
00001900  4EF8 18C2               1186          JMP     WrapperAddrIndirectPostEnd
00001904                          1187  
00001904                          1188  AddrIndPoReg4
00001904  43F9 00002092           1189          LEA     OutAddrIndPoReg4,A1
0000190A  103C 000E               1190          MOVE.B  #14,D0
0000190E  4E4F                    1191          TRAP    #15
00001910                          1192          
00001910  4EF8 18C2               1193          JMP     WrapperAddrIndirectPostEnd
00001914                          1194  
00001914                          1195  AddrIndPoReg5
00001914  43F9 0000209A           1196          LEA     OutAddrIndPoReg5,A1
0000191A  103C 000E               1197          MOVE.B  #14,D0
0000191E  4E4F                    1198          TRAP    #15
00001920                          1199          
00001920  4EF8 18C2               1200          JMP     WrapperAddrIndirectPostEnd
00001924                          1201  
00001924                          1202  AddrIndPoReg6
00001924  43F9 000020A2           1203          LEA     OutAddrIndPoReg6,A1
0000192A  103C 000E               1204          MOVE.B  #14,D0
0000192E  4E4F                    1205          TRAP    #15
00001930                          1206          
00001930  4EF8 18C2               1207          JMP     WrapperAddrIndirectPostEnd
00001934                          1208  
00001934                          1209  AddrIndPoReg7
00001934  43F9 000020AA           1210          LEA     OutAddrIndPoReg7,A1
0000193A  103C 000E               1211          MOVE.B  #14,D0
0000193E  4E4F                    1212          TRAP    #15
00001940                          1213          
00001940  4EF8 18C2               1214          JMP     WrapperAddrIndirectPostEnd
00001944                          1215  
00001944                          1216  
00001944                          1217  *-----------------------------------------------------------        
00001944                          1218  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001944                          1219  *-----------------------------------------------------------     
00001944                          1220  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001944                          1221  WrapperAddrIndirectPre
00001944                          1222          *Depending on the EA Register, output a different register number
00001944  B63C 0000               1223          CMP.B   #$00,D3
00001948  6700 003C               1224          BEQ     AddrIndPrReg0
0000194C                          1225          
0000194C  B63C 0001               1226          CMP.B   #$01,D3
00001950  6700 0044               1227          BEQ     AddrIndPrReg1
00001954                          1228          
00001954  B63C 0002               1229          CMP.B   #$02,D3
00001958  6700 004C               1230          BEQ     AddrIndPrReg2
0000195C                          1231          
0000195C  B63C 0003               1232          CMP.B   #$03,D3
00001960  6700 0054               1233          BEQ     AddrIndPrReg3
00001964                          1234          
00001964  B63C 0004               1235          CMP.B   #$04,D3
00001968  6700 005C               1236          BEQ     AddrIndPrReg4
0000196C                          1237          
0000196C  B63C 0005               1238          CMP.B   #$05,D3
00001970  6700 0064               1239          BEQ     AddrIndPrReg5
00001974                          1240          
00001974  B63C 0006               1241          CMP.B   #$06,D3
00001978  6700 006C               1242          BEQ     AddrIndPrReg6
0000197C                          1243          
0000197C  B63C 0007               1244          CMP.B   #$07,D3
00001980  6700 0074               1245          BEQ     AddrIndPrReg7
00001984                          1246  
00001984                          1247  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001984                          1248  WrapperAddrIndirectPreEnd
00001984  4E75                    1249          RTS        
00001986                          1250  
00001986                          1251  AddrIndPrReg0
00001986                          1252          *Output the specific address indirect post register...
00001986  43F9 000020B2           1253          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
0000198C  103C 000E               1254          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001990  4E4F                    1255          TRAP    #15                 *Displays Message        
00001992                          1256          
00001992  4EF8 1984               1257          JMP     WrapperAddrIndirectPreEnd
00001996                          1258  
00001996                          1259  AddrIndPrReg1
00001996  43F9 000020BA           1260          LEA     OutAddrIndPrReg1,A1
0000199C  103C 000E               1261          MOVE.B  #14,D0
000019A0  4E4F                    1262          TRAP    #15
000019A2                          1263          
000019A2  4EF8 1984               1264          JMP     WrapperAddrIndirectPreEnd
000019A6                          1265  
000019A6                          1266  AddrIndPrReg2
000019A6  43F9 000020C2           1267          LEA     OutAddrIndPrReg2,A1
000019AC  103C 000E               1268          MOVE.B  #14,D0
000019B0  4E4F                    1269          TRAP    #15
000019B2                          1270          
000019B2  4EF8 1984               1271          JMP     WrapperAddrIndirectPreEnd
000019B6                          1272  
000019B6                          1273  AddrIndPrReg3
000019B6  43F9 000020CA           1274          LEA     OutAddrIndPrReg3,A1
000019BC  103C 000E               1275          MOVE.B  #14,D0
000019C0  4E4F                    1276          TRAP    #15
000019C2                          1277          
000019C2  4EF8 1984               1278          JMP     WrapperAddrIndirectPreEnd
000019C6                          1279  
000019C6                          1280  AddrIndPrReg4
000019C6  43F9 000020D2           1281          LEA     OutAddrIndPrReg4,A1
000019CC  103C 000E               1282          MOVE.B  #14,D0
000019D0  4E4F                    1283          TRAP    #15
000019D2                          1284          
000019D2  4EF8 1984               1285          JMP     WrapperAddrIndirectPreEnd
000019D6                          1286  
000019D6                          1287  AddrIndPrReg5
000019D6  43F9 000020DA           1288          LEA     OutAddrIndPrReg5,A1
000019DC  103C 000E               1289          MOVE.B  #14,D0
000019E0  4E4F                    1290          TRAP    #15
000019E2                          1291          
000019E2  4EF8 1984               1292          JMP     WrapperAddrIndirectPreEnd
000019E6                          1293  
000019E6                          1294  AddrIndPrReg6
000019E6  43F9 000020E2           1295          LEA     OutAddrIndPrReg6,A1
000019EC  103C 000E               1296          MOVE.B  #14,D0
000019F0  4E4F                    1297          TRAP    #15
000019F2                          1298          
000019F2  4EF8 1984               1299          JMP     WrapperAddrIndirectPreEnd
000019F6                          1300  
000019F6                          1301  AddrIndPrReg7
000019F6  43F9 000020EA           1302          LEA     OutAddrIndPrReg7,A1
000019FC  103C 000E               1303          MOVE.B  #14,D0
00001A00  4E4F                    1304          TRAP    #15
00001A02                          1305          
00001A02  4EF8 1984               1306          JMP     WrapperAddrIndirectPreEnd
00001A06                          1307  
00001A06                          1308  
00001A06                          1309  *-----------------------------------------------------------        
00001A06                          1310  * Output logic for absolute memory addressing (0-7)
00001A06                          1311  *-----------------------------------------------------------     
00001A06                          1312  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001A06                          1313  WrapperAddrAbsolute
00001A06  4284                    1314          CLR.L   D4
00001A08                          1315          *Depending on the EA Register, choose which size to decode
00001A08  B63C 0000               1316          CMP.B   #$00,D3
00001A0C  6700 000C               1317          BEQ     WordSizeAbsolute
00001A10                          1318  
00001A10  B63C 0001               1319          CMP.B   #$01,D3
00001A14  6700 002C               1320          BEQ     LongSizeAbsolute
00001A18                          1321          
00001A18                          1322  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001A18                          1323  WrapperAddrAbsoluteEnd
00001A18  4E75                    1324          RTS
00001A1A                          1325  
00001A1A                          1326  WordSizeAbsolute        
00001A1A  3818                    1327          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001A1C                          1328          
00001A1C                          1329          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001A1C  4281                    1330          CLR.L   D1
00001A1E  123C 0001               1331          MOVE.B  #$01,D1     
00001A22                          1332              
00001A22                          1333          *Output ',$' just after source operand
00001A22  43F9 000020FA           1334          LEA     Bang,A1
00001A28  103C 000E               1335          MOVE.B  #14,D0
00001A2C  4E4F                    1336          TRAP    #15
00001A2E                          1337              
00001A2E                          1338          *output the absolute mem address to console with the hex-ascii converter
00001A2E  4EB8 11D6               1339          JSR     HEXASCII
00001A32                          1340          
00001A32                          1341          *Print a new line, since this should be the last piece of data for an instruction
00001A32  43F9 000020F4           1342          LEA     NewLine,A1
00001A38  103C 000E               1343          MOVE.B  #14,D0
00001A3C  4E4F                    1344          TRAP    #15
00001A3E                          1345          
00001A3E  4EF8 1A18               1346          JMP     WrapperAddrAbsoluteEnd
00001A42                          1347  
00001A42                          1348  LongSizeAbsolute
00001A42  2818                    1349          MOVE.L  (A0)+,D4    *read in next long, data is that long
00001A44                          1350                  
00001A44                          1351          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001A44  4281                    1352          CLR.L   D1
00001A46  123C 0010               1353          MOVE.B  #$10,D1
00001A4A                          1354                  
00001A4A                          1355          *Output ',$' just after source operand
00001A4A  43F9 000020FA           1356          LEA     Bang,A1
00001A50  103C 000E               1357          MOVE.B  #14,D0
00001A54  4E4F                    1358          TRAP    #15  
00001A56                          1359          
00001A56                          1360          *output the absolute mem address to console with the hex-ascii converter
00001A56  4EB8 11D6               1361          JSR     HEXASCII
00001A5A                          1362          
00001A5A                          1363          *Print a new line, since this should be the last piece of data for an instruction
00001A5A  43F9 000020F4           1364          LEA     NewLine,A1
00001A60  103C 000E               1365          MOVE.B  #14,D0
00001A64  4E4F                    1366          TRAP    #15
00001A66                          1367  
00001A66  4EF8 1A18               1368          JMP     WrapperAddrAbsoluteEnd
00001A6A                          1369          
00001A6A                          1370  
00001A6A                          1371  *-----------------------------------------------------------        
00001A6A                          1372  * Current handling of bad op/ea codes. Should be revisited.
00001A6A                          1373  *----------------------------------------------------------- 
00001A6A                          1374  BADOPCODE
00001A6A                          1375          *We found a bad op code, output some error to the screen, jump to the 
00001A6A                          1376          *next instruction in memory.
00001A6A                          1377          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001A6A                          1378          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001A6A                          1379          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001A6A                          1380          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001A6A                          1381          *i/o and error message code...
00001A6A  43F9 0000210C           1382          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001A70  103C 000E               1383          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A74  4E4F                    1384          TRAP    #15         *Displays Message
00001A76  4EF8 135C               1385          JMP     GRAB_NEXT_OP
00001A7A                          1386                  
00001A7A                          1387  BADEACODE
00001A7A                          1388          *We found a bad ea code, output some error to the screen, jump to the
00001A7A                          1389          *next instruction in memory.
00001A7A                          1390          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001A7A                          1391          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001A7A  43F9 000020FC           1392          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001A80  103C 000E               1393          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A84  4E4F                    1394          TRAP    #15         *Displays Message
00001A86  4EF8 135C               1395          JMP     GRAB_NEXT_OP
00001A8A                          1396          
00001A8A                          1397          
00001A8A                          1398  *-----------------------------------------------------------        
00001A8A                          1399  * End of Disassembler
00001A8A                          1400  *-----------------------------------------------------------    
00001A8A                          1401  
00001A8A  4E72 2700               1402  DONE    STOP    #$2700  *What does this do? Why was it added?
00001A8E                          1403  
00001A8E  103C 0009               1404  THEEND  MOVE.B  #9,D0
00001A92  4E4F                    1405          TRAP    #15             Halt Simulator        
00001A94                          1406          
00001A94                          1407       
00001A94                          1408  *-----------------------------------------------------------        
00001A94                          1409  * Output stuff
00001A94                          1410  *-----------------------------------------------------------     
00001A94  =0000000D               1411  CR      EQU     $0D             ASCII code for Carriage Return
00001A94  =0000000A               1412  LF      EQU     $0A             ASCII code for Line Feed
00001A94= 2D 2D 2D 2D 2D 2D ...   1413  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001AD3= 7C 7C 20 20 20 20 ...   1414              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001B12= 2D 2D 2D 2D 2D 2D ...   1415              DC.B    '-------------------------------------------------------------',CR,LF
00001B51= 2A 2A 2A 2A 2A 2A ...   1416              DC.B    '*************************************************************',CR,LF
00001B90= 2A 2A 2A 2A 2A 2A ...   1417              DC.B    '*************************************************************',CR,LF
00001BCF= 2A 2A 2A 2A 2A 2A ...   1418              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001C0E= 2A 2A 2A 2A 2A 2A ...   1419              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001C4D= 2A 2A 2A 2A 2A 2A ...   1420              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001C8C= 2A 2A 2A 2A 2A 2A ...   1421              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001CCB= 2A 2A 2A 2A 2A 2A ...   1422              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001D0A= 2A 2A 2A 2A 2A 2A ...   1423              DC.B    '*************************************************************',CR,LF
00001D49= 2A 2A 2A 2A 2A 2A ...   1424              DC.B    '*************************************************************',CR,LF
00001D88= 2A 20 20 20 20 20 ...   1425              DC.B    '*                                                           *',CR,LF
00001DC7= 2A 20 41 75 74 68 ...   1426              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001E06= 2A 20 20 20 20 20 ...   1427              DC.B    '*                                                           *',CR,LF
00001E45= 2A 2A 2A 2A 2A 2A ...   1428              DC.B    '*************************************************************',CR,LF,CR,LF
00001E86= 53 74 61 72 74 69 ...   1429              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001EA3                          1430              
00001EA3= 57 6F 75 6C 64 20 ...   1431  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001ED4                          1432  
00001ED4= 20 0D 0A                1433  GETSTRTADDR DC.B    ' ',CR,LF
00001ED7= 50 6C 65 61 73 65 ...   1434              DC.B    'Please type in your starting address request: ',0
00001F06                          1435              
00001F06= 20 0D 0A                1436  GETENDADDR  DC.B    ' ',CR,LF
00001F09= 50 6C 65 61 73 65 ...   1437              DC.B    'Please type in your ending address request: ',0
00001F36                          1438              
00001F36= 20 0D 0A                1439  QUIT_MSG    DC.B    ' ',CR,LF
00001F39= 57 6F 75 6C 64 20 ...   1440              DC.B    'Would you like to quit (Y/N)? ',0
00001F58                          1441  
00001F58                          1442  *****************************************************
00001F58                          1443  * I/O storages - assuming users knows what to do.
00001F58                          1444  *****************************************************
00001F58                          1445  CMD_HLD     DS.B    30
00001F76                          1446  CMD_SZ      DS.B    30
00001F94                          1447  STADDR      DS.B    10
00001F9E                          1448  STADDRSZ    DS.B    10
00001FA8                          1449  PROGST      DS.L    1
00001FAC                          1450  ENDADDR     DS.B    10
00001FB6                          1451  ENDADDRSZ   DS.B    10
00001FC0                          1452  PROGEND     DS.L    1
00001FC4                          1453  *****************************************************
00001FC4                          1454  
00001FC4                          1455  *Table for 0-9 && A-F
00001FC4= 30 00                   1456  PRNT0   DC.B    '0',0
00001FC6= 31 00                   1457  PRNT1   DC.B    '1',0
00001FC8= 32 00                   1458  PRNT2   DC.B    '2',0
00001FCA= 33 00                   1459  PRNT3   DC.B    '3',0
00001FCC= 34 00                   1460  PRNT4   DC.B    '4',0
00001FCE= 35 00                   1461  PRNT5   DC.B    '5',0
00001FD0= 36 00                   1462  PRNT6   DC.B    '6',0
00001FD2= 37 00                   1463  PRNT7   DC.B    '7',0
00001FD4= 38 00                   1464  PRNT8   DC.B    '8',0
00001FD6= 39 00                   1465  PRNT9   DC.B    '9',0
00001FD8= 41 00                   1466  PRNTA   DC.B    'A',0
00001FDA= 42 00                   1467  PRNTB   DC.B    'B',0
00001FDC= 43 00                   1468  PRNTC   DC.B    'C',0
00001FDE= 44 00                   1469  PRNTD   DC.B    'D',0
00001FE0= 45 00                   1470  PRNTE   DC.B    'E',0
00001FE2= 46 00                   1471  PRNTF   DC.B    'F',0
00001FE4                          1472  
00001FE4                          1473  *output for all OPCODEs
00001FE4= 41 44 44 49 00          1474  ADDI    DC.B    'ADDI',0
00001FE9= 41 4E 44 49 00          1475  ANDI    DC.B    'ANDI',0
00001FEE= 45 4F 52 49 00          1476  EORI    DC.B    'EORI',0
00001FF3= 42 43 48 47 00          1477  BCHG    DC.B    'BCHG',0
00001FF8= 43 4D 50 49 00          1478  CMPI    DC.B    'CMPI',0
00001FFD                          1479  
00001FFD                          1480  *output for the size of the operation
00001FFD= 2E 42 20 20 20 20 00    1481  ByteSize    DC.B    '.B    ',0
00002004= 2E 57 20 20 20 20 00    1482  WordSize    DC.B    '.W    ',0
0000200B= 2E 4C 20 20 20 20 00    1483  LongSize    DC.B    '.L    ',0
00002012                          1484  
00002012                          1485  *output for all destination data registers (0-7)
00002012= 44 30 0D 0A 00          1486  OutDataReg0 DC.B    'D0',CR,LF,0
00002017= 44 31 0D 0A 00          1487  OutDataReg1 DC.B    'D1',CR,LF,0
0000201C= 44 32 0D 0A 00          1488  OutDataReg2 DC.B    'D2',CR,LF,0
00002021= 44 33 0D 0A 00          1489  OutDataReg3 DC.B    'D3',CR,LF,0
00002026= 44 34 0D 0A 00          1490  OutDataReg4 DC.B    'D4',CR,LF,0
0000202B= 44 35 0D 0A 00          1491  OutDataReg5 DC.B    'D5',CR,LF,0
00002030= 44 36 0D 0A 00          1492  OutDataReg6 DC.B    'D6',CR,LF,0
00002035= 44 37 0D 0A 00          1493  OutDataReg7 DC.B    'D7',CR,LF,0
0000203A                          1494  
0000203A                          1495  *output for all address indirect registers (0-7)
0000203A= 28 41 30 29 0D 0A 00    1496  OutAddrIndReg0  DC.B    '(A0)',CR,LF,0
00002041= 28 41 31 29 0D 0A 00    1497  OutAddrIndReg1  DC.B    '(A1)',CR,LF,0
00002048= 28 41 32 29 0D 0A 00    1498  OutAddrIndReg2  DC.B    '(A2)',CR,LF,0
0000204F= 28 41 33 29 0D 0A 00    1499  OutAddrIndReg3  DC.B    '(A3)',CR,LF,0
00002056= 28 41 34 29 0D 0A 00    1500  OutAddrIndReg4  DC.B    '(A4)',CR,LF,0
0000205D= 28 41 35 29 0D 0A 00    1501  OutAddrIndReg5  DC.B    '(A5)',CR,LF,0
00002064= 28 41 36 29 0D 0A 00    1502  OutAddrIndReg6  DC.B    '(A6)',CR,LF,0
0000206B= 28 41 37 29 0D 0A 00    1503  OutAddrIndReg7  DC.B    '(A7)',CR,LF,0
00002072                          1504  
00002072                          1505  *output for all address indirect post registers (0-7)
00002072= 28 41 30 29 2B 0D ...   1506  OutAddrIndPoReg0    DC.B    '(A0)+',CR,LF,0
0000207A= 28 41 31 29 2B 0D ...   1507  OutAddrIndPoReg1    DC.B    '(A1)+',CR,LF,0
00002082= 28 41 32 29 2B 0D ...   1508  OutAddrIndPoReg2    DC.B    '(A2)+',CR,LF,0
0000208A= 28 41 33 29 2B 0D ...   1509  OutAddrIndPoReg3    DC.B    '(A3)+',CR,LF,0
00002092= 28 41 34 29 2B 0D ...   1510  OutAddrIndPoReg4    DC.B    '(A4)+',CR,LF,0
0000209A= 28 41 35 29 2B 0D ...   1511  OutAddrIndPoReg5    DC.B    '(A5)+',CR,LF,0
000020A2= 28 41 36 29 2B 0D ...   1512  OutAddrIndPoReg6    DC.B    '(A6)+',CR,LF,0
000020AA= 28 41 37 29 2B 0D ...   1513  OutAddrIndPoReg7    DC.B    '(A7)+',CR,LF,0
000020B2                          1514  
000020B2                          1515  *output for all address indirect pre registers (0-7)
000020B2= 2D 28 41 30 29 0D ...   1516  OutAddrIndPrReg0    DC.B    '-(A0)',CR,LF,0
000020BA= 2D 28 41 31 29 0D ...   1517  OutAddrIndPrReg1    DC.B    '-(A1)',CR,LF,0
000020C2= 2D 28 41 32 29 0D ...   1518  OutAddrIndPrReg2    DC.B    '-(A2)',CR,LF,0
000020CA= 2D 28 41 33 29 0D ...   1519  OutAddrIndPrReg3    DC.B    '-(A3)',CR,LF,0
000020D2= 2D 28 41 34 29 0D ...   1520  OutAddrIndPrReg4    DC.B    '-(A4)',CR,LF,0
000020DA= 2D 28 41 35 29 0D ...   1521  OutAddrIndPrReg5    DC.B    '-(A5)',CR,LF,0
000020E2= 2D 28 41 36 29 0D ...   1522  OutAddrIndPrReg6    DC.B    '-(A6)',CR,LF,0
000020EA= 2D 28 41 37 29 0D ...   1523  OutAddrIndPrReg7    DC.B    '-(A7)',CR,LF,0
000020F2                          1524  
000020F2                          1525  *output for a comma only
000020F2= 2C 00                   1526  Comma   DC.B    ',',0
000020F4                          1527  
000020F4                          1528  *output for a new line only
000020F4= 0D 0A 00                1529  NewLine DC.B    CR,LF,0
000020F7                          1530  
000020F7                          1531  *output for a '#$' and '$' only
000020F7= 23 24 00                1532  ShaBang DC.B    '#$',0
000020FA= 24 00                   1533  Bang    DC.B    '$',0
000020FC                          1534  
000020FC                          1535  *current output for error messages
000020FC= 42 41 44 20 45 41 ...   1536  BADEAMSG    DC.B    'BAD EA, WHY?!',CR,LF,0
0000210C= 42 41 44 20 4F 50 ...   1537  BADOPMSG    DC.B    'BAD OP CODE, WHY?!',CR,LF,0
00002121= 49 6D 70 72 6F 70 ...   1538  INV_MSG     DC.B    'Improper command.',CR,LF,0
00002135= 49 6E 76 61 6C 69 ...   1539  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
0000214E= 49 6E 76 61 6C 69 ...   1540  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
00002165                          1541  
00002165                          1542          
00002165                          1543          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                1FE4
ADDRABSOLUTEMODE    16F4
ADDRDIRECTMODE      16D0
ADDRINDIRECTMODE    16D0
ADDRINDIRECTPOSTMODE  16E0
ADDRINDIRECTPREMODE  16EA
ADDRINDPOREG0       18C4
ADDRINDPOREG1       18D4
ADDRINDPOREG2       18E4
ADDRINDPOREG3       18F4
ADDRINDPOREG4       1904
ADDRINDPOREG5       1914
ADDRINDPOREG6       1924
ADDRINDPOREG7       1934
ADDRINDPRREG0       1986
ADDRINDPRREG1       1996
ADDRINDPRREG2       19A6
ADDRINDPRREG3       19B6
ADDRINDPRREG4       19C6
ADDRINDPRREG5       19D6
ADDRINDPRREG6       19E6
ADDRINDPRREG7       19F6
ADDRINDREG0         1802
ADDRINDREG1         1812
ADDRINDREG2         1822
ADDRINDREG3         1832
ADDRINDREG4         1842
ADDRINDREG5         1852
ADDRINDREG6         1862
ADDRINDREG7         1872
ANDI                1FE9
ASCIIHEX            1164
ASCIIHEX1           1168
BADEACODE           1A7A
BADEAMSG            20FC
BADOPCODE           1A6A
BADOPMSG            210C
BANG                20FA
BCHG                1FF3
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         1368
BUCKET_0001         1638
BUCKET_0010         1638
BUCKET_0011         1638
BUCKET_0100         1638
BUCKET_0101         1638
BUCKET_0110         1638
BUCKET_1000         1638
BUCKET_1001         1638
BUCKET_1011         1638
BUCKET_1100         1638
BUCKET_1101         1638
BUCKET_1110         1638
BYTESIZE            1FFD
BYTESIZEIMMEDIATE   165A
CHECK               11DA
CHECKEND1           10EE
CHECKSTRT1          10D8
CHECK_LOWN          111C
CHECK_LOWY          110C
CHECK_UPN           1114
CHECK_UPY           1104
CHNG_SZB            120C
CHNG_SZL            11F2
CHNG_SZW            1226
CMD_HLD             1F58
CMD_SZ              1F76
CMPI                1FF8
COMMA               20F2
CONV_LOL            11C4
CONV_LOOP           1240
CONV_NUM            11B0
CONV_UPL            11BA
CR                  D
DATAREG0            1740
DATAREG1            1750
DATAREG2            1760
DATAREG3            1770
DATAREG4            1780
DATAREG5            1790
DATAREG6            17A0
DATAREG7            17B0
DATAREGMODE         16C0
DONE                1A8A
EA_ADDI             13F4
EA_ANDI             146A
EA_BCHG_D           1562
EA_BCHG_S           15BC
EA_CMPI             15F8
EA_EORI             14E0
ENDADDR             1FAC
ENDADDRSZ           1FB6
EORI                1FEE
EXITSUB             11D0
EXIT_CONV           12C6
GETENDADDR          1F06
GETSTRTADDR         1ED4
GET_END             1086
GET_STRT            1038
GRAB_NEXT_OP        135C
HEXASCII            11D6
HEXASCIIREG         11EE
IMMEDIATEDATAMODE   16FE
INVALID1            1124
INVENDMSG           214E
INVSTRTMSG          2135
INV_END1            1150
INV_MSG             2121
INV_STRT1           113C
IS_ADDI             13BE
IS_ANDI             1434
IS_BCHG_D           1520
IS_BCHG_S           15A6
IS_CMPI             15C2
IS_EORI             14AA
LF                  A
LONGSIZE            200B
LONGSIZEABSOLUTE    1A42
LONGSIZEIMMEDIATE   169E
LOOP_1              1010
LOOP_B              1210
LOOP_L              11F6
LOOP_W              122A
MESSAGE             1A94
NEWLINE             20F4
NUM_0               12D4
NUM_1               12DC
NUM_2               12E4
NUM_3               12EC
NUM_4               12F4
NUM_5               12FC
NUM_6               1304
NUM_7               130C
NUM_8               1314
NUM_9               131C
NUM_A               1324
NUM_B               132C
NUM_C               1334
NUM_D               133C
NUM_E               1344
NUM_F               134C
OUTADDRINDPOREG0    2072
OUTADDRINDPOREG1    207A
OUTADDRINDPOREG2    2082
OUTADDRINDPOREG3    208A
OUTADDRINDPOREG4    2092
OUTADDRINDPOREG5    209A
OUTADDRINDPOREG6    20A2
OUTADDRINDPOREG7    20AA
OUTADDRINDPRREG0    20B2
OUTADDRINDPRREG1    20BA
OUTADDRINDPRREG2    20C2
OUTADDRINDPRREG3    20CA
OUTADDRINDPRREG4    20D2
OUTADDRINDPRREG5    20DA
OUTADDRINDPRREG6    20E2
OUTADDRINDPRREG7    20EA
OUTADDRINDREG0      203A
OUTADDRINDREG1      2041
OUTADDRINDREG2      2048
OUTADDRINDREG3      204F
OUTADDRINDREG4      2056
OUTADDRINDREG5      205D
OUTADDRINDREG6      2064
OUTADDRINDREG7      206B
OUTDATAREG0         2012
OUTDATAREG1         2017
OUTDATAREG2         201C
OUTDATAREG3         2021
OUTDATAREG4         2026
OUTDATAREG5         202B
OUTDATAREG6         2030
OUTDATAREG7         2035
PRINT_NUM           12CC
PRNT0               1FC4
PRNT1               1FC6
PRNT2               1FC8
PRNT3               1FCA
PRNT4               1FCC
PRNT5               1FCE
PRNT6               1FD0
PRNT7               1FD2
PRNT8               1FD4
PRNT9               1FD6
PRNTA               1FD8
PRNTB               1FDA
PRNTC               1FDC
PRNTD               1FDE
PRNTE               1FE0
PRNTF               1FE2
PROGEND             1FC0
PROGST              1FA8
QUIT_MSG            1F36
SHABANG             20F7
STACK               7000
STADDR              1F94
STADDRSZ            1F9E
START               1000
STARTASSEM          1EA3
ST_ADDR             7FC6
ST_BAD              11CE
THEEND              1A8E
WORDSIZE            2004
WORDSIZEABSOLUTE    1A1A
WORDSIZEIMMEDIATE   167C
WRAPPERADDRABSOLUTE  1A06
WRAPPERADDRABSOLUTEEND  1A18
WRAPPERADDRINDIRECT  17C0
WRAPPERADDRINDIRECTEND  1800
WRAPPERADDRINDIRECTPOST  1882
WRAPPERADDRINDIRECTPOSTEND  18C2
WRAPPERADDRINDIRECTPRE  1944
WRAPPERADDRINDIRECTPREEND  1984
WRAPPERDATAREG      16FE
WRAPPERDATAREGEND   173E
WRAPPERSIZEIMMEDIATE  163E
WRAPPERSIZEIMMEDIATEEND  1658
