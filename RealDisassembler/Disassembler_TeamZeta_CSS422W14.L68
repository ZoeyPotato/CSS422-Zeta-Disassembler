00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.0
Created On: 3/11/2014 9:33:29 PM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/1/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC0                  9  ST_ADDR     EQU $7FC0   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00000000                            11  
00001000                            12  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 13              LEA stack,SP
00001004                            14  
00001004                            15  *-----------------------------------------------------------
00001004                            16  * Start of I/O
00001004                            17  *-----------------------------------------------------------
00001004  307C 7FC0                 18              MOVEA.W #ST_ADDR,A0 *Load starting location of test input file into A0
00001008                            19              
00001008  43F9 00001234             20              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 21              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      22              TRAP    #15         *Displays Message
00001014                            23          
00001014  303C 0000                 24  loop_1      MOVE    #0,D0       
00001018  43F9 00001643             25              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 26              MOVE.B  #14,D0
00001022  4E4F                      27              TRAP    #15    
00001024  303C 0002                 28              MOVE    #2,D0
00001028  43F9 000016F8             29              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      30              TRAP    #15
00001030  6000 0002                 31              BRA     CHECK_UPY
00001034                            32          
00001034                            33  *-----------------------------------------------------------
00001034                            34  * I/O: Input check for Y, y, N, n
00001034                            35  *-----------------------------------------------------------
00001034  0C11 0059                 36  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001038  6600 0006                 37              BNE     CHECK_LOWy
0000103C  6700 004C                 38              BEQ     NXT_CMD
00001040                            39              
00001040  0C11 0079                 40  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
00001044  6600 0006                 41              BNE     CHECK_UPN
00001048  6700 0040                 42              BEQ     NXT_CMD
0000104C                            43              
0000104C  0C11 004E                 44  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001050  6700 01D8                 45              BEQ     DONE
00001054  6600 0002                 46              BNE     CHECK_LOWn
00001058                            47              
00001058  0C11 006E                 48  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
0000105C  6600 0006                 49              BNE     INVALID1
00001060  6700 01C8                 50              BEQ     DONE
00001064                            51              
00001064  303C 0000                 52  INVALID1    MOVE    #0,D0       *Prints invalid command msg if not found
00001068  43F9 00001819             53              LEA     INV_MSG,A1
0000106E  303C 000E                 54              MOVE    #14,D0
00001072  4E4F                      55              TRAP    #15
00001074  4EF8 1014                 56              JMP     loop_1
00001078                            57              
00001078  43F9 0000182D             58  INV_STRT1   LEA     INVSTRTMSG,A1
0000107E  103C 000E                 59              MOVE.B  #14,D0
00001082  4E4F                      60              TRAP    #15
00001084  4EF9 0000108A             61              JMP     NXT_CMD     
0000108A                            62              
0000108A                            63  *-----------------------------------------------------------
0000108A                            64  *
0000108A                            65  * I/O: Check Start Address
0000108A                            66  *
0000108A                            67  * Make sure that start address starts after allocated 
0000108A                            68  * memory addresses. Else, it will print out a message 
0000108A                            69  * saying that requested address is invalid & prompts the
0000108A                            70  * user again for the starting address.
0000108A                            71  *-----------------------------------------------------------
0000108A  43F9 00001674             72  NXT_CMD     LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001090  103C 000E                 73              MOVE.B  #14,D0
00001094  4E4F                      74              TRAP    #15
00001096  43F9 000016F8             75              LEA     CMD_HLD,A1  *Need to change where it can hold the start/end address
0000109C  303C 0002                 76              MOVE    #2,D0           *Get start address
000010A0  4E4F                      77              TRAP    #15
000010A2  2811                      78              MOVE.L  (A1),D4
000010A4  4EB9 000010AA             79              JSR     CHECKSTRT1
000010AA  0C81 00000008             80  CHECKSTRT1  CMPI.L  #08,D1      *Check if size 
000010B0  6EC6                      81              BGT     INV_STRT1
000010B2  0C81 00000000             82              CMPI.L  #00,D1
000010B8  63BE                      83              BLS     INV_STRT1
000010BA  4E75                      84              RTS         
000010BC                            85              
000010BC                            86  *-----------------------------------------------------------        
000010BC                            87  * Start of Disassembler
000010BC                            88  *-----------------------------------------------------------
000010BC                            89  GRAB_NEXT_OP
000010BC                            90          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
000010BC                            91          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
000010BC                            92          *data that may be associated with the instruction.
000010BC                            93          *Post increment addr, A0 will point to the start of next instruction or will 
000010BC                            94          *point to the start of any immed/abso data with this current instruction
000010BC  4280                      95          CLR.L   D0
000010BE  3018                      96          MOVE.W  (A0)+,D0
000010C0                            97          *Copy the word data we just moved into D0 into D7. We are copying this data
000010C0                            98          *So we always have a copy of the WHOLE instruction somewhere
000010C0  4287                      99          CLR.L   D7
000010C2  3E00                     100          MOVE.W  D0,D7
000010C4                           101          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000010C4                           102          *four bits of the instruction. Once we have just the first four bits, we can
000010C4                           103          *begin to see which 'bucket'/category this instruction falls into. 
000010C4  E048                     104          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000010C6  E848                     105          LSR.W   #$04,D0
000010C8                           106          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000010C8                           107          *list of buckets until we find which one this instruction falls into.
000010C8                           108  
000010C8                           109  
000010C8                           110  *-----------------------------------------------------------        
000010C8                           111  * Bucket 0000:
000010C8                           112  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
000010C8                           113  *                   BCHG(dynamic) | BCHG (static) | CMPI----
000010C8                           114  *-----------------------------------------------------------
000010C8                           115  BUCKET_0000
000010C8  =00000000                116  BUCKET0000_BITS EQU $0
000010C8  4281                     117          CLR.L   D1
000010CA                           118          *Load the first 4 bits (really a byte) of BUCKET0 into D1
000010CA  123C 0000                119          MOVE.B  #BUCKET0000_BITS,D1
000010CE                           120          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
000010CE                           121          *If equal, continue decoding. If not, branch to next bucket.
000010CE  B200                     122          CMP.B   D0,D1
000010D0  6600 0132                123          BNE     BUCKET_0001
000010D4                           124  
000010D4                           125          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
000010D4                           126          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
000010D4  3007                     127          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
000010D6  0800 0008                128          BTST.L  #$08,D0
000010DA  6600 00C2                129          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
000010DE                           130          
000010DE                           131          *Now we can check bits 11-8 in the instruction and branch to different op-codes
000010DE                           132          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
000010DE  E048                     133          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
000010E0  0880 0004                134          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
000010E4  0880 0005                135          BCLR.L  #$05,D0
000010E8  0880 0006                136          BCLR.L  #$06,D0
000010EC  0880 0007                137          BCLR.L  #$07,D0
000010F0                           138          
000010F0                           139          *Perform compares with these 4 bits to see which specific instruction it is.
000010F0  B03C 0006                140          CMP.B   #$06,D0 *Is this an ADDI?
000010F4  6700 0028                141          BEQ     IS_ADDI
000010F8  B03C 0002                142          CMP.B   #$02,D0 *Is this an ANDI?
000010FC  6700 0068                143          BEQ     IS_ANDI
00001100  B03C 000A                144          CMP.B   #$0A,D0 *Is this an EORI?
00001104  6700 007C                145          BEQ     IS_EORI
00001108  B03C 0008                146          CMP.B   #$08,D0 *Is this a BCHG(static)?
0000110C  6700 00BE                147          BEQ     IS_BCHG_S
00001110  B03C 000C                148          CMP.B   #$0C,D0 *Is this a CMPI?
00001114  6700 00D2                149          BEQ     IS_CMPI
00001118                           150          
00001118                           151          *If we get through all of the compares without finding the specific instruction,
00001118                           152          *then this instruction is either not in our list of OP CODES to decode, or is an
00001118                           153          *invalid instruction/syntax.
00001118  4EF9 0000120A            154          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
0000111E                           155  
0000111E                           156  
0000111E                           157  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
0000111E                           158  IS_ADDI
0000111E                           159          *Don't need to verify anymore bits for this particular op code (all important
0000111E                           160          *opcode bits were 'verified' by getting here...)
0000111E                           161  
0000111E                           162          *Output some message, hey we found an ADDI instruction...
0000111E  43F9 0000175C            163          LEA     FNDADDI,A1  *Loads FNDADDI into address register A1
00001124  103C 000E                164          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001128  4E4F                     165          TRAP    #15         *Displays Message
0000112A                           166          
0000112A                           167          *Should have a valid IS_ADDI op code. Set data up for EA.
0000112A                           168                 
0000112A                           169          *Set D0 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000112A  3007                     170          MOVE.W  D7,D0   *Move the WHOLE instruction to D0
0000112C  EC48                     171          LSR.W   #$06,D0 *Shift the first 10 bits into LSB position
0000112E  0880 0008                172          BCLR.L  #$08,D0 *Set first 8 bits to 0, leaving only bits 7-6 of the instruction
00001132  0880 0009                173          BCLR.L  #$09,D0 *This should be a func (jsr) since a lot of instructions will do this...
00001136  0880 000A                174          BCLR.L  #$0A,D0 *SEE BFCLR
0000113A  0880 000B                175          BCLR.L  #$0B,D0        
0000113E  0880 000C                176          BCLR.L  #$0C,D0        
00001142  0880 000D                177          BCLR.L  #$0D,D0        
00001146  0880 000E                178          BCLR.L  #$0E,D0        
0000114A  0880 000F                179          BCLR.L  #$0F,D0
0000114E                           180          
0000114E                           181          *Set D1 to the EA mode of the operation located in bits 5-3 of the instruction        
0000114E  3207                     182          MOVE.W  D7,D1   *Move the WHOLE instruction to D1
00001150                           183          *Okay! So I thought of something weird to do... I am going to shift the instruction
00001150                           184          *to the LEFT by 10 bits, putting bits 5-0 of the original instruction into MSB position.
00001150  E149                     185          LSL.W   #$08,D1
00001152  E549                     186          LSL.W   #$02,D1
00001154                           187          *Now! I am going to shift the register to the RIGHT by 13 bits, leaving only bits 5-3
00001154                           188          *in LSB position, and the rest of the bits will be zero in the register.
00001154  E049                     189          LSR.W   #$08,D1
00001156  EA49                     190          LSR.W   #$05,D1
00001158                           191          *Now is this a better way than just shifting once and clearing like I did above with 'size'?
00001158                           192          
00001158                           193          *Set D2 to the EA register of the operation located in bits 2-0 of the instruction
00001158  3407                     194          MOVE.W  D7,D2   *Move the WHOLE instruction to D2
0000115A                           195          *TODO, REMEMBER LOOK INTO BFCLR
0000115A                           196          
0000115A  4EF9 00001160            197          JMP     EA_ADDI
00001160                           198  
00001160                           199  EA_ADDI
00001160                           200          *some code verifiying the integrity/syntax of the EA bits of the instruction
00001160                           201          *if bad EA, jump to BADEACODE, where i/o will take care of it
00001160                           202          
00001160                           203          *make sure when you leave an EA func that you also read in and either use
00001160                           204          *or ignore immediate/absoluate data, so that we can we ready to start reading
00001160                           205          *in the next instruction.
00001160  4EF9 0000122E            206          JMP     THEEND  *For now just end
00001166                           207  
00001166                           208  
00001166                           209  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
00001166                           210  IS_ANDI
00001166                           211          *TODO:Verify bits
00001166                           212  
00001166                           213          *Output some message, hey we found an ANDI instruction...
00001166  43F9 00001773            214          LEA     FNDANDI,A1  *Loads FNDANDI into address register A1
0000116C  103C 000E                215          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001170  4E4F                     216          TRAP    #15         *Displays Message
00001172                           217          
00001172                           218          *Should have a valid IS_ANDI op code. Set data up for EA.
00001172                           219          *TODO:
00001172  163C 000E                220          MOVE.B  #14,D3
00001176  4EF9 0000117C            221          JMP     EA_ANDI
0000117C                           222  
0000117C                           223  EA_ANDI
0000117C  4EF9 0000122E            224          JMP     THEEND  *For now just end
00001182                           225  
00001182                           226  
00001182                           227  *Now we know this instruction is exactly EORI, lets set everything up for EA.
00001182                           228  IS_EORI
00001182                           229          *TODO:Verify bits
00001182                           230  
00001182                           231          *Output some message, hey we found an EORI instruction...
00001182  43F9 0000178A            232          LEA     FNDEORI,A1  *Loads FNDEORI into address register A1
00001188  103C 000E                233          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000118C  4E4F                     234          TRAP    #15         *Displays Message
0000118E                           235          
0000118E                           236          *Should have a valid IS_EORI op code. Set data up for EA.
0000118E                           237          *TODO:
0000118E  163C 000E                238          MOVE.B  #14,D3
00001192  4EF9 00001198            239          JMP     EA_EORI
00001198                           240  
00001198                           241  EA_EORI
00001198  4EF9 0000122E            242          JMP     THEEND  *For now just end
0000119E                           243  
0000119E                           244  
0000119E                           245  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
0000119E                           246  * everything up for EA if is a legit instruction. Assuming D0 holds full instruction.
0000119E                           247  IS_BCHG_D
0000119E  3007                     248          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
000011A0                           249          
000011A0                           250          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000011A0                           251          *invalid, branch to BADOPCODE
000011A0  0800 0007                252          BTST.L  #$07,D0
000011A4  6600 0064                253          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000011A8  0800 0006                254          BTST.L  #$06,D0
000011AC  6700 005C                255          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000011B0                           256          
000011B0                           257          *Output a message, hey we found a BCHG(dynamic) instruction...
000011B0  43F9 000017A1            258          LEA     FNDBCHG_D,A1    *Loads FNDBCHG_D into address register A1
000011B6  103C 000E                259          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000011BA  4E4F                     260          TRAP    #15             *Displays Message
000011BC                           261                  
000011BC                           262          *Should have a valid BCHG(dynamic) op code. Set data up for EA.
000011BC                           263          *TODO:
000011BC  163C 000E                264          MOVE.B  #14,D3
000011C0  4EF9 000011C6            265          JMP     EA_BCHG_D
000011C6                           266  
000011C6                           267  EA_BCHG_D
000011C6  4EF9 0000122E            268          JMP     THEEND  *For now just end
000011CC                           269  
000011CC                           270  
000011CC                           271  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
000011CC                           272  IS_BCHG_S
000011CC                           273          *TODO:Verify bits
000011CC                           274  
000011CC                           275          *Output some message, hey we found an BCHG_S instruction...
000011CC  43F9 000017C0            276          LEA     FNDBCHG_S,A1    *Loads FNDBCHG_S into address register A1
000011D2  103C 000E                277          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000011D6  4E4F                     278          TRAP    #15             *Displays Message
000011D8                           279          
000011D8                           280          *Should have a valid IS_BCHG_S op code. Set data up for EA.
000011D8                           281          *TODO:
000011D8  163C 000E                282          MOVE.B  #14,D3
000011DC  4EF9 000011E2            283          JMP     EA_BCHG_S
000011E2                           284  
000011E2                           285  EA_BCHG_S
000011E2  4EF9 0000122E            286          JMP     THEEND  *For now just end
000011E8                           287  
000011E8                           288  
000011E8                           289  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000011E8                           290  IS_CMPI
000011E8                           291          *TODO:Verify bits
000011E8                           292  
000011E8                           293          *Output some message, hey we found an CMPI instruction...
000011E8  43F9 000017DE            294          LEA     FNDCMPI,A1  *Loads FNDCMPI into address register A1
000011EE  103C 000E                295          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000011F2  4E4F                     296          TRAP    #15         *Displays Message
000011F4                           297          
000011F4                           298          *Should have a valid IS_CMPI op code. Set data up for EA.
000011F4                           299          *TODO:
000011F4  163C 000E                300          MOVE.B  #14,D3
000011F8  4EF9 000011FE            301          JMP     EA_CMPI
000011FE                           302  
000011FE                           303  EA_CMPI
000011FE  4EF9 0000122E            304          JMP     THEEND  *For now just end
00001204                           305  
00001204                           306  
00001204                           307  *STARTS WITH 0001, MOVE.B-----------------------------------
00001204                           308  BUCKET_0001
00001204  =00000001                309  BUCKET0001_BITS EQU $1
00001204                           310          
00001204                           311          *some code...
00001204                           312  
00001204                           313  
00001204                           314  *STARTS WITH 0010, MOVE.L-----------------------------------
00001204                           315  BUCKET_0010
00001204  =00000002                316  BUCKET0010_BITS EQU $2
00001204                           317  
00001204                           318          *some code...
00001204                           319  
00001204                           320  
00001204                           321  *STARTS WITH 0011, MOVE.W-----------------------------------
00001204                           322  BUCKET_0011
00001204  =00000003                323  BUCKET0011_BITS EQU $3
00001204                           324  
00001204                           325          *some code...
00001204                           326  
00001204                           327  
00001204                           328  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
00001204                           329  BUCKET_0100
00001204  =00000004                330  BUCKET0100_BITS EQU $4
00001204                           331  
00001204                           332          *some code...
00001204                           333  
00001204                           334  
00001204                           335  *STARTS WITH 0101, SUBQ-------------------------------------
00001204                           336  BUCKET_0101
00001204  =00000005                337  BUCKET0101_BITS EQU $5
00001204                           338  
00001204                           339          *some code...
00001204                           340  
00001204                           341  
00001204                           342  *STARTS WITH 0110, BCC--------------------------------------
00001204                           343  BUCKET_0110
00001204  =00000006                344  BUCKET0110_BITS EQU $6
00001204                           345  
00001204                           346          *some code...
00001204                           347  
00001204                           348  
00001204                           349  *STARTS WITH 1000, DIVU-------------------------------------
00001204                           350  BUCKET_1000
00001204  =00000008                351  BUCKET1000_BITS EQU $8
00001204                           352  
00001204                           353          *some code...
00001204                           354  
00001204                           355  
00001204                           356  *STARTS WITH 1001, SUBA-------------------------------------
00001204                           357  BUCKET_1001
00001204  =00000009                358  BUCKET1001_BITS EQU $9
00001204                           359  
00001204                           360          *some code...
00001204                           361  
00001204                           362  
00001204                           363  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
00001204                           364  BUCKET_1011
00001204  =0000000B                365  BUCKET1011_BITS EQU $B
00001204                           366  
00001204                           367          *some code...
00001204                           368  
00001204                           369  
00001204                           370  *STARTS WITH 1100, MULS(W) | AND----------------------------
00001204                           371  BUCKET_1100
00001204  =0000000C                372  BUCKET1100_BITS EQU $C
00001204                           373  
00001204                           374          *some code...
00001204                           375  
00001204                           376  
00001204                           377  *STARTS WITH 1101, ADD | ADDA-------------------------------
00001204                           378  BUCKET_1101
00001204  =0000000D                379  BUCKET1101_BITS EQU $D
00001204                           380  
00001204                           381          *some code...
00001204                           382  
00001204                           383  
00001204                           384  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
00001204                           385  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
00001204                           386  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
00001204                           387  BUCKET_1110
00001204  =0000000E                388  BUCKET1110_BITS EQU $E     
00001204                           389  
00001204                           390          *some code...
00001204                           391  
00001204                           392  
00001204                           393  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
00001204                           394  *for this disassembler, jump to BADOPCODE and let I/O take care of it
00001204  4EF9 0000120A            395          JMP     BADOPCODE  
0000120A                           396          
0000120A                           397          
0000120A                           398  BADOPCODE
0000120A                           399          *We found a bad op code, output some error to the screen, jump to the 
0000120A                           400          *next instruction in memory.
0000120A                           401          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
0000120A                           402          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
0000120A                           403          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
0000120A                           404          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
0000120A                           405          *i/o and error message code...
0000120A  43F9 00001804            406          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001210  103C 000E                407          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001214  4E4F                     408          TRAP    #15         *Displays Message
00001216  4EF8 10BC                409          JMP     GRAB_NEXT_OP
0000121A                           410          
0000121A                           411          
0000121A                           412  BADEACODE
0000121A                           413          *We found a bad ea code, output some error to the screen, jump to the
0000121A                           414          *next instruction in memory.
0000121A                           415          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
0000121A                           416          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
0000121A  43F9 000017F4            417          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001220  103C 000E                418          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001224  4E4F                     419          TRAP    #15         *Displays Message
00001226  4EF8 10BC                420          JMP     GRAB_NEXT_OP
0000122A                           421          
0000122A                           422  *-----------------------------------------------------------        
0000122A                           423  * End of Disassembler
0000122A                           424  *-----------------------------------------------------------    
0000122A                           425  
0000122A  4E72 2700                426  DONE    STOP    #$2700  *What does this do? Why was it added?
0000122E                           427  
0000122E  103C 0009                428  THEEND  MOVE.B  #9,D0
00001232  4E4F                     429          TRAP    #15             Halt Simulator        
00001234                           430          
00001234  =0000000D                431  CR      EQU     $0D             ASCII code for Carriage Return
00001234  =0000000A                432  LF      EQU     $0A             ASCII code for Line Feed
00001234= 2D 2D 2D 2D 2D 2D ...    433  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001273= 7C 7C 20 20 20 20 ...    434              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
000012B2= 2D 2D 2D 2D 2D 2D ...    435              DC.B    '-------------------------------------------------------------',CR,LF
000012F1= 2A 2A 2A 2A 2A 2A ...    436              DC.B    '*************************************************************',CR,LF
00001330= 2A 2A 2A 2A 2A 2A ...    437              DC.B    '*************************************************************',CR,LF
0000136F= 2A 2A 2A 2A 2A 2A ...    438              DC.B    '******           ***        ***           ****    ***********',CR,LF
000013AE= 2A 2A 2A 2A 2A 2A ...    439              DC.B    '************    ****   ************   *******  **  **********',CR,LF
000013ED= 2A 2A 2A 2A 2A 2A ...    440              DC.B    '**********    ******        *******   ******        *********',CR,LF
0000142C= 2A 2A 2A 2A 2A 2A ...    441              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
0000146B= 2A 2A 2A 2A 2A 2A ...    442              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
000014AA= 2A 2A 2A 2A 2A 2A ...    443              DC.B    '*************************************************************',CR,LF
000014E9= 2A 2A 2A 2A 2A 2A ...    444              DC.B    '*************************************************************',CR,LF
00001528= 2A 20 20 20 20 20 ...    445              DC.B    '*                                                           *',CR,LF
00001567= 2A 20 41 75 74 68 ...    446              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
000015A6= 2A 20 20 20 20 20 ...    447              DC.B    '*                                                           *',CR,LF
000015E5= 2A 2A 2A 2A 2A 2A ...    448              DC.B    '*************************************************************',CR,LF,CR,LF
00001626= 53 74 61 72 74 69 ...    449              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001643                           450              
00001643= 57 6F 75 6C 64 20 ...    451  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001674                           452  
00001674= 20 0D 0A                 453  GETSTRTADDR DC.B    ' ',CR,LF
00001677= 50 6C 65 61 73 65 ...    454              DC.B    'Please type in your starting address request: ',0
000016A6                           455              
000016A6= 20 0D 0A                 456  GETENDADDR  DC.B    ' ',CR,LF
000016A9= 50 6C 65 61 73 65 ...    457              DC.B    'Please type in your ending address request: ',0
000016D6                           458              
000016D6= 20 0D 0A                 459  QUIT_MSG    DC.B    ' ',CR,LF
000016D9= 57 6F 75 6C 64 20 ...    460              DC.B    'Would you like to quit (Y/N)? ',0
000016F8                           461  
000016F8                           462  *****************************************************
000016F8                           463  * I/O storages - assuming users knows what to do.
000016F8                           464  *****************************************************
000016F8                           465  CMD_HLD     DS.B    30
00001716                           466  CMD_SZ      DS.B    30
00001734                           467  STADDR      DS.B    10
0000173E                           468  STADDRSZ    DS.B    10
00001748                           469  ENDADDR     DS.B    10
00001752                           470  ENDADDRSZ   DS.B    10
0000175C                           471  *****************************************************
0000175C                           472  
0000175C                           473  *for now, i guess every OPCODE will have a corresponding 'found it' msg...
0000175C= 46 6F 75 6E 64 20 ...    474  FNDADDI     DC.B    'Found an ADDI opcode',CR,LF,0
00001773= 46 6F 75 6E 64 20 ...    475  FNDANDI     DC.B    'Found an ANDI opcode',CR,LF,0
0000178A= 46 6F 75 6E 64 20 ...    476  FNDEORI     DC.B    'Found an EORI opcode',CR,LF,0
000017A1= 46 6F 75 6E 64 20 ...    477  FNDBCHG_D   DC.B    'Found a BCHG(dynamic) opcode',CR,LF,0
000017C0= 46 6F 75 6E 64 20 ...    478  FNDBCHG_S   DC.B    'Found a BCHG(static) opcode',CR,LF,0
000017DE= 46 6F 75 6E 64 20 ...    479  FNDCMPI     DC.B    'Found a CMPI opcode',CR,LF,0
000017F4                           480  
000017F4= 42 41 44 20 45 41 ...    481  BADEAMSG    DC.B    'BAD EA, WHY?!',CR,LF,0
00001804= 42 41 44 20 4F 50 ...    482  BADOPMSG    DC.B    'BAD OP CODE, WHY?!',CR,LF,0
00001819= 49 6D 70 72 6F 70 ...    483  INV_MSG     DC.B    'Improper command.',CR,LF,0
0000182D= 49 6E 76 61 6C 69 ...    484  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
00001846                           485          
00001846                           486          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BADEACODE           121A
BADEAMSG            17F4
BADOPCODE           120A
BADOPMSG            1804
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         10C8
BUCKET_0001         1204
BUCKET_0010         1204
BUCKET_0011         1204
BUCKET_0100         1204
BUCKET_0101         1204
BUCKET_0110         1204
BUCKET_1000         1204
BUCKET_1001         1204
BUCKET_1011         1204
BUCKET_1100         1204
BUCKET_1101         1204
BUCKET_1110         1204
CHECKSTRT1          10AA
CHECK_LOWN          1058
CHECK_LOWY          1040
CHECK_UPN           104C
CHECK_UPY           1034
CMD_HLD             16F8
CMD_SZ              1716
CR                  D
DONE                122A
EA_ADDI             1160
EA_ANDI             117C
EA_BCHG_D           11C6
EA_BCHG_S           11E2
EA_CMPI             11FE
EA_EORI             1198
ENDADDR             1748
ENDADDRSZ           1752
FNDADDI             175C
FNDANDI             1773
FNDBCHG_D           17A1
FNDBCHG_S           17C0
FNDCMPI             17DE
FNDEORI             178A
GETENDADDR          16A6
GETSTRTADDR         1674
GRAB_NEXT_OP        10BC
INVALID1            1064
INVSTRTMSG          182D
INV_MSG             1819
INV_STRT1           1078
IS_ADDI             111E
IS_ANDI             1166
IS_BCHG_D           119E
IS_BCHG_S           11CC
IS_CMPI             11E8
IS_EORI             1182
LF                  A
LOOP_1              1014
MESSAGE             1234
NXT_CMD             108A
QUIT_MSG            16D6
STACK               7000
STADDR              1734
STADDRSZ            173E
START               1000
STARTASSEM          1643
ST_ADDR             7FC0
THEEND              122E
