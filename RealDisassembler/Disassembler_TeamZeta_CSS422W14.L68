00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 2:35:16 AM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/11/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC6                  9  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00001000                            11  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 12              LEA stack,SP
00001004                            13  
00001004                            14  
00001004                            15  *-----------------------------------------------------------
00001004                            16  * Start of I/O
00001004                            17  *-----------------------------------------------------------            
00001004  43F9 00001AAE             18              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100A  103C 000E                 19              MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000100E  4E4F                      20              TRAP    #15         *Displays Message
00001010                            21          
00001010  303C 0000                 22  loop_1      MOVE    #0,D0       
00001014  43F9 00001EBD             23              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101A  103C 000E                 24              MOVE.B  #14,D0
0000101E  4E4F                      25              TRAP    #15    
00001020  303C 0002                 26              MOVE    #2,D0
00001024  43F9 00001F72             27              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102A  4E4F                      28              TRAP    #15
0000102C  0C01 0001                 29              CMPI.B  #01,D1
00001030  6600 00F2                 30              BNE     INVALID1
00001034  6000 00CE                 31              BRA     CHECK_UPY
00001038                            32  *-----------------------------------------------------------
00001038                            33  *
00001038                            34  * I/O: Check Start Address
00001038                            35  *
00001038                            36  * Make sure that start address starts after allocated 
00001038                            37  * memory addresses. Else, it will print out a message 
00001038                            38  * saying that requested address is invalid & prompts the
00001038                            39  * user again for the starting address.
00001038                            40  *-----------------------------------------------------------
00001038  43F9 00001EEE             41  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
0000103E  103C 000E                 42              MOVE.B  #14,D0
00001042  4E4F                      43              TRAP    #15
00001044  43F9 00001FAE             44              LEA     STADDR,A1   *Need to change where it can hold the start/end address
0000104A  3239 00001FB8             45              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001050  303C 0002                 46              MOVE    #2,D0           *Get start address
00001054  4E4F                      47              TRAP    #15
00001056  4EB9 000010D8             48              JSR     CHECKSTRT1
0000105C  4287                      49              CLR.L   D7
0000105E  4EB9 00001164             50              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
00001064  0C03 0001                 51              CMPI.B  #01,D3      *Check if there was a bad start
00001068  6700 00D2                 52              BEQ     INV_STRT1   *Prints error message if there was a bad start
0000106C  0C87 00007FC6             53              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001072  6D00 00C8                 54              BLT     INV_STRT1   *Asks for another start address if invalid
00001076  0C87 00FFFFFE             55              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
0000107C  6C00 00BE                 56              BGE     INV_STRT1
00001080  23C7 00001FC2             57              MOVE.L  D7,PROGST
00001086                            58  
00001086  43F9 00001F20             59  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
0000108C  103C 000E                 60              MOVE.B  #14,D0
00001090  4E4F                      61              TRAP    #15
00001092  43F9 00001FC6             62              LEA     ENDADDR,A1      *Buffer to hold end address
00001098  3239 00001FD0             63              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
0000109E  303C 0002                 64              MOVE    #2,D0
000010A2  4E4F                      65              TRAP    #15
000010A4  4EB9 000010EE             66              JSR     CHECKEND1
000010AA  4287                      67              CLR.L   D7
000010AC  4EB9 00001164             68              JSR     ASCIIHEX
000010B2  0C03 0001                 69              CMPI.B  #01,D3
000010B6  6700 0098                 70              BEQ     INV_END1
000010BA  0C87 00001FC2             71              CMPI.L  #PROGST,D7
000010C0  6D00 008E                 72              BLT     INV_END1
000010C4  0C87 00FFFFFF             73              CMPI.L  #$00FFFFFF,D7
000010CA  6C00 0084                 74              BGE     INV_END1
000010CE  2079 00001FC2             75              MOVEA.L PROGST,A0
000010D4  6000 0286                 76              BRA     GRAB_NEXT_OP            
000010D8                            77                          
000010D8  0C81 00000008             78  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010DE  6E00 005C                 79              BGT     INV_STRT1
000010E2  0C81 00000000             80              CMPI.L  #00,D1
000010E8  6300 0052                 81              BLS     INV_STRT1
000010EC  4E75                      82              RTS         
000010EE                            83              
000010EE  0C81 00000008             84  CHECKEND1   CMPI.L  #08,D1
000010F4  6E00 005A                 85              BGT     INV_END1
000010F8  0C81 00000000             86              CMPI.L  #00,D1
000010FE  6300 0050                 87              BLS     INV_END1
00001102  4E75                      88              RTS
00001104                            89  
00001104                            90  *-----------------------------------------------------------
00001104                            91  * I/O: Input check for Y, y, N, n
00001104                            92  *-----------------------------------------------------------
00001104  0C11 0059                 93  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001108  6700 FF2E                 94              BEQ     GET_STRT
0000110C                            95              
0000110C  0C11 0079                 96  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
00001110  6700 FF26                 97              BEQ     GET_STRT
00001114                            98              
00001114  0C11 004E                 99  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001118  6700 098A                100              BEQ     DONE
0000111C                           101              
0000111C  0C11 006E                102  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001120  6700 0982                103              BEQ     DONE
00001124                           104              
00001124  163C 0000                105  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001128  303C 0000                106              MOVE    #0,D0       *Prints invalid command msg if not found
0000112C  43F9 00002140            107              LEA     INV_MSG,A1
00001132  303C 000E                108              MOVE    #14,D0
00001136  4E4F                     109              TRAP    #15
00001138  6000 FED6                110              BRA     loop_1
0000113C                           111              
0000113C  43F9 00002154            112  INV_STRT1   LEA     INVSTRTMSG,A1
00001142  103C 000E                113              MOVE.B  #14,D0
00001146  4E4F                     114              TRAP    #15
00001148  163C 0000                115              MOVE.B  #00,D3      *Reset flag
0000114C  6000 FEEA                116              BRA     GET_STRT        
00001150                           117              
00001150  43F9 0000216D            118  INV_END1    LEA     INVENDMSG,A1
00001156  103C 000E                119              MOVE.B  #14,D0
0000115A  4E4F                     120              TRAP    #15
0000115C  163C 0000                121              MOVE.B  #00,D3      *Reset flag
00001160  6000 FF24                122              BRA     GET_END
00001164                           123              
00001164                           124  *-----------------------------------------------------------
00001164                           125  * ASCII to Hex converter
00001164                           126  *
00001164                           127  * Checks and converts the ASCII value to the hex equivalent
00001164                           128  *-----------------------------------------------------------
00001164  48E7 6000                129  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001168  0C01 0000                130  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000116C  6700 0062                131              BEQ     exitSub     *Exit subroutine 
00001170  5301                     132              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001172  E99F                     133              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001174  1419                     134              MOVE.B  (A1)+,D2    *Takes the first char
00001176  0C02 0024                135              CMPI.B  #$24,D2     *See if the first char is $
0000117A  67EC                     136              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000117C  0C02 0030                137              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001180  6D00 004C                138              BLT     st_bad      *Put error message
00001184  0C02 0039                139              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001188  6F00 0026                140              BLE     CONV_NUM    *Convert to number, if so
0000118C  0C02 0041                141              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
00001190  6D00 003C                142              BLT     st_bad      *Put error message
00001194  0C02 0046                143              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
00001198  6F00 0020                144              BLE     CONV_UpL    *Convert to hex
0000119C  0C02 0061                145              CMPI.B  #$61,D2     *Checks for non-valid chars
000011A0  6D00 002C                146              BLT     st_bad
000011A4  0C02 0066                147              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011A8  6F00 001A                148              BLE     CONV_LoL    
000011AC  6E00 0020                149              BGT     st_bad      *Puts error message for anything greater than f value
000011B0                           150              
000011B0  0402 0030                151  CONV_NUM    SUBI.B  #$30,D2
000011B4  8E02                     152              OR.B    D2,D7
000011B6  4EF8 1168                153              JMP     ASCIIHEX1
000011BA  0402 0037                154  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011BE  8E02                     155              OR.B    D2,D7
000011C0  4EF8 1168                156              JMP     ASCIIHEX1
000011C4  0402 0057                157  CONV_LoL    SUBI.B  #$57,D2
000011C8  8E02                     158              OR.B    D2,D7
000011CA  4EF8 1168                159              JMP     ASCIIHEX1   
000011CE                           160  
000011CE  5203                     161  st_bad      ADDI.B  #01,D3
000011D0  4CDF 0006                162  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011D4  4E75                     163              RTS
000011D6                           164              
000011D6                           165  *-----------------------------------------------------------
000011D6                           166  * Hex to ASCII converter
000011D6                           167  *-----------------------------------------------------------
000011D6  48E7 4C00                168  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011DA  0C01 0000                169  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011DE  6700 002C                170              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011E2  B27C 0001                171              CMP.W   #01,D1          
000011E6  6700 003E                172              BEQ     CHNG_SZW
000011EA  6000 0006                173              BRA     CHNG_SZL        
000011EE                           174  
000011EE  48E7 4C00                175  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011F2  123C 0008                176  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
000011F6  0C01 0000                177  LOOP_L      CMPI.B  #00,D1
000011FA  6700 00CA                178              BEQ     EXIT_CONV
000011FE  5301                     179              SUBI.B  #01,D1
00001200  E99C                     180              ROL.L   #4,D4           * Shift it for next bit
00001202  2A04                     181              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001204  4EB9 00001240            182              JSR     CONV_LOOP
0000120A  60EA                     183              BRA     LOOP_L      
0000120C                           184  
0000120C  123C 0002                185  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001210  0C01 0000                186  LOOP_B      CMPI.B  #00,D1
00001214  6700 00B0                187              BEQ     EXIT_CONV
00001218  5301                     188              SUBI.B  #01,D1
0000121A  E91C                     189              ROL.B   #4,D4           * Shift it for next bit
0000121C  2A04                     190              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000121E  4EB9 00001240            191              JSR     CONV_LOOP
00001224  60EA                     192              BRA     LOOP_B
00001226                           193              
00001226  123C 0004                194  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000122A  0C01 0000                195  LOOP_W      CMPI.B  #00,D1
0000122E  6700 0096                196              BEQ     EXIT_CONV
00001232  5301                     197              SUBI.B  #01,D1
00001234  E95C                     198              ROL.W   #4,D4           * Shift it for next bit
00001236  2A04                     199              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001238  4EB9 00001240            200              JSR     CONV_LOOP
0000123E  60EA                     201              BRA     LOOP_W
00001240                           202  
00001240  0285 0000000F            203  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001246  0C05 0000                204              CMPI.B  #$0,D5
0000124A  6700 0088                205              BEQ     NUM_0
0000124E  0C05 0001                206              CMPI.B  #$1,D5
00001252  6700 0088                207              BEQ     NUM_1
00001256  0C05 0002                208              CMPI.B  #$2,D5
0000125A  6700 0088                209              BEQ     NUM_2
0000125E  0C05 0003                210              CMPI.B  #$3,D5
00001262  6700 0088                211              BEQ     NUM_3
00001266  0C05 0004                212              CMPI.B  #$4,D5
0000126A  6700 0088                213              BEQ     NUM_4
0000126E  0C05 0005                214              CMPI.B  #$5,D5
00001272  6700 0088                215              BEQ     NUM_5
00001276  0C05 0006                216              CMPI.B  #$6,D5
0000127A  6700 0088                217              BEQ     NUM_6
0000127E  0C05 0007                218              CMPI.B  #$7,D5
00001282  6700 0088                219              BEQ     NUM_7
00001286  0C05 0008                220              CMPI.B  #$8,D5
0000128A  6700 0088                221              BEQ     NUM_8
0000128E  0C05 0009                222              CMPI.B  #$9,D5
00001292  6700 0088                223              BEQ     NUM_9
00001296  0C05 000A                224              CMPI.B  #$A,D5
0000129A  6700 0088                225              BEQ     NUM_A
0000129E  0C05 000B                226              CMPI.B  #$B,D5
000012A2  6700 0088                227              BEQ     NUM_B
000012A6  0C05 000C                228              CMPI.B  #$C,D5
000012AA  6700 0088                229              BEQ     NUM_C
000012AE  0C05 000D                230              CMPI.B  #$D,D5
000012B2  6700 0088                231              BEQ     NUM_D
000012B6  0C05 000E                232              CMPI.B  #$E,D5
000012BA  6700 0088                233              BEQ     NUM_E
000012BE  0C05 000F                234              CMPI.B  #$F,D5
000012C2  6700 0088                235              BEQ     NUM_F
000012C6                           236              
000012C6  4CDF 0032                237  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012CA  4E75                     238              RTS
000012CC                           239              
000012CC  303C 000E                240  PRINT_NUM   MOVE    #14,D0
000012D0  4E4F                     241              TRAP    #15
000012D2  4E75                     242              RTS
000012D4  43F9 00001FDE            243  NUM_0       LEA     PRNT0,A1
000012DA  60F0                     244              BRA     PRINT_NUM
000012DC  43F9 00001FE0            245  NUM_1       LEA     PRNT1,A1
000012E2  60E8                     246              BRA     PRINT_NUM
000012E4  43F9 00001FE2            247  NUM_2       LEA     PRNT2,A1
000012EA  60E0                     248              BRA     PRINT_NUM
000012EC  43F9 00001FE4            249  NUM_3       LEA     PRNT3,A1
000012F2  60D8                     250              BRA     PRINT_NUM
000012F4  43F9 00001FE6            251  NUM_4       LEA     PRNT4,A1
000012FA  60D0                     252              BRA     PRINT_NUM
000012FC  43F9 00001FE8            253  NUM_5       LEA     PRNT5,A1
00001302  60C8                     254              BRA     PRINT_NUM
00001304  43F9 00001FEA            255  NUM_6       LEA     PRNT6,A1
0000130A  60C0                     256              BRA     PRINT_NUM
0000130C  43F9 00001FEC            257  NUM_7       LEA     PRNT7,A1
00001312  60B8                     258              BRA     PRINT_NUM
00001314  43F9 00001FEE            259  NUM_8       LEA     PRNT8,A1
0000131A  60B0                     260              BRA     PRINT_NUM
0000131C  43F9 00001FF0            261  NUM_9       LEA     PRNT9,A1
00001322  60A8                     262              BRA     PRINT_NUM
00001324  43F9 00001FF2            263  NUM_A       LEA     PRNTA,A1
0000132A  60A0                     264              BRA     PRINT_NUM
0000132C  43F9 00001FF4            265  NUM_B       LEA     PRNTB,A1
00001332  6098                     266              BRA     PRINT_NUM
00001334  43F9 00001FF6            267  NUM_C       LEA     PRNTC,A1
0000133A  6090                     268              BRA     PRINT_NUM
0000133C  43F9 00001FF8            269  NUM_D       LEA     PRNTD,A1
00001342  6088                     270              BRA     PRINT_NUM
00001344  43F9 00001FFA            271  NUM_E       LEA     PRNTE,A1
0000134A  6080                     272              BRA     PRINT_NUM
0000134C  43F9 00001FFC            273  NUM_F       LEA     PRNTF,A1
00001352  6000 FF78                274              BRA     PRINT_NUM
00001356                           275  
00001356                           276  *-----------------------------------------------------------        
00001356                           277  * Start of Disassembler
00001356                           278  *-----------------------------------------------------------
00001356                           279          *FOR DEBUGGING ONLY!!!
00001356  207C 00007FC6            280          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000135C                           281          
0000135C                           282  GRAB_NEXT_OP
0000135C                           283          *Check and see if A0 == end of test address. If so, go to end of program.
0000135C                           284          *some code...
0000135C                           285          
0000135C                           286          *Output the address of this instruction to console...
0000135C  2808                     287          MOVE.L  A0,D4
0000135E  4EB8 11EE                288          JSR     HEXASCIIREG
00001362                           289          
00001362                           290          *Output a tab (4 spaces) to console, just after the address...
00001362  43F9 0000210C            291          LEA     Tab,A1  *Loads Tab into address register A1
00001368  103C 000E                292          MOVE.B  #14,D0  *Moves the number 14 into data register D0
0000136C  4E4F                     293          TRAP    #15     *Displays Message
0000136E                           294          
0000136E                           295          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
0000136E                           296          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
0000136E                           297          *data that may be associated with the instruction.
0000136E                           298          *Post increment addr, A0 will point to the start of next instruction or will 
0000136E                           299          *point to the start of any immed/abso data with this current instruction
0000136E  4280                     300          CLR.L   D0
00001370  3018                     301          MOVE.W  (A0)+,D0
00001372                           302          *Copy the word data we just moved into D0 into D7. We are copying this data
00001372                           303          *So we always have a copy of the WHOLE instruction somewhere
00001372  4287                     304          CLR.L   D7
00001374  3E00                     305          MOVE.W  D0,D7
00001376                           306          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
00001376                           307          *four bits of the instruction. Once we have just the first four bits, we can
00001376                           308          *begin to see which 'bucket'/category this instruction falls into. 
00001376  E048                     309          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
00001378  E848                     310          LSR.W   #$04,D0
0000137A                           311          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
0000137A                           312          *list of buckets until we find which one this instruction falls into.
0000137A                           313  
0000137A                           314  
0000137A                           315  *-----------------------------------------------------------        
0000137A                           316  * Bucket 0000:
0000137A                           317  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
0000137A                           318  *                   BCHG(dynamic) | BCHG (static) | CMPI----
0000137A                           319  *-----------------------------------------------------------
0000137A                           320  BUCKET_0000
0000137A  =00000000                321  BUCKET0000_BITS EQU $0
0000137A  4281                     322          CLR.L   D1
0000137C                           323          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000137C  123C 0000                324          MOVE.B  #BUCKET0000_BITS,D1
00001380                           325          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
00001380                           326          *If equal, continue decoding. If not, branch to next bucket.
00001380  B200                     327          CMP.B   D0,D1
00001382  6600 02CE                328          BNE     BUCKET_0001
00001386                           329  
00001386                           330          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001386                           331          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001386  3007                     332          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001388  0800 0008                333          BTST.L  #$08,D0
0000138C  6600 01A4                334          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
00001390                           335          
00001390                           336          *Now we can check bits 11-8 in the instruction and branch to different op-codes
00001390                           337          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
00001390  E048                     338          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001392  0880 0004                339          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001396  0880 0005                340          BCLR.L  #$05,D0
0000139A  0880 0006                341          BCLR.L  #$06,D0
0000139E  0880 0007                342          BCLR.L  #$07,D0
000013A2                           343          
000013A2                           344          *Perform compares with these 4 bits to see which specific instruction it is.
000013A2  B03C 0006                345          CMP.B   #$06,D0 *Is this an ADDI?
000013A6  6700 0028                346          BEQ     IS_ADDI
000013AA  B03C 0002                347          CMP.B   #$02,D0 *Is this an ANDI?
000013AE  6700 0096                348          BEQ     IS_ANDI
000013B2  B03C 000A                349          CMP.B   #$0A,D0 *Is this an EORI?
000013B6  6700 0104                350          BEQ     IS_EORI
000013BA  B03C 0008                351          CMP.B   #$08,D0 *Is this a BCHG(static)?
000013BE  6700 0200                352          BEQ     IS_BCHG_S
000013C2  B03C 000C                353          CMP.B   #$0C,D0 *Is this a CMPI?
000013C6  6700 0214                354          BEQ     IS_CMPI
000013CA                           355          
000013CA                           356          *If we get through all of the compares without finding the specific instruction,
000013CA                           357          *then this instruction is either not in our list of OP CODES to decode, or is an
000013CA                           358          *invalid instruction/syntax.
000013CA  4EF9 00001A84            359          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000013D0                           360          
000013D0                           361          
000013D0                           362  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
000013D0                           363  IS_ADDI
000013D0                           364          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000013D0                           365          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000013D0  4281                     366          CLR.L   D1
000013D2  3207                     367          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000013D4  C27C 00C0                368          AND.W   #$00C0,D1   *Mask out everything but the size bits
000013D8  EC09                     369          LSR.B   #$06,D1     *Shift the size bits into LSB
000013DA                           370          
000013DA  B23C 0003                371          CMP.B   #$03,D1     *Compare the size bits to $3
000013DE  6700 06A4                372          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000013E2                           373          
000013E2                           374          *Output 'ADDI' to console...
000013E2  43F9 00001FFE            375          LEA     ADDI,A1     *Loads ADDI into address register A1
000013E8  103C 000E                376          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000013EC  4E4F                     377          TRAP    #15         *Displays Message
000013EE                           378          
000013EE                           379          
000013EE                           380          *Should have a valid ADDI op code. Set data up for EA.
000013EE                           381          
000013EE                           382          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000013EE  4282                     383          CLR.L   D2
000013F0  3407                     384          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000013F2  C47C 003C                385          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000013F6  E60A                     386          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000013F8                           387                  
000013F8                           388          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000013F8  4283                     389          CLR.L   D3
000013FA  3607                     390          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000013FC  C67C 0007                391          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001400                           392          
00001400  4EF9 00001406            393          JMP     EA_ADDI
00001406                           394  
00001406                           395  EA_ADDI
00001406                           396          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
00001406                           397          *and D3 holds the EA register.
00001406                           398          
00001406                           399          *Determine how much data to read in, depending on the size of the operation
00001406                           400          *output the size of the operation and the immediate data to console
00001406  4EB9 00001658            401          JSR     WrapperSizeImmediate
0000140C                           402          
0000140C                           403          *manually output a comma here...
0000140C  43F9 00002111            404          LEA     Comma,A1        *Loads Comma into address register A1
00001412  103C 000E                405          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001416  4E4F                     406          TRAP    #15             *Displays Message        
00001418                           407          
00001418                           408          *Determine which EA mode and thus Register/Mem Address this instruction used
00001418  B43C 0000                409          CMP.B   #$00,D2
0000141C  6700 02BC                410          BEQ     DataRegMode *If EA mode is a data register, output that
00001420                           411          
00001420  B43C 0002                412          CMP.B   #$02,D2
00001424  6700 02C4                413          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001428                           414          
00001428  B43C 0003                415          CMP.B   #$03,D2
0000142C  6700 02CC                416          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001430                           417          
00001430  B43C 0004                418          CMP.B   #$04,D2
00001434  6700 02CE                419          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001438                           420          
00001438  B43C 0007                421          CMP.B   #$07,D2
0000143C  6700 02D0                422          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001440                           423          
00001440                           424          *If the ea mode isn't equal to any of these, it is an invalid EA
00001440  4EF9 00001A94            425          JMP     BADEACODE                               
00001446                           426          
00001446                           427  
00001446                           428  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
00001446                           429  IS_ANDI
00001446                           430          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001446                           431          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001446  4281                     432          CLR.L   D1
00001448  3207                     433          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000144A  C27C 00C0                434          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000144E  EC09                     435          LSR.B   #$06,D1     *Shift the size bits into LSB
00001450                           436          
00001450  B23C 0003                437          CMP.B   #$03,D1     *Compare the size bits to $3
00001454  6700 062E                438          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001458                           439          
00001458                           440          *Output 'ANDI' to console...
00001458  43F9 00002003            441          LEA     ANDI,A1     *Loads ANDI into address register A1
0000145E  103C 000E                442          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001462  4E4F                     443          TRAP    #15         *Displays Message
00001464                           444          
00001464                           445          
00001464                           446          *Should have a valid ANDI op code. Set data up for EA.
00001464                           447          
00001464                           448          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001464  4282                     449          CLR.L   D2
00001466  3407                     450          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001468  C47C 003C                451          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
0000146C  E60A                     452          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000146E                           453                  
0000146E                           454          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000146E  4283                     455          CLR.L   D3
00001470  3607                     456          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001472  C67C 0007                457          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001476                           458          
00001476  4EF9 0000147C            459          JMP     EA_ANDI
0000147C                           460  
0000147C                           461  EA_ANDI
0000147C                           462          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
0000147C                           463          *and D3 holds the EA register.
0000147C                           464          
0000147C                           465          *Determine how much data to read in, depending on the size of the operation
0000147C                           466          *output the size of the operation and the immediate data to console
0000147C  4EB9 00001658            467          JSR     WrapperSizeImmediate
00001482                           468          
00001482                           469          *manually output a comma here...
00001482  43F9 00002111            470          LEA     Comma,A1        *Loads Comma into address register A1
00001488  103C 000E                471          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000148C  4E4F                     472          TRAP    #15             *Displays Message        
0000148E                           473          
0000148E                           474          *Determine which EA mode and thus Register/Mem Address this instruction used
0000148E  B43C 0000                475          CMP.B   #$00,D2
00001492  6700 0246                476          BEQ     DataRegMode *If EA mode is a data register, output that
00001496                           477          
00001496  B43C 0002                478          CMP.B   #$02,D2
0000149A  6700 024E                479          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000149E                           480          
0000149E  B43C 0003                481          CMP.B   #$03,D2
000014A2  6700 0256                482          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014A6                           483          
000014A6  B43C 0004                484          CMP.B   #$04,D2
000014AA  6700 0258                485          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014AE                           486          
000014AE  B43C 0007                487          CMP.B   #$07,D2
000014B2  6700 025A                488          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014B6                           489          
000014B6                           490          *If the ea mode isn't equal to any of these, it is an invalid EA
000014B6  4EF9 00001A94            491          JMP     BADEACODE
000014BC                           492          
000014BC                           493  
000014BC                           494  *Now we know this instruction is exactly EORI, lets set everything up for EA.
000014BC                           495  IS_EORI
000014BC                           496          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014BC                           497          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014BC  4281                     498          CLR.L   D1
000014BE  3207                     499          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014C0  C27C 00C0                500          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014C4  EC09                     501          LSR.B   #$06,D1     *Shift the size bits into LSB
000014C6                           502          
000014C6  B23C 0003                503          CMP.B   #$03,D1     *Compare the size bits to $3
000014CA  6700 05B8                504          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014CE                           505          
000014CE                           506          *Output 'EORI' to console...
000014CE  43F9 00002008            507          LEA     EORI,A1     *Loads EORI into address register A1
000014D4  103C 000E                508          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014D8  4E4F                     509          TRAP    #15         *Displays Message
000014DA                           510          
000014DA                           511          
000014DA                           512          *Should have a valid EORI op code. Set data up for EA.
000014DA                           513          
000014DA                           514          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014DA  4282                     515          CLR.L   D2
000014DC  3407                     516          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014DE  C47C 003C                517          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000014E2  E60A                     518          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000014E4                           519                  
000014E4                           520          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000014E4  4283                     521          CLR.L   D3
000014E6  3607                     522          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000014E8  C67C 0007                523          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000014EC                           524          
000014EC  4EF9 000014F2            525          JMP     EA_EORI
000014F2                           526  
000014F2                           527  EA_EORI
000014F2                           528          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
000014F2                           529          *and D3 holds the EA register.
000014F2                           530          
000014F2                           531          *Determine how much data to read in, depending on the size of the operation
000014F2                           532          *output the size of the operation and the immediate data to console
000014F2  4EB9 00001658            533          JSR     WrapperSizeImmediate
000014F8                           534          
000014F8                           535          *manually output a comma here...
000014F8  43F9 00002111            536          LEA     Comma,A1        *Loads Comma into address register A1
000014FE  103C 000E                537          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001502  4E4F                     538          TRAP    #15             *Displays Message        
00001504                           539          
00001504                           540          *Determine which EA mode and thus Register/Mem Address this instruction used
00001504  B43C 0000                541          CMP.B   #$00,D2
00001508  6700 01D0                542          BEQ     DataRegMode *If EA mode is a data register, output that
0000150C                           543          
0000150C  B43C 0002                544          CMP.B   #$02,D2
00001510  6700 01D8                545          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001514                           546          
00001514  B43C 0003                547          CMP.B   #$03,D2
00001518  6700 01E0                548          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000151C                           549          
0000151C  B43C 0004                550          CMP.B   #$04,D2
00001520  6700 01E2                551          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001524                           552          
00001524  B43C 0007                553          CMP.B   #$07,D2
00001528  6700 01E4                554          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000152C                           555          
0000152C                           556          *If the ea mode isn't equal to any of these, it is an invalid EA
0000152C  4EF9 00001A94            557          JMP     BADEACODE
00001532                           558  
00001532                           559  
00001532                           560  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
00001532                           561  * everything up for EA if is a legit instruction.
00001532                           562  IS_BCHG_D
00001532                           563          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
00001532                           564          *invalid, branch to BADOPCODE
00001532  3007                     565          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
00001534  0800 0007                566          BTST.L  #$07,D0
00001538  6600 054A                567          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
0000153C  0800 0006                568          BTST.L  #$06,D0
00001540  6700 0542                569          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
00001544                           570          
00001544                           571          *Output 'BCHG' to console...
00001544  43F9 0000200D            572          LEA     BCHG,A1         *Loads BCHG into address register A1
0000154A  103C 000E                573          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000154E  4E4F                     574          TRAP    #15             *Displays Message
00001550                           575                  
00001550                           576                  
00001550                           577          *Should have a valid BCHG op code. Set data up for EA.
00001550                           578  
00001550                           579          *Set D1 to the EA source register located in bits 11-9 of the instruction
00001550  4281                     580          CLR.L   D1
00001552  3207                     581          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001554  C27C 0E00                582          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
00001558  E009                     583          LSR.B   #$08,D1     *Shift the EA source register bits into LSB
0000155A  E209                     584          LSR.B   #$01,D1
0000155C                           585  
0000155C                           586          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000155C  4282                     587          CLR.L   D2
0000155E  3407                     588          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001560  C47C 003C                589          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001564  E60A                     590          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001566                           591                  
00001566                           592          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001566  4283                     593          CLR.L   D3
00001568  3607                     594          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000156A  C67C 0007                595          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000156E                           596  
0000156E  4EF9 00001574            597          JMP     EA_BCHG_D
00001574                           598  
00001574                           599  EA_BCHG_D
00001574                           600          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001574                           601          *D2 holds the EA mode, and D3 holds the EA register.
00001574                           602          
00001574                           603          *output the source register to console, flag D6 with a 1 so we come back...
00001574  48E7 0200                604          MOVEM.L  D6,-(SP)   *Push current contents of D6 into stack (line counter)
00001578  1C3C 0001                605          MOVE.B  #$01,D6
0000157C  4EB9 000016DA            606          JSR     DataRegMode
00001582  4CDF 0040                607          MOVEM.L (SP)+,D6    *Pull current contents of stack back into D6
00001586                           608          
00001586                           609          *manually output a comma here...
00001586  43F9 00002111            610          LEA     Comma,A1        *Loads Comma into address register A1
0000158C  103C 000E                611          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001590  4E4F                     612          TRAP    #15             *Displays Message
00001592                           613          
00001592                           614          *Determine which EA mode and thus Register/Mem Address this instruction used
00001592  B43C 0000                615          CMP.B   #$00,D2
00001596  6700 0142                616          BEQ     DataRegMode *If EA mode is a data register, output that
0000159A                           617          
0000159A  B43C 0002                618          CMP.B   #$02,D2
0000159E  6700 014A                619          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015A2                           620          
000015A2  B43C 0003                621          CMP.B   #$03,D2
000015A6  6700 0152                622          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015AA                           623          
000015AA  B43C 0004                624          CMP.B   #$04,D2
000015AE  6700 0154                625          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015B2                           626          
000015B2  B43C 0007                627          CMP.B   #$07,D2
000015B6  6700 0156                628          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015BA                           629          
000015BA                           630          *If the ea mode isn't equal to any of these, it is an invalid EA
000015BA  4EF9 00001A94            631          JMP     BADEACODE
000015C0                           632  
000015C0                           633  
000015C0                           634  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
000015C0                           635  IS_BCHG_S
000015C0                           636          *TODO:Verify bits
000015C0                           637  
000015C0                           638          *Output 'BCHG' to console...
000015C0  43F9 0000200D            639          LEA     BCHG,A1 *Loads FNDBCHG_S into address register A1
000015C6  103C 000E                640          MOVE.B  #14,D0  *Moves the number 14 into data register D0
000015CA  4E4F                     641          TRAP    #15     *Displays Message
000015CC                           642          
000015CC                           643          *Should have a valid BCHG_S op code. Set data up for EA.
000015CC                           644          *TODO:
000015CC  163C 000E                645          MOVE.B  #14,D3
000015D0  4EF9 000015D6            646          JMP     EA_BCHG_S
000015D6                           647  
000015D6                           648  EA_BCHG_S
000015D6  4EF9 00001AA8            649          JMP     THEEND  *For now just end
000015DC                           650  
000015DC                           651  
000015DC                           652  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000015DC                           653  IS_CMPI
000015DC                           654          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000015DC                           655          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000015DC  4281                     656          CLR.L   D1
000015DE  3207                     657          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015E0  C27C 00C0                658          AND.W   #$00C0,D1   *Mask out everything but the size bits
000015E4  EC09                     659          LSR.B   #$06,D1     *Shift the size bits into LSB
000015E6                           660          
000015E6  B23C 0003                661          CMP.B   #$03,D1     *Compare the size bits to $3
000015EA  6700 0498                662          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000015EE                           663          
000015EE                           664          *Output 'CMPI' to console...
000015EE  43F9 00002012            665          LEA     CMPI,A1     *Loads CMPI into address register A1
000015F4  103C 000E                666          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000015F8  4E4F                     667          TRAP    #15         *Displays Message
000015FA                           668          
000015FA                           669          
000015FA                           670          *Should have a valid CMPI op code. Set data up for EA.
000015FA                           671          
000015FA                           672          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015FA  4282                     673          CLR.L   D2
000015FC  3407                     674          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000015FE  C47C 003C                675          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001602  E60A                     676          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001604                           677                  
00001604                           678          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001604  4283                     679          CLR.L   D3
00001606  3607                     680          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001608  C67C 0007                681          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000160C                           682          
0000160C  4EF9 00001612            683          JMP     EA_CMPI
00001612                           684  
00001612                           685  EA_CMPI
00001612                           686          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
00001612                           687          *and D3 holds the EA register.
00001612                           688          
00001612                           689          *Determine how much data to read in, depending on the size of the operation
00001612                           690          *output the size of the operation and the immediate data to console
00001612  4EB9 00001658            691          JSR     WrapperSizeImmediate
00001618                           692          
00001618                           693          *manually output a comma here...
00001618  43F9 00002111            694          LEA     Comma,A1        *Loads Comma into address register A1
0000161E  103C 000E                695          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001622  4E4F                     696          TRAP    #15             *Displays Message
00001624                           697          
00001624                           698          *Determine which EA mode and thus Register/Mem Address this instruction used
00001624  B43C 0000                699          CMP.B   #$00,D2
00001628  6700 00B0                700          BEQ     DataRegMode *If EA mode is a data register, output that
0000162C                           701          
0000162C  B43C 0002                702          CMP.B   #$02,D2
00001630  6700 00B8                703          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001634                           704          
00001634  B43C 0003                705          CMP.B   #$03,D2
00001638  6700 00C0                706          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000163C                           707          
0000163C  B43C 0004                708          CMP.B   #$04,D2
00001640  6700 00C2                709          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001644                           710          
00001644  B43C 0007                711          CMP.B   #$07,D2
00001648  6700 00C4                712          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000164C                           713          
0000164C                           714          *If the ea mode isn't equal to any of these, it is an invalid EA
0000164C  4EF9 00001A94            715          JMP     BADEACODE
00001652                           716  
00001652                           717          
00001652                           718  *STARTS WITH 0001, MOVE.B-----------------------------------
00001652                           719  BUCKET_0001
00001652  =00000001                720  BUCKET0001_BITS EQU $1
00001652                           721          
00001652                           722          *some code...
00001652                           723  
00001652                           724  
00001652                           725  *STARTS WITH 0010, MOVE.L-----------------------------------
00001652                           726  BUCKET_0010
00001652  =00000002                727  BUCKET0010_BITS EQU $2
00001652                           728  
00001652                           729          *some code...
00001652                           730  
00001652                           731  
00001652                           732  *STARTS WITH 0011, MOVE.W-----------------------------------
00001652                           733  BUCKET_0011
00001652  =00000003                734  BUCKET0011_BITS EQU $3
00001652                           735  
00001652                           736          *some code...
00001652                           737  
00001652                           738  
00001652                           739  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
00001652                           740  BUCKET_0100
00001652  =00000004                741  BUCKET0100_BITS EQU $4
00001652                           742  
00001652                           743          *some code...
00001652                           744  
00001652                           745  
00001652                           746  *STARTS WITH 0101, SUBQ-------------------------------------
00001652                           747  BUCKET_0101
00001652  =00000005                748  BUCKET0101_BITS EQU $5
00001652                           749  
00001652                           750          *some code...
00001652                           751  
00001652                           752  
00001652                           753  *STARTS WITH 0110, BCC--------------------------------------
00001652                           754  BUCKET_0110
00001652  =00000006                755  BUCKET0110_BITS EQU $6
00001652                           756  
00001652                           757          *some code...
00001652                           758  
00001652                           759  
00001652                           760  *STARTS WITH 1000, DIVU-------------------------------------
00001652                           761  BUCKET_1000
00001652  =00000008                762  BUCKET1000_BITS EQU $8
00001652                           763  
00001652                           764          *some code...
00001652                           765  
00001652                           766  
00001652                           767  *STARTS WITH 1001, SUBA-------------------------------------
00001652                           768  BUCKET_1001
00001652  =00000009                769  BUCKET1001_BITS EQU $9
00001652                           770  
00001652                           771          *some code...
00001652                           772  
00001652                           773  
00001652                           774  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
00001652                           775  BUCKET_1011
00001652  =0000000B                776  BUCKET1011_BITS EQU $B
00001652                           777  
00001652                           778          *some code...
00001652                           779  
00001652                           780  
00001652                           781  *STARTS WITH 1100, MULS(W) | AND----------------------------
00001652                           782  BUCKET_1100
00001652  =0000000C                783  BUCKET1100_BITS EQU $C
00001652                           784  
00001652                           785          *some code...
00001652                           786  
00001652                           787  
00001652                           788  *STARTS WITH 1101, ADD | ADDA-------------------------------
00001652                           789  BUCKET_1101
00001652  =0000000D                790  BUCKET1101_BITS EQU $D
00001652                           791  
00001652                           792          *some code...
00001652                           793  
00001652                           794  
00001652                           795  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
00001652                           796  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
00001652                           797  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
00001652                           798  BUCKET_1110
00001652  =0000000E                799  BUCKET1110_BITS EQU $E     
00001652                           800  
00001652                           801          *some code...
00001652                           802  
00001652                           803  
00001652                           804  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
00001652                           805  *for this disassembler, jump to BADOPCODE and let I/O take care of it
00001652  4EF9 00001A84            806          JMP     BADOPCODE  
00001658                           807          
00001658                           808  
00001658                           809  *-----------------------------------------------------------        
00001658                           810  * EA operation size decoding functionality
00001658                           811  *-----------------------------------------------------------   
00001658                           812  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001658                           813  WrapperSizeImmediate
00001658  4284                     814          CLR.L   D4
0000165A                           815          *Depending on the EA Register, choose which size to decode
0000165A  B23C 0000                816          CMP.B   #$00,D1
0000165E  6700 0014                817          BEQ     ByteSizeImmediate
00001662                           818          
00001662  B23C 0001                819          CMP.B   #$01,D1
00001666  6700 002E                820          BEQ     WordSizeImmediate
0000166A                           821  
0000166A  B23C 0002                822          CMP.B   #$02,D1
0000166E  6700 0048                823          BEQ     LongSizeImmediate
00001672                           824          
00001672                           825  *Used to get back to what we were doing, after dealing with the specific size
00001672                           826  WrapperSizeImmediateEnd
00001672  4E75                     827          RTS
00001674                           828          
00001674                           829  ByteSizeImmediate
00001674  3818                     830          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
00001676                           831          
00001676                           832          *Output '.B' to console...
00001676  43F9 00002017            833          LEA     ByteSize,A1 *Loads ByteSize into address register A1
0000167C  103C 000E                834          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001680  4E4F                     835          TRAP    #15         *Displays Message
00001682                           836          
00001682                           837          *Output '#$' just before the immediate data
00001682  43F9 00002116            838          LEA     ShaBang,A1
00001688  103C 000E                839          MOVE.B  #14,D0
0000168C  4E4F                     840          TRAP    #15  
0000168E                           841          
0000168E                           842          *output the immediate data to console with the hex-ascii converter
0000168E  4EB8 11D6                843          JSR     HEXASCII
00001692                           844                  
00001692  4EF8 1672                845          JMP     WrapperSizeImmediateEnd
00001696                           846                  
00001696                           847  WordSizeImmediate
00001696  3818                     848          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001698                           849          
00001698                           850          *Output '.W' to console...
00001698  43F9 0000201E            851          LEA     WordSize,A1 *Loads WordSize into address register A1
0000169E  103C 000E                852          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000016A2  4E4F                     853          TRAP    #15         *Displays Message
000016A4                           854          
000016A4                           855          *Output '#$' just before the immediate data
000016A4  43F9 00002116            856          LEA     ShaBang,A1
000016AA  103C 000E                857          MOVE.B  #14,D0
000016AE  4E4F                     858          TRAP    #15  
000016B0                           859          
000016B0                           860          *output the immediate data to console with the hex-ascii converter
000016B0  4EB8 11D6                861          JSR     HEXASCII
000016B4                           862          
000016B4  4EF8 1672                863          JMP     WrapperSizeImmediateEnd
000016B8                           864                  
000016B8                           865  LongSizeImmediate
000016B8  2818                     866          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
000016BA                           867          
000016BA                           868          *Output '.L' to console...
000016BA  43F9 00002025            869          LEA     LongSize,A1 *Loads LongSize into address register A1
000016C0  103C 000E                870          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000016C4  4E4F                     871          TRAP    #15         *Displays Message
000016C6                           872          
000016C6                           873          *Output '#$' just before the immediate data
000016C6  43F9 00002116            874          LEA     ShaBang,A1
000016CC  103C 000E                875          MOVE.B  #14,D0
000016D0  4E4F                     876          TRAP    #15  
000016D2                           877          
000016D2                           878          *output the immediate data to console with the hex-ascii converter
000016D2  4EB8 11D6                879          JSR     HEXASCII
000016D6                           880          
000016D6  4EF8 1672                881          JMP     WrapperSizeImmediateEnd
000016DA                           882  
000016DA                           883  
000016DA                           884  *-----------------------------------------------------------        
000016DA                           885  * EA Mode/EA Register decoding functionality
000016DA                           886  *-----------------------------------------------------------        
000016DA                           887  DataRegMode
000016DA                           888          *Depending on the EA Register, output a different register number
000016DA  4EB9 00001718            889          JSR     WrapperDataReg        
000016E0                           890          
000016E0                           891          *if this was called for a destination decoding then we are done decoding this        
000016E0                           892          *instruction, go get the next instruction
000016E0  BC3C 0001                893          CMP.B   #$01,D6
000016E4  6600 FC76                894          BNE     GRAB_NEXT_OP
000016E8                           895          
000016E8                           896          *else this was a source decoding, rts back to we can keep decoding
000016E8  4E75                     897          RTS
000016EA                           898  
000016EA                           899  AddrDirectMode
000016EA                           900          *some code...
000016EA                           901  
000016EA                           902  AddrIndirectMode
000016EA                           903          *Depending on the EA Register, output a different register number
000016EA  4EB9 000017DA            904          JSR     WrapperAddrIndirect
000016F0                           905                          
000016F0                           906          *if this was called for a destination decoding then we are done decoding this        
000016F0                           907          *instruction, go get the next instruction
000016F0  BC3C 0001                908          CMP.B   #$01,D6
000016F4  6600 FC66                909          BNE     GRAB_NEXT_OP
000016F8                           910          
000016F8                           911          *else this was a source decoding, rts back to we can keep decoding
000016F8  4E75                     912          RTS
000016FA                           913  
000016FA                           914  AddrIndirectPostMode
000016FA                           915          *Depending on the EA Register, output a different register number
000016FA  4EB9 0000189C            916          JSR     WrapperAddrIndirectPost
00001700                           917  
00001700                           918          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001700                           919          *some wrapper (i'll define later)
00001700                           920          
00001700                           921          *else this was a destination EA decoding, we can just go get the next instruction
00001700                           922          *since there is no more decoding to do for the current instruction
00001700  4EF8 135C                923          JMP     GRAB_NEXT_OP
00001704                           924  
00001704                           925  AddrIndirectPreMode
00001704                           926          *Depending on the EA Register, output a different register number
00001704  4EB9 0000195E            927          JSR     WrapperAddrIndirectPre
0000170A                           928  
0000170A                           929          *need to read some flag, if this was called from a source EA decoding then jmp to 
0000170A                           930          *some wrapper (i'll define later)
0000170A                           931          
0000170A                           932          *else this was a destination EA decoding, we can just go get the next instruction
0000170A                           933          *since there is no more decoding to do for the current instruction
0000170A  4EF8 135C                934          JMP     GRAB_NEXT_OP
0000170E                           935  
0000170E                           936  AddrAbsoluteMode
0000170E                           937          *Depending on the EA Register, output a different register number
0000170E  4EB9 00001A20            938          JSR     WrapperAddrAbsolute        
00001714                           939  
00001714                           940          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001714                           941          *some wrapper (i'll define later)
00001714                           942          
00001714                           943          *else this was a destination EA decoding, we can just go get the next instruction
00001714                           944          *since there is no more decoding to do for the current instruction
00001714  4EF8 135C                945          JMP     GRAB_NEXT_OP
00001718                           946          
00001718                           947  ImmediateDataMode
00001718                           948          *some code        
00001718                           949          
00001718                           950          
00001718                           951  *-----------------------------------------------------------        
00001718                           952  * Output logic for all Data Registers (0-7)
00001718                           953  *-----------------------------------------------------------
00001718                           954  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001718                           955  WrapperDataReg
00001718                           956          *Depending on the EA destination register, output a different register number
00001718  B63C 0000                957          CMP.B   #$00,D3
0000171C  6700 003C                958          BEQ     DataReg0
00001720                           959          
00001720  B63C 0001                960          CMP.B   #$01,D3
00001724  6700 0044                961          BEQ     DataReg1
00001728                           962          
00001728  B63C 0002                963          CMP.B   #$02,D3
0000172C  6700 004C                964          BEQ     DataReg2
00001730                           965          
00001730  B63C 0003                966          CMP.B   #$03,D3
00001734  6700 0054                967          BEQ     DataReg3
00001738                           968          
00001738  B63C 0004                969          CMP.B   #$04,D3
0000173C  6700 005C                970          BEQ     DataReg4
00001740                           971          
00001740  B63C 0005                972          CMP.B   #$05,D3
00001744  6700 0064                973          BEQ     DataReg5
00001748                           974          
00001748  B63C 0006                975          CMP.B   #$06,D3
0000174C  6700 006C                976          BEQ     DataReg6
00001750                           977          
00001750  B63C 0007                978          CMP.B   #$07,D3
00001754  6700 0074                979          BEQ     DataReg7        
00001758                           980  
00001758                           981  *Used to get back to 'DataRegMode', after dealing with the specific register
00001758                           982  WrapperDataRegEnd
00001758  4E75                     983          RTS
0000175A                           984  
0000175A                           985  DataReg0
0000175A                           986          *Output the specific data register...
0000175A  43F9 0000202C            987          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
00001760  103C 000E                988          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001764  4E4F                     989          TRAP    #15             *Displays Message   
00001766                           990          
00001766  4EF8 1758                991          JMP     WrapperDataRegEnd
0000176A                           992  
0000176A                           993  DataReg1
0000176A  43F9 00002031            994          LEA     OutDataReg1,A1
00001770  103C 000E                995          MOVE.B  #14,D0
00001774  4E4F                     996          TRAP    #15
00001776                           997          
00001776  4EF8 1758                998          JMP     WrapperDataRegEnd
0000177A                           999  
0000177A                          1000  DataReg2
0000177A  43F9 00002036           1001          LEA     OutDataReg2,A1
00001780  103C 000E               1002          MOVE.B  #14,D0
00001784  4E4F                    1003          TRAP    #15
00001786                          1004  
00001786  4EF8 1758               1005          JMP     WrapperDataRegEnd
0000178A                          1006      
0000178A                          1007  DataReg3
0000178A  43F9 0000203B           1008          LEA     OutDataReg3,A1
00001790  103C 000E               1009          MOVE.B  #14,D0
00001794  4E4F                    1010          TRAP    #15
00001796                          1011  
00001796  4EF8 1758               1012          JMP     WrapperDataRegEnd
0000179A                          1013          
0000179A                          1014  DataReg4
0000179A  43F9 00002040           1015          LEA     OutDataReg4,A1
000017A0  103C 000E               1016          MOVE.B  #14,D0
000017A4  4E4F                    1017          TRAP    #15
000017A6                          1018  
000017A6  4EF8 1758               1019          JMP     WrapperDataRegEnd
000017AA                          1020                 
000017AA                          1021  DataReg5
000017AA  43F9 00002045           1022          LEA     OutDataReg5,A1
000017B0  103C 000E               1023          MOVE.B  #14,D0
000017B4  4E4F                    1024          TRAP    #15
000017B6                          1025  
000017B6  4EF8 1758               1026          JMP     WrapperDataRegEnd
000017BA                          1027          
000017BA                          1028  DataReg6
000017BA  43F9 0000204A           1029          LEA     OutDataReg6,A1 A1
000017C0  103C 000E               1030          MOVE.B  #14,D0
000017C4  4E4F                    1031          TRAP    #15
000017C6                          1032  
000017C6  4EF8 1758               1033          JMP     WrapperDataRegEnd
000017CA                          1034          
000017CA                          1035  DataReg7
000017CA  43F9 0000204F           1036          LEA     OutDataReg7,A1
000017D0  103C 000E               1037          MOVE.B  #14,D0
000017D4  4E4F                    1038          TRAP    #15
000017D6                          1039          
000017D6  4EF8 1758               1040          JMP     WrapperDataRegEnd
000017DA                          1041  
000017DA                          1042  
000017DA                          1043  *-----------------------------------------------------------        
000017DA                          1044  * Output logic for all Address Indirect Registers (0-7)
000017DA                          1045  *-----------------------------------------------------------     
000017DA                          1046  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000017DA                          1047  WrapperAddrIndirect
000017DA                          1048          *Depending on the EA Register, output a different register number
000017DA  B63C 0000               1049          CMP.B   #$00,D3
000017DE  6700 003C               1050          BEQ     AddrIndReg0
000017E2                          1051          
000017E2  B63C 0001               1052          CMP.B   #$01,D3
000017E6  6700 0044               1053          BEQ     AddrIndReg1
000017EA                          1054          
000017EA  B63C 0002               1055          CMP.B   #$02,D3
000017EE  6700 004C               1056          BEQ     AddrIndReg2
000017F2                          1057          
000017F2  B63C 0003               1058          CMP.B   #$03,D3
000017F6  6700 0054               1059          BEQ     AddrIndReg3
000017FA                          1060          
000017FA  B63C 0004               1061          CMP.B   #$04,D3
000017FE  6700 005C               1062          BEQ     AddrIndReg4
00001802                          1063          
00001802  B63C 0005               1064          CMP.B   #$05,D3
00001806  6700 0064               1065          BEQ     AddrIndReg5
0000180A                          1066          
0000180A  B63C 0006               1067          CMP.B   #$06,D3
0000180E  6700 006C               1068          BEQ     AddrIndReg6
00001812                          1069          
00001812  B63C 0007               1070          CMP.B   #$07,D3
00001816  6700 0074               1071          BEQ     AddrIndReg7
0000181A                          1072  
0000181A                          1073  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
0000181A                          1074  WrapperAddrIndirectEnd
0000181A  4E75                    1075          RTS        
0000181C                          1076  
0000181C                          1077  AddrIndReg0
0000181C                          1078          *Output the specific address indirect register...
0000181C  43F9 00002054           1079          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001822  103C 000E               1080          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001826  4E4F                    1081          TRAP    #15                 *Displays Message        
00001828                          1082          
00001828  4EF8 181A               1083          JMP     WrapperAddrIndirectEnd
0000182C                          1084  
0000182C                          1085  AddrIndReg1
0000182C  43F9 0000205B           1086          LEA     OutAddrIndReg1,A1
00001832  103C 000E               1087          MOVE.B  #14,D0
00001836  4E4F                    1088          TRAP    #15
00001838                          1089          
00001838  4EF8 181A               1090          JMP     WrapperAddrIndirectEnd
0000183C                          1091  
0000183C                          1092  AddrIndReg2
0000183C  43F9 00002062           1093          LEA     OutAddrIndReg2,A1
00001842  103C 000E               1094          MOVE.B  #14,D0
00001846  4E4F                    1095          TRAP    #15
00001848                          1096          
00001848  4EF8 181A               1097          JMP     WrapperAddrIndirectEnd
0000184C                          1098  
0000184C                          1099  AddrIndReg3
0000184C  43F9 00002069           1100          LEA     OutAddrIndReg3,A1
00001852  103C 000E               1101          MOVE.B  #14,D0
00001856  4E4F                    1102          TRAP    #15
00001858                          1103          
00001858  4EF8 181A               1104          JMP     WrapperAddrIndirectEnd
0000185C                          1105  
0000185C                          1106  AddrIndReg4
0000185C  43F9 00002070           1107          LEA     OutAddrIndReg4,A1
00001862  103C 000E               1108          MOVE.B  #14,D0
00001866  4E4F                    1109          TRAP    #15
00001868                          1110          
00001868  4EF8 181A               1111          JMP     WrapperAddrIndirectEnd
0000186C                          1112  
0000186C                          1113  AddrIndReg5
0000186C  43F9 00002077           1114          LEA     OutAddrIndReg5,A1
00001872  103C 000E               1115          MOVE.B  #14,D0
00001876  4E4F                    1116          TRAP    #15
00001878                          1117          
00001878  4EF8 181A               1118          JMP     WrapperAddrIndirectEnd
0000187C                          1119  
0000187C                          1120  AddrIndReg6
0000187C  43F9 0000207E           1121          LEA     OutAddrIndReg6,A1
00001882  103C 000E               1122          MOVE.B  #14,D0
00001886  4E4F                    1123          TRAP    #15
00001888                          1124          
00001888  4EF8 181A               1125          JMP     WrapperAddrIndirectEnd
0000188C                          1126  
0000188C                          1127  AddrIndReg7
0000188C  43F9 00002085           1128          LEA     OutAddrIndReg7,A1
00001892  103C 000E               1129          MOVE.B  #14,D0
00001896  4E4F                    1130          TRAP    #15
00001898                          1131          
00001898  4EF8 181A               1132          JMP     WrapperAddrIndirectEnd
0000189C                          1133          
0000189C                          1134          
0000189C                          1135  *-----------------------------------------------------------        
0000189C                          1136  * Output logic for all Address Indirect Post Increment Registers (0-7)
0000189C                          1137  *-----------------------------------------------------------     
0000189C                          1138  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
0000189C                          1139  WrapperAddrIndirectPost
0000189C                          1140          *Depending on the EA Register, output a different register number
0000189C  B63C 0000               1141          CMP.B   #$00,D3
000018A0  6700 003C               1142          BEQ     AddrIndPoReg0
000018A4                          1143          
000018A4  B63C 0001               1144          CMP.B   #$01,D3
000018A8  6700 0044               1145          BEQ     AddrIndPoReg1
000018AC                          1146          
000018AC  B63C 0002               1147          CMP.B   #$02,D3
000018B0  6700 004C               1148          BEQ     AddrIndPoReg2
000018B4                          1149          
000018B4  B63C 0003               1150          CMP.B   #$03,D3
000018B8  6700 0054               1151          BEQ     AddrIndPoReg3
000018BC                          1152          
000018BC  B63C 0004               1153          CMP.B   #$04,D3
000018C0  6700 005C               1154          BEQ     AddrIndPoReg4
000018C4                          1155          
000018C4  B63C 0005               1156          CMP.B   #$05,D3
000018C8  6700 0064               1157          BEQ     AddrIndPoReg5
000018CC                          1158          
000018CC  B63C 0006               1159          CMP.B   #$06,D3
000018D0  6700 006C               1160          BEQ     AddrIndPoReg6
000018D4                          1161          
000018D4  B63C 0007               1162          CMP.B   #$07,D3
000018D8  6700 0074               1163          BEQ     AddrIndPoReg7
000018DC                          1164  
000018DC                          1165  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
000018DC                          1166  WrapperAddrIndirectPostEnd
000018DC  4E75                    1167          RTS        
000018DE                          1168  
000018DE                          1169  AddrIndPoReg0
000018DE                          1170          *Output the specific address indirect post register...
000018DE  43F9 0000208C           1171          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
000018E4  103C 000E               1172          MOVE.B  #14,D0              *Moves the number 14 into data register D0
000018E8  4E4F                    1173          TRAP    #15                 *Displays Message        
000018EA                          1174          
000018EA  4EF8 18DC               1175          JMP     WrapperAddrIndirectPostEnd
000018EE                          1176  
000018EE                          1177  AddrIndPoReg1
000018EE  43F9 00002094           1178          LEA     OutAddrIndPoReg1,A1
000018F4  103C 000E               1179          MOVE.B  #14,D0
000018F8  4E4F                    1180          TRAP    #15
000018FA                          1181          
000018FA  4EF8 18DC               1182          JMP     WrapperAddrIndirectPostEnd
000018FE                          1183  
000018FE                          1184  AddrIndPoReg2
000018FE  43F9 0000209C           1185          LEA     OutAddrIndPoReg2,A1
00001904  103C 000E               1186          MOVE.B  #14,D0
00001908  4E4F                    1187          TRAP    #15
0000190A                          1188          
0000190A  4EF8 18DC               1189          JMP     WrapperAddrIndirectPostEnd
0000190E                          1190  
0000190E                          1191  AddrIndPoReg3
0000190E  43F9 000020A4           1192          LEA     OutAddrIndPoReg3,A1
00001914  103C 000E               1193          MOVE.B  #14,D0
00001918  4E4F                    1194          TRAP    #15
0000191A                          1195          
0000191A  4EF8 18DC               1196          JMP     WrapperAddrIndirectPostEnd
0000191E                          1197  
0000191E                          1198  AddrIndPoReg4
0000191E  43F9 000020AC           1199          LEA     OutAddrIndPoReg4,A1
00001924  103C 000E               1200          MOVE.B  #14,D0
00001928  4E4F                    1201          TRAP    #15
0000192A                          1202          
0000192A  4EF8 18DC               1203          JMP     WrapperAddrIndirectPostEnd
0000192E                          1204  
0000192E                          1205  AddrIndPoReg5
0000192E  43F9 000020B4           1206          LEA     OutAddrIndPoReg5,A1
00001934  103C 000E               1207          MOVE.B  #14,D0
00001938  4E4F                    1208          TRAP    #15
0000193A                          1209          
0000193A  4EF8 18DC               1210          JMP     WrapperAddrIndirectPostEnd
0000193E                          1211  
0000193E                          1212  AddrIndPoReg6
0000193E  43F9 000020BC           1213          LEA     OutAddrIndPoReg6,A1
00001944  103C 000E               1214          MOVE.B  #14,D0
00001948  4E4F                    1215          TRAP    #15
0000194A                          1216          
0000194A  4EF8 18DC               1217          JMP     WrapperAddrIndirectPostEnd
0000194E                          1218  
0000194E                          1219  AddrIndPoReg7
0000194E  43F9 000020C4           1220          LEA     OutAddrIndPoReg7,A1
00001954  103C 000E               1221          MOVE.B  #14,D0
00001958  4E4F                    1222          TRAP    #15
0000195A                          1223          
0000195A  4EF8 18DC               1224          JMP     WrapperAddrIndirectPostEnd
0000195E                          1225  
0000195E                          1226  
0000195E                          1227  *-----------------------------------------------------------        
0000195E                          1228  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
0000195E                          1229  *-----------------------------------------------------------     
0000195E                          1230  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
0000195E                          1231  WrapperAddrIndirectPre
0000195E                          1232          *Depending on the EA Register, output a different register number
0000195E  B63C 0000               1233          CMP.B   #$00,D3
00001962  6700 003C               1234          BEQ     AddrIndPrReg0
00001966                          1235          
00001966  B63C 0001               1236          CMP.B   #$01,D3
0000196A  6700 0044               1237          BEQ     AddrIndPrReg1
0000196E                          1238          
0000196E  B63C 0002               1239          CMP.B   #$02,D3
00001972  6700 004C               1240          BEQ     AddrIndPrReg2
00001976                          1241          
00001976  B63C 0003               1242          CMP.B   #$03,D3
0000197A  6700 0054               1243          BEQ     AddrIndPrReg3
0000197E                          1244          
0000197E  B63C 0004               1245          CMP.B   #$04,D3
00001982  6700 005C               1246          BEQ     AddrIndPrReg4
00001986                          1247          
00001986  B63C 0005               1248          CMP.B   #$05,D3
0000198A  6700 0064               1249          BEQ     AddrIndPrReg5
0000198E                          1250          
0000198E  B63C 0006               1251          CMP.B   #$06,D3
00001992  6700 006C               1252          BEQ     AddrIndPrReg6
00001996                          1253          
00001996  B63C 0007               1254          CMP.B   #$07,D3
0000199A  6700 0074               1255          BEQ     AddrIndPrReg7
0000199E                          1256  
0000199E                          1257  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
0000199E                          1258  WrapperAddrIndirectPreEnd
0000199E  4E75                    1259          RTS        
000019A0                          1260  
000019A0                          1261  AddrIndPrReg0
000019A0                          1262          *Output the specific address indirect post register...
000019A0  43F9 000020CC           1263          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
000019A6  103C 000E               1264          MOVE.B  #14,D0              *Moves the number 14 into data register D0
000019AA  4E4F                    1265          TRAP    #15                 *Displays Message        
000019AC                          1266          
000019AC  4EF8 199E               1267          JMP     WrapperAddrIndirectPreEnd
000019B0                          1268  
000019B0                          1269  AddrIndPrReg1
000019B0  43F9 000020D4           1270          LEA     OutAddrIndPrReg1,A1
000019B6  103C 000E               1271          MOVE.B  #14,D0
000019BA  4E4F                    1272          TRAP    #15
000019BC                          1273          
000019BC  4EF8 199E               1274          JMP     WrapperAddrIndirectPreEnd
000019C0                          1275  
000019C0                          1276  AddrIndPrReg2
000019C0  43F9 000020DC           1277          LEA     OutAddrIndPrReg2,A1
000019C6  103C 000E               1278          MOVE.B  #14,D0
000019CA  4E4F                    1279          TRAP    #15
000019CC                          1280          
000019CC  4EF8 199E               1281          JMP     WrapperAddrIndirectPreEnd
000019D0                          1282  
000019D0                          1283  AddrIndPrReg3
000019D0  43F9 000020E4           1284          LEA     OutAddrIndPrReg3,A1
000019D6  103C 000E               1285          MOVE.B  #14,D0
000019DA  4E4F                    1286          TRAP    #15
000019DC                          1287          
000019DC  4EF8 199E               1288          JMP     WrapperAddrIndirectPreEnd
000019E0                          1289  
000019E0                          1290  AddrIndPrReg4
000019E0  43F9 000020EC           1291          LEA     OutAddrIndPrReg4,A1
000019E6  103C 000E               1292          MOVE.B  #14,D0
000019EA  4E4F                    1293          TRAP    #15
000019EC                          1294          
000019EC  4EF8 199E               1295          JMP     WrapperAddrIndirectPreEnd
000019F0                          1296  
000019F0                          1297  AddrIndPrReg5
000019F0  43F9 000020F4           1298          LEA     OutAddrIndPrReg5,A1
000019F6  103C 000E               1299          MOVE.B  #14,D0
000019FA  4E4F                    1300          TRAP    #15
000019FC                          1301          
000019FC  4EF8 199E               1302          JMP     WrapperAddrIndirectPreEnd
00001A00                          1303  
00001A00                          1304  AddrIndPrReg6
00001A00  43F9 000020FC           1305          LEA     OutAddrIndPrReg6,A1
00001A06  103C 000E               1306          MOVE.B  #14,D0
00001A0A  4E4F                    1307          TRAP    #15
00001A0C                          1308          
00001A0C  4EF8 199E               1309          JMP     WrapperAddrIndirectPreEnd
00001A10                          1310  
00001A10                          1311  AddrIndPrReg7
00001A10  43F9 00002104           1312          LEA     OutAddrIndPrReg7,A1
00001A16  103C 000E               1313          MOVE.B  #14,D0
00001A1A  4E4F                    1314          TRAP    #15
00001A1C                          1315          
00001A1C  4EF8 199E               1316          JMP     WrapperAddrIndirectPreEnd
00001A20                          1317  
00001A20                          1318  
00001A20                          1319  *-----------------------------------------------------------        
00001A20                          1320  * Output logic for absolute memory addressing (0-7)
00001A20                          1321  *-----------------------------------------------------------     
00001A20                          1322  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001A20                          1323  WrapperAddrAbsolute
00001A20  4284                    1324          CLR.L   D4
00001A22                          1325          *Depending on the EA Register, choose which size to decode
00001A22  B63C 0000               1326          CMP.B   #$00,D3
00001A26  6700 000C               1327          BEQ     WordSizeAbsolute
00001A2A                          1328  
00001A2A  B63C 0001               1329          CMP.B   #$01,D3
00001A2E  6700 002C               1330          BEQ     LongSizeAbsolute
00001A32                          1331          
00001A32                          1332  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001A32                          1333  WrapperAddrAbsoluteEnd
00001A32  4E75                    1334          RTS
00001A34                          1335  
00001A34                          1336  WordSizeAbsolute        
00001A34  3818                    1337          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001A36                          1338          
00001A36                          1339          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001A36  4281                    1340          CLR.L   D1
00001A38  123C 0001               1341          MOVE.B  #$01,D1     
00001A3C                          1342              
00001A3C                          1343          *Output ',$' just after source operand
00001A3C  43F9 00002119           1344          LEA     Bang,A1
00001A42  103C 000E               1345          MOVE.B  #14,D0
00001A46  4E4F                    1346          TRAP    #15
00001A48                          1347              
00001A48                          1348          *output the absolute mem address to console with the hex-ascii converter
00001A48  4EB8 11D6               1349          JSR     HEXASCII
00001A4C                          1350          
00001A4C                          1351          *Print a new line, since this should be the last piece of data for an instruction
00001A4C  43F9 00002113           1352          LEA     NewLine,A1
00001A52  103C 000E               1353          MOVE.B  #14,D0
00001A56  4E4F                    1354          TRAP    #15
00001A58                          1355          
00001A58  4EF8 1A32               1356          JMP     WrapperAddrAbsoluteEnd
00001A5C                          1357  
00001A5C                          1358  LongSizeAbsolute
00001A5C  2818                    1359          MOVE.L  (A0)+,D4    *read in next long, data is that long
00001A5E                          1360                  
00001A5E                          1361          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001A5E  4281                    1362          CLR.L   D1
00001A60  123C 0010               1363          MOVE.B  #$10,D1
00001A64                          1364                  
00001A64                          1365          *Output ',$' just after source operand
00001A64  43F9 00002119           1366          LEA     Bang,A1
00001A6A  103C 000E               1367          MOVE.B  #14,D0
00001A6E  4E4F                    1368          TRAP    #15  
00001A70                          1369          
00001A70                          1370          *output the absolute mem address to console with the hex-ascii converter
00001A70  4EB8 11D6               1371          JSR     HEXASCII
00001A74                          1372          
00001A74                          1373          *Print a new line, since this should be the last piece of data for an instruction
00001A74  43F9 00002113           1374          LEA     NewLine,A1
00001A7A  103C 000E               1375          MOVE.B  #14,D0
00001A7E  4E4F                    1376          TRAP    #15
00001A80                          1377  
00001A80  4EF8 1A32               1378          JMP     WrapperAddrAbsoluteEnd
00001A84                          1379          
00001A84                          1380  
00001A84                          1381  *-----------------------------------------------------------        
00001A84                          1382  * Current handling of bad op/ea codes. Should be revisited.
00001A84                          1383  *----------------------------------------------------------- 
00001A84                          1384  BADOPCODE
00001A84                          1385          *We found a bad op code, output some error to the screen, jump to the 
00001A84                          1386          *next instruction in memory.
00001A84                          1387          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001A84                          1388          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001A84                          1389          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001A84                          1390          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001A84                          1391          *i/o and error message code...
00001A84  43F9 0000212B           1392          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001A8A  103C 000E               1393          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A8E  4E4F                    1394          TRAP    #15         *Displays Message
00001A90  4EF8 135C               1395          JMP     GRAB_NEXT_OP
00001A94                          1396                  
00001A94                          1397  BADEACODE
00001A94                          1398          *We found a bad ea code, output some error to the screen, jump to the
00001A94                          1399          *next instruction in memory.
00001A94                          1400          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001A94                          1401          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001A94  43F9 0000211B           1402          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001A9A  103C 000E               1403          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A9E  4E4F                    1404          TRAP    #15         *Displays Message
00001AA0  4EF8 135C               1405          JMP     GRAB_NEXT_OP
00001AA4                          1406          
00001AA4                          1407          
00001AA4                          1408  *-----------------------------------------------------------        
00001AA4                          1409  * End of Disassembler
00001AA4                          1410  *-----------------------------------------------------------    
00001AA4                          1411  
00001AA4  4E72 2700               1412  DONE    STOP    #$2700  *What does this do? Why was it added?
00001AA8                          1413  
00001AA8  103C 0009               1414  THEEND  MOVE.B  #9,D0
00001AAC  4E4F                    1415          TRAP    #15             Halt Simulator        
00001AAE                          1416          
00001AAE                          1417       
00001AAE                          1418  *-----------------------------------------------------------        
00001AAE                          1419  * Output stuff
00001AAE                          1420  *-----------------------------------------------------------     
00001AAE  =0000000D               1421  CR      EQU     $0D             ASCII code for Carriage Return
00001AAE  =0000000A               1422  LF      EQU     $0A             ASCII code for Line Feed
00001AAE= 2D 2D 2D 2D 2D 2D ...   1423  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001AED= 7C 7C 20 20 20 20 ...   1424              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001B2C= 2D 2D 2D 2D 2D 2D ...   1425              DC.B    '-------------------------------------------------------------',CR,LF
00001B6B= 2A 2A 2A 2A 2A 2A ...   1426              DC.B    '*************************************************************',CR,LF
00001BAA= 2A 2A 2A 2A 2A 2A ...   1427              DC.B    '*************************************************************',CR,LF
00001BE9= 2A 2A 2A 2A 2A 2A ...   1428              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001C28= 2A 2A 2A 2A 2A 2A ...   1429              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001C67= 2A 2A 2A 2A 2A 2A ...   1430              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001CA6= 2A 2A 2A 2A 2A 2A ...   1431              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001CE5= 2A 2A 2A 2A 2A 2A ...   1432              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001D24= 2A 2A 2A 2A 2A 2A ...   1433              DC.B    '*************************************************************',CR,LF
00001D63= 2A 2A 2A 2A 2A 2A ...   1434              DC.B    '*************************************************************',CR,LF
00001DA2= 2A 20 20 20 20 20 ...   1435              DC.B    '*                                                           *',CR,LF
00001DE1= 2A 20 41 75 74 68 ...   1436              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001E20= 2A 20 20 20 20 20 ...   1437              DC.B    '*                                                           *',CR,LF
00001E5F= 2A 2A 2A 2A 2A 2A ...   1438              DC.B    '*************************************************************',CR,LF,CR,LF
00001EA0= 53 74 61 72 74 69 ...   1439              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001EBD                          1440              
00001EBD= 57 6F 75 6C 64 20 ...   1441  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001EEE                          1442  
00001EEE= 20 0D 0A                1443  GETSTRTADDR DC.B    ' ',CR,LF
00001EF1= 50 6C 65 61 73 65 ...   1444              DC.B    'Please type in your starting address request: ',0
00001F20                          1445              
00001F20= 20 0D 0A                1446  GETENDADDR  DC.B    ' ',CR,LF
00001F23= 50 6C 65 61 73 65 ...   1447              DC.B    'Please type in your ending address request: ',0
00001F50                          1448              
00001F50= 20 0D 0A                1449  QUIT_MSG    DC.B    ' ',CR,LF
00001F53= 57 6F 75 6C 64 20 ...   1450              DC.B    'Would you like to quit (Y/N)? ',0
00001F72                          1451  
00001F72                          1452  *****************************************************
00001F72                          1453  * I/O storages - assuming users knows what to do.
00001F72                          1454  *****************************************************
00001F72                          1455  CMD_HLD     DS.B    30
00001F90                          1456  CMD_SZ      DS.B    30
00001FAE                          1457  STADDR      DS.B    10
00001FB8                          1458  STADDRSZ    DS.B    10
00001FC2                          1459  PROGST      DS.L    1
00001FC6                          1460  ENDADDR     DS.B    10
00001FD0                          1461  ENDADDRSZ   DS.B    10
00001FDA                          1462  PROGEND     DS.L    1
00001FDE                          1463  *****************************************************
00001FDE                          1464  
00001FDE                          1465  *Table for 0-9 && A-F
00001FDE= 30 00                   1466  PRNT0   DC.B    '0',0
00001FE0= 31 00                   1467  PRNT1   DC.B    '1',0
00001FE2= 32 00                   1468  PRNT2   DC.B    '2',0
00001FE4= 33 00                   1469  PRNT3   DC.B    '3',0
00001FE6= 34 00                   1470  PRNT4   DC.B    '4',0
00001FE8= 35 00                   1471  PRNT5   DC.B    '5',0
00001FEA= 36 00                   1472  PRNT6   DC.B    '6',0
00001FEC= 37 00                   1473  PRNT7   DC.B    '7',0
00001FEE= 38 00                   1474  PRNT8   DC.B    '8',0
00001FF0= 39 00                   1475  PRNT9   DC.B    '9',0
00001FF2= 41 00                   1476  PRNTA   DC.B    'A',0
00001FF4= 42 00                   1477  PRNTB   DC.B    'B',0
00001FF6= 43 00                   1478  PRNTC   DC.B    'C',0
00001FF8= 44 00                   1479  PRNTD   DC.B    'D',0
00001FFA= 45 00                   1480  PRNTE   DC.B    'E',0
00001FFC= 46 00                   1481  PRNTF   DC.B    'F',0
00001FFE                          1482  
00001FFE                          1483  *output for all OPCODEs
00001FFE= 41 44 44 49 00          1484  ADDI    DC.B    'ADDI',0
00002003= 41 4E 44 49 00          1485  ANDI    DC.B    'ANDI',0
00002008= 45 4F 52 49 00          1486  EORI    DC.B    'EORI',0
0000200D= 42 43 48 47 00          1487  BCHG    DC.B    'BCHG',0
00002012= 43 4D 50 49 00          1488  CMPI    DC.B    'CMPI',0
00002017                          1489  
00002017                          1490  *output for the size of the operation
00002017= 2E 42 20 20 20 20 00    1491  ByteSize    DC.B    '.B    ',0
0000201E= 2E 57 20 20 20 20 00    1492  WordSize    DC.B    '.W    ',0
00002025= 2E 4C 20 20 20 20 00    1493  LongSize    DC.B    '.L    ',0
0000202C                          1494  
0000202C                          1495  *output for all destination data registers (0-7)
0000202C= 44 30 0D 0A 00          1496  OutDataReg0 DC.B    'D0',CR,LF,0
00002031= 44 31 0D 0A 00          1497  OutDataReg1 DC.B    'D1',CR,LF,0
00002036= 44 32 0D 0A 00          1498  OutDataReg2 DC.B    'D2',CR,LF,0
0000203B= 44 33 0D 0A 00          1499  OutDataReg3 DC.B    'D3',CR,LF,0
00002040= 44 34 0D 0A 00          1500  OutDataReg4 DC.B    'D4',CR,LF,0
00002045= 44 35 0D 0A 00          1501  OutDataReg5 DC.B    'D5',CR,LF,0
0000204A= 44 36 0D 0A 00          1502  OutDataReg6 DC.B    'D6',CR,LF,0
0000204F= 44 37 0D 0A 00          1503  OutDataReg7 DC.B    'D7',CR,LF,0
00002054                          1504  
00002054                          1505  *output for all address indirect registers (0-7)
00002054= 28 41 30 29 0D 0A 00    1506  OutAddrIndReg0  DC.B    '(A0)',CR,LF,0
0000205B= 28 41 31 29 0D 0A 00    1507  OutAddrIndReg1  DC.B    '(A1)',CR,LF,0
00002062= 28 41 32 29 0D 0A 00    1508  OutAddrIndReg2  DC.B    '(A2)',CR,LF,0
00002069= 28 41 33 29 0D 0A 00    1509  OutAddrIndReg3  DC.B    '(A3)',CR,LF,0
00002070= 28 41 34 29 0D 0A 00    1510  OutAddrIndReg4  DC.B    '(A4)',CR,LF,0
00002077= 28 41 35 29 0D 0A 00    1511  OutAddrIndReg5  DC.B    '(A5)',CR,LF,0
0000207E= 28 41 36 29 0D 0A 00    1512  OutAddrIndReg6  DC.B    '(A6)',CR,LF,0
00002085= 28 41 37 29 0D 0A 00    1513  OutAddrIndReg7  DC.B    '(A7)',CR,LF,0
0000208C                          1514  
0000208C                          1515  *output for all address indirect post registers (0-7)
0000208C= 28 41 30 29 2B 0D ...   1516  OutAddrIndPoReg0    DC.B    '(A0)+',CR,LF,0
00002094= 28 41 31 29 2B 0D ...   1517  OutAddrIndPoReg1    DC.B    '(A1)+',CR,LF,0
0000209C= 28 41 32 29 2B 0D ...   1518  OutAddrIndPoReg2    DC.B    '(A2)+',CR,LF,0
000020A4= 28 41 33 29 2B 0D ...   1519  OutAddrIndPoReg3    DC.B    '(A3)+',CR,LF,0
000020AC= 28 41 34 29 2B 0D ...   1520  OutAddrIndPoReg4    DC.B    '(A4)+',CR,LF,0
000020B4= 28 41 35 29 2B 0D ...   1521  OutAddrIndPoReg5    DC.B    '(A5)+',CR,LF,0
000020BC= 28 41 36 29 2B 0D ...   1522  OutAddrIndPoReg6    DC.B    '(A6)+',CR,LF,0
000020C4= 28 41 37 29 2B 0D ...   1523  OutAddrIndPoReg7    DC.B    '(A7)+',CR,LF,0
000020CC                          1524  
000020CC                          1525  *output for all address indirect pre registers (0-7)
000020CC= 2D 28 41 30 29 0D ...   1526  OutAddrIndPrReg0    DC.B    '-(A0)',CR,LF,0
000020D4= 2D 28 41 31 29 0D ...   1527  OutAddrIndPrReg1    DC.B    '-(A1)',CR,LF,0
000020DC= 2D 28 41 32 29 0D ...   1528  OutAddrIndPrReg2    DC.B    '-(A2)',CR,LF,0
000020E4= 2D 28 41 33 29 0D ...   1529  OutAddrIndPrReg3    DC.B    '-(A3)',CR,LF,0
000020EC= 2D 28 41 34 29 0D ...   1530  OutAddrIndPrReg4    DC.B    '-(A4)',CR,LF,0
000020F4= 2D 28 41 35 29 0D ...   1531  OutAddrIndPrReg5    DC.B    '-(A5)',CR,LF,0
000020FC= 2D 28 41 36 29 0D ...   1532  OutAddrIndPrReg6    DC.B    '-(A6)',CR,LF,0
00002104= 2D 28 41 37 29 0D ...   1533  OutAddrIndPrReg7    DC.B    '-(A7)',CR,LF,0
0000210C                          1534  
0000210C                          1535  *output for a tab only (4 spaces)
0000210C= 20 20 20 20 00          1536  Tab DC.B    '    ',0
00002111                          1537  
00002111                          1538  *output for a comma only
00002111= 2C 00                   1539  Comma   DC.B    ',',0
00002113                          1540  
00002113                          1541  *output for a new line only
00002113= 0D 0A 00                1542  NewLine DC.B    CR,LF,0
00002116                          1543  
00002116                          1544  *output for a '#$' and '$' only
00002116= 23 24 00                1545  ShaBang DC.B    '#$',0
00002119= 24 00                   1546  Bang    DC.B    '$',0
0000211B                          1547  
0000211B                          1548  *current output for error messages
0000211B= 42 41 44 20 45 41 ...   1549  BADEAMSG    DC.B    'BAD EA, WHY?!',CR,LF,0
0000212B= 42 41 44 20 4F 50 ...   1550  BADOPMSG    DC.B    'BAD OP CODE, WHY?!',CR,LF,0
00002140= 49 6D 70 72 6F 70 ...   1551  INV_MSG     DC.B    'Improper command.',CR,LF,0
00002154= 49 6E 76 61 6C 69 ...   1552  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
0000216D= 49 6E 76 61 6C 69 ...   1553  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
00002184                          1554  
00002184                          1555          
00002184                          1556          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                1FFE
ADDRABSOLUTEMODE    170E
ADDRDIRECTMODE      16EA
ADDRINDIRECTMODE    16EA
ADDRINDIRECTPOSTMODE  16FA
ADDRINDIRECTPREMODE  1704
ADDRINDPOREG0       18DE
ADDRINDPOREG1       18EE
ADDRINDPOREG2       18FE
ADDRINDPOREG3       190E
ADDRINDPOREG4       191E
ADDRINDPOREG5       192E
ADDRINDPOREG6       193E
ADDRINDPOREG7       194E
ADDRINDPRREG0       19A0
ADDRINDPRREG1       19B0
ADDRINDPRREG2       19C0
ADDRINDPRREG3       19D0
ADDRINDPRREG4       19E0
ADDRINDPRREG5       19F0
ADDRINDPRREG6       1A00
ADDRINDPRREG7       1A10
ADDRINDREG0         181C
ADDRINDREG1         182C
ADDRINDREG2         183C
ADDRINDREG3         184C
ADDRINDREG4         185C
ADDRINDREG5         186C
ADDRINDREG6         187C
ADDRINDREG7         188C
ANDI                2003
ASCIIHEX            1164
ASCIIHEX1           1168
BADEACODE           1A94
BADEAMSG            211B
BADOPCODE           1A84
BADOPMSG            212B
BANG                2119
BCHG                200D
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         137A
BUCKET_0001         1652
BUCKET_0010         1652
BUCKET_0011         1652
BUCKET_0100         1652
BUCKET_0101         1652
BUCKET_0110         1652
BUCKET_1000         1652
BUCKET_1001         1652
BUCKET_1011         1652
BUCKET_1100         1652
BUCKET_1101         1652
BUCKET_1110         1652
BYTESIZE            2017
BYTESIZEIMMEDIATE   1674
CHECK               11DA
CHECKEND1           10EE
CHECKSTRT1          10D8
CHECK_LOWN          111C
CHECK_LOWY          110C
CHECK_UPN           1114
CHECK_UPY           1104
CHNG_SZB            120C
CHNG_SZL            11F2
CHNG_SZW            1226
CMD_HLD             1F72
CMD_SZ              1F90
CMPI                2012
COMMA               2111
CONV_LOL            11C4
CONV_LOOP           1240
CONV_NUM            11B0
CONV_UPL            11BA
CR                  D
DATAREG0            175A
DATAREG1            176A
DATAREG2            177A
DATAREG3            178A
DATAREG4            179A
DATAREG5            17AA
DATAREG6            17BA
DATAREG7            17CA
DATAREGMODE         16DA
DONE                1AA4
EA_ADDI             1406
EA_ANDI             147C
EA_BCHG_D           1574
EA_BCHG_S           15D6
EA_CMPI             1612
EA_EORI             14F2
ENDADDR             1FC6
ENDADDRSZ           1FD0
EORI                2008
EXITSUB             11D0
EXIT_CONV           12C6
GETENDADDR          1F20
GETSTRTADDR         1EEE
GET_END             1086
GET_STRT            1038
GRAB_NEXT_OP        135C
HEXASCII            11D6
HEXASCIIREG         11EE
IMMEDIATEDATAMODE   1718
INVALID1            1124
INVENDMSG           216D
INVSTRTMSG          2154
INV_END1            1150
INV_MSG             2140
INV_STRT1           113C
IS_ADDI             13D0
IS_ANDI             1446
IS_BCHG_D           1532
IS_BCHG_S           15C0
IS_CMPI             15DC
IS_EORI             14BC
LF                  A
LONGSIZE            2025
LONGSIZEABSOLUTE    1A5C
LONGSIZEIMMEDIATE   16B8
LOOP_1              1010
LOOP_B              1210
LOOP_L              11F6
LOOP_W              122A
MESSAGE             1AAE
NEWLINE             2113
NUM_0               12D4
NUM_1               12DC
NUM_2               12E4
NUM_3               12EC
NUM_4               12F4
NUM_5               12FC
NUM_6               1304
NUM_7               130C
NUM_8               1314
NUM_9               131C
NUM_A               1324
NUM_B               132C
NUM_C               1334
NUM_D               133C
NUM_E               1344
NUM_F               134C
OUTADDRINDPOREG0    208C
OUTADDRINDPOREG1    2094
OUTADDRINDPOREG2    209C
OUTADDRINDPOREG3    20A4
OUTADDRINDPOREG4    20AC
OUTADDRINDPOREG5    20B4
OUTADDRINDPOREG6    20BC
OUTADDRINDPOREG7    20C4
OUTADDRINDPRREG0    20CC
OUTADDRINDPRREG1    20D4
OUTADDRINDPRREG2    20DC
OUTADDRINDPRREG3    20E4
OUTADDRINDPRREG4    20EC
OUTADDRINDPRREG5    20F4
OUTADDRINDPRREG6    20FC
OUTADDRINDPRREG7    2104
OUTADDRINDREG0      2054
OUTADDRINDREG1      205B
OUTADDRINDREG2      2062
OUTADDRINDREG3      2069
OUTADDRINDREG4      2070
OUTADDRINDREG5      2077
OUTADDRINDREG6      207E
OUTADDRINDREG7      2085
OUTDATAREG0         202C
OUTDATAREG1         2031
OUTDATAREG2         2036
OUTDATAREG3         203B
OUTDATAREG4         2040
OUTDATAREG5         2045
OUTDATAREG6         204A
OUTDATAREG7         204F
PRINT_NUM           12CC
PRNT0               1FDE
PRNT1               1FE0
PRNT2               1FE2
PRNT3               1FE4
PRNT4               1FE6
PRNT5               1FE8
PRNT6               1FEA
PRNT7               1FEC
PRNT8               1FEE
PRNT9               1FF0
PRNTA               1FF2
PRNTB               1FF4
PRNTC               1FF6
PRNTD               1FF8
PRNTE               1FFA
PRNTF               1FFC
PROGEND             1FDA
PROGST              1FC2
QUIT_MSG            1F50
SHABANG             2116
STACK               7000
STADDR              1FAE
STADDRSZ            1FB8
START               1000
STARTASSEM          1EBD
ST_ADDR             7FC6
ST_BAD              11CE
TAB                 210C
THEEND              1AA8
WORDSIZE            201E
WORDSIZEABSOLUTE    1A34
WORDSIZEIMMEDIATE   1696
WRAPPERADDRABSOLUTE  1A20
WRAPPERADDRABSOLUTEEND  1A32
WRAPPERADDRINDIRECT  17DA
WRAPPERADDRINDIRECTEND  181A
WRAPPERADDRINDIRECTPOST  189C
WRAPPERADDRINDIRECTPOSTEND  18DC
WRAPPERADDRINDIRECTPRE  195E
WRAPPERADDRINDIRECTPREEND  199E
WRAPPERDATAREG      1718
WRAPPERDATAREGEND   1758
WRAPPERSIZEIMMEDIATE  1658
WRAPPERSIZEIMMEDIATEEND  1672
