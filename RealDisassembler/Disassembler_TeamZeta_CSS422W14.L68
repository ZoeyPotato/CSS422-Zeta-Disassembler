00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 10:16:00 PM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/14/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. After specifying
00000000                             7  * where the program to be disassembled is located, this program will disassemble
00000000                             8  * instructions of that program, and output the contents to console.
00000000                             9  *
00000000                            10  * For use with the EASy68K Emulator. To run, open this program in the emulator.
00000000                            11  * Hit 'F9' to execute. In the execution window, open the test input file, and press
00000000                            12  * 'F9' to run the program.
00000000                            13  *
00000000                            14  * This program will not disassemble every 68k instruction, only a subset of instructions
00000000                            15  * that we have currently implemented. See corresponding documentation for more details.
00000000                            16  *-------------------------------------------------------------
00000000  =00007FC6                 17  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 18  STACK       EQU $7000   *Stack location
00000000  =00000020                 19  MAX_LINE    EQU 32      *Maximum number of instructions that can be displayed
00001000                            20  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 21              LEA stack,SP
00001004  3C3C 0020                 22              MOVE    #MAX_LINE,D6
00001008                            23              
00001008                            24  
00001008                            25  *-----------------------------------------------------------
00001008                            26  * Start of I/O
00001008                            27  *-----------------------------------------------------------            
00001008  43F9 00001F9A             28              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 29              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      30              TRAP    #15         *Displays Message
00001014                            31          
00001014  303C 0000                 32  loop_1      MOVE    #0,D0
00001018  363C 0000                 33              MOVE    #0,D3       
0000101C  43F9 000023A9             34              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
00001022  103C 000D                 35              MOVE.B  #13,D0
00001026  4E4F                      36              TRAP    #15    
00001028  303C 0002                 37              MOVE    #2,D0
0000102C  43F9 00002484             38              LEA     CMD_HLD,A1  *Store the command in a buffer
00001032  4E4F                      39              TRAP    #15
00001034  0C01 0001                 40              CMPI.B  #01,D1
00001038  6600 00FE                 41              BNE     INVALID1
0000103C  4EB9 00001114             42              JSR     CHECK_UPY
00001042                            43              
00001042                            44              
00001042                            45  *-----------------------------------------------------------
00001042                            46  * I/O: Check Start Address
00001042                            47  *
00001042                            48  * Make sure that start address starts after allocated 
00001042                            49  * memory addresses. Else, it will print out a message 
00001042                            50  * saying that requested address is invalid & prompts the
00001042                            51  * user again for the starting address.
00001042                            52  *-----------------------------------------------------------
00001042  43F9 000023DA             53  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001048  103C 000E                 54              MOVE.B  #14,D0
0000104C  4E4F                      55              TRAP    #15
0000104E  43F9 000024C0             56              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001054  3239 000024CA             57              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
0000105A  303C 0002                 58              MOVE    #2,D0           *Get start address
0000105E  4E4F                      59              TRAP    #15
00001060  4EB9 000010E8             60              JSR     CHECKSTRT1
00001066  4287                      61              CLR.L   D7
00001068  4EB9 00001178             62              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106E  0C03 0001                 63              CMPI.B  #01,D3      *Check if there was a bad start
00001072  6700 00DC                 64              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001076  0C87 00007FC6             65              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
0000107C  6D00 00D2                 66              BLT     INV_STRT1   *Asks for another start address if invalid
00001080  0C87 00FFFFFE             67              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001086  6C00 00C8                 68              BGE     INV_STRT1
0000108A  23C7 000024D4             69              MOVE.L  D7,PROGST
00001090                            70  
00001090  43F9 0000240C             71  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001096  103C 000E                 72              MOVE.B  #14,D0
0000109A  4E4F                      73              TRAP    #15
0000109C  43F9 000024D8             74              LEA     ENDADDR,A1      *Buffer to hold end address
000010A2  3239 000024E2             75              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A8  303C 0002                 76              MOVE    #2,D0
000010AC  4E4F                      77              TRAP    #15
000010AE  4EB9 000010FE             78              JSR     CHECKEND1
000010B4  4287                      79              CLR.L   D7
000010B6  4EB9 00001178             80              JSR     ASCIIHEX
000010BC  0C03 0001                 81              CMPI.B  #01,D3
000010C0  6700 00A2                 82              BEQ     INV_END1
000010C4  0C87 000024D4             83              CMPI.L  #PROGST,D7
000010CA  6D00 0098                 84              BLT     INV_END1
000010CE  0C87 00FFFFFF             85              CMPI.L  #$00FFFFFF,D7
000010D4  6C00 008E                 86              BGE     INV_END1
000010D8  23C7 000024EC             87              MOVE.L  D7,PROGEND
000010DE  2079 000024D4             88              MOVEA.L PROGST,A0
000010E4  6000 02A0                 89              BRA     GRAB_NEXT_OP            
000010E8                            90                          
000010E8  0C81 00000008             91  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EE  6E00 0060                 92              BGT     INV_STRT1
000010F2  0C81 00000000             93              CMPI.L  #00,D1
000010F8  6300 0056                 94              BLS     INV_STRT1
000010FC  4E75                      95              RTS         
000010FE                            96              
000010FE  0C81 00000008             97  CHECKEND1   CMPI.L  #08,D1
00001104  6E00 005E                 98              BGT     INV_END1
00001108  0C81 00000000             99              CMPI.L  #00,D1
0000110E  6300 0054                100              BLS     INV_END1
00001112  4E75                     101              RTS
00001114                           102  
00001114                           103  
00001114                           104  *-----------------------------------------------------------
00001114                           105  * I/O: Input check for Y, y, N, n
00001114                           106  *-----------------------------------------------------------
00001114  0C11 0059                107  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001118  6600 0004                108              BNE     CHECK_LOWY
0000111C  4E75                     109              RTS
0000111E  0C11 0079                110  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
00001122  6600 0004                111              BNE     CHECK_UPN
00001126  4E75                     112              RTS
00001128  0C11 004E                113  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
0000112C  6700 0E62                114              BEQ     DONE
00001130                           115              
00001130  0C11 006E                116  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001134  6700 0E5A                117              BEQ     DONE
00001138                           118              
00001138  163C 0000                119  INVALID1    MOVE.B  #0,D3       *Reset bad flag
0000113C  303C 0000                120              MOVE    #0,D0       *Prints invalid command msg if not found
00001140  43F9 0000265D            121              LEA     INV_MSG,A1
00001146  303C 000E                122              MOVE    #14,D0
0000114A  4E4F                     123              TRAP    #15
0000114C  6000 FEC6                124              BRA     loop_1
00001150                           125              
00001150  43F9 00002671            126  INV_STRT1   LEA     INVSTRTMSG,A1
00001156  103C 000E                127              MOVE.B  #14,D0
0000115A  4E4F                     128              TRAP    #15
0000115C  163C 0000                129              MOVE.B  #00,D3      *Reset flag
00001160  6000 FEE0                130              BRA     GET_STRT        
00001164                           131              
00001164  43F9 0000268A            132  INV_END1    LEA     INVENDMSG,A1
0000116A  103C 000E                133              MOVE.B  #14,D0
0000116E  4E4F                     134              TRAP    #15
00001170  163C 0000                135              MOVE.B  #00,D3      *Reset flag
00001174  6000 FF1A                136              BRA     GET_END
00001178                           137              
00001178                           138              
00001178                           139  *-----------------------------------------------------------
00001178                           140  * ASCII to Hex converter
00001178                           141  *
00001178                           142  * Checks and converts the ASCII value to the hex equivalent
00001178                           143  *-----------------------------------------------------------
00001178  48E7 6000                144  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
0000117C  0C01 0000                145  ASCIIHEX1   CMPI.B  #00,D1      *See if done
00001180  6700 0062                146              BEQ     exitSub     *Exit subroutine 
00001184  5301                     147              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001186  E99F                     148              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001188  1419                     149              MOVE.B  (A1)+,D2    *Takes the first char
0000118A  0C02 0024                150              CMPI.B  #$24,D2     *See if the first char is $
0000118E  67EC                     151              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
00001190  0C02 0030                152              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001194  6D00 004C                153              BLT     st_bad      *Put error message
00001198  0C02 0039                154              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
0000119C  6F00 0026                155              BLE     CONV_NUM    *Convert to number, if so
000011A0  0C02 0041                156              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A4  6D00 003C                157              BLT     st_bad      *Put error message
000011A8  0C02 0046                158              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011AC  6F00 0020                159              BLE     CONV_UpL    *Convert to hex
000011B0  0C02 0061                160              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B4  6D00 002C                161              BLT     st_bad
000011B8  0C02 0066                162              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011BC  6F00 001A                163              BLE     CONV_LoL    
000011C0  6E00 0020                164              BGT     st_bad      *Puts error message for anything greater than f value
000011C4                           165              
000011C4  0402 0030                166  CONV_NUM    SUBI.B  #$30,D2
000011C8  8E02                     167              OR.B    D2,D7
000011CA  4EF8 117C                168              JMP     ASCIIHEX1
000011CE  0402 0037                169  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011D2  8E02                     170              OR.B    D2,D7
000011D4  4EF8 117C                171              JMP     ASCIIHEX1
000011D8  0402 0057                172  CONV_LoL    SUBI.B  #$57,D2
000011DC  8E02                     173              OR.B    D2,D7
000011DE  4EF8 117C                174              JMP     ASCIIHEX1   
000011E2                           175  
000011E2  5203                     176  st_bad      ADDI.B  #01,D3
000011E4  4CDF 0006                177  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E8  4E75                     178              RTS
000011EA                           179              
000011EA                           180              
000011EA                           181  *-----------------------------------------------------------
000011EA                           182  * Hex to ASCII converter
000011EA                           183  *-----------------------------------------------------------
000011EA  48E7 4C00                184  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EE  0C01 0000                185  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011F2  6700 002C                186              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F6  B27C 0001                187              CMP.W   #01,D1          
000011FA  6700 003E                188              BEQ     CHNG_SZW
000011FE  6000 0006                189              BRA     CHNG_SZL        
00001202                           190  
00001202  48E7 4C00                191  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001206  123C 0008                192  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
0000120A  0C01 0000                193  LOOP_L      CMPI.B  #00,D1
0000120E  6700 00CA                194              BEQ     EXIT_CONV
00001212  5301                     195              SUBI.B  #01,D1
00001214  E99C                     196              ROL.L   #4,D4           * Shift it for next bit
00001216  2A04                     197              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001218  4EB9 00001254            198              JSR     CONV_LOOP
0000121E  60EA                     199              BRA     LOOP_L      
00001220                           200  
00001220  123C 0002                201  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001224  0C01 0000                202  LOOP_B      CMPI.B  #00,D1
00001228  6700 00B0                203              BEQ     EXIT_CONV
0000122C  5301                     204              SUBI.B  #01,D1
0000122E  E91C                     205              ROL.B   #4,D4           * Shift it for next bit
00001230  2A04                     206              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001232  4EB9 00001254            207              JSR     CONV_LOOP
00001238  60EA                     208              BRA     LOOP_B
0000123A                           209              
0000123A  123C 0004                210  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123E  0C01 0000                211  LOOP_W      CMPI.B  #00,D1
00001242  6700 0096                212              BEQ     EXIT_CONV
00001246  5301                     213              SUBI.B  #01,D1
00001248  E95C                     214              ROL.W   #4,D4           * Shift it for next bit
0000124A  2A04                     215              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000124C  4EB9 00001254            216              JSR     CONV_LOOP
00001252  60EA                     217              BRA     LOOP_W
00001254                           218  
00001254  0285 0000000F            219  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
0000125A  0C05 0000                220              CMPI.B  #$0,D5
0000125E  6700 0088                221              BEQ     NUM_0
00001262  0C05 0001                222              CMPI.B  #$1,D5
00001266  6700 0088                223              BEQ     NUM_1
0000126A  0C05 0002                224              CMPI.B  #$2,D5
0000126E  6700 0088                225              BEQ     NUM_2
00001272  0C05 0003                226              CMPI.B  #$3,D5
00001276  6700 0088                227              BEQ     NUM_3
0000127A  0C05 0004                228              CMPI.B  #$4,D5
0000127E  6700 0088                229              BEQ     NUM_4
00001282  0C05 0005                230              CMPI.B  #$5,D5
00001286  6700 0088                231              BEQ     NUM_5
0000128A  0C05 0006                232              CMPI.B  #$6,D5
0000128E  6700 0088                233              BEQ     NUM_6
00001292  0C05 0007                234              CMPI.B  #$7,D5
00001296  6700 0088                235              BEQ     NUM_7
0000129A  0C05 0008                236              CMPI.B  #$8,D5
0000129E  6700 0088                237              BEQ     NUM_8
000012A2  0C05 0009                238              CMPI.B  #$9,D5
000012A6  6700 0088                239              BEQ     NUM_9
000012AA  0C05 000A                240              CMPI.B  #$A,D5
000012AE  6700 0088                241              BEQ     NUM_A
000012B2  0C05 000B                242              CMPI.B  #$B,D5
000012B6  6700 0088                243              BEQ     NUM_B
000012BA  0C05 000C                244              CMPI.B  #$C,D5
000012BE  6700 0088                245              BEQ     NUM_C
000012C2  0C05 000D                246              CMPI.B  #$D,D5
000012C6  6700 0088                247              BEQ     NUM_D
000012CA  0C05 000E                248              CMPI.B  #$E,D5
000012CE  6700 0088                249              BEQ     NUM_E
000012D2  0C05 000F                250              CMPI.B  #$F,D5
000012D6  6700 0088                251              BEQ     NUM_F
000012DA                           252              
000012DA  4CDF 0032                253  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DE  4E75                     254              RTS
000012E0                           255              
000012E0  303C 000E                256  PRINT_NUM   MOVE    #14,D0
000012E4  4E4F                     257              TRAP    #15
000012E6  4E75                     258              RTS
000012E8  43F9 0000250E            259  NUM_0       LEA     PRNT0,A1
000012EE  60F0                     260              BRA     PRINT_NUM
000012F0  43F9 00002510            261  NUM_1       LEA     PRNT1,A1
000012F6  60E8                     262              BRA     PRINT_NUM
000012F8  43F9 00002512            263  NUM_2       LEA     PRNT2,A1
000012FE  60E0                     264              BRA     PRINT_NUM
00001300  43F9 00002514            265  NUM_3       LEA     PRNT3,A1
00001306  60D8                     266              BRA     PRINT_NUM
00001308  43F9 00002516            267  NUM_4       LEA     PRNT4,A1
0000130E  60D0                     268              BRA     PRINT_NUM
00001310  43F9 00002518            269  NUM_5       LEA     PRNT5,A1
00001316  60C8                     270              BRA     PRINT_NUM
00001318  43F9 0000251A            271  NUM_6       LEA     PRNT6,A1
0000131E  60C0                     272              BRA     PRINT_NUM
00001320  43F9 0000251C            273  NUM_7       LEA     PRNT7,A1
00001326  60B8                     274              BRA     PRINT_NUM
00001328  43F9 0000251E            275  NUM_8       LEA     PRNT8,A1
0000132E  60B0                     276              BRA     PRINT_NUM
00001330  43F9 00002520            277  NUM_9       LEA     PRNT9,A1
00001336  60A8                     278              BRA     PRINT_NUM
00001338  43F9 00002522            279  NUM_A       LEA     PRNTA,A1
0000133E  60A0                     280              BRA     PRINT_NUM
00001340  43F9 00002524            281  NUM_B       LEA     PRNTB,A1
00001346  6098                     282              BRA     PRINT_NUM
00001348  43F9 00002526            283  NUM_C       LEA     PRNTC,A1
0000134E  6090                     284              BRA     PRINT_NUM
00001350  43F9 00002528            285  NUM_D       LEA     PRNTD,A1
00001356  6088                     286              BRA     PRINT_NUM
00001358  43F9 0000252A            287  NUM_E       LEA     PRNTE,A1
0000135E  6080                     288              BRA     PRINT_NUM
00001360  43F9 0000252C            289  NUM_F       LEA     PRNTF,A1
00001366  6000 FF78                290              BRA     PRINT_NUM
0000136A                           291  
0000136A                           292  
0000136A                           293  *-----------------------------------------------------------        
0000136A                           294  * Start of Disassembler
0000136A                           295  *-----------------------------------------------------------
0000136A                           296          *FOR DEBUGGING ONLY!!!
0000136A  207C 00007FC6            297          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
00001370  4286                     298  CLR_D6  CLR.L   D6
00001372  3C3C 0020                299          MOVE    #MAX_LINE,D6
00001376  43F9 00002647            300          LEA     NewLine,A1  *Loads NewLine into address register A1
0000137C  103C 000E                301          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001380  4E4F                     302          TRAP    #15         *Displays Message
00001382  6000 FC90                303          BRA     loop_1
00001386                           304          
00001386                           305  GRAB_NEXT_OP
00001386                           306          *Check and see if A0 == end of test address. If so, we need to end.
00001386  2E08                     307          MOVE.L  A0,D7
00001388  2479 000024EC            308          MOVEA.L PROGEND,A2
0000138E  BE8A                     309          CMP.L   A2,D7       * Check and see if A0 == end of test address. 
00001390  6CDE                     310          BGE     CLR_D6      * Ask user if they want to do the disassembler again
00001392  0C86 00000002            311          CMPI.L  #02,D6      * Check if max line of instructions output on console is reached
00001398  6700 0032                312          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
0000139C  5306                     313  CONT_OP SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
0000139E                           314  
0000139E                           315          *Output a newline to console...        
0000139E  43F9 00002647            316          LEA     NewLine,A1  *Loads NewLine into address register A1
000013A4  103C 000E                317          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000013A8  4E4F                     318          TRAP    #15         *Displays Message
000013AA                           319  
000013AA                           320          *Output the address of this instruction to console...
000013AA  2808                     321          MOVE.L  A0,D4
000013AC  4EB8 1202                322          JSR     HEXASCIIREG
000013B0                           323          
000013B0                           324          *Output a tab (4 spaces) to console, just after the address...
000013B0  43F9 00002640            325          LEA     Tab,A1  *Loads Tab into address register A1
000013B6  103C 000E                326          MOVE.B  #14,D0  *Moves the number 14 into data register D0
000013BA  4E4F                     327          TRAP    #15     *Displays Message
000013BC                           328          
000013BC                           329          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
000013BC                           330          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
000013BC                           331          *data that may be associated with the instruction.
000013BC                           332          *Post increment addr, A0 will point to the start of next instruction or will 
000013BC                           333          *point to the start of any immed/abso data with this current instruction
000013BC  4280                     334          CLR.L   D0
000013BE  3018                     335          MOVE.W  (A0)+,D0
000013C0                           336          *Copy the word data we just moved into D0 into D7. We are copying this data
000013C0                           337          *So we always have a copy of the WHOLE instruction somewhere
000013C0  4287                     338          CLR.L   D7
000013C2  3E00                     339          MOVE.W  D0,D7
000013C4                           340          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000013C4                           341          *four bits of the instruction. Once we have just the first four bits, we can
000013C4                           342          *begin to see which 'bucket'/category this instruction falls into. 
000013C4  E048                     343          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013C6  E848                     344          LSR.W   #$04,D0
000013C8                           345          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013C8                           346          *list of buckets until we find which one this instruction falls into.
000013C8  6000 006C                347          BRA     BUCKET_0000     * Start with 0000
000013CC                           348  
000013CC                           349  
000013CC                           350  *-----------------------------------------------------------        
000013CC                           351  * Question Prompts
000013CC                           352  *-----------------------------------------------------------        
000013CC  43F9 0000243C            353  CONT_Q      LEA     QUES_CONT,A1
000013D2  303C 000E                354              MOVE    #14,D0
000013D6  4E4F                     355              TRAP    #15
000013D8  43F9 000024F0            356              LEA     CONT,A1     *Need to store Y/N
000013DE  303C 0002                357              MOVE    #2,D0
000013E2  4E4F                     358              TRAP    #15
000013E4  0C01 0001                359              CMPI.B  #01,D1
000013E8  6600 FD4E                360              BNE     INVALID1
000013EC  0C39 0059 000024F0       361              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013F4  6600 000A                362              BNE     CHECK_Y
000013F8  4286                     363              CLR.L   D6
000013FA  3C3C 0020                364              MOVE    #MAX_LINE,D6    *Resets counter
000013FE  609C                     365              BRA     CONT_OP
00001400  0C11 0079                366  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
00001404  6600 000A                367              BNE     CHECK_N
00001408  4286                     368              CLR.L   D6
0000140A  3C3C 0020                369              MOVE    #MAX_LINE,D6    *Resets counter
0000140E  608C                     370              BRA     CONT_OP
00001410  0C11 004E                371  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001414  6700 FBFE                372              BEQ     loop_1
00001418  0C11 006E                373              CMPI.B  #$6E,(A1)   *Checks for lowercase n
0000141C  6700 FBF6                374              BEQ     loop_1      
00001420                           375  
00001420  163C 0000                376  INV2        MOVE.B  #0,D3       *Reset bad flag
00001424  303C 0000                377              MOVE    #0,D0       *Prints invalid command msg if not found
00001428  43F9 0000265D            378              LEA     INV_MSG,A1
0000142E  303C 000E                379              MOVE    #14,D0
00001432  4E4F                     380              TRAP    #15
00001434  6096                     381              BRA     CONT_Q
00001436                           382  
00001436                           383  *-----------------------------------------------------------        
00001436                           384  * Bucket 0000:
00001436                           385  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
00001436                           386  *                   BCHG(dynamic) | BCHG (static) | CMPI----
00001436                           387  *-----------------------------------------------------------
00001436                           388  BUCKET_0000
00001436  =00000000                389  BUCKET0000_BITS EQU $0
00001436  4281                     390          CLR.L   D1
00001438                           391          *Load the first 4 bits (really a byte) of BUCKET0000 into D1
00001438  123C 0000                392          MOVE.B  #BUCKET0000_BITS,D1
0000143C                           393          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0000. 
0000143C                           394          *If equal, continue decoding. If not, branch to next bucket.
0000143C  B200                     395          CMP.B   D0,D1
0000143E  6600 0344                396          BNE     BUCKET_0001
00001442                           397  
00001442                           398          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001442                           399          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001442  3007                     400          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001444  0800 0008                401          BTST.L  #$08,D0
00001448  6600 01A4                402          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to IS_BCHG_D
0000144C                           403          
0000144C                           404          *Now we can check bits 11-8 in the instruction and branch to different op-codes
0000144C                           405          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
0000144C  E048                     406          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
0000144E  0880 0004                407          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001452  0880 0005                408          BCLR.L  #$05,D0
00001456  0880 0006                409          BCLR.L  #$06,D0
0000145A  0880 0007                410          BCLR.L  #$07,D0
0000145E                           411          
0000145E                           412          *Perform compares with these 4 bits to see which specific instruction it is.
0000145E  B03C 0006                413          CMP.B   #$06,D0 *Is this an ADDI?
00001462  6700 0028                414          BEQ     IS_ADDI
00001466  B03C 0002                415          CMP.B   #$02,D0 *Is this an ANDI?
0000146A  6700 0096                416          BEQ     IS_ANDI
0000146E  B03C 000A                417          CMP.B   #$0A,D0 *Is this an EORI?
00001472  6700 0104                418          BEQ     IS_EORI
00001476  B03C 0008                419          CMP.B   #$08,D0 *Is this a BCHG(static)?
0000147A  6700 0210                420          BEQ     IS_BCHG_S
0000147E  B03C 000C                421          CMP.B   #$0C,D0 *Is this a CMPI?
00001482  6700 028A                422          BEQ     IS_CMPI
00001486                           423          
00001486                           424          *If we get through all of the compares without finding the specific instruction,
00001486                           425          *then this instruction is either not in our list of OP CODES to decode, or is an
00001486                           426          *invalid instruction/syntax.
00001486  4EF9 00001F70            427          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
0000148C                           428          
0000148C                           429          
0000148C                           430  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
0000148C                           431  IS_ADDI
0000148C                           432          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000148C                           433          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000148C  4281                     434          CLR.L   D1
0000148E  3207                     435          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001490  C27C 00C0                436          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001494  EC09                     437          LSR.B   #$06,D1     *Shift the size bits into LSB
00001496                           438          
00001496  B23C 0003                439          CMP.B   #$03,D1     *Compare the size bits to $3
0000149A  6700 0AD4                440          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000149E                           441          
0000149E                           442          *Output 'ADDI' to console...
0000149E  43F9 0000252E            443          LEA     ADDI,A1     *Loads ADDI into address register A1
000014A4  103C 000E                444          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014A8  4E4F                     445          TRAP    #15         *Displays Message
000014AA                           446          
000014AA                           447          
000014AA                           448          *Should have a valid ADDI op code. Set data up for EA.
000014AA                           449          
000014AA                           450          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014AA  4282                     451          CLR.L   D2
000014AC  3407                     452          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014AE  C47C 0038                453          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000014B2  E60A                     454          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000014B4                           455                  
000014B4                           456          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000014B4  4283                     457          CLR.L   D3
000014B6  3607                     458          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000014B8  C67C 0007                459          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000014BC                           460          
000014BC  4EF9 000014C2            461          JMP     EA_ADDI
000014C2                           462  
000014C2                           463  EA_ADDI
000014C2                           464          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
000014C2                           465          *and D3 holds the EA register.
000014C2                           466          
000014C2                           467          *Determine how much data to read in, depending on the size of the operation
000014C2                           468          *output the size of the operation and the immediate data to console
000014C2  4EB9 000019C6            469          JSR     WrapperSizeImmediate
000014C8                           470          
000014C8                           471          *manually output a comma here...
000014C8  43F9 00002645            472          LEA     Comma,A1        *Loads Comma into address register A1
000014CE  103C 000E                473          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014D2  4E4F                     474          TRAP    #15             *Displays Message        
000014D4                           475          
000014D4                           476          *Determine which EA mode and thus Register/Mem Address this instruction used
000014D4  B43C 0000                477          CMP.B   #$00,D2
000014D8  6700 0610                478          BEQ     DataRegMode *If EA mode is a data register, output that
000014DC                           479          
000014DC  B43C 0002                480          CMP.B   #$02,D2
000014E0  6700 0628                481          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014E4                           482          
000014E4  B43C 0003                483          CMP.B   #$03,D2
000014E8  6700 0630                484          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014EC                           485          
000014EC  B43C 0004                486          CMP.B   #$04,D2
000014F0  6700 0638                487          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014F4                           488          
000014F4  B43C 0007                489          CMP.B   #$07,D2
000014F8  6700 0640                490          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014FC                           491          
000014FC                           492          *If the ea mode isn't equal to any of these, it is an invalid EA
000014FC  4EF9 00001F80            493          JMP     BADEACODE                               
00001502                           494          
00001502                           495  
00001502                           496  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
00001502                           497  IS_ANDI
00001502                           498          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001502                           499          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001502  4281                     500          CLR.L   D1
00001504  3207                     501          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001506  C27C 00C0                502          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000150A  EC09                     503          LSR.B   #$06,D1     *Shift the size bits into LSB
0000150C                           504          
0000150C  B23C 0003                505          CMP.B   #$03,D1     *Compare the size bits to $3
00001510  6700 0A5E                506          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001514                           507          
00001514                           508          *Output 'ANDI' to console...
00001514  43F9 00002533            509          LEA     ANDI,A1     *Loads ANDI into address register A1
0000151A  103C 000E                510          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000151E  4E4F                     511          TRAP    #15         *Displays Message
00001520                           512          
00001520                           513          
00001520                           514          *Should have a valid ANDI op code. Set data up for EA.
00001520                           515          
00001520                           516          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001520  4282                     517          CLR.L   D2
00001522  3407                     518          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001524  C47C 0038                519          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001528  E60A                     520          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000152A                           521                  
0000152A                           522          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000152A  4283                     523          CLR.L   D3
0000152C  3607                     524          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000152E  C67C 0007                525          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001532                           526          
00001532  4EF9 00001538            527          JMP     EA_ANDI
00001538                           528  
00001538                           529  EA_ANDI
00001538                           530          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
00001538                           531          *and D3 holds the EA register.
00001538                           532          
00001538                           533          *Determine how much data to read in, depending on the size of the operation
00001538                           534          *output the size of the operation and the immediate data to console
00001538  4EB9 000019C6            535          JSR     WrapperSizeImmediate
0000153E                           536          
0000153E                           537          *manually output a comma here...
0000153E  43F9 00002645            538          LEA     Comma,A1        *Loads Comma into address register A1
00001544  103C 000E                539          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001548  4E4F                     540          TRAP    #15             *Displays Message        
0000154A                           541          
0000154A                           542          *Determine which EA mode and thus Register/Mem Address this instruction used
0000154A  B43C 0000                543          CMP.B   #$00,D2
0000154E  6700 059A                544          BEQ     DataRegMode *If EA mode is a data register, output that
00001552                           545          
00001552  B43C 0002                546          CMP.B   #$02,D2
00001556  6700 05B2                547          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000155A                           548          
0000155A  B43C 0003                549          CMP.B   #$03,D2
0000155E  6700 05BA                550          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001562                           551          
00001562  B43C 0004                552          CMP.B   #$04,D2
00001566  6700 05C2                553          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000156A                           554          
0000156A  B43C 0007                555          CMP.B   #$07,D2
0000156E  6700 05CA                556          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001572                           557          
00001572                           558          *If the ea mode isn't equal to any of these, it is an invalid EA
00001572  4EF9 00001F80            559          JMP     BADEACODE
00001578                           560          
00001578                           561  
00001578                           562  *Now we know this instruction is exactly EORI, lets set everything up for EA.
00001578                           563  IS_EORI
00001578                           564          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001578                           565          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001578  4281                     566          CLR.L   D1
0000157A  3207                     567          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000157C  C27C 00C0                568          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001580  EC09                     569          LSR.B   #$06,D1     *Shift the size bits into LSB
00001582                           570          
00001582  B23C 0003                571          CMP.B   #$03,D1     *Compare the size bits to $3
00001586  6700 09E8                572          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000158A                           573          
0000158A                           574          *Output 'EORI' to console...
0000158A  43F9 00002538            575          LEA     EORI,A1     *Loads EORI into address register A1
00001590  103C 000E                576          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001594  4E4F                     577          TRAP    #15         *Displays Message
00001596                           578          
00001596                           579          
00001596                           580          *Should have a valid EORI op code. Set data up for EA.
00001596                           581          
00001596                           582          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001596  4282                     583          CLR.L   D2
00001598  3407                     584          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000159A  C47C 0038                585          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000159E  E60A                     586          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000015A0                           587                  
000015A0                           588          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000015A0  4283                     589          CLR.L   D3
000015A2  3607                     590          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000015A4  C67C 0007                591          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000015A8                           592          
000015A8  4EF9 000015AE            593          JMP     EA_EORI
000015AE                           594  
000015AE                           595  EA_EORI
000015AE                           596          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
000015AE                           597          *and D3 holds the EA register.
000015AE                           598          
000015AE                           599          *Determine how much data to read in, depending on the size of the operation
000015AE                           600          *output the size of the operation and the immediate data to console
000015AE  4EB9 000019C6            601          JSR     WrapperSizeImmediate
000015B4                           602          
000015B4                           603          *manually output a comma here...
000015B4  43F9 00002645            604          LEA     Comma,A1        *Loads Comma into address register A1
000015BA  103C 000E                605          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015BE  4E4F                     606          TRAP    #15             *Displays Message        
000015C0                           607          
000015C0                           608          *Determine which EA mode and thus Register/Mem Address this instruction used
000015C0  B43C 0000                609          CMP.B   #$00,D2
000015C4  6700 0524                610          BEQ     DataRegMode *If EA mode is a data register, output that
000015C8                           611          
000015C8  B43C 0002                612          CMP.B   #$02,D2
000015CC  6700 053C                613          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015D0                           614          
000015D0  B43C 0003                615          CMP.B   #$03,D2
000015D4  6700 0544                616          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015D8                           617          
000015D8  B43C 0004                618          CMP.B   #$04,D2
000015DC  6700 054C                619          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015E0                           620          
000015E0  B43C 0007                621          CMP.B   #$07,D2
000015E4  6700 0554                622          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015E8                           623          
000015E8                           624          *If the ea mode isn't equal to any of these, it is an invalid EA
000015E8  4EF9 00001F80            625          JMP     BADEACODE
000015EE                           626  
000015EE                           627  
000015EE                           628  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015EE                           629  *everything up for EA, if is a legit instruction.
000015EE                           630  IS_BCHG_D
000015EE                           631          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015EE                           632          *invalid, branch to BADOPCODE
000015EE  3007                     633          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015F0  0800 0007                634          BTST.L  #$07,D0
000015F4  6600 097A                635          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015F8  0800 0006                636          BTST.L  #$06,D0
000015FC  6700 0972                637          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
00001600                           638          
00001600                           639          *Output 'BCHG' to console...
00001600  43F9 0000253D            640          LEA     BCHG,A1         *Loads BCHG into address register A1
00001606  103C 000E                641          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000160A  4E4F                     642          TRAP    #15             *Displays Message
0000160C                           643                  
0000160C                           644                  
0000160C                           645          *Should have a valid BCHG op code. Set data up for EA.
0000160C                           646  
0000160C                           647          *Set D1 to the EA source register located in bits 11-9 of the instruction
0000160C  4281                     648          CLR.L   D1
0000160E  3207                     649          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001610  C27C 0E00                650          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
00001614  E049                     651          LSR.W   #$08,D1     *Shift the EA source register bits into LSB
00001616  E249                     652          LSR.W   #$01,D1
00001618                           653  
00001618                           654          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001618  4282                     655          CLR.L   D2
0000161A  3407                     656          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000161C  C47C 0038                657          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001620  E60A                     658          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001622                           659                  
00001622                           660          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001622  4283                     661          CLR.L   D3
00001624  3607                     662          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001626  C67C 0007                663          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000162A                           664  
0000162A  4EF9 00001630            665          JMP     EA_BCHG_D
00001630                           666  
00001630                           667  EA_BCHG_D
00001630                           668          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001630                           669          *D2 holds the EA mode, and D3 holds the EA register.
00001630                           670          
00001630                           671          *Determine the size of this BCHG instruction. Output the correct size...
00001630  4EB9 00001A92            672          JSR     BCHGSizeHelper
00001636                           673          
00001636                           674          *output the source register to console, flag D6 with a 1 so we come back...
00001636  48E7 0200                675          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
0000163A  48E7 1000                676          MOVEM.L D3,-(SP)    *Push EA destination register into stack            
0000163E  1C3C 0001                677          MOVE.B  #$01,D6     *Flag D6
00001642  1601                     678          MOVE.B  D1,D3       *Move source register into D3
00001644  4EB9 00001AEA            679          JSR     DataRegMode
0000164A  4CDF 0008                680          MOVEM.L (SP)+,D3    *Pull destination register back into D3
0000164E  4CDF 0040                681          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001652                           682          
00001652                           683          *manually output a comma here...
00001652  43F9 00002645            684          LEA     Comma,A1        *Loads Comma into address register A1
00001658  103C 000E                685          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000165C  4E4F                     686          TRAP    #15             *Displays Message
0000165E                           687          
0000165E                           688          *Determine which EA mode and thus Register/Mem Address this instruction used
0000165E  B43C 0000                689          CMP.B   #$00,D2
00001662  6700 0486                690          BEQ     DataRegMode *If EA mode is a data register, output that
00001666                           691          
00001666  B43C 0002                692          CMP.B   #$02,D2
0000166A  6700 049E                693          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000166E                           694          
0000166E  B43C 0003                695          CMP.B   #$03,D2
00001672  6700 04A6                696          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001676                           697          
00001676  B43C 0004                698          CMP.B   #$04,D2
0000167A  6700 04AE                699          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000167E                           700          
0000167E  B43C 0007                701          CMP.B   #$07,D2
00001682  6700 04B6                702          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001686                           703          
00001686                           704          *If the ea mode isn't equal to any of these, it is an invalid EA
00001686  4EF9 00001F80            705          JMP     BADEACODE
0000168C                           706  
0000168C                           707  
0000168C                           708  *Found a possible BCHG(static) instruction. Verify its bit integrity and then set up
0000168C                           709  *everything up for EA, if is a legit instruction.
0000168C                           710  IS_BCHG_S
0000168C                           711          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
0000168C                           712          *invalid, branch to BADOPCODE
0000168C  3007                     713          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
0000168E  0800 0007                714          BTST.L  #$07,D0
00001692  6600 08DC                715          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
00001696  0800 0006                716          BTST.L  #$06,D0
0000169A  6700 08D4                717          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
0000169E                           718          
0000169E                           719          *Output 'BCHG' to console...
0000169E  43F9 0000253D            720          LEA     BCHG,A1         *Loads BCHG into address register A1
000016A4  103C 000E                721          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016A8  4E4F                     722          TRAP    #15             *Displays Message
000016AA                           723          
000016AA                           724          
000016AA                           725          *Should have a valid BCHG op code. Set data up for EA.
000016AA                           726          
000016AA                           727          *Move #$00 into D1, BCHG_S's immediate data is always in byte size
000016AA  4281                     728          CLR.L   D1
000016AC  323C 0000                729          MOVE.W  #$00,D1
000016B0                           730  
000016B0                           731          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000016B0  4282                     732          CLR.L   D2
000016B2  3407                     733          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000016B4  C47C 0038                734          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000016B8  E60A                     735          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000016BA                           736                  
000016BA                           737          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000016BA  4283                     738          CLR.L   D3
000016BC  3607                     739          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000016BE  C67C 0007                740          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000016C2                           741  
000016C2  4EF9 000016C8            742          JMP     EA_BCHG_S
000016C8                           743  
000016C8                           744  EA_BCHG_S
000016C8                           745          *Decode the ea bits of BCHG(static). Assuming D2 holds the EA mode, and 
000016C8                           746          *D3 holds the EA register.
000016C8                           747          
000016C8                           748          *Determine the size of this BCHG instruction. Output the correct size...
000016C8  4EB9 00001A92            749          JSR     BCHGSizeHelper                
000016CE                           750          
000016CE                           751          *output the immediate data of this operation to console (always byte)...
000016CE  4EB9 00001AC2            752          JSR     BCHGImmediate
000016D4                           753          
000016D4                           754          *manually output a comma here...
000016D4  43F9 00002645            755          LEA     Comma,A1        *Loads Comma into address register A1
000016DA  103C 000E                756          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016DE  4E4F                     757          TRAP    #15             *Displays Message
000016E0                           758          
000016E0                           759          *Determine which EA mode and thus Register/Mem Address this instruction used
000016E0  B43C 0000                760          CMP.B   #$00,D2
000016E4  6700 0404                761          BEQ     DataRegMode *If EA mode is a data register, output that
000016E8                           762          
000016E8  B43C 0002                763          CMP.B   #$02,D2
000016EC  6700 041C                764          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016F0                           765          
000016F0  B43C 0003                766          CMP.B   #$03,D2
000016F4  6700 0424                767          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016F8                           768          
000016F8  B43C 0004                769          CMP.B   #$04,D2
000016FC  6700 042C                770          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001700                           771          
00001700  B43C 0007                772          CMP.B   #$07,D2
00001704  6700 0434                773          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001708                           774          
00001708                           775          *If the ea mode isn't equal to any of these, it is an invalid EA
00001708  4EF9 00001F80            776          JMP     BADEACODE
0000170E                           777  
0000170E                           778  
0000170E                           779  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
0000170E                           780  IS_CMPI
0000170E                           781          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000170E                           782          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000170E  4281                     783          CLR.L   D1
00001710  3207                     784          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001712  C27C 00C0                785          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001716  EC09                     786          LSR.B   #$06,D1     *Shift the size bits into LSB
00001718                           787          
00001718  B23C 0003                788          CMP.B   #$03,D1     *Compare the size bits to $3
0000171C  6700 0852                789          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001720                           790          
00001720                           791          *Output 'CMPI' to console...
00001720  43F9 00002542            792          LEA     CMPI,A1     *Loads CMPI into address register A1
00001726  103C 000E                793          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000172A  4E4F                     794          TRAP    #15         *Displays Message
0000172C                           795          
0000172C                           796          
0000172C                           797          *Should have a valid CMPI op code. Set data up for EA.
0000172C                           798          
0000172C                           799          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000172C  4282                     800          CLR.L   D2
0000172E  3407                     801          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001730  C47C 0038                802          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001734  E60A                     803          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001736                           804                  
00001736                           805          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001736  4283                     806          CLR.L   D3
00001738  3607                     807          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000173A  C67C 0007                808          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000173E                           809          
0000173E  4EF9 00001744            810          JMP     EA_CMPI
00001744                           811  
00001744                           812  EA_CMPI
00001744                           813          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
00001744                           814          *and D3 holds the EA register.
00001744                           815          
00001744                           816          *Determine how much data to read in, depending on the size of the operation
00001744                           817          *output the size of the operation and the immediate data to console
00001744  4EB9 000019C6            818          JSR     WrapperSizeImmediate
0000174A                           819          
0000174A                           820          *manually output a comma here...
0000174A  43F9 00002645            821          LEA     Comma,A1        *Loads Comma into address register A1
00001750  103C 000E                822          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001754  4E4F                     823          TRAP    #15             *Displays Message
00001756                           824          
00001756                           825          *Determine which EA mode and thus Register/Mem Address this instruction used
00001756  B43C 0000                826          CMP.B   #$00,D2
0000175A  6700 038E                827          BEQ     DataRegMode *If EA mode is a data register, output that
0000175E                           828          
0000175E  B43C 0002                829          CMP.B   #$02,D2
00001762  6700 03A6                830          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001766                           831          
00001766  B43C 0003                832          CMP.B   #$03,D2
0000176A  6700 03AE                833          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000176E                           834          
0000176E  B43C 0004                835          CMP.B   #$04,D2
00001772  6700 03B6                836          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001776                           837          
00001776  B43C 0007                838          CMP.B   #$07,D2
0000177A  6700 03BE                839          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000177E                           840          
0000177E                           841          *If the ea mode isn't equal to any of these, it is an invalid EA
0000177E  4EF9 00001F80            842          JMP     BADEACODE
00001784                           843        
00001784                           844    
00001784                           845  *STARTS WITH 0001, MOVE.B-----------------------------------
00001784                           846  BUCKET_0001
00001784  =00000001                847  BUCKET0001_BITS EQU $1
00001784                           848          
00001784                           849          *some code...
00001784                           850  
00001784                           851  
00001784                           852  *STARTS WITH 0010, MOVE.L-----------------------------------
00001784                           853  BUCKET_0010
00001784  =00000002                854  BUCKET0010_BITS EQU $2
00001784                           855  
00001784                           856          *some code...
00001784                           857  
00001784                           858  
00001784                           859  *STARTS WITH 0011, MOVE.W-----------------------------------
00001784                           860  BUCKET_0011
00001784  =00000003                861  BUCKET0011_BITS EQU $3
00001784                           862  
00001784                           863          *some code...
00001784                           864  
00001784                           865  
00001784                           866  *-----------------------------------------------------------        
00001784                           867  * Bucket 0100:
00001784                           868  * STARTS WITH 0100, MOVEM | MULS(L)-------------------------
00001784                           869  *                   LEA | CLR | JSR | RTS-------------------
00001784                           870  *-----------------------------------------------------------
00001784                           871  BUCKET_0100
00001784  =00000004                872  BUCKET0100_BITS EQU $4
00001784  4281                     873          CLR.L   D1
00001786                           874          *Load the first 4 bits (really a byte) of BUCKET0100 into D1
00001786  123C 0004                875          MOVE.B  #BUCKET0100_BITS,D1
0000178A                           876          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0100. 
0000178A                           877          *If equal, continue decoding. If not, branch to next bucket.
0000178A  B200                     878          CMP.B   D0,D1
0000178C  6600 017C                879          BNE     BUCKET_0101
00001790                           880  
00001790                           881          *Test the 8th bit in this instruction, if it is 1, then it is an LEA 
00001790                           882          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1.
00001790  3007                     883          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001792  0800 0008                884          BTST.L  #$08,D0
00001796  6600 0038                885          BNE     IS_LEA  *If the zbit was 0 (the 8th bit is 1), branch to IS_LEA
0000179A                           886  
0000179A                           887          *JSR/RTS in this bucket can only be determined by only bits 11-6
0000179A  C07C 0FC0                888          AND.W   #$0FC0,D0   *Mask out everything but bits 11-6
0000179E  EC48                     889          LSR.W   #$06,D0     *Move bits 11-6 into LSB position
000017A0                           890          
000017A0                           891          *Check bits 11-6 in the instruction and branch to different either JSR or RTS 
000017A0                           892          *depending on what the bits equal
000017A0  B03C 003A                893          CMP.B   #$3A,D0 *Is this a JSR?
000017A4  6700 010C                894          BEQ     IS_JSR
000017A8  B03C 0039                895          CMP.B   #$39,D0 *Is this a RTS?
000017AC  6700 013C                896          BEQ     IS_RTS
000017B0                           897  
000017B0                           898          *Now we can use only bits 11-8 and branch to different op-codes only needing these
000017B0                           899          *four bits to be unambiguous
000017B0  E448                     900          LSR.W   #$02,D0 *Shift the 7-6 bits out, leaving only 11-8
000017B2  B03C 0008                901          CMP.B   #$08,D0 *Is this a MOVEM(RegToMem)?
000017B6  6700 0018                902          BEQ     IS_MOVEM_RegToMem
000017BA  B03C 000C                903          CMP.B   #$0C,D0 *Is this a MOVEM(MemToReg)?
000017BE  6700 0010                904          BEQ     IS_MOVEM_MemToReg
000017C2  B03C 0002                905          CMP.B   #$02,D0 *Is this a CLR?
000017C6  6700 0080                906          BEQ     IS_CLR
000017CA                           907          
000017CA                           908          *If we get through all of the compares without finding the specific instruction,
000017CA                           909          *then this instruction is either not in our list of OP CODES to decode, or is an
000017CA                           910          *invalid instruction/syntax.
000017CA  4EF9 00001F70            911          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000017D0                           912  
000017D0                           913  
000017D0                           914  *Now we know this instruction is exactly MOVEM(RegToMem), lets set everything up for EA.
000017D0                           915  IS_MOVEM_RegToMem
000017D0                           916  
000017D0                           917  EA_MOVEM_RegToMem
000017D0                           918  
000017D0                           919  
000017D0                           920  *Now we know this instruction is exactly MOVEM(MemToReg), lets set everything up for EA.
000017D0                           921  IS_MOVEM_MemToReg
000017D0                           922  
000017D0                           923  EA_MOVEM_MemToReg
000017D0                           924  
000017D0                           925  
000017D0                           926  *Now we know this instruction is exactly LEA, lets set everything up for EA.
000017D0                           927  IS_LEA
000017D0                           928          *Check bits 7 and 6, these should be 1 and 1. If not, this instruction is
000017D0                           929          *invalid, branch to BADOPCODE
000017D0  3007                     930          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000017D2  0800 0007                931          BTST.L  #$07,D0
000017D6  6700 0798                932          BEQ     BADOPCODE  *If the zbit was 1 (the 7th bit is 0), branch to BADOPCODE
000017DA  0800 0006                933          BTST.L  #$06,D0
000017DE  6700 0790                934          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000017E2                           935          
000017E2                           936          *Output 'LEA' to console...
000017E2  43F9 00002552            937          LEA     LEA,A1         *Loads LEA into address register A1
000017E8  103C 000E                938          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000017EC  4E4F                     939          TRAP    #15             *Displays Message
000017EE                           940          
000017EE                           941          
000017EE                           942          *Should have a valid LEA op code. Set data up for EA.      
000017EE                           943          
000017EE                           944          *Set D1 to the EA destination register located in bits 11-9 of the instruction
000017EE  4281                     945          CLR.L   D1
000017F0  3207                     946          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000017F2  C27C 0E00                947          AND.W   #$0E00,D1   *Mask out everything but the EA destination register bits
000017F6  E049                     948          LSR.W   #$08,D1     *Shift the EA destination register bits into LSB
000017F8  E249                     949          LSR.W   #$01,D1
000017FA                           950  
000017FA                           951          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000017FA  4282                     952          CLR.L   D2
000017FC  3407                     953          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000017FE  C47C 0038                954          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001802  E60A                     955          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001804                           956                  
00001804                           957          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001804  4283                     958          CLR.L   D3
00001806  3607                     959          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001808  C67C 0007                960          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000180C                           961  
0000180C  4EF9 00001812            962          JMP     EA_LEA       
00001812                           963  
00001812                           964  EA_LEA
00001812                           965          *Decode the ea bits of LEA. Assuming D1 holds the destination register, D2 holds the
00001812                           966          *EA mode, and D3 holds the EA register.
00001812                           967          
00001812                           968          *Determine which EA mode and thus Register/Mem Address this instruction used
00001812  48E7 0200                969          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
00001816  1C3C 0001                970          MOVE.B  #$01,D6     *Flag D6 so that we come back
0000181A                           971          
0000181A  B43C 0002                972          CMP.B   #$02,D2
0000181E  6700 02B6                973          BEQ     LEA_AddrIndirectWrapper *If EA mode is an addr indirect, output that
00001822                           974          
00001822  B43C 0007                975          CMP.B   #$07,D2
00001826  6700 02B8                976          BEQ     LEA_AddrAbsoluteWrapper *If EA mode is an addr absolute word/long, output that
0000182A                           977  
0000182A                           978  EA_LEA_WrapperEnd        
0000182A  4CDF 0040                979          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
0000182E                           980                  
0000182E                           981          *manually output a comma here...
0000182E  43F9 00002645            982          LEA     Comma,A1        *Loads Comma into address register A1
00001834  103C 000E                983          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001838  4E4F                     984          TRAP    #15             *Displays Message
0000183A                           985          
0000183A                           986          *output the destination address register to console
0000183A                           987          *Overwrite the EA register with destination register (no longer need D3 at this point)
0000183A  1601                     988          MOVE.B  D1,D3
0000183C  4EB9 00001AFA            989          JSR     AddrRegMode
00001842                           990          
00001842                           991          *If the ea mode isn't equal to any of these, it is an invalid EA
00001842  4EF9 00001F80            992          JMP     BADEACODE
00001848                           993          
00001848                           994          
00001848                           995  *Now we know this instruction is exactly CLR, lets set everything up for EA.
00001848                           996  IS_CLR
00001848                           997          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001848                           998          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001848  4281                     999          CLR.L   D1
0000184A  3207                    1000          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000184C  C27C 00C0               1001          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001850  EC09                    1002          LSR.B   #$06,D1     *Shift the size bits into LSB
00001852                          1003          
00001852  B23C 0003               1004          CMP.B   #$03,D1     *Compare the size bits to $3
00001856  6700 0718               1005          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000185A                          1006          
0000185A                          1007          *Output 'CLR' to console...
0000185A  43F9 0000255C           1008          LEA     CLR,A1      *Loads CLR into address register A1
00001860  103C 000E               1009          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001864  4E4F                    1010          TRAP    #15         *Displays Message
00001866                          1011          
00001866                          1012          
00001866                          1013          *Should have a valid CLR op code. Set data up for EA.
00001866                          1014          
00001866                          1015          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001866  4282                    1016          CLR.L   D2
00001868  3407                    1017          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000186A  C47C 0038               1018          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000186E  E60A                    1019          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001870                          1020                  
00001870                          1021          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001870  4283                    1022          CLR.L   D3
00001872  3607                    1023          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001874  C67C 0007               1024          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001878                          1025          
00001878  4EF9 0000187E           1026          JMP     EA_CLR
0000187E                          1027  
0000187E                          1028  EA_CLR
0000187E                          1029          *Decode the ea bits of CLR. Assuming D1 holds the size, D2 holds the EA mode,
0000187E                          1030          *and D3 holds the EA register.
0000187E                          1031          
0000187E                          1032          *output the size of the operation to console
0000187E  4EB9 00001A48           1033          JSR     WrapperSize       
00001884                          1034          
00001884                          1035          *Determine which EA mode and thus Register/Mem Address this instruction used
00001884  B43C 0000               1036          CMP.B   #$00,D2
00001888  6700 0260               1037          BEQ     DataRegMode *If EA mode is a data register, output that
0000188C                          1038          
0000188C  B43C 0002               1039          CMP.B   #$02,D2
00001890  6700 0278               1040          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001894                          1041          
00001894  B43C 0003               1042          CMP.B   #$03,D2
00001898  6700 0280               1043          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000189C                          1044          
0000189C  B43C 0004               1045          CMP.B   #$04,D2
000018A0  6700 0288               1046          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000018A4                          1047          
000018A4  B43C 0007               1048          CMP.B   #$07,D2
000018A8  6700 0290               1049          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000018AC                          1050          
000018AC                          1051          *If the ea mode isn't equal to any of these, it is an invalid EA
000018AC  4EF9 00001F80           1052          JMP     BADEACODE
000018B2                          1053  
000018B2                          1054  
000018B2                          1055  *Now we know this instruction is exactly JSR, lets set everything up for EA.
000018B2                          1056  IS_JSR        
000018B2                          1057          *Output 'JSR' to console...
000018B2  43F9 00002560           1058          LEA     JSR,A1      *Loads JSR into address register A1
000018B8  103C 000E               1059          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018BC  4E4F                    1060          TRAP    #15         *Displays Message
000018BE                          1061          
000018BE                          1062          
000018BE                          1063          *Should have a valid JSR op code. Set data up for EA.
000018BE                          1064          
000018BE                          1065          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000018BE  4282                    1066          CLR.L   D2
000018C0  3407                    1067          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000018C2  C47C 0038               1068          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000018C6  E60A                    1069          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000018C8                          1070                  
000018C8                          1071          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000018C8  4283                    1072          CLR.L   D3
000018CA  3607                    1073          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000018CC  C67C 0007               1074          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000018D0                          1075          
000018D0  4EF8 187E               1076          JMP     EA_CLR
000018D4                          1077  
000018D4                          1078  EA_JSR
000018D4                          1079          *Decode the ea bits of JSR. Assuming D1 holds the size, D2 holds the EA mode,
000018D4                          1080          *and D3 holds the EA register.               
000018D4                          1081          
000018D4                          1082          *Determine which EA mode and thus Register/Mem Address this instruction used        
000018D4  B43C 0002               1083          CMP.B   #$02,D2
000018D8  6700 0230               1084          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000018DC                          1085                         
000018DC  B43C 0007               1086          CMP.B   #$07,D2
000018E0  6700 0258               1087          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000018E4                          1088          
000018E4                          1089          *If the ea mode isn't equal to any of these, it is an invalid EA
000018E4  4EF9 00001F80           1090          JMP     BADEACODE
000018EA                          1091  
000018EA                          1092  
000018EA                          1093  *Now we know this instruction is exactly RTS, lets set everything up for EA.
000018EA                          1094  IS_RTS
000018EA                          1095          *Verify bits 5-0 of this instruction. If its not equal to %11 0101, it is an
000018EA                          1096          *invalid op code        
000018EA  4282                    1097          CLR.L   D2
000018EC  3407                    1098          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000018EE  C47C 003F               1099          AND.W   #$003F,D2   *Mask out everything but bits 5-0
000018F2                          1100          
000018F2                          1101          *Bits 5-0 aren't equal to $35, bad op code
000018F2  B43C 0035               1102          CMP.B   #$35,D2
000018F6  6600 0678               1103          BNE     BADOPCODE
000018FA                          1104  
000018FA                          1105          *Output 'RTS' to console...
000018FA  43F9 0000256A           1106          LEA     RTS,A1      *Loads RTS into address register A1
00001900  103C 000E               1107          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001904  4E4F                    1108          TRAP    #15         *Displays Message
00001906                          1109                          
00001906                          1110          *Should have a valid RTS op code. Note: No EA decoding is needed for RTS!        
00001906  4EF8 1386               1111          JMP     GRAB_NEXT_OP
0000190A                          1112  
0000190A                          1113  
0000190A                          1114  *STARTS WITH 0101, SUBQ-------------------------------------
0000190A                          1115  BUCKET_0101
0000190A  =00000005               1116  BUCKET0101_BITS EQU $5
0000190A  4281                    1117          CLR.L   D1
0000190C                          1118          *Load the first 4 bits (really a byte) of BUCKET0101 into D1
0000190C  123C 0005               1119          MOVE.B  #BUCKET0101_BITS,D1
00001910                          1120          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0101. 
00001910                          1121          *If equal, continue decoding. If not, branch to next bucket.
00001910  B200                    1122          CMP.B   D0,D1
00001912  6600 00AC               1123          BNE     BUCKET_0110
00001916                          1124  
00001916                          1125          *Test the 8th bit in this instruction, if it is 1, then it is a SUBQ 
00001916                          1126          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1.
00001916  3007                    1127          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001918  0800 0008               1128          BTST.L  #$08,D0
0000191C  6600 0008               1129          BNE     IS_SUBQ *If the zbit was 0 (the 8th bit is 1), branch to IS_LEA
00001920                          1130          
00001920                          1131          *If we get through all of the compares without finding the specific instruction,
00001920                          1132          *then this instruction is either not in our list of OP CODES to decode, or is an
00001920                          1133          *invalid instruction/syntax.
00001920  4EF9 00001F70           1134          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
00001926                          1135  
00001926                          1136  
00001926                          1137  IS_SUBQ
00001926                          1138          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001926                          1139          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001926  4281                    1140          CLR.L   D1
00001928  3207                    1141          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000192A  C27C 00C0               1142          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000192E  EC09                    1143          LSR.B   #$06,D1     *Shift the size bits into LSB
00001930                          1144          
00001930  B23C 0003               1145          CMP.B   #$03,D1     *Compare the size bits to $3
00001934  6700 063A               1146          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)                        
00001938                          1147          
00001938                          1148          *Output 'SUBQ' to console...
00001938  43F9 0000256E           1149          LEA     SUBQ,A1         *Loads SUBQ into address register A1
0000193E  103C 000E               1150          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001942  4E4F                    1151          TRAP    #15             *Displays Message
00001944                          1152                  
00001944                          1153                  
00001944                          1154          *Should have a valid SUBQ op code. Set data up for EA.
00001944                          1155  
00001944                          1156          *Set D4 to the immediate data located in bits 11-9 of the instruction
00001944  4284                    1157          CLR.L   D4
00001946  3807                    1158          MOVE.W  D7,D4       *Move the WHOLE instruction to D0
00001948  C87C 0E00               1159          AND.W   #$0E00,D4   *Mask out everything but the immediate data bits
0000194C  E04C                    1160          LSR.W   #$08,D4     *Shift the immediate data bits into LSB
0000194E  E24C                    1161          LSR.W   #$01,D4
00001950                          1162  
00001950                          1163          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001950  4282                    1164          CLR.L   D2
00001952  3407                    1165          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001954  C47C 0038               1166          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001958  E60A                    1167          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000195A                          1168                  
0000195A                          1169          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000195A  4283                    1170          CLR.L   D3
0000195C  3607                    1171          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000195E  C67C 0007               1172          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001962                          1173  
00001962  4EF9 00001968           1174          JMP     EA_SUBQ
00001968                          1175  
00001968                          1176  EA_SUBQ
00001968                          1177          *Decode the ea bits of SUBQ. Assuming D4 holds the immediate data D1 holds the size, 
00001968                          1178          *D2 holds the EA mode, and D3 holds the EA register.                    
00001968                          1179      
00001968                          1180          *output the size of the operation to console
00001968  4EB9 00001A48           1181          JSR     WrapperSize
0000196E                          1182              
0000196E                          1183          *Output '#$' just before the immediate data
0000196E  43F9 0000264A           1184          LEA     ShaBang,A1
00001974  103C 000E               1185          MOVE.B  #14,D0
00001978  4E4F                    1186          TRAP    #15            
0000197A                          1187              
0000197A                          1188          *output the immediate data for this instruction with the hex-ascii converter
0000197A  4EB8 11EA               1189          JSR     HEXASCII
0000197E                          1190                          
0000197E                          1191          *manually output a comma here...
0000197E  43F9 00002645           1192          LEA     Comma,A1        *Loads Comma into address register A1
00001984  103C 000E               1193          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001988  4E4F                    1194          TRAP    #15             *Displays Message
0000198A                          1195          
0000198A                          1196          *Determine which EA mode and thus Register/Mem Address this instruction used
0000198A  B43C 0000               1197          CMP.B   #$00,D2
0000198E  6700 015A               1198          BEQ     DataRegMode *If EA mode is a data register, output that
00001992                          1199          
00001992  B43C 0001               1200          CMP.B   #$01,D2
00001996  6700 0162               1201          BEQ     AddrRegMode *If EA mode is an address register, output that
0000199A                          1202          
0000199A  B43C 0002               1203          CMP.B   #$02,D2
0000199E  6700 016A               1204          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000019A2                          1205          
000019A2  B43C 0003               1206          CMP.B   #$03,D2
000019A6  6700 0172               1207          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000019AA                          1208          
000019AA  B43C 0004               1209          CMP.B   #$04,D2
000019AE  6700 017A               1210          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000019B2                          1211          
000019B2  B43C 0007               1212          CMP.B   #$07,D2
000019B6  6700 0182               1213          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000019BA                          1214          
000019BA                          1215          *If the ea mode isn't equal to any of these, it is an invalid EA
000019BA  4EF9 00001F80           1216          JMP     BADEACODE
000019C0                          1217  
000019C0                          1218  
000019C0                          1219  *STARTS WITH 0110, BCC--------------------------------------
000019C0                          1220  BUCKET_0110
000019C0  =00000006               1221  BUCKET0110_BITS EQU $6
000019C0                          1222  
000019C0                          1223          *some code...
000019C0                          1224  
000019C0                          1225  
000019C0                          1226  *STARTS WITH 1000, DIVU-------------------------------------
000019C0                          1227  BUCKET_1000
000019C0  =00000008               1228  BUCKET1000_BITS EQU $8
000019C0                          1229  
000019C0                          1230          *some code...
000019C0                          1231  
000019C0                          1232  
000019C0                          1233  *STARTS WITH 1001, SUBA-------------------------------------
000019C0                          1234  BUCKET_1001
000019C0  =00000009               1235  BUCKET1001_BITS EQU $9
000019C0                          1236  
000019C0                          1237          *some code...
000019C0                          1238  
000019C0                          1239  
000019C0                          1240  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000019C0                          1241  BUCKET_1011
000019C0  =0000000B               1242  BUCKET1011_BITS EQU $B
000019C0                          1243  
000019C0                          1244          *some code...
000019C0                          1245  
000019C0                          1246  
000019C0                          1247  *STARTS WITH 1100, MULS(W) | AND----------------------------
000019C0                          1248  BUCKET_1100
000019C0  =0000000C               1249  BUCKET1100_BITS EQU $C
000019C0                          1250  
000019C0                          1251          *some code...
000019C0                          1252  
000019C0                          1253  
000019C0                          1254  *STARTS WITH 1101, ADD | ADDA-------------------------------
000019C0                          1255  BUCKET_1101
000019C0  =0000000D               1256  BUCKET1101_BITS EQU $D
000019C0                          1257  
000019C0                          1258          *some code...
000019C0                          1259  
000019C0                          1260  
000019C0                          1261  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000019C0                          1262  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000019C0                          1263  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000019C0                          1264  BUCKET_1110
000019C0  =0000000E               1265  BUCKET1110_BITS EQU $E     
000019C0                          1266  
000019C0                          1267          *some code...
000019C0                          1268  
000019C0                          1269  
000019C0                          1270  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000019C0                          1271  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000019C0  4EF9 00001F70           1272          JMP     BADOPCODE  
000019C6                          1273  
000019C6                          1274  
000019C6                          1275  *-----------------------------------------------------------        
000019C6                          1276  * EA operation size decoding functionality for immediate data
000019C6                          1277  *-----------------------------------------------------------   
000019C6                          1278  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
000019C6                          1279  WrapperSizeImmediate
000019C6  4284                    1280          CLR.L   D4
000019C8                          1281          *Depending on the EA size, choose which size to decode
000019C8  B23C 0000               1282          CMP.B   #$00,D1
000019CC  6700 0014               1283          BEQ     ByteSizeImmediate
000019D0                          1284          
000019D0  B23C 0001               1285          CMP.B   #$01,D1
000019D4  6700 002E               1286          BEQ     WordSizeImmediate
000019D8                          1287  
000019D8  B23C 0002               1288          CMP.B   #$02,D1
000019DC  6700 0048               1289          BEQ     LongSizeImmediate
000019E0                          1290          
000019E0                          1291  *Used to get back to what we were doing, after dealing with the specific size
000019E0                          1292  WrapperSizeImmediateEnd
000019E0  4E75                    1293          RTS
000019E2                          1294          
000019E2                          1295  ByteSizeImmediate
000019E2  3818                    1296          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
000019E4                          1297          
000019E4                          1298          *Output '.B' to console...
000019E4  43F9 00002573           1299          LEA     ByteSize,A1 *Loads ByteSize into address register A1
000019EA  103C 000E               1300          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000019EE  4E4F                    1301          TRAP    #15         *Displays Message
000019F0                          1302          
000019F0                          1303          *Output '#$' just before the immediate data
000019F0  43F9 0000264A           1304          LEA     ShaBang,A1
000019F6  103C 000E               1305          MOVE.B  #14,D0
000019FA  4E4F                    1306          TRAP    #15  
000019FC                          1307          
000019FC                          1308          *output the immediate data to console with the hex-ascii converter
000019FC  4EB8 11EA               1309          JSR     HEXASCII
00001A00                          1310                  
00001A00  4EF8 19E0               1311          JMP     WrapperSizeImmediateEnd
00001A04                          1312                  
00001A04                          1313  WordSizeImmediate
00001A04  3818                    1314          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001A06                          1315          
00001A06                          1316          *Output '.W' to console...
00001A06  43F9 0000257A           1317          LEA     WordSize,A1 *Loads WordSize into address register A1
00001A0C  103C 000E               1318          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A10  4E4F                    1319          TRAP    #15         *Displays Message
00001A12                          1320          
00001A12                          1321          *Output '#$' just before the immediate data
00001A12  43F9 0000264A           1322          LEA     ShaBang,A1
00001A18  103C 000E               1323          MOVE.B  #14,D0
00001A1C  4E4F                    1324          TRAP    #15  
00001A1E                          1325          
00001A1E                          1326          *output the immediate data to console with the hex-ascii converter
00001A1E  4EB8 11EA               1327          JSR     HEXASCII
00001A22                          1328          
00001A22  4EF8 19E0               1329          JMP     WrapperSizeImmediateEnd
00001A26                          1330                  
00001A26                          1331  LongSizeImmediate
00001A26  2818                    1332          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
00001A28                          1333          
00001A28                          1334          *Output '.L' to console...
00001A28  43F9 00002581           1335          LEA     LongSize,A1 *Loads LongSize into address register A1
00001A2E  103C 000E               1336          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A32  4E4F                    1337          TRAP    #15         *Displays Message
00001A34                          1338          
00001A34                          1339          *Output '#$' just before the immediate data
00001A34  43F9 0000264A           1340          LEA     ShaBang,A1
00001A3A  103C 000E               1341          MOVE.B  #14,D0
00001A3E  4E4F                    1342          TRAP    #15  
00001A40                          1343          
00001A40                          1344          *output the immediate data to console with the hex-ascii converter
00001A40  4EB8 11EA               1345          JSR     HEXASCII
00001A44                          1346          
00001A44  4EF8 19E0               1347          JMP     WrapperSizeImmediateEnd        
00001A48                          1348  
00001A48                          1349  
00001A48                          1350  *-----------------------------------------------------------        
00001A48                          1351  * EA operation size decoding functionality for non-immediate data. Used to figure out
00001A48                          1352  * and output the size affix for a typical opcode.
00001A48                          1353  *-----------------------------------------------------------   
00001A48                          1354  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001A48                          1355  WrapperSize
00001A48                          1356          *Depending on the EA size, choose which size to decode
00001A48  B23C 0000               1357          CMP.B   #$00,D1
00001A4C  6700 0014               1358          BEQ     ByteSizeOp
00001A50                          1359          
00001A50  B23C 0001               1360          CMP.B   #$01,D1
00001A54  6700 001C               1361          BEQ     WordSizeOp
00001A58                          1362  
00001A58  B23C 0002               1363          CMP.B   #$02,D1
00001A5C  6700 0024               1364          BEQ     LongSizeOp
00001A60                          1365          
00001A60                          1366  *Used to get back to what we were doing, after dealing with the specific size
00001A60                          1367  WrapperSizeEnd
00001A60  4E75                    1368          RTS
00001A62                          1369          
00001A62                          1370  ByteSizeOp                
00001A62                          1371          *Output '.B' to console...
00001A62  43F9 00002573           1372          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001A68  103C 000E               1373          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A6C  4E4F                    1374          TRAP    #15         *Displays Message                
00001A6E                          1375                  
00001A6E  4EF8 1A60               1376          JMP     WrapperSizeEnd
00001A72                          1377                  
00001A72                          1378  WordSizeOp
00001A72                          1379          *Output '.W' to console...
00001A72  43F9 0000257A           1380          LEA     WordSize,A1 *Loads WordSize into address register A1
00001A78  103C 000E               1381          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A7C  4E4F                    1382          TRAP    #15         *Displays Message               
00001A7E                          1383          
00001A7E  4EF8 1A60               1384          JMP     WrapperSizeEnd
00001A82                          1385                  
00001A82                          1386  LongSizeOp      
00001A82                          1387          *Output '.L' to console...
00001A82  43F9 00002581           1388          LEA     LongSize,A1 *Loads LongSize into address register A1
00001A88  103C 000E               1389          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001A8C  4E4F                    1390          TRAP    #15         *Displays Message                
00001A8E                          1391          
00001A8E  4EF8 1A60               1392          JMP     WrapperSizeEnd        
00001A92                          1393  
00001A92                          1394  
00001A92                          1395  *-----------------------------------------------------------        
00001A92                          1396  * BCHG Size decoding functionality
00001A92                          1397  *----------------------------------------------------------- 
00001A92                          1398  BCHGSizeHelper
00001A92                          1399          *Determine if the EA mode is a data register. If so, output '.L' to console...
00001A92  B43C 0000               1400          CMP.B   #$00,D2
00001A96  6700 000A               1401          BEQ     BCHGLongSize
00001A9A                          1402          
00001A9A                          1403          *If the EA mode isn't a data register, WE MUST output a '.B' to console...
00001A9A  4EF9 00001AB2           1404          JMP     BCHGByteSize
00001AA0                          1405          
00001AA0                          1406  *Used to get back to what we were doing, after dealing with the specific size
00001AA0                          1407  BCHGSizeHelperEnd
00001AA0  4E75                    1408          RTS  
00001AA2                          1409          
00001AA2                          1410  BCHGLongSize
00001AA2                          1411          *Output '.L' to console...
00001AA2  43F9 00002581           1412          LEA     LongSize,A1 *Loads LongSize into address register A1
00001AA8  103C 000E               1413          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001AAC  4E4F                    1414          TRAP    #15         *Displays Message
00001AAE                          1415  
00001AAE  4EF8 1AA0               1416          JMP     BCHGSizeHelperEnd
00001AB2                          1417          
00001AB2                          1418  BCHGByteSize
00001AB2                          1419          *Output '.B' to console...
00001AB2  43F9 00002573           1420          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001AB8  103C 000E               1421          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001ABC  4E4F                    1422          TRAP    #15         *Displays Message   
00001ABE                          1423          
00001ABE  4EF8 1AA0               1424          JMP     BCHGSizeHelperEnd
00001AC2                          1425          
00001AC2                          1426  *Output the immediate data for a BCHG(static). Data is always byte size.
00001AC2                          1427  BCHGImmediate
00001AC2  3818                    1428          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word        
00001AC4                          1429          
00001AC4                          1430          *Output '#$' just before the immediate data
00001AC4  43F9 0000264A           1431          LEA     ShaBang,A1
00001ACA  103C 000E               1432          MOVE.B  #14,D0
00001ACE  4E4F                    1433          TRAP    #15  
00001AD0                          1434          
00001AD0                          1435          *output the immediate data to console with the hex-ascii converter
00001AD0  4EB8 11EA               1436          JSR     HEXASCII
00001AD4                          1437                  
00001AD4  4E75                    1438          RTS        
00001AD6                          1439  
00001AD6                          1440  
00001AD6                          1441  *-----------------------------------------------------------        
00001AD6                          1442  * LEA Wrappers to conform to design of EA mode/register as destination operand. 
00001AD6                          1443  * LEA is weird in that its EA mode/register is used as a source operand.
00001AD6                          1444  *-----------------------------------------------------------        
00001AD6                          1445  *This conforms LEA to the JSR requirement of AddrIndirectMode. JMPs back to LEA after the JSR.
00001AD6                          1446  LEA_AddrIndirectWrapper
00001AD6  4EB9 00001B0A           1447          JSR     AddrIndirectMode
00001ADC                          1448          
00001ADC  4EF8 182A               1449          JMP     EA_LEA_WrapperEnd
00001AE0                          1450          
00001AE0                          1451  *This conforms LEA to the JSR requirement of AddrAbsoluteMode. JMPs back to LEA after the JSR.
00001AE0                          1452  LEA_AddrAbsoluteWrapper
00001AE0  4EB9 00001B3A           1453          JSR     AddrAbsoluteMode
00001AE6                          1454          
00001AE6  4EF8 182A               1455          JMP     EA_LEA_WrapperEnd
00001AEA                          1456  
00001AEA                          1457  
00001AEA                          1458  *-----------------------------------------------------------        
00001AEA                          1459  * EA Mode/EA Register decoding functionality
00001AEA                          1460  *-----------------------------------------------------------        
00001AEA                          1461  DataRegMode
00001AEA                          1462          *Depending on the EA Register, output a different register number
00001AEA  4EB9 00001B4A           1463          JSR     WrapperDataReg        
00001AF0                          1464          
00001AF0                          1465          *if this was called for a destination decoding then we are done decoding this        
00001AF0                          1466          *instruction, go get the next instruction
00001AF0  BC3C 0001               1467          CMP.B   #$01,D6
00001AF4  6600 F890               1468          BNE     GRAB_NEXT_OP
00001AF8                          1469          
00001AF8                          1470          *else this was a source decoding, rts back to we can keep decoding
00001AF8  4E75                    1471          RTS
00001AFA                          1472  
00001AFA                          1473  AddrRegMode
00001AFA  4EB9 00001C0C           1474          JSR     WrapperAddrReg
00001B00                          1475          
00001B00                          1476          *if this was called for a destination decoding then we are done decoding this        
00001B00                          1477          *instruction, go get the next instruction
00001B00  BC3C 0001               1478          CMP.B   #$01,D6
00001B04  6600 F880               1479          BNE     GRAB_NEXT_OP
00001B08                          1480          
00001B08                          1481          *else this was a source decoding, rts back to we can keep decoding
00001B08  4E75                    1482          RTS
00001B0A                          1483  
00001B0A                          1484  AddrIndirectMode
00001B0A                          1485          *Depending on the EA Register, output a different register number
00001B0A  4EB9 00001CCE           1486          JSR     WrapperAddrIndirect
00001B10                          1487                          
00001B10                          1488          *if this was called for a destination decoding then we are done decoding this        
00001B10                          1489          *instruction, go get the next instruction
00001B10  BC3C 0001               1490          CMP.B   #$01,D6
00001B14  6600 F870               1491          BNE     GRAB_NEXT_OP
00001B18                          1492          
00001B18                          1493          *else this was a source decoding, rts back to we can keep decoding
00001B18  4E75                    1494          RTS
00001B1A                          1495  
00001B1A                          1496  AddrIndirectPostMode
00001B1A                          1497          *Depending on the EA Register, output a different register number
00001B1A  4EB9 00001D90           1498          JSR     WrapperAddrIndirectPost
00001B20                          1499  
00001B20                          1500          *if this was called for a destination decoding then we are done decoding this        
00001B20                          1501          *instruction, go get the next instruction
00001B20  BC3C 0001               1502          CMP.B   #$01,D6
00001B24  6600 F860               1503          BNE     GRAB_NEXT_OP
00001B28                          1504          
00001B28                          1505          *else this was a source decoding, rts back to we can keep decoding
00001B28  4E75                    1506          RTS
00001B2A                          1507  
00001B2A                          1508  AddrIndirectPreMode
00001B2A                          1509          *Depending on the EA Register, output a different register number
00001B2A  4EB9 00001E52           1510          JSR     WrapperAddrIndirectPre
00001B30                          1511  
00001B30                          1512          *if this was called for a destination decoding then we are done decoding this        
00001B30                          1513          *instruction, go get the next instruction
00001B30  BC3C 0001               1514          CMP.B   #$01,D6
00001B34  6600 F850               1515          BNE     GRAB_NEXT_OP
00001B38                          1516          
00001B38                          1517          *else this was a source decoding, rts back to we can keep decoding
00001B38  4E75                    1518          RTS
00001B3A                          1519  
00001B3A                          1520  AddrAbsoluteMode
00001B3A                          1521          *Depending on the EA Register, output a different register number
00001B3A  4EB9 00001F14           1522          JSR     WrapperAddrAbsolute        
00001B40                          1523  
00001B40                          1524          *if this was called for a destination decoding then we are done decoding this        
00001B40                          1525          *instruction, go get the next instruction
00001B40  BC3C 0001               1526          CMP.B   #$01,D6
00001B44  6600 F840               1527          BNE     GRAB_NEXT_OP
00001B48                          1528          
00001B48                          1529          *else this was a source decoding, rts back to we can keep decoding
00001B48  4E75                    1530          RTS
00001B4A                          1531          
00001B4A                          1532  ImmediateDataMode
00001B4A                          1533          *some code        
00001B4A                          1534          
00001B4A                          1535          
00001B4A                          1536  *-----------------------------------------------------------        
00001B4A                          1537  * Output logic for all Data Registers (0-7)
00001B4A                          1538  *-----------------------------------------------------------
00001B4A                          1539  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001B4A                          1540  WrapperDataReg
00001B4A                          1541          *Depending on the EA destination register, output a different register number
00001B4A  B63C 0000               1542          CMP.B   #$00,D3
00001B4E  6700 003C               1543          BEQ     DataReg0
00001B52                          1544          
00001B52  B63C 0001               1545          CMP.B   #$01,D3
00001B56  6700 0044               1546          BEQ     DataReg1
00001B5A                          1547          
00001B5A  B63C 0002               1548          CMP.B   #$02,D3
00001B5E  6700 004C               1549          BEQ     DataReg2
00001B62                          1550          
00001B62  B63C 0003               1551          CMP.B   #$03,D3
00001B66  6700 0054               1552          BEQ     DataReg3
00001B6A                          1553          
00001B6A  B63C 0004               1554          CMP.B   #$04,D3
00001B6E  6700 005C               1555          BEQ     DataReg4
00001B72                          1556          
00001B72  B63C 0005               1557          CMP.B   #$05,D3
00001B76  6700 0064               1558          BEQ     DataReg5
00001B7A                          1559          
00001B7A  B63C 0006               1560          CMP.B   #$06,D3
00001B7E  6700 006C               1561          BEQ     DataReg6
00001B82                          1562          
00001B82  B63C 0007               1563          CMP.B   #$07,D3
00001B86  6700 0074               1564          BEQ     DataReg7        
00001B8A                          1565  
00001B8A                          1566  *Used to get back to 'DataRegMode', after dealing with the specific register
00001B8A                          1567  WrapperDataRegEnd
00001B8A  4E75                    1568          RTS
00001B8C                          1569  
00001B8C                          1570  DataReg0
00001B8C                          1571          *Output the specific data register...
00001B8C  43F9 00002588           1572          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
00001B92  103C 000E               1573          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001B96  4E4F                    1574          TRAP    #15             *Displays Message   
00001B98                          1575          
00001B98  4EF8 1B8A               1576          JMP     WrapperDataRegEnd
00001B9C                          1577  
00001B9C                          1578  DataReg1
00001B9C  43F9 0000258B           1579          LEA     OutDataReg1,A1
00001BA2  103C 000E               1580          MOVE.B  #14,D0
00001BA6  4E4F                    1581          TRAP    #15
00001BA8                          1582          
00001BA8  4EF8 1B8A               1583          JMP     WrapperDataRegEnd
00001BAC                          1584  
00001BAC                          1585  DataReg2
00001BAC  43F9 0000258E           1586          LEA     OutDataReg2,A1
00001BB2  103C 000E               1587          MOVE.B  #14,D0
00001BB6  4E4F                    1588          TRAP    #15
00001BB8                          1589  
00001BB8  4EF8 1B8A               1590          JMP     WrapperDataRegEnd
00001BBC                          1591      
00001BBC                          1592  DataReg3
00001BBC  43F9 00002591           1593          LEA     OutDataReg3,A1
00001BC2  103C 000E               1594          MOVE.B  #14,D0
00001BC6  4E4F                    1595          TRAP    #15
00001BC8                          1596  
00001BC8  4EF8 1B8A               1597          JMP     WrapperDataRegEnd
00001BCC                          1598          
00001BCC                          1599  DataReg4
00001BCC  43F9 00002594           1600          LEA     OutDataReg4,A1
00001BD2  103C 000E               1601          MOVE.B  #14,D0
00001BD6  4E4F                    1602          TRAP    #15
00001BD8                          1603  
00001BD8  4EF8 1B8A               1604          JMP     WrapperDataRegEnd
00001BDC                          1605                 
00001BDC                          1606  DataReg5
00001BDC  43F9 00002597           1607          LEA     OutDataReg5,A1
00001BE2  103C 000E               1608          MOVE.B  #14,D0
00001BE6  4E4F                    1609          TRAP    #15
00001BE8                          1610  
00001BE8  4EF8 1B8A               1611          JMP     WrapperDataRegEnd
00001BEC                          1612          
00001BEC                          1613  DataReg6
00001BEC  43F9 0000259A           1614          LEA     OutDataReg6,A1 A1
00001BF2  103C 000E               1615          MOVE.B  #14,D0
00001BF6  4E4F                    1616          TRAP    #15
00001BF8                          1617  
00001BF8  4EF8 1B8A               1618          JMP     WrapperDataRegEnd
00001BFC                          1619          
00001BFC                          1620  DataReg7
00001BFC  43F9 0000259D           1621          LEA     OutDataReg7,A1
00001C02  103C 000E               1622          MOVE.B  #14,D0
00001C06  4E4F                    1623          TRAP    #15
00001C08                          1624          
00001C08  4EF8 1B8A               1625          JMP     WrapperDataRegEnd
00001C0C                          1626  
00001C0C                          1627  
00001C0C                          1628  *-----------------------------------------------------------        
00001C0C                          1629  * Output logic for all Address Registers (0-7)
00001C0C                          1630  *-----------------------------------------------------------     
00001C0C                          1631  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001C0C                          1632  WrapperAddrReg
00001C0C                          1633          *Depending on the EA Register, output a different register number
00001C0C  B63C 0000               1634          CMP.B   #$00,D3
00001C10  6700 003C               1635          BEQ     AddrReg0
00001C14                          1636          
00001C14  B63C 0001               1637          CMP.B   #$01,D3
00001C18  6700 0044               1638          BEQ     AddrReg1
00001C1C                          1639          
00001C1C  B63C 0002               1640          CMP.B   #$02,D3
00001C20  6700 004C               1641          BEQ     AddrReg2
00001C24                          1642          
00001C24  B63C 0003               1643          CMP.B   #$03,D3
00001C28  6700 0054               1644          BEQ     AddrReg3
00001C2C                          1645          
00001C2C  B63C 0004               1646          CMP.B   #$04,D3
00001C30  6700 005C               1647          BEQ     AddrReg4
00001C34                          1648          
00001C34  B63C 0005               1649          CMP.B   #$05,D3
00001C38  6700 0064               1650          BEQ     AddrReg5
00001C3C                          1651          
00001C3C  B63C 0006               1652          CMP.B   #$06,D3
00001C40  6700 006C               1653          BEQ     AddrReg6
00001C44                          1654          
00001C44  B63C 0007               1655          CMP.B   #$07,D3
00001C48  6700 0074               1656          BEQ     AddrReg7
00001C4C                          1657  
00001C4C                          1658  *Used to get back to 'AddrRegMode', after dealing with the specific register
00001C4C                          1659  WrapperAddrRegEnd
00001C4C  4E75                    1660          RTS        
00001C4E                          1661  
00001C4E                          1662  AddrReg0
00001C4E                          1663          *Output the specific address indirect register...
00001C4E  43F9 000025A0           1664          LEA     OutAddrReg0,A1      *Loads AddrReg0 into address register A1
00001C54  103C 000E               1665          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001C58  4E4F                    1666          TRAP    #15                 *Displays Message        
00001C5A                          1667          
00001C5A  4EF8 1C4C               1668          JMP     WrapperAddrRegEnd
00001C5E                          1669  
00001C5E                          1670  AddrReg1
00001C5E  43F9 000025A3           1671          LEA     OutAddrReg1,A1
00001C64  103C 000E               1672          MOVE.B  #14,D0
00001C68  4E4F                    1673          TRAP    #15
00001C6A                          1674          
00001C6A  4EF8 1C4C               1675          JMP     WrapperAddrRegEnd
00001C6E                          1676  
00001C6E                          1677  AddrReg2
00001C6E  43F9 000025A6           1678          LEA     OutAddrReg2,A1
00001C74  103C 000E               1679          MOVE.B  #14,D0
00001C78  4E4F                    1680          TRAP    #15
00001C7A                          1681          
00001C7A  4EF8 1C4C               1682          JMP     WrapperAddrRegEnd
00001C7E                          1683  
00001C7E                          1684  AddrReg3
00001C7E  43F9 000025A9           1685          LEA     OutAddrReg3,A1
00001C84  103C 000E               1686          MOVE.B  #14,D0
00001C88  4E4F                    1687          TRAP    #15
00001C8A                          1688          
00001C8A  4EF8 1C4C               1689          JMP     WrapperAddrRegEnd
00001C8E                          1690  
00001C8E                          1691  AddrReg4
00001C8E  43F9 000025AC           1692          LEA     OutAddrReg4,A1
00001C94  103C 000E               1693          MOVE.B  #14,D0
00001C98  4E4F                    1694          TRAP    #15
00001C9A                          1695          
00001C9A  4EF8 1C4C               1696          JMP     WrapperAddrRegEnd
00001C9E                          1697  
00001C9E                          1698  AddrReg5
00001C9E  43F9 000025AF           1699          LEA     OutAddrReg5,A1
00001CA4  103C 000E               1700          MOVE.B  #14,D0
00001CA8  4E4F                    1701          TRAP    #15
00001CAA                          1702          
00001CAA  4EF8 1C4C               1703          JMP     WrapperAddrRegEnd
00001CAE                          1704  
00001CAE                          1705  AddrReg6
00001CAE  43F9 000025B2           1706          LEA     OutAddrReg6,A1
00001CB4  103C 000E               1707          MOVE.B  #14,D0
00001CB8  4E4F                    1708          TRAP    #15
00001CBA                          1709          
00001CBA  4EF8 1C4C               1710          JMP     WrapperAddrRegEnd
00001CBE                          1711  
00001CBE                          1712  AddrReg7
00001CBE  43F9 000025B5           1713          LEA     OutAddrReg7,A1
00001CC4  103C 000E               1714          MOVE.B  #14,D0
00001CC8  4E4F                    1715          TRAP    #15
00001CCA                          1716          
00001CCA  4EF8 1C4C               1717          JMP     WrapperAddrRegEnd
00001CCE                          1718  
00001CCE                          1719  
00001CCE                          1720  *-----------------------------------------------------------        
00001CCE                          1721  * Output logic for all Address Indirect Registers (0-7)
00001CCE                          1722  *-----------------------------------------------------------     
00001CCE                          1723  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001CCE                          1724  WrapperAddrIndirect
00001CCE                          1725          *Depending on the EA Register, output a different register number
00001CCE  B63C 0000               1726          CMP.B   #$00,D3
00001CD2  6700 003C               1727          BEQ     AddrIndReg0
00001CD6                          1728          
00001CD6  B63C 0001               1729          CMP.B   #$01,D3
00001CDA  6700 0044               1730          BEQ     AddrIndReg1
00001CDE                          1731          
00001CDE  B63C 0002               1732          CMP.B   #$02,D3
00001CE2  6700 004C               1733          BEQ     AddrIndReg2
00001CE6                          1734          
00001CE6  B63C 0003               1735          CMP.B   #$03,D3
00001CEA  6700 0054               1736          BEQ     AddrIndReg3
00001CEE                          1737          
00001CEE  B63C 0004               1738          CMP.B   #$04,D3
00001CF2  6700 005C               1739          BEQ     AddrIndReg4
00001CF6                          1740          
00001CF6  B63C 0005               1741          CMP.B   #$05,D3
00001CFA  6700 0064               1742          BEQ     AddrIndReg5
00001CFE                          1743          
00001CFE  B63C 0006               1744          CMP.B   #$06,D3
00001D02  6700 006C               1745          BEQ     AddrIndReg6
00001D06                          1746          
00001D06  B63C 0007               1747          CMP.B   #$07,D3
00001D0A  6700 0074               1748          BEQ     AddrIndReg7
00001D0E                          1749  
00001D0E                          1750  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
00001D0E                          1751  WrapperAddrIndirectEnd
00001D0E  4E75                    1752          RTS        
00001D10                          1753  
00001D10                          1754  AddrIndReg0
00001D10                          1755          *Output the specific address indirect register...
00001D10  43F9 000025B8           1756          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001D16  103C 000E               1757          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001D1A  4E4F                    1758          TRAP    #15                 *Displays Message        
00001D1C                          1759          
00001D1C  4EF8 1D0E               1760          JMP     WrapperAddrIndirectEnd
00001D20                          1761  
00001D20                          1762  AddrIndReg1
00001D20  43F9 000025BD           1763          LEA     OutAddrIndReg1,A1
00001D26  103C 000E               1764          MOVE.B  #14,D0
00001D2A  4E4F                    1765          TRAP    #15
00001D2C                          1766          
00001D2C  4EF8 1D0E               1767          JMP     WrapperAddrIndirectEnd
00001D30                          1768  
00001D30                          1769  AddrIndReg2
00001D30  43F9 000025C2           1770          LEA     OutAddrIndReg2,A1
00001D36  103C 000E               1771          MOVE.B  #14,D0
00001D3A  4E4F                    1772          TRAP    #15
00001D3C                          1773          
00001D3C  4EF8 1D0E               1774          JMP     WrapperAddrIndirectEnd
00001D40                          1775  
00001D40                          1776  AddrIndReg3
00001D40  43F9 000025C7           1777          LEA     OutAddrIndReg3,A1
00001D46  103C 000E               1778          MOVE.B  #14,D0
00001D4A  4E4F                    1779          TRAP    #15
00001D4C                          1780          
00001D4C  4EF8 1D0E               1781          JMP     WrapperAddrIndirectEnd
00001D50                          1782  
00001D50                          1783  AddrIndReg4
00001D50  43F9 000025CC           1784          LEA     OutAddrIndReg4,A1
00001D56  103C 000E               1785          MOVE.B  #14,D0
00001D5A  4E4F                    1786          TRAP    #15
00001D5C                          1787          
00001D5C  4EF8 1D0E               1788          JMP     WrapperAddrIndirectEnd
00001D60                          1789  
00001D60                          1790  AddrIndReg5
00001D60  43F9 000025D1           1791          LEA     OutAddrIndReg5,A1
00001D66  103C 000E               1792          MOVE.B  #14,D0
00001D6A  4E4F                    1793          TRAP    #15
00001D6C                          1794          
00001D6C  4EF8 1D0E               1795          JMP     WrapperAddrIndirectEnd
00001D70                          1796  
00001D70                          1797  AddrIndReg6
00001D70  43F9 000025D6           1798          LEA     OutAddrIndReg6,A1
00001D76  103C 000E               1799          MOVE.B  #14,D0
00001D7A  4E4F                    1800          TRAP    #15
00001D7C                          1801          
00001D7C  4EF8 1D0E               1802          JMP     WrapperAddrIndirectEnd
00001D80                          1803  
00001D80                          1804  AddrIndReg7
00001D80  43F9 000025DB           1805          LEA     OutAddrIndReg7,A1
00001D86  103C 000E               1806          MOVE.B  #14,D0
00001D8A  4E4F                    1807          TRAP    #15
00001D8C                          1808          
00001D8C  4EF8 1D0E               1809          JMP     WrapperAddrIndirectEnd
00001D90                          1810          
00001D90                          1811          
00001D90                          1812  *-----------------------------------------------------------        
00001D90                          1813  * Output logic for all Address Indirect Post Increment Registers (0-7)
00001D90                          1814  *-----------------------------------------------------------     
00001D90                          1815  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001D90                          1816  WrapperAddrIndirectPost
00001D90                          1817          *Depending on the EA Register, output a different register number
00001D90  B63C 0000               1818          CMP.B   #$00,D3
00001D94  6700 003C               1819          BEQ     AddrIndPoReg0
00001D98                          1820          
00001D98  B63C 0001               1821          CMP.B   #$01,D3
00001D9C  6700 0044               1822          BEQ     AddrIndPoReg1
00001DA0                          1823          
00001DA0  B63C 0002               1824          CMP.B   #$02,D3
00001DA4  6700 004C               1825          BEQ     AddrIndPoReg2
00001DA8                          1826          
00001DA8  B63C 0003               1827          CMP.B   #$03,D3
00001DAC  6700 0054               1828          BEQ     AddrIndPoReg3
00001DB0                          1829          
00001DB0  B63C 0004               1830          CMP.B   #$04,D3
00001DB4  6700 005C               1831          BEQ     AddrIndPoReg4
00001DB8                          1832          
00001DB8  B63C 0005               1833          CMP.B   #$05,D3
00001DBC  6700 0064               1834          BEQ     AddrIndPoReg5
00001DC0                          1835          
00001DC0  B63C 0006               1836          CMP.B   #$06,D3
00001DC4  6700 006C               1837          BEQ     AddrIndPoReg6
00001DC8                          1838          
00001DC8  B63C 0007               1839          CMP.B   #$07,D3
00001DCC  6700 0074               1840          BEQ     AddrIndPoReg7
00001DD0                          1841  
00001DD0                          1842  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
00001DD0                          1843  WrapperAddrIndirectPostEnd
00001DD0  4E75                    1844          RTS        
00001DD2                          1845  
00001DD2                          1846  AddrIndPoReg0
00001DD2                          1847          *Output the specific address indirect post register...
00001DD2  43F9 000025E0           1848          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001DD8  103C 000E               1849          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001DDC  4E4F                    1850          TRAP    #15                 *Displays Message        
00001DDE                          1851          
00001DDE  4EF8 1DD0               1852          JMP     WrapperAddrIndirectPostEnd
00001DE2                          1853  
00001DE2                          1854  AddrIndPoReg1
00001DE2  43F9 000025E6           1855          LEA     OutAddrIndPoReg1,A1
00001DE8  103C 000E               1856          MOVE.B  #14,D0
00001DEC  4E4F                    1857          TRAP    #15
00001DEE                          1858          
00001DEE  4EF8 1DD0               1859          JMP     WrapperAddrIndirectPostEnd
00001DF2                          1860  
00001DF2                          1861  AddrIndPoReg2
00001DF2  43F9 000025EC           1862          LEA     OutAddrIndPoReg2,A1
00001DF8  103C 000E               1863          MOVE.B  #14,D0
00001DFC  4E4F                    1864          TRAP    #15
00001DFE                          1865          
00001DFE  4EF8 1DD0               1866          JMP     WrapperAddrIndirectPostEnd
00001E02                          1867  
00001E02                          1868  AddrIndPoReg3
00001E02  43F9 000025F2           1869          LEA     OutAddrIndPoReg3,A1
00001E08  103C 000E               1870          MOVE.B  #14,D0
00001E0C  4E4F                    1871          TRAP    #15
00001E0E                          1872          
00001E0E  4EF8 1DD0               1873          JMP     WrapperAddrIndirectPostEnd
00001E12                          1874  
00001E12                          1875  AddrIndPoReg4
00001E12  43F9 000025F8           1876          LEA     OutAddrIndPoReg4,A1
00001E18  103C 000E               1877          MOVE.B  #14,D0
00001E1C  4E4F                    1878          TRAP    #15
00001E1E                          1879          
00001E1E  4EF8 1DD0               1880          JMP     WrapperAddrIndirectPostEnd
00001E22                          1881  
00001E22                          1882  AddrIndPoReg5
00001E22  43F9 000025FE           1883          LEA     OutAddrIndPoReg5,A1
00001E28  103C 000E               1884          MOVE.B  #14,D0
00001E2C  4E4F                    1885          TRAP    #15
00001E2E                          1886          
00001E2E  4EF8 1DD0               1887          JMP     WrapperAddrIndirectPostEnd
00001E32                          1888  
00001E32                          1889  AddrIndPoReg6
00001E32  43F9 00002604           1890          LEA     OutAddrIndPoReg6,A1
00001E38  103C 000E               1891          MOVE.B  #14,D0
00001E3C  4E4F                    1892          TRAP    #15
00001E3E                          1893          
00001E3E  4EF8 1DD0               1894          JMP     WrapperAddrIndirectPostEnd
00001E42                          1895  
00001E42                          1896  AddrIndPoReg7
00001E42  43F9 0000260A           1897          LEA     OutAddrIndPoReg7,A1
00001E48  103C 000E               1898          MOVE.B  #14,D0
00001E4C  4E4F                    1899          TRAP    #15
00001E4E                          1900          
00001E4E  4EF8 1DD0               1901          JMP     WrapperAddrIndirectPostEnd
00001E52                          1902  
00001E52                          1903  
00001E52                          1904  *-----------------------------------------------------------        
00001E52                          1905  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001E52                          1906  *-----------------------------------------------------------     
00001E52                          1907  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001E52                          1908  WrapperAddrIndirectPre
00001E52                          1909          *Depending on the EA Register, output a different register number
00001E52  B63C 0000               1910          CMP.B   #$00,D3
00001E56  6700 003C               1911          BEQ     AddrIndPrReg0
00001E5A                          1912          
00001E5A  B63C 0001               1913          CMP.B   #$01,D3
00001E5E  6700 0044               1914          BEQ     AddrIndPrReg1
00001E62                          1915          
00001E62  B63C 0002               1916          CMP.B   #$02,D3
00001E66  6700 004C               1917          BEQ     AddrIndPrReg2
00001E6A                          1918          
00001E6A  B63C 0003               1919          CMP.B   #$03,D3
00001E6E  6700 0054               1920          BEQ     AddrIndPrReg3
00001E72                          1921          
00001E72  B63C 0004               1922          CMP.B   #$04,D3
00001E76  6700 005C               1923          BEQ     AddrIndPrReg4
00001E7A                          1924          
00001E7A  B63C 0005               1925          CMP.B   #$05,D3
00001E7E  6700 0064               1926          BEQ     AddrIndPrReg5
00001E82                          1927          
00001E82  B63C 0006               1928          CMP.B   #$06,D3
00001E86  6700 006C               1929          BEQ     AddrIndPrReg6
00001E8A                          1930          
00001E8A  B63C 0007               1931          CMP.B   #$07,D3
00001E8E  6700 0074               1932          BEQ     AddrIndPrReg7
00001E92                          1933  
00001E92                          1934  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001E92                          1935  WrapperAddrIndirectPreEnd
00001E92  4E75                    1936          RTS        
00001E94                          1937  
00001E94                          1938  AddrIndPrReg0
00001E94                          1939          *Output the specific address indirect post register...
00001E94  43F9 00002610           1940          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001E9A  103C 000E               1941          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001E9E  4E4F                    1942          TRAP    #15                 *Displays Message        
00001EA0                          1943          
00001EA0  4EF8 1E92               1944          JMP     WrapperAddrIndirectPreEnd
00001EA4                          1945  
00001EA4                          1946  AddrIndPrReg1
00001EA4  43F9 00002616           1947          LEA     OutAddrIndPrReg1,A1
00001EAA  103C 000E               1948          MOVE.B  #14,D0
00001EAE  4E4F                    1949          TRAP    #15
00001EB0                          1950          
00001EB0  4EF8 1E92               1951          JMP     WrapperAddrIndirectPreEnd
00001EB4                          1952  
00001EB4                          1953  AddrIndPrReg2
00001EB4  43F9 0000261C           1954          LEA     OutAddrIndPrReg2,A1
00001EBA  103C 000E               1955          MOVE.B  #14,D0
00001EBE  4E4F                    1956          TRAP    #15
00001EC0                          1957          
00001EC0  4EF8 1E92               1958          JMP     WrapperAddrIndirectPreEnd
00001EC4                          1959  
00001EC4                          1960  AddrIndPrReg3
00001EC4  43F9 00002622           1961          LEA     OutAddrIndPrReg3,A1
00001ECA  103C 000E               1962          MOVE.B  #14,D0
00001ECE  4E4F                    1963          TRAP    #15
00001ED0                          1964          
00001ED0  4EF8 1E92               1965          JMP     WrapperAddrIndirectPreEnd
00001ED4                          1966  
00001ED4                          1967  AddrIndPrReg4
00001ED4  43F9 00002628           1968          LEA     OutAddrIndPrReg4,A1
00001EDA  103C 000E               1969          MOVE.B  #14,D0
00001EDE  4E4F                    1970          TRAP    #15
00001EE0                          1971          
00001EE0  4EF8 1E92               1972          JMP     WrapperAddrIndirectPreEnd
00001EE4                          1973  
00001EE4                          1974  AddrIndPrReg5
00001EE4  43F9 0000262E           1975          LEA     OutAddrIndPrReg5,A1
00001EEA  103C 000E               1976          MOVE.B  #14,D0
00001EEE  4E4F                    1977          TRAP    #15
00001EF0                          1978          
00001EF0  4EF8 1E92               1979          JMP     WrapperAddrIndirectPreEnd
00001EF4                          1980  
00001EF4                          1981  AddrIndPrReg6
00001EF4  43F9 00002634           1982          LEA     OutAddrIndPrReg6,A1
00001EFA  103C 000E               1983          MOVE.B  #14,D0
00001EFE  4E4F                    1984          TRAP    #15
00001F00                          1985          
00001F00  4EF8 1E92               1986          JMP     WrapperAddrIndirectPreEnd
00001F04                          1987  
00001F04                          1988  AddrIndPrReg7
00001F04  43F9 0000263A           1989          LEA     OutAddrIndPrReg7,A1
00001F0A  103C 000E               1990          MOVE.B  #14,D0
00001F0E  4E4F                    1991          TRAP    #15
00001F10                          1992          
00001F10  4EF8 1E92               1993          JMP     WrapperAddrIndirectPreEnd
00001F14                          1994  
00001F14                          1995  
00001F14                          1996  *-----------------------------------------------------------        
00001F14                          1997  * Output logic for absolute memory addressing (0-7)
00001F14                          1998  *-----------------------------------------------------------     
00001F14                          1999  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001F14                          2000  WrapperAddrAbsolute
00001F14  4284                    2001          CLR.L   D4
00001F16                          2002          *Depending on the EA Register, choose which size to decode
00001F16  B63C 0000               2003          CMP.B   #$00,D3
00001F1A  6700 000C               2004          BEQ     WordSizeAbsolute
00001F1E                          2005  
00001F1E  B63C 0001               2006          CMP.B   #$01,D3
00001F22  6700 0028               2007          BEQ     LongSizeAbsolute
00001F26                          2008          
00001F26                          2009  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001F26                          2010  WrapperAddrAbsoluteEnd
00001F26  4E75                    2011          RTS
00001F28                          2012  
00001F28                          2013  WordSizeAbsolute        
00001F28  3818                    2014          MOVE.W  (A0)+,D4    *read in next word, data is that word        
00001F2A                          2015              
00001F2A                          2016          *Output ',$' just after source operand
00001F2A  43F9 0000264D           2017          LEA     Bang,A1
00001F30  103C 000E               2018          MOVE.B  #14,D0
00001F34  4E4F                    2019          TRAP    #15
00001F36                          2020              
00001F36                          2021          *Push D1 into stack, in case something was using it
00001F36  48E7 4000               2022          MOVEM.L D1,-(SP)
00001F3A                          2023          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001F3A  4281                    2024          CLR.L   D1
00001F3C  123C 0001               2025          MOVE.B  #$01,D1
00001F40                          2026              
00001F40                          2027          *output the absolute mem address to console with the hex-ascii converter
00001F40  4EB8 11EA               2028          JSR     HEXASCII
00001F44  4CDF 0002               2029          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001F48                          2030          
00001F48  4EF8 1F26               2031          JMP     WrapperAddrAbsoluteEnd
00001F4C                          2032  
00001F4C                          2033  LongSizeAbsolute
00001F4C  2818                    2034          MOVE.L  (A0)+,D4    *read in next long, data is that long                
00001F4E                          2035                  
00001F4E                          2036          *Output ',$' just after source operand
00001F4E  43F9 0000264D           2037          LEA     Bang,A1
00001F54  103C 000E               2038          MOVE.B  #14,D0
00001F58  4E4F                    2039          TRAP    #15  
00001F5A                          2040          
00001F5A                          2041          *Push D1 into stack, in case something was using it
00001F5A  48E7 4000               2042          MOVEM.L D1,-(SP)
00001F5E                          2043          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001F5E  4281                    2044          CLR.L   D1
00001F60  123C 0010               2045          MOVE.B  #$10,D1
00001F64                          2046              
00001F64                          2047          *output the absolute mem address to console with the hex-ascii converter
00001F64  4EB8 11EA               2048          JSR     HEXASCII
00001F68  4CDF 0002               2049          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001F6C                          2050          
00001F6C  4EF8 1F26               2051          JMP     WrapperAddrAbsoluteEnd
00001F70                          2052          
00001F70                          2053  
00001F70                          2054  *-----------------------------------------------------------        
00001F70                          2055  * Current handling of bad op/ea codes. Should be revisited.
00001F70                          2056  *----------------------------------------------------------- 
00001F70                          2057  BADOPCODE
00001F70                          2058          *We found a bad op code, output some error to the screen, jump to the 
00001F70                          2059          *next instruction in memory.
00001F70                          2060          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001F70                          2061          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001F70                          2062          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001F70                          2063          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001F70                          2064          *i/o and error message code...
00001F70  43F9 00002656           2065          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001F76  103C 000E               2066          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001F7A  4E4F                    2067          TRAP    #15         *Displays Message
00001F7C  4EF8 1386               2068          JMP     GRAB_NEXT_OP
00001F80                          2069                  
00001F80                          2070  BADEACODE
00001F80                          2071          *We found a bad ea code, output some error to the screen, jump to the
00001F80                          2072          *next instruction in memory.
00001F80                          2073          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001F80                          2074          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001F80  43F9 0000264F           2075          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001F86  103C 000E               2076          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001F8A  4E4F                    2077          TRAP    #15         *Displays Message
00001F8C  4EF8 1386               2078          JMP     GRAB_NEXT_OP
00001F90                          2079          
00001F90                          2080          
00001F90                          2081  *-----------------------------------------------------------        
00001F90                          2082  * End of Disassembler
00001F90                          2083  *-----------------------------------------------------------    
00001F90                          2084  
00001F90  4E72 2700               2085  DONE    STOP    #$2700  *What does this do? Why was it added?
00001F94                          2086  
00001F94  103C 0009               2087  THEEND  MOVE.B  #9,D0
00001F98  4E4F                    2088          TRAP    #15             Halt Simulator        
00001F9A                          2089          
00001F9A                          2090       
00001F9A                          2091  *-----------------------------------------------------------        
00001F9A                          2092  * Output stuff
00001F9A                          2093  *-----------------------------------------------------------     
00001F9A  =0000000D               2094  CR      EQU     $0D             ASCII code for Carriage Return
00001F9A  =0000000A               2095  LF      EQU     $0A             ASCII code for Line Feed
00001F9A= 2D 2D 2D 2D 2D 2D ...   2096  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001FD9= 7C 7C 20 20 20 20 ...   2097              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00002018= 2D 2D 2D 2D 2D 2D ...   2098              DC.B    '-------------------------------------------------------------',CR,LF
00002057= 2A 2A 2A 2A 2A 2A ...   2099              DC.B    '*************************************************************',CR,LF
00002096= 2A 2A 2A 2A 2A 2A ...   2100              DC.B    '*************************************************************',CR,LF
000020D5= 2A 2A 2A 2A 2A 2A ...   2101              DC.B    '******           ***        ***           ****    ***********',CR,LF
00002114= 2A 2A 2A 2A 2A 2A ...   2102              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00002153= 2A 2A 2A 2A 2A 2A ...   2103              DC.B    '**********    ******        *******   ******        *********',CR,LF
00002192= 2A 2A 2A 2A 2A 2A ...   2104              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
000021D1= 2A 2A 2A 2A 2A 2A ...   2105              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00002210= 2A 2A 2A 2A 2A 2A ...   2106              DC.B    '*************************************************************',CR,LF
0000224F= 2A 2A 2A 2A 2A 2A ...   2107              DC.B    '*************************************************************',CR,LF
0000228E= 2A 20 20 20 20 20 ...   2108              DC.B    '*                                                           *',CR,LF
000022CD= 2A 20 41 75 74 68 ...   2109              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
0000230C= 2A 20 20 20 20 20 ...   2110              DC.B    '*                                                           *',CR,LF
0000234B= 2A 2A 2A 2A 2A 2A ...   2111              DC.B    '*************************************************************',CR,LF,CR,LF
0000238C= 53 74 61 72 74 69 ...   2112              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
000023A9                          2113              
000023A9= 57 6F 75 6C 64 20 ...   2114  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
000023DA                          2115  
000023DA= 20 0D 0A                2116  GETSTRTADDR DC.B    ' ',CR,LF
000023DD= 50 6C 65 61 73 65 ...   2117              DC.B    'Please type in your starting address request: ',0
0000240C                          2118              
0000240C= 20 0D 0A                2119  GETENDADDR  DC.B    ' ',CR,LF
0000240F= 50 6C 65 61 73 65 ...   2120              DC.B    'Please type in your ending address request: ',0
0000243C                          2121              
0000243C= 20 0D 0A                2122  QUES_CONT   DC.B    ' ',CR,LF
0000243F= 57 6F 75 6C 64 20 ...   2123              DC.B    'Would you like to continue (Y/N)? ',0
00002462                          2124              
00002462= 20 0D 0A                2125  QUIT_MSG    DC.B    ' ',CR,LF
00002465= 57 6F 75 6C 64 20 ...   2126              DC.B    'Would you like to quit (Y/N)? ',0
00002484                          2127  
00002484                          2128  *****************************************************
00002484                          2129  * I/O storages - assuming users knows what to do.
00002484                          2130  *****************************************************
00002484                          2131  CMD_HLD     DS.B    30
000024A2                          2132  CMD_SZ      DS.B    30
000024C0                          2133  STADDR      DS.B    10
000024CA                          2134  STADDRSZ    DS.B    10
000024D4                          2135  PROGST      DS.L    1
000024D8                          2136  ENDADDR     DS.B    10
000024E2                          2137  ENDADDRSZ   DS.B    10
000024EC                          2138  PROGEND     DS.L    1
000024F0                          2139  CONT        DS.B    30
0000250E                          2140  *****************************************************
0000250E                          2141  
0000250E                          2142  *Table for 0-9 && A-F
0000250E= 30 00                   2143  PRNT0   DC.B    '0',0
00002510= 31 00                   2144  PRNT1   DC.B    '1',0
00002512= 32 00                   2145  PRNT2   DC.B    '2',0
00002514= 33 00                   2146  PRNT3   DC.B    '3',0
00002516= 34 00                   2147  PRNT4   DC.B    '4',0
00002518= 35 00                   2148  PRNT5   DC.B    '5',0
0000251A= 36 00                   2149  PRNT6   DC.B    '6',0
0000251C= 37 00                   2150  PRNT7   DC.B    '7',0
0000251E= 38 00                   2151  PRNT8   DC.B    '8',0
00002520= 39 00                   2152  PRNT9   DC.B    '9',0
00002522= 41 00                   2153  PRNTA   DC.B    'A',0
00002524= 42 00                   2154  PRNTB   DC.B    'B',0
00002526= 43 00                   2155  PRNTC   DC.B    'C',0
00002528= 44 00                   2156  PRNTD   DC.B    'D',0
0000252A= 45 00                   2157  PRNTE   DC.B    'E',0
0000252C= 46 00                   2158  PRNTF   DC.B    'F',0
0000252E                          2159  
0000252E                          2160  *output for all OPCODEs
0000252E                          2161  *Bucket 0000
0000252E= 41 44 44 49 00          2162  ADDI    DC.B    'ADDI',0
00002533= 41 4E 44 49 00          2163  ANDI    DC.B    'ANDI',0
00002538= 45 4F 52 49 00          2164  EORI    DC.B    'EORI',0
0000253D= 42 43 48 47 00          2165  BCHG    DC.B    'BCHG',0
00002542= 43 4D 50 49 00          2166  CMPI    DC.B    'CMPI',0
00002547                          2167  *Bucket 0100
00002547= 4D 4F 56 45 4D 00       2168  MOVEM   DC.B    'MOVEM',0
0000254D= 4D 55 4C 53 00          2169  MULS    DC.B    'MULS',0
00002552= 4C 45 41 20 20 20 ...   2170  LEA     DC.B    'LEA      ',0   *Need spaces here since LEA has no size
0000255C= 43 4C 52 00             2171  CLR     DC.B    'CLR',0
00002560= 4A 53 52 20 20 20 ...   2172  JSR     DC.B    'JSR      ',0   *Need spaces here since JSR has no size
0000256A= 52 54 53 00             2173  RTS     DC.B    'RTS',0
0000256E                          2174  *Bucket 0101
0000256E= 53 55 42 51 00          2175  SUBQ    DC.B    'SUBQ',0
00002573                          2176  
00002573                          2177  *output for the size of the operation
00002573= 2E 42 20 20 20 20 00    2178  ByteSize    DC.B    '.B    ',0
0000257A= 2E 57 20 20 20 20 00    2179  WordSize    DC.B    '.W    ',0
00002581= 2E 4C 20 20 20 20 00    2180  LongSize    DC.B    '.L    ',0
00002588                          2181  
00002588                          2182  *output for all data registers (0-7)
00002588= 44 30 00                2183  OutDataReg0 DC.B    'D0',0
0000258B= 44 31 00                2184  OutDataReg1 DC.B    'D1',0
0000258E= 44 32 00                2185  OutDataReg2 DC.B    'D2',0
00002591= 44 33 00                2186  OutDataReg3 DC.B    'D3',0
00002594= 44 34 00                2187  OutDataReg4 DC.B    'D4',0
00002597= 44 35 00                2188  OutDataReg5 DC.B    'D5',0
0000259A= 44 36 00                2189  OutDataReg6 DC.B    'D6',0
0000259D= 44 37 00                2190  OutDataReg7 DC.B    'D7',0
000025A0                          2191  
000025A0                          2192  *output for all address registers (0-7)
000025A0= 41 30 00                2193  OutAddrReg0 DC.B    'A0',0
000025A3= 41 31 00                2194  OutAddrReg1 DC.B    'A1',0
000025A6= 41 32 00                2195  OutAddrReg2 DC.B    'A2',0
000025A9= 41 33 00                2196  OutAddrReg3 DC.B    'A3',0
000025AC= 41 34 00                2197  OutAddrReg4 DC.B    'A4',0
000025AF= 41 35 00                2198  OutAddrReg5 DC.B    'A5',0
000025B2= 41 36 00                2199  OutAddrReg6 DC.B    'A6',0
000025B5= 41 37 00                2200  OutAddrReg7 DC.B    'A7',0
000025B8                          2201          
000025B8                          2202  *output for all address indirect registers (0-7)
000025B8= 28 41 30 29 00          2203  OutAddrIndReg0  DC.B    '(A0)',0
000025BD= 28 41 31 29 00          2204  OutAddrIndReg1  DC.B    '(A1)',0
000025C2= 28 41 32 29 00          2205  OutAddrIndReg2  DC.B    '(A2)',0
000025C7= 28 41 33 29 00          2206  OutAddrIndReg3  DC.B    '(A3)',0
000025CC= 28 41 34 29 00          2207  OutAddrIndReg4  DC.B    '(A4)',0
000025D1= 28 41 35 29 00          2208  OutAddrIndReg5  DC.B    '(A5)',0
000025D6= 28 41 36 29 00          2209  OutAddrIndReg6  DC.B    '(A6)',0
000025DB= 28 41 37 29 00          2210  OutAddrIndReg7  DC.B    '(A7)',0
000025E0                          2211  
000025E0                          2212  *output for all address indirect post registers (0-7)
000025E0= 28 41 30 29 2B 00       2213  OutAddrIndPoReg0    DC.B    '(A0)+',0
000025E6= 28 41 31 29 2B 00       2214  OutAddrIndPoReg1    DC.B    '(A1)+',0
000025EC= 28 41 32 29 2B 00       2215  OutAddrIndPoReg2    DC.B    '(A2)+',0
000025F2= 28 41 33 29 2B 00       2216  OutAddrIndPoReg3    DC.B    '(A3)+',0
000025F8= 28 41 34 29 2B 00       2217  OutAddrIndPoReg4    DC.B    '(A4)+',0
000025FE= 28 41 35 29 2B 00       2218  OutAddrIndPoReg5    DC.B    '(A5)+',0
00002604= 28 41 36 29 2B 00       2219  OutAddrIndPoReg6    DC.B    '(A6)+',0
0000260A= 28 41 37 29 2B 00       2220  OutAddrIndPoReg7    DC.B    '(A7)+',0
00002610                          2221  
00002610                          2222  *output for all address indirect pre registers (0-7)
00002610= 2D 28 41 30 29 00       2223  OutAddrIndPrReg0    DC.B    '-(A0)',0
00002616= 2D 28 41 31 29 00       2224  OutAddrIndPrReg1    DC.B    '-(A1)',0
0000261C= 2D 28 41 32 29 00       2225  OutAddrIndPrReg2    DC.B    '-(A2)',0
00002622= 2D 28 41 33 29 00       2226  OutAddrIndPrReg3    DC.B    '-(A3)',0
00002628= 2D 28 41 34 29 00       2227  OutAddrIndPrReg4    DC.B    '-(A4)',0
0000262E= 2D 28 41 35 29 00       2228  OutAddrIndPrReg5    DC.B    '-(A5)',0
00002634= 2D 28 41 36 29 00       2229  OutAddrIndPrReg6    DC.B    '-(A6)',0
0000263A= 2D 28 41 37 29 00       2230  OutAddrIndPrReg7    DC.B    '-(A7)',0
00002640                          2231  
00002640                          2232  *output for a tab only (4 spaces)
00002640= 20 20 20 20 00          2233  Tab DC.B    '    ',0
00002645                          2234  
00002645                          2235  *output for a comma only
00002645= 2C 00                   2236  Comma   DC.B    ',',0
00002647                          2237  
00002647                          2238  *output for a new line only
00002647= 0D 0A 00                2239  NewLine DC.B    CR,LF,0
0000264A                          2240  
0000264A                          2241  *output for a '#$' and '$' only
0000264A= 23 24 00                2242  ShaBang DC.B    '#$',0
0000264D= 24 00                   2243  Bang    DC.B    '$',0
0000264F                          2244  
0000264F                          2245  *current output for error messages
0000264F= 42 41 44 20 45 41 00    2246  BADEAMSG    DC.B    'BAD EA',0
00002656= 42 41 44 20 4F 50 00    2247  BADOPMSG    DC.B    'BAD OP',0
0000265D= 49 6D 70 72 6F 70 ...   2248  INV_MSG     DC.B    'Improper command.',CR,LF,0
00002671= 49 6E 76 61 6C 69 ...   2249  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
0000268A= 49 6E 76 61 6C 69 ...   2250  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
000026A1                          2251  
000026A1                          2252          
000026A1                          2253          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                252E
ADDRABSOLUTEMODE    1B3A
ADDRINDIRECTMODE    1B0A
ADDRINDIRECTPOSTMODE  1B1A
ADDRINDIRECTPREMODE  1B2A
ADDRINDPOREG0       1DD2
ADDRINDPOREG1       1DE2
ADDRINDPOREG2       1DF2
ADDRINDPOREG3       1E02
ADDRINDPOREG4       1E12
ADDRINDPOREG5       1E22
ADDRINDPOREG6       1E32
ADDRINDPOREG7       1E42
ADDRINDPRREG0       1E94
ADDRINDPRREG1       1EA4
ADDRINDPRREG2       1EB4
ADDRINDPRREG3       1EC4
ADDRINDPRREG4       1ED4
ADDRINDPRREG5       1EE4
ADDRINDPRREG6       1EF4
ADDRINDPRREG7       1F04
ADDRINDREG0         1D10
ADDRINDREG1         1D20
ADDRINDREG2         1D30
ADDRINDREG3         1D40
ADDRINDREG4         1D50
ADDRINDREG5         1D60
ADDRINDREG6         1D70
ADDRINDREG7         1D80
ADDRREG0            1C4E
ADDRREG1            1C5E
ADDRREG2            1C6E
ADDRREG3            1C7E
ADDRREG4            1C8E
ADDRREG5            1C9E
ADDRREG6            1CAE
ADDRREG7            1CBE
ADDRREGMODE         1AFA
ANDI                2533
ASCIIHEX            1178
ASCIIHEX1           117C
BADEACODE           1F80
BADEAMSG            264F
BADOPCODE           1F70
BADOPMSG            2656
BANG                264D
BCHG                253D
BCHGBYTESIZE        1AB2
BCHGIMMEDIATE       1AC2
BCHGLONGSIZE        1AA2
BCHGSIZEHELPER      1A92
BCHGSIZEHELPEREND   1AA0
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         1436
BUCKET_0001         1784
BUCKET_0010         1784
BUCKET_0011         1784
BUCKET_0100         1784
BUCKET_0101         190A
BUCKET_0110         19C0
BUCKET_1000         19C0
BUCKET_1001         19C0
BUCKET_1011         19C0
BUCKET_1100         19C0
BUCKET_1101         19C0
BUCKET_1110         19C0
BYTESIZE            2573
BYTESIZEIMMEDIATE   19E2
BYTESIZEOP          1A62
CHECK               11EE
CHECKEND1           10FE
CHECKSTRT1          10E8
CHECK_LOWN          1130
CHECK_LOWY          111E
CHECK_N             1410
CHECK_UPN           1128
CHECK_UPY           1114
CHECK_Y             1400
CHNG_SZB            1220
CHNG_SZL            1206
CHNG_SZW            123A
CLR                 255C
CLR_D6              1370
CMD_HLD             2484
CMD_SZ              24A2
CMPI                2542
COMMA               2645
CONT                24F0
CONT_OP             139C
CONT_Q              13CC
CONV_LOL            11D8
CONV_LOOP           1254
CONV_NUM            11C4
CONV_UPL            11CE
CR                  D
DATAREG0            1B8C
DATAREG1            1B9C
DATAREG2            1BAC
DATAREG3            1BBC
DATAREG4            1BCC
DATAREG5            1BDC
DATAREG6            1BEC
DATAREG7            1BFC
DATAREGMODE         1AEA
DONE                1F90
EA_ADDI             14C2
EA_ANDI             1538
EA_BCHG_D           1630
EA_BCHG_S           16C8
EA_CLR              187E
EA_CMPI             1744
EA_EORI             15AE
EA_JSR              18D4
EA_LEA              1812
EA_LEA_WRAPPEREND   182A
EA_MOVEM_MEMTOREG   17D0
EA_MOVEM_REGTOMEM   17D0
EA_SUBQ             1968
ENDADDR             24D8
ENDADDRSZ           24E2
EORI                2538
EXITSUB             11E4
EXIT_CONV           12DA
GETENDADDR          240C
GETSTRTADDR         23DA
GET_END             1090
GET_STRT            1042
GRAB_NEXT_OP        1386
HEXASCII            11EA
HEXASCIIREG         1202
IMMEDIATEDATAMODE   1B4A
INV2                1420
INVALID1            1138
INVENDMSG           268A
INVSTRTMSG          2671
INV_END1            1164
INV_MSG             265D
INV_STRT1           1150
IS_ADDI             148C
IS_ANDI             1502
IS_BCHG_D           15EE
IS_BCHG_S           168C
IS_CLR              1848
IS_CMPI             170E
IS_EORI             1578
IS_JSR              18B2
IS_LEA              17D0
IS_MOVEM_MEMTOREG   17D0
IS_MOVEM_REGTOMEM   17D0
IS_RTS              18EA
IS_SUBQ             1926
JSR                 2560
LEA                 2552
LEA_ADDRABSOLUTEWRAPPER  1AE0
LEA_ADDRINDIRECTWRAPPER  1AD6
LF                  A
LONGSIZE            2581
LONGSIZEABSOLUTE    1F4C
LONGSIZEIMMEDIATE   1A26
LONGSIZEOP          1A82
LOOP_1              1014
LOOP_B              1224
LOOP_L              120A
LOOP_W              123E
MAX_LINE            20
MESSAGE             1F9A
MOVEM               2547
MULS                254D
NEWLINE             2647
NUM_0               12E8
NUM_1               12F0
NUM_2               12F8
NUM_3               1300
NUM_4               1308
NUM_5               1310
NUM_6               1318
NUM_7               1320
NUM_8               1328
NUM_9               1330
NUM_A               1338
NUM_B               1340
NUM_C               1348
NUM_D               1350
NUM_E               1358
NUM_F               1360
OUTADDRINDPOREG0    25E0
OUTADDRINDPOREG1    25E6
OUTADDRINDPOREG2    25EC
OUTADDRINDPOREG3    25F2
OUTADDRINDPOREG4    25F8
OUTADDRINDPOREG5    25FE
OUTADDRINDPOREG6    2604
OUTADDRINDPOREG7    260A
OUTADDRINDPRREG0    2610
OUTADDRINDPRREG1    2616
OUTADDRINDPRREG2    261C
OUTADDRINDPRREG3    2622
OUTADDRINDPRREG4    2628
OUTADDRINDPRREG5    262E
OUTADDRINDPRREG6    2634
OUTADDRINDPRREG7    263A
OUTADDRINDREG0      25B8
OUTADDRINDREG1      25BD
OUTADDRINDREG2      25C2
OUTADDRINDREG3      25C7
OUTADDRINDREG4      25CC
OUTADDRINDREG5      25D1
OUTADDRINDREG6      25D6
OUTADDRINDREG7      25DB
OUTADDRREG0         25A0
OUTADDRREG1         25A3
OUTADDRREG2         25A6
OUTADDRREG3         25A9
OUTADDRREG4         25AC
OUTADDRREG5         25AF
OUTADDRREG6         25B2
OUTADDRREG7         25B5
OUTDATAREG0         2588
OUTDATAREG1         258B
OUTDATAREG2         258E
OUTDATAREG3         2591
OUTDATAREG4         2594
OUTDATAREG5         2597
OUTDATAREG6         259A
OUTDATAREG7         259D
PRINT_NUM           12E0
PRNT0               250E
PRNT1               2510
PRNT2               2512
PRNT3               2514
PRNT4               2516
PRNT5               2518
PRNT6               251A
PRNT7               251C
PRNT8               251E
PRNT9               2520
PRNTA               2522
PRNTB               2524
PRNTC               2526
PRNTD               2528
PRNTE               252A
PRNTF               252C
PROGEND             24EC
PROGST              24D4
QUES_CONT           243C
QUIT_MSG            2462
RTS                 256A
SHABANG             264A
STACK               7000
STADDR              24C0
STADDRSZ            24CA
START               1000
STARTASSEM          23A9
ST_ADDR             7FC6
ST_BAD              11E2
SUBQ                256E
TAB                 2640
THEEND              1F94
WORDSIZE            257A
WORDSIZEABSOLUTE    1F28
WORDSIZEIMMEDIATE   1A04
WORDSIZEOP          1A72
WRAPPERADDRABSOLUTE  1F14
WRAPPERADDRABSOLUTEEND  1F26
WRAPPERADDRINDIRECT  1CCE
WRAPPERADDRINDIRECTEND  1D0E
WRAPPERADDRINDIRECTPOST  1D90
WRAPPERADDRINDIRECTPOSTEND  1DD0
WRAPPERADDRINDIRECTPRE  1E52
WRAPPERADDRINDIRECTPREEND  1E92
WRAPPERADDRREG      1C0C
WRAPPERADDRREGEND   1C4C
WRAPPERDATAREG      1B4A
WRAPPERDATAREGEND   1B8A
WRAPPERSIZE         1A48
WRAPPERSIZEEND      1A60
WRAPPERSIZEIMMEDIATE  19C6
WRAPPERSIZEIMMEDIATEEND  19E0
