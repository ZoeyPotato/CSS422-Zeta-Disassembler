00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.0
Created On: 3/6/2014 11:11:28 PM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/1/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k
00000000                             7  * assembly instructions. *visit this later, describe what it 
00000000                             8  * does, how to use it, assumptions, etc.
00000000                             9  *-------------------------------------------------------------
00000000                            10  
00001000                            11  START   ORG $1000   *Start program at provided location
00001000  =00007FC0                 12  ST_ADDR EQU $7FC0   *Starting address of input test file
00001000  =00007000                 13  STACK   EQU $7000   *Stack location
00001000                            14  
00001000                            15  *-----------------------------------------------------------
00001000                            16  * Start of I/O
00001000                            17  *-----------------------------------------------------------
00001000  307C 7FC0                 18              MOVEA.W #ST_ADDR,A0 *Load starting location of test input file into A0
00001004  43F9 0000111A             19              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100A  103C 000E                 20              MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000100E  4E4F                      21              TRAP    #15         *Displays Message
00001010                            22          
00001010  303C 0000                 23  loop_1      MOVE    #0,D0       
00001014  303C 0000                 24              MOVE    #0,D0
00001018  43F9 00001333             25              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 26              MOVE.B  #14,D0
00001022  4E4F                      27              TRAP    #15    
00001024  303C 0002                 28              MOVE    #2,D0
00001028  43F9 000013E8             29              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      30              TRAP    #15
00001030  4EB9 0000104A             31              JSR     CHECK_UPY
00001036  0C07 0001                 32              CMPI.B  #01,D7
0000103A  67D4                      33              BEQ     loop_1
0000103C  303C 0002                 34  NXT_CMD     MOVE    #2,D0
00001040  43F9 000013E8             35              LEA     CMD_HLD,A1  *Need to change where it can hold the start/end address
00001046  4E4F                      36              TRAP    #15
00001048  2811                      37              MOVE.L  (A1),D4
0000104A                            38          
0000104A                            39  *-----------------------------------------------------------
0000104A                            40  * I/O: Input check for Y, y, N, n, Q, q
0000104A                            41  *-----------------------------------------------------------
0000104A  0C11 0059                 42  CHECK_UPY   CMPI.B  #$59,(A1)
0000104E  6600 0004                 43              BNE     CHECK_LOWy
00001052  4E75                      44              RTS
00001054  0C11 0079                 45  CHECK_LOWy  CMPI.B  #$79,(A1)
00001058  6600 0004                 46              BNE     CHECK_UPN
0000105C  4E75                      47              RTS
0000105E  0C11 004E                 48  CHECK_UPN   CMPI.B  #$4E,(A1)
00001062  6700 00AC                 49              BEQ     DONE
00001066  6600 0004                 50              BNE     CHECK_LOWn
0000106A  4E75                      51              RTS
0000106C  0C11 006E                 52  CHECK_LOWn  CMPI.B  #$6E,(A1)
00001070  6600 0008                 53              BNE     INVALID
00001074  6700 009A                 54              BEQ     DONE
00001078  4E75                      55              RTS
0000107A  303C 0000                 56  INVALID     MOVE    #0,D0
0000107E  43F9 00001461             57              LEA     INV_MSG,A1
00001084  303C 000E                 58              MOVE    #14,D0
00001088  4E4F                      59              TRAP    #15
0000108A  5207                      60              ADDI.B  #1,D7
0000108C  6082                      61              BRA     loop_1
0000108E                            62  *-----------------------------------------------------------        
0000108E                            63  * Start of Disassembler
0000108E                            64  *-----------------------------------------------------------        
0000108E                            65  
0000108E                            66  GRAB_NEXT_OP
0000108E                            67          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
0000108E                            68          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
0000108E                            69          *data that may be associated with the instruction.
0000108E  4280                      70          CLR.L   D0
00001090                            71          *Post increment addr, A0 will point to the start of next instruction or will 
00001090                            72          *point to the start of any immed/abso data with this current instruction
00001090  3018                      73          MOVE.W  (A0)+,D0
00001092                            74          *Copy the word data we just moved into D0 into D7. We are copying this data
00001092                            75          *So we always have a copy of the WHOLE instruction somewhere
00001092  3E00                      76          MOVE.W  D0,D7
00001094                            77          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
00001094                            78          *four bits of the instruction. Once we have just the first four bits, we can
00001094                            79          *begin to see which 'bucket'/category this instruction falls into. 
00001094  E048                      80          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
00001096  E848                      81          LSR.W   #$04,D0
00001098                            82          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
00001098                            83          *list of buckets until we find which one this instruction falls into.
00001098                            84  
00001098                            85  
00001098                            86  *STARTS WITH 0000, ADDI | ANDI | EORI-----------------------
00001098                            87  *                  BCHG(dynamic) | BCHG (static) | CMPI-----
00001098                            88  BUCKET_0000
00001098  =00000000                 89  BUCKET0_BITS    EQU $0
00001098                            90  
00001098  4281                      91          CLR.L   D1
0000109A                            92          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000109A  123C 0000                 93          MOVE.B  #BUCKET0_BITS,D1  
0000109E                            94          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
0000109E                            95          *If equal, continue decoding. If not, branch to next bucket.
0000109E  B200                      96          CMP.B   D0,D1
000010A0  6600 0048                 97          BNE     BUCKET_0001
000010A4                            98  
000010A4                            99          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
000010A4                           100          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
000010A4  3007                     101          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
000010A6  0800 0008                102          BTST.L  #$08,D0
000010AA  6600 0018                103          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
000010AE                           104          
000010AE                           105          *TODO:
000010AE                           106          *Check the next four bits in the instruction, branch to different subsets 
000010AE                           107          *depending on what the bits equal
000010AE                           108          *Perform compares with these 4 bits to see which specific instruction it is.
000010AE                           109          *If we get through all of the if's without finding the specific instruction,
000010AE                           110          *then this instruction is either not in our list of OP CODES to decode, or
000010AE                           111          *is an invalid instruction/syntax.
000010AE                           112          *If invalid, jump to BADOPCODE, where i/o will take care of it.
000010AE  4EF9 000010F0            113          JMP     BADOPCODE  
000010B4                           114  
000010B4                           115  
000010B4                           116  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
000010B4                           117  *THIS IS STILL PART OF OPCODES RESPONSIBILITY
000010B4                           118  IS_ADDI
000010B4                           119          *Output some message, hey we found an ADDI instruction or something...
000010B4  43F9 00001406            120          LEA     FNDADDI,A1  *Loads FNDADDI into address register A1
000010BA  103C 000E                121          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000010BE  4E4F                     122          TRAP    #15         *Displays Message
000010C0  4EF8 108E                123          JMP     GRAB_NEXT_OP    *Jump and go to the next instruction
000010C4                           124          
000010C4                           125          *some code setting up registers/data for EA to disect and verify
000010C4                           126  
000010C4                           127  *THIS IS AN 'EAFUNC', EA'S RESPONSIBILITY  
000010C4                           128  EA_ADDI
000010C4                           129          *some code verifiying the integrity/syntax of the EA bits of the instruction
000010C4                           130          *if bad EA, jump to BADEACODE, where i/o will take care of it
000010C4                           131          
000010C4                           132          *make sure when you leave an EA func that you also read in and either use
000010C4                           133          *or ignore immediate/absoluate data, so that we can we ready to start reading
000010C4                           134          *in the next instruction.
000010C4                           135  
000010C4                           136  
000010C4                           137  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000010C4                           138  IS_ANDI
000010C4                           139  EA_ANDI
000010C4                           140  
000010C4                           141  
000010C4                           142  *Now we know this instruction is exactly EORI, lets set everything up for EA.
000010C4                           143  IS_EORI
000010C4                           144  EA_EORI
000010C4                           145  
000010C4                           146  
000010C4                           147  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000010C4                           148  * everything up for EA if is a legit instruction. Assuming D0 holds full instruction.
000010C4                           149  IS_BCHG_D
000010C4                           150          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000010C4                           151          *invalid, branch to BADOPCODE    
000010C4  0800 0007                152          BTST.L  #$07,D0
000010C8  6600 0026                153          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000010CC  0800 0006                154          BTST.L  #$06,D0
000010D0  6700 001E                155          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000010D4                           156          
000010D4                           157          *Output a message, hey we found a BCHG(dynamic) instruction...
000010D4  43F9 0000141D            158          LEA     FNDBCHG_D,A1    *Loads FNDBCHG_D into address register A1
000010DA  103C 000E                159          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000010DE  4E4F                     160          TRAP    #15             *Displays Message
000010E0                           161                  
000010E0                           162          *Should have a valid BCHG(dynamic) instruction. Set data up for EA.
000010E0                           163          *TODO:
000010E0  163C 000E                164          MOVE.B  #14,D3
000010E4  4EF9 000010EA            165          JMP     EA_BCHG_D
000010EA                           166  
000010EA                           167  EA_BCHG_D
000010EA                           168  
000010EA                           169  
000010EA                           170  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
000010EA                           171  IS_BCHG_S
000010EA                           172  EA_BCHG_S
000010EA                           173  
000010EA                           174  
000010EA                           175  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000010EA                           176  IS_CMPI
000010EA                           177  EA_CMPI
000010EA                           178  
000010EA                           179  
000010EA                           180  *STARTS WITH 0001, MOVE.B-----------------------------------
000010EA                           181  BUCKET_0001
000010EA  =00000001                182  BUCKET1_BITS    EQU $1
000010EA                           183          
000010EA                           184          *some code...
000010EA                           185  
000010EA                           186  
000010EA                           187  *STARTS WITH 0010, MOVE.L-----------------------------------
000010EA                           188  BUCKET_0010
000010EA  =00000002                189  BUCKET2_BITS    EQU $2
000010EA                           190  
000010EA                           191          *some code...
000010EA                           192  
000010EA                           193  
000010EA                           194  *STARTS WITH 0011, MOVE.W-----------------------------------
000010EA                           195  BUCKET_0011
000010EA  =00000003                196  BUCKET3_BITS    EQU $3
000010EA                           197  
000010EA                           198          *some code...
000010EA                           199  
000010EA                           200  
000010EA                           201  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
000010EA                           202  BUCKET_0100
000010EA  =00000004                203  BUCKET4_BITS    EQU $4
000010EA                           204  
000010EA                           205          *some code...
000010EA                           206  
000010EA                           207  
000010EA                           208  *STARTS WITH 0101, SUBQ-------------------------------------
000010EA                           209  BUCKET_0101
000010EA  =00000005                210  BUCKET5_BITS    EQU $5
000010EA                           211  
000010EA                           212          *some code...
000010EA                           213  
000010EA                           214  
000010EA                           215  *STARTS WITH 0110, BCC--------------------------------------
000010EA                           216  BUCKET_0110
000010EA  =00000006                217  BUCKET6_BITS    EQU $6
000010EA                           218  
000010EA                           219          *some code...
000010EA                           220  
000010EA                           221  
000010EA                           222  *STARTS WITH 1000, DIVU-------------------------------------
000010EA                           223  BUCKET_1000
000010EA  =00000008                224  BUCKET8_BITS    EQU $8
000010EA                           225  
000010EA                           226          *some code...
000010EA                           227  
000010EA                           228  
000010EA                           229  *STARTS WITH 1001, SUBA-------------------------------------
000010EA                           230  BUCKET_1001
000010EA  =00000009                231  BUCKET9_BITS    EQU $9
000010EA                           232  
000010EA                           233          *some code...
000010EA                           234  
000010EA                           235  
000010EA                           236  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000010EA                           237  BUCKET_1011
000010EA  =0000000B                238  BUCKETB_BITS    EQU $B
000010EA                           239  
000010EA                           240          *some code...
000010EA                           241  
000010EA                           242  
000010EA                           243  *STARTS WITH 1100, MULS(W) | AND----------------------------
000010EA                           244  BUCKET_1100
000010EA  =0000000C                245  BUCKETC_BITS    EQU $C
000010EA                           246  
000010EA                           247          *some code...
000010EA                           248  
000010EA                           249  
000010EA                           250  *STARTS WITH 1101, ADD | ADDA-------------------------------
000010EA                           251  BUCKET_1101
000010EA  =0000000D                252  BUCKETD_BITS    EQU $D
000010EA                           253  
000010EA                           254          *some code...
000010EA                           255  
000010EA                           256  
000010EA                           257  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000010EA                           258  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000010EA                           259  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000010EA                           260  BUCKET_1110
000010EA  =0000000E                261  BUCKETE_BITS    EQU $E     
000010EA                           262  
000010EA                           263          *some code...
000010EA                           264  
000010EA                           265  
000010EA                           266  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000010EA                           267  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000010EA  4EF9 000010F0            268          JMP     BADOPCODE  
000010F0                           269          
000010F0                           270          
000010F0                           271  BADOPCODE
000010F0                           272          *We found a bad op code, output some error to the screen, jump to the 
000010F0                           273          *next instruction in memory.
000010F0                           274          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
000010F0                           275          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
000010F0                           276          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
000010F0                           277          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
000010F0                           278          *i/o and error message code...
000010F0  43F9 0000144C            279          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
000010F6  103C 000E                280          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000010FA  4E4F                     281          TRAP    #15         *Displays Message
000010FC  4EF8 108E                282          JMP     GRAB_NEXT_OP
00001100                           283          
00001100                           284          
00001100                           285  BADEACODE
00001100                           286          *We found a bad ea code, output some error to the screen, jump to the
00001100                           287          *next instruction in memory.
00001100                           288          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001100                           289          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001100  43F9 0000143C            290          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001106  103C 000E                291          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000110A  4E4F                     292          TRAP    #15         *Displays Message
0000110C  4EF8 108E                293          JMP     GRAB_NEXT_OP
00001110                           294          
00001110                           295  *-----------------------------------------------------------        
00001110                           296  * End of Disassembler
00001110                           297  *-----------------------------------------------------------    
00001110                           298  
00001110  4E72 2700                299  DONE    STOP    #$2700
00001114                           300    
00001114  103C 0009                301  THEEND  MOVE.B  #9,D0
00001118  4E4F                     302          TRAP    #15             Halt Simulator        
0000111A                           303          
0000111A  =0000000D                304  CR      EQU     $0D             ASCII code for Carriage Return
0000111A  =0000000A                305  LF      EQU     $0A             ASCII code for Line Feed
0000111A= 2D 2D 2D 2D 2D 2D ...    306  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001159= 7C 7C 20 20 20 20 ...    307              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001198= 2D 2D 2D 2D 2D 2D ...    308              DC.B    '-------------------------------------------------------------',CR,LF,CR,LF
000011D9= 2A 2A 2A 2A 2A 2A ...    309              DC.B    '*************************************************************',CR,LF
00001218= 2A 20 20 20 20 20 ...    310              DC.B    '*                                                           *',CR,LF
00001257= 2A 20 41 75 74 68 ...    311              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001296= 2A 20 20 20 20 20 ...    312              DC.B    '*                                                           *',CR,LF
000012D5= 2A 2A 2A 2A 2A 2A ...    313              DC.B    '*************************************************************',CR,LF,CR,LF
00001316= 53 74 61 72 74 69 ...    314              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001333                           315              
00001333= 57 6F 75 6C 64 20 ...    316  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001364                           317  
00001364= 20 0D 0A                 318  GETSTRTADDR DC.B    ' ',CR,LF
00001367= 50 6C 65 61 73 65 ...    319              DC.B    'Please type in your starting address request: ',0
00001396                           320              
00001396= 20 0D 0A                 321  GETENDADDR  DC.B    ' ',CR,LF
00001399= 50 6C 65 61 73 65 ...    322              DC.B    'Please type in your ending address request: ',0
000013C6                           323              
000013C6= 20 0D 0A                 324  QUIT_MSG    DC.B    ' ',CR,LF
000013C9= 57 6F 75 6C 64 20 ...    325              DC.B    'Would you like to quit (Y/N)? ',0
000013E8                           326  
000013E8                           327  CMD_HLD     DS.B    30
00001406                           328          
00001406= 46 6F 75 6E 64 20 ...    329  FNDADDI     DC.B    'Found an ADDI opcode',CR,LF,0
0000141D= 46 6F 75 6E 64 20 ...    330  FNDBCHG_D   DC.B    'Found a BCHG(dynamic) opcode',CR,LF,0
0000143C                           331  *for now, i guess every OPCODE will have a corresponding 'found it' msg...
0000143C                           332  
0000143C= 42 41 44 20 45 41 ...    333  BADEAMSG    DC.B    'BAD EA, WHY?!',CR,LF,0
0000144C= 42 41 44 20 4F 50 ...    334  BADOPMSG    DC.B    'BAD OP CODE, WHY?!',CR,LF,0
00001461= 49 6D 70 72 6F 70 ...    335  INV_MSG     DC.B    'Improper command.',CR,LF,0
00001475                           336          
00001475                           337          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BADEACODE           1100
BADEAMSG            143C
BADOPCODE           10F0
BADOPMSG            144C
BUCKET0_BITS        0
BUCKET1_BITS        1
BUCKET2_BITS        2
BUCKET3_BITS        3
BUCKET4_BITS        4
BUCKET5_BITS        5
BUCKET6_BITS        6
BUCKET8_BITS        8
BUCKET9_BITS        9
BUCKETB_BITS        B
BUCKETC_BITS        C
BUCKETD_BITS        D
BUCKETE_BITS        E
BUCKET_0000         1098
BUCKET_0001         10EA
BUCKET_0010         10EA
BUCKET_0011         10EA
BUCKET_0100         10EA
BUCKET_0101         10EA
BUCKET_0110         10EA
BUCKET_1000         10EA
BUCKET_1001         10EA
BUCKET_1011         10EA
BUCKET_1100         10EA
BUCKET_1101         10EA
BUCKET_1110         10EA
CHECK_LOWN          106C
CHECK_LOWY          1054
CHECK_UPN           105E
CHECK_UPY           104A
CMD_HLD             13E8
CR                  D
DONE                1110
EA_ADDI             10C4
EA_ANDI             10C4
EA_BCHG_D           10EA
EA_BCHG_S           10EA
EA_CMPI             10EA
EA_EORI             10C4
FNDADDI             1406
FNDBCHG_D           141D
GETENDADDR          1396
GETSTRTADDR         1364
GRAB_NEXT_OP        108E
INVALID             107A
INV_MSG             1461
IS_ADDI             10B4
IS_ANDI             10C4
IS_BCHG_D           10C4
IS_BCHG_S           10EA
IS_CMPI             10EA
IS_EORI             10C4
LF                  A
LOOP_1              1010
MESSAGE             111A
NXT_CMD             103C
QUIT_MSG            13C6
STACK               7000
START               1000
STARTASSEM          1333
ST_ADDR             7FC0
THEEND              1114
