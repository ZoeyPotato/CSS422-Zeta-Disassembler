00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 5:34:03 AM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/11/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC6                  9  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00000000  =0000000F                 11  MAX_LINE    EQU     15      *Maximum number of instructions that can be 
00001000                            12  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 13              LEA stack,SP
00001004  3C3C 000F                 14              MOVE    #MAX_LINE,D6
00001008                            15  
00001008                            16  
00001008                            17  *-----------------------------------------------------------
00001008                            18  * Start of I/O
00001008                            19  *-----------------------------------------------------------            
00001008  43F9 00001BF6             20              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 21              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      22              TRAP    #15         *Displays Message
00001014                            23          
00001014  303C 0000                 24  loop_1      MOVE    #0,D0       
00001018  43F9 00002005             25              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 26              MOVE.B  #14,D0
00001022  4E4F                      27              TRAP    #15    
00001024  303C 0002                 28              MOVE    #2,D0
00001028  43F9 000020E0             29              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      30              TRAP    #15
00001030  0C01 0001                 31              CMPI.B  #01,D1
00001034  6600 00FE                 32              BNE     INVALID1
00001038  4EB9 00001110             33              JSR     CHECK_UPY
0000103E                            34              
0000103E                            35              
0000103E                            36  *-----------------------------------------------------------
0000103E                            37  * I/O: Check Start Address
0000103E                            38  *
0000103E                            39  * Make sure that start address starts after allocated 
0000103E                            40  * memory addresses. Else, it will print out a message 
0000103E                            41  * saying that requested address is invalid & prompts the
0000103E                            42  * user again for the starting address.
0000103E                            43  *-----------------------------------------------------------
0000103E  43F9 00002036             44  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001044  103C 000E                 45              MOVE.B  #14,D0
00001048  4E4F                      46              TRAP    #15
0000104A  43F9 0000211C             47              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001050  3239 00002126             48              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001056  303C 0002                 49              MOVE    #2,D0           *Get start address
0000105A  4E4F                      50              TRAP    #15
0000105C  4EB9 000010E4             51              JSR     CHECKSTRT1
00001062  4287                      52              CLR.L   D7
00001064  4EB9 00001174             53              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106A  0C03 0001                 54              CMPI.B  #01,D3      *Check if there was a bad start
0000106E  6700 00DC                 55              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001072  0C87 00007FC6             56              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001078  6D00 00D2                 57              BLT     INV_STRT1   *Asks for another start address if invalid
0000107C  0C87 00FFFFFE             58              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001082  6C00 00C8                 59              BGE     INV_STRT1
00001086  23C7 00002130             60              MOVE.L  D7,PROGST
0000108C                            61  
0000108C  43F9 00002068             62  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001092  103C 000E                 63              MOVE.B  #14,D0
00001096  4E4F                      64              TRAP    #15
00001098  43F9 00002134             65              LEA     ENDADDR,A1      *Buffer to hold end address
0000109E  3239 0000213E             66              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A4  303C 0002                 67              MOVE    #2,D0
000010A8  4E4F                      68              TRAP    #15
000010AA  4EB9 000010FA             69              JSR     CHECKEND1
000010B0  4287                      70              CLR.L   D7
000010B2  4EB9 00001174             71              JSR     ASCIIHEX
000010B8  0C03 0001                 72              CMPI.B  #01,D3
000010BC  6700 00A2                 73              BEQ     INV_END1
000010C0  0C87 00002130             74              CMPI.L  #PROGST,D7
000010C6  6D00 0098                 75              BLT     INV_END1
000010CA  0C87 00FFFFFF             76              CMPI.L  #$00FFFFFF,D7
000010D0  6C00 008E                 77              BGE     INV_END1
000010D4  23C7 00002148             78              MOVE.L  D7,PROGEND
000010DA  2079 00002130             79              MOVEA.L PROGST,A0
000010E0  6000 028A                 80              BRA     GRAB_NEXT_OP            
000010E4                            81                          
000010E4  0C81 00000008             82  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EA  6E00 0060                 83              BGT     INV_STRT1
000010EE  0C81 00000000             84              CMPI.L  #00,D1
000010F4  6300 0056                 85              BLS     INV_STRT1
000010F8  4E75                      86              RTS         
000010FA                            87              
000010FA  0C81 00000008             88  CHECKEND1   CMPI.L  #08,D1
00001100  6E00 005E                 89              BGT     INV_END1
00001104  0C81 00000000             90              CMPI.L  #00,D1
0000110A  6300 0054                 91              BLS     INV_END1
0000110E  4E75                      92              RTS
00001110                            93  
00001110                            94  
00001110                            95  *-----------------------------------------------------------
00001110                            96  * I/O: Input check for Y, y, N, n
00001110                            97  *-----------------------------------------------------------
00001110  0C11 0059                 98  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001114  6600 0004                 99              BNE     CHECK_LOWY
00001118  4E75                     100              RTS
0000111A  0C11 0079                101  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
0000111E  6600 0004                102              BNE     CHECK_UPN
00001122  4E75                     103              RTS
00001124  0C11 004E                104  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001128  6700 0AC2                105              BEQ     DONE
0000112C                           106              
0000112C  0C11 006E                107  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001130  6700 0ABA                108              BEQ     DONE
00001134                           109              
00001134  163C 0000                110  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001138  303C 0000                111              MOVE    #0,D0       *Prints invalid command msg if not found
0000113C  43F9 00002275            112              LEA     INV_MSG,A1
00001142  303C 000E                113              MOVE    #14,D0
00001146  4E4F                     114              TRAP    #15
00001148  6000 FECA                115              BRA     loop_1
0000114C                           116              
0000114C  43F9 00002289            117  INV_STRT1   LEA     INVSTRTMSG,A1
00001152  103C 000E                118              MOVE.B  #14,D0
00001156  4E4F                     119              TRAP    #15
00001158  163C 0000                120              MOVE.B  #00,D3      *Reset flag
0000115C  6000 FEE0                121              BRA     GET_STRT        
00001160                           122              
00001160  43F9 000022A2            123  INV_END1    LEA     INVENDMSG,A1
00001166  103C 000E                124              MOVE.B  #14,D0
0000116A  4E4F                     125              TRAP    #15
0000116C  163C 0000                126              MOVE.B  #00,D3      *Reset flag
00001170  6000 FF1A                127              BRA     GET_END
00001174                           128              
00001174                           129              
00001174                           130  *-----------------------------------------------------------
00001174                           131  * ASCII to Hex converter
00001174                           132  *
00001174                           133  * Checks and converts the ASCII value to the hex equivalent
00001174                           134  *-----------------------------------------------------------
00001174  48E7 6000                135  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001178  0C01 0000                136  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000117C  6700 0062                137              BEQ     exitSub     *Exit subroutine 
00001180  5301                     138              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001182  E99F                     139              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001184  1419                     140              MOVE.B  (A1)+,D2    *Takes the first char
00001186  0C02 0024                141              CMPI.B  #$24,D2     *See if the first char is $
0000118A  67EC                     142              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000118C  0C02 0030                143              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001190  6D00 004C                144              BLT     st_bad      *Put error message
00001194  0C02 0039                145              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001198  6F00 0026                146              BLE     CONV_NUM    *Convert to number, if so
0000119C  0C02 0041                147              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A0  6D00 003C                148              BLT     st_bad      *Put error message
000011A4  0C02 0046                149              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011A8  6F00 0020                150              BLE     CONV_UpL    *Convert to hex
000011AC  0C02 0061                151              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B0  6D00 002C                152              BLT     st_bad
000011B4  0C02 0066                153              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011B8  6F00 001A                154              BLE     CONV_LoL    
000011BC  6E00 0020                155              BGT     st_bad      *Puts error message for anything greater than f value
000011C0                           156              
000011C0  0402 0030                157  CONV_NUM    SUBI.B  #$30,D2
000011C4  8E02                     158              OR.B    D2,D7
000011C6  4EF8 1178                159              JMP     ASCIIHEX1
000011CA  0402 0037                160  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011CE  8E02                     161              OR.B    D2,D7
000011D0  4EF8 1178                162              JMP     ASCIIHEX1
000011D4  0402 0057                163  CONV_LoL    SUBI.B  #$57,D2
000011D8  8E02                     164              OR.B    D2,D7
000011DA  4EF8 1178                165              JMP     ASCIIHEX1   
000011DE                           166  
000011DE  5203                     167  st_bad      ADDI.B  #01,D3
000011E0  4CDF 0006                168  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E4  4E75                     169              RTS
000011E6                           170              
000011E6                           171              
000011E6                           172  *-----------------------------------------------------------
000011E6                           173  * Hex to ASCII converter
000011E6                           174  *-----------------------------------------------------------
000011E6  48E7 4C00                175  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EA  0C01 0000                176  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011EE  6700 002C                177              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F2  B27C 0001                178              CMP.W   #01,D1          
000011F6  6700 003E                179              BEQ     CHNG_SZW
000011FA  6000 0006                180              BRA     CHNG_SZL        
000011FE                           181  
000011FE  48E7 4C00                182  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001202  123C 0008                183  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
00001206  0C01 0000                184  LOOP_L      CMPI.B  #00,D1
0000120A  6700 00CA                185              BEQ     EXIT_CONV
0000120E  5301                     186              SUBI.B  #01,D1
00001210  E99C                     187              ROL.L   #4,D4           * Shift it for next bit
00001212  2A04                     188              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001214  4EB9 00001250            189              JSR     CONV_LOOP
0000121A  60EA                     190              BRA     LOOP_L      
0000121C                           191  
0000121C  123C 0002                192  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001220  0C01 0000                193  LOOP_B      CMPI.B  #00,D1
00001224  6700 00B0                194              BEQ     EXIT_CONV
00001228  5301                     195              SUBI.B  #01,D1
0000122A  E91C                     196              ROL.B   #4,D4           * Shift it for next bit
0000122C  2A04                     197              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000122E  4EB9 00001250            198              JSR     CONV_LOOP
00001234  60EA                     199              BRA     LOOP_B
00001236                           200              
00001236  123C 0004                201  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123A  0C01 0000                202  LOOP_W      CMPI.B  #00,D1
0000123E  6700 0096                203              BEQ     EXIT_CONV
00001242  5301                     204              SUBI.B  #01,D1
00001244  E95C                     205              ROL.W   #4,D4           * Shift it for next bit
00001246  2A04                     206              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001248  4EB9 00001250            207              JSR     CONV_LOOP
0000124E  60EA                     208              BRA     LOOP_W
00001250                           209  
00001250  0285 0000000F            210  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001256  0C05 0000                211              CMPI.B  #$0,D5
0000125A  6700 0088                212              BEQ     NUM_0
0000125E  0C05 0001                213              CMPI.B  #$1,D5
00001262  6700 0088                214              BEQ     NUM_1
00001266  0C05 0002                215              CMPI.B  #$2,D5
0000126A  6700 0088                216              BEQ     NUM_2
0000126E  0C05 0003                217              CMPI.B  #$3,D5
00001272  6700 0088                218              BEQ     NUM_3
00001276  0C05 0004                219              CMPI.B  #$4,D5
0000127A  6700 0088                220              BEQ     NUM_4
0000127E  0C05 0005                221              CMPI.B  #$5,D5
00001282  6700 0088                222              BEQ     NUM_5
00001286  0C05 0006                223              CMPI.B  #$6,D5
0000128A  6700 0088                224              BEQ     NUM_6
0000128E  0C05 0007                225              CMPI.B  #$7,D5
00001292  6700 0088                226              BEQ     NUM_7
00001296  0C05 0008                227              CMPI.B  #$8,D5
0000129A  6700 0088                228              BEQ     NUM_8
0000129E  0C05 0009                229              CMPI.B  #$9,D5
000012A2  6700 0088                230              BEQ     NUM_9
000012A6  0C05 000A                231              CMPI.B  #$A,D5
000012AA  6700 0088                232              BEQ     NUM_A
000012AE  0C05 000B                233              CMPI.B  #$B,D5
000012B2  6700 0088                234              BEQ     NUM_B
000012B6  0C05 000C                235              CMPI.B  #$C,D5
000012BA  6700 0088                236              BEQ     NUM_C
000012BE  0C05 000D                237              CMPI.B  #$D,D5
000012C2  6700 0088                238              BEQ     NUM_D
000012C6  0C05 000E                239              CMPI.B  #$E,D5
000012CA  6700 0088                240              BEQ     NUM_E
000012CE  0C05 000F                241              CMPI.B  #$F,D5
000012D2  6700 0088                242              BEQ     NUM_F
000012D6                           243              
000012D6  4CDF 0032                244  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DA  4E75                     245              RTS
000012DC                           246              
000012DC  303C 000E                247  PRINT_NUM   MOVE    #14,D0
000012E0  4E4F                     248              TRAP    #15
000012E2  4E75                     249              RTS
000012E4  43F9 0000216A            250  NUM_0       LEA     PRNT0,A1
000012EA  60F0                     251              BRA     PRINT_NUM
000012EC  43F9 0000216C            252  NUM_1       LEA     PRNT1,A1
000012F2  60E8                     253              BRA     PRINT_NUM
000012F4  43F9 0000216E            254  NUM_2       LEA     PRNT2,A1
000012FA  60E0                     255              BRA     PRINT_NUM
000012FC  43F9 00002170            256  NUM_3       LEA     PRNT3,A1
00001302  60D8                     257              BRA     PRINT_NUM
00001304  43F9 00002172            258  NUM_4       LEA     PRNT4,A1
0000130A  60D0                     259              BRA     PRINT_NUM
0000130C  43F9 00002174            260  NUM_5       LEA     PRNT5,A1
00001312  60C8                     261              BRA     PRINT_NUM
00001314  43F9 00002176            262  NUM_6       LEA     PRNT6,A1
0000131A  60C0                     263              BRA     PRINT_NUM
0000131C  43F9 00002178            264  NUM_7       LEA     PRNT7,A1
00001322  60B8                     265              BRA     PRINT_NUM
00001324  43F9 0000217A            266  NUM_8       LEA     PRNT8,A1
0000132A  60B0                     267              BRA     PRINT_NUM
0000132C  43F9 0000217C            268  NUM_9       LEA     PRNT9,A1
00001332  60A8                     269              BRA     PRINT_NUM
00001334  43F9 0000217E            270  NUM_A       LEA     PRNTA,A1
0000133A  60A0                     271              BRA     PRINT_NUM
0000133C  43F9 00002180            272  NUM_B       LEA     PRNTB,A1
00001342  6098                     273              BRA     PRINT_NUM
00001344  43F9 00002182            274  NUM_C       LEA     PRNTC,A1
0000134A  6090                     275              BRA     PRINT_NUM
0000134C  43F9 00002184            276  NUM_D       LEA     PRNTD,A1
00001352  6088                     277              BRA     PRINT_NUM
00001354  43F9 00002186            278  NUM_E       LEA     PRNTE,A1
0000135A  6080                     279              BRA     PRINT_NUM
0000135C  43F9 00002188            280  NUM_F       LEA     PRNTF,A1
00001362  6000 FF78                281              BRA     PRINT_NUM
00001366                           282  
00001366                           283  
00001366                           284  *-----------------------------------------------------------        
00001366                           285  * Start of Disassembler
00001366                           286  *-----------------------------------------------------------
00001366                           287          *FOR DEBUGGING ONLY!!!
00001366  207C 00007FC6            288          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000136C                           289          
0000136C                           290  GRAB_NEXT_OP
0000136C                           291          *Check and see if A0 == end of test address. If so, we need to end.
0000136C  2E08                     292          MOVE.L  A0,D7       
0000136E                           293          *CMPI.L #PROGEND,D7   
0000136E                           294          *BGE        loop_1      * Ask user if they want to do the disassembler again
0000136E  0C86 00000000            295          CMPI.L  #00,D6      * Check if max line of instructions output on console is reached
00001374  6700 0032                296          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
00001378  5306                     297          SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
0000137A                           298  
0000137A                           299          *Output a newline to console...        
0000137A  43F9 0000225F            300          LEA     NewLine,A1  *Loads NewLine into address register A1
00001380  103C 000E                301          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001384  4E4F                     302          TRAP    #15         *Displays Message
00001386                           303  
00001386                           304          *Output the address of this instruction to console...
00001386  2808                     305          MOVE.L  A0,D4
00001388  4EB8 11FE                306          JSR     HEXASCIIREG
0000138C                           307          
0000138C                           308          *Output a tab (4 spaces) to console, just after the address...
0000138C  43F9 00002258            309          LEA     Tab,A1  *Loads Tab into address register A1
00001392  103C 000E                310          MOVE.B  #14,D0  *Moves the number 14 into data register D0
00001396  4E4F                     311          TRAP    #15     *Displays Message
00001398                           312          
00001398                           313          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
00001398                           314          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
00001398                           315          *data that may be associated with the instruction.
00001398                           316          *Post increment addr, A0 will point to the start of next instruction or will 
00001398                           317          *point to the start of any immed/abso data with this current instruction
00001398  4280                     318          CLR.L   D0
0000139A  3018                     319          MOVE.W  (A0)+,D0
0000139C                           320          *Copy the word data we just moved into D0 into D7. We are copying this data
0000139C                           321          *So we always have a copy of the WHOLE instruction somewhere
0000139C  4287                     322          CLR.L   D7
0000139E  3E00                     323          MOVE.W  D0,D7
000013A0                           324          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000013A0                           325          *four bits of the instruction. Once we have just the first four bits, we can
000013A0                           326          *begin to see which 'bucket'/category this instruction falls into. 
000013A0  E048                     327          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013A2  E848                     328          LSR.W   #$04,D0
000013A4                           329          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013A4                           330          *list of buckets until we find which one this instruction falls into.
000013A4  6000 0068                331          BRA     BUCKET_0000     * Start with 0000
000013A8                           332  
000013A8                           333  
000013A8                           334  *-----------------------------------------------------------        
000013A8                           335  * Question Prompts
000013A8                           336  *-----------------------------------------------------------        
000013A8  43F9 00002098            337  CONT_Q      LEA     QUES_CONT,A1
000013AE  303C 000E                338              MOVE    #14,D0
000013B2  4E4F                     339              TRAP    #15
000013B4  43F9 0000214C            340              LEA     CONT,A1     *Need to store Y/N
000013BA  303C 0002                341              MOVE    #2,D0
000013BE  4E4F                     342              TRAP    #15
000013C0  0C01 0001                343              CMPI.B  #01,D1
000013C4  6600 FD6E                344              BNE     INVALID1
000013C8  0C39 0059 0000214C       345              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013D0  6600 0008                346              BNE     CHECK_Y
000013D4  3C3C 000F                347              MOVE    #MAX_LINE,D6    *Resets counter
000013D8  4E75                     348              RTS
000013DA  0C11 0079                349  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
000013DE  6600 0008                350              BNE     CHECK_N
000013E2  3C3C 000F                351              MOVE    #MAX_LINE,D6    *Resets counter
000013E6  4E75                     352              RTS
000013E8  0C11 004E                353  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
000013EC  6700 FC26                354              BEQ     loop_1
000013F0  0C11 006E                355              CMPI.B  #$6E,(A1)   *Checks for lowercase n
000013F4  6700 FC1E                356              BEQ     loop_1      
000013F8                           357  
000013F8  163C 0000                358  INV2        MOVE.B  #0,D3       *Reset bad flag
000013FC  303C 0000                359              MOVE    #0,D0       *Prints invalid command msg if not found
00001400  43F9 00002275            360              LEA     INV_MSG,A1
00001406  303C 000E                361              MOVE    #14,D0
0000140A  4E4F                     362              TRAP    #15
0000140C  609A                     363              BRA     CONT_Q
0000140E                           364  
0000140E                           365  *-----------------------------------------------------------        
0000140E                           366  * Bucket 0000:
0000140E                           367  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
0000140E                           368  *                   BCHG(dynamic) | BCHG (static) | CMPI----
0000140E                           369  *-----------------------------------------------------------
0000140E                           370  BUCKET_0000
0000140E  =00000000                371  BUCKET0000_BITS EQU $0
0000140E  4281                     372          CLR.L   D1
00001410                           373          *Load the first 4 bits (really a byte) of BUCKET0 into D1
00001410  123C 0000                374          MOVE.B  #BUCKET0000_BITS,D1
00001414                           375          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
00001414                           376          *If equal, continue decoding. If not, branch to next bucket.
00001414  B200                     377          CMP.B   D0,D1
00001416  6600 0344                378          BNE     BUCKET_0001
0000141A                           379  
0000141A                           380          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
0000141A                           381          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
0000141A  3007                     382          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
0000141C  0800 0008                383          BTST.L  #$08,D0
00001420  6600 01A4                384          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
00001424                           385          
00001424                           386          *Now we can check bits 11-8 in the instruction and branch to different op-codes
00001424                           387          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
00001424  E048                     388          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001426  0880 0004                389          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
0000142A  0880 0005                390          BCLR.L  #$05,D0
0000142E  0880 0006                391          BCLR.L  #$06,D0
00001432  0880 0007                392          BCLR.L  #$07,D0
00001436                           393          
00001436                           394          *Perform compares with these 4 bits to see which specific instruction it is.
00001436  B03C 0006                395          CMP.B   #$06,D0 *Is this an ADDI?
0000143A  6700 0028                396          BEQ     IS_ADDI
0000143E  B03C 0002                397          CMP.B   #$02,D0 *Is this an ANDI?
00001442  6700 0096                398          BEQ     IS_ANDI
00001446  B03C 000A                399          CMP.B   #$0A,D0 *Is this an EORI?
0000144A  6700 0104                400          BEQ     IS_EORI
0000144E  B03C 0008                401          CMP.B   #$08,D0 *Is this a BCHG(static)?
00001452  6700 0210                402          BEQ     IS_BCHG_S
00001456  B03C 000C                403          CMP.B   #$0C,D0 *Is this a CMPI?
0000145A  6700 028A                404          BEQ     IS_CMPI
0000145E                           405          
0000145E                           406          *If we get through all of the compares without finding the specific instruction,
0000145E                           407          *then this instruction is either not in our list of OP CODES to decode, or is an
0000145E                           408          *invalid instruction/syntax.
0000145E  4EF9 00001BCC            409          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
00001464                           410          
00001464                           411          
00001464                           412  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
00001464                           413  IS_ADDI
00001464                           414          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001464                           415          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001464  4281                     416          CLR.L   D1
00001466  3207                     417          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001468  C27C 00C0                418          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000146C  EC09                     419          LSR.B   #$06,D1     *Shift the size bits into LSB
0000146E                           420          
0000146E  B23C 0003                421          CMP.B   #$03,D1     *Compare the size bits to $3
00001472  6700 0758                422          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001476                           423          
00001476                           424          *Output 'ADDI' to console...
00001476  43F9 0000218A            425          LEA     ADDI,A1     *Loads ADDI into address register A1
0000147C  103C 000E                426          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001480  4E4F                     427          TRAP    #15         *Displays Message
00001482                           428          
00001482                           429          
00001482                           430          *Should have a valid ADDI op code. Set data up for EA.
00001482                           431          
00001482                           432          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001482  4282                     433          CLR.L   D2
00001484  3407                     434          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001486  C47C 003C                435          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
0000148A  E60A                     436          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000148C                           437                  
0000148C                           438          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000148C  4283                     439          CLR.L   D3
0000148E  3607                     440          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001490  C67C 0007                441          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001494                           442          
00001494  4EF9 0000149A            443          JMP     EA_ADDI
0000149A                           444  
0000149A                           445  EA_ADDI
0000149A                           446          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
0000149A                           447          *and D3 holds the EA register.
0000149A                           448          
0000149A                           449          *Determine how much data to read in, depending on the size of the operation
0000149A                           450          *output the size of the operation and the immediate data to console
0000149A  4EB9 00001762            451          JSR     WrapperSizeImmediate
000014A0                           452          
000014A0                           453          *manually output a comma here...
000014A0  43F9 0000225D            454          LEA     Comma,A1        *Loads Comma into address register A1
000014A6  103C 000E                455          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014AA  4E4F                     456          TRAP    #15             *Displays Message        
000014AC                           457          
000014AC                           458          *Determine which EA mode and thus Register/Mem Address this instruction used
000014AC  B43C 0000                459          CMP.B   #$00,D2
000014B0  6700 0376                460          BEQ     DataRegMode *If EA mode is a data register, output that
000014B4                           461          
000014B4  B43C 0002                462          CMP.B   #$02,D2
000014B8  6700 037E                463          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014BC                           464          
000014BC  B43C 0003                465          CMP.B   #$03,D2
000014C0  6700 0386                466          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014C4                           467          
000014C4  B43C 0004                468          CMP.B   #$04,D2
000014C8  6700 038E                469          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014CC                           470          
000014CC  B43C 0007                471          CMP.B   #$07,D2
000014D0  6700 0396                472          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014D4                           473          
000014D4                           474          *If the ea mode isn't equal to any of these, it is an invalid EA
000014D4  4EF9 00001BDC            475          JMP     BADEACODE                               
000014DA                           476          
000014DA                           477  
000014DA                           478  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000014DA                           479  IS_ANDI
000014DA                           480          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014DA                           481          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014DA  4281                     482          CLR.L   D1
000014DC  3207                     483          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014DE  C27C 00C0                484          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014E2  EC09                     485          LSR.B   #$06,D1     *Shift the size bits into LSB
000014E4                           486          
000014E4  B23C 0003                487          CMP.B   #$03,D1     *Compare the size bits to $3
000014E8  6700 06E2                488          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014EC                           489          
000014EC                           490          *Output 'ANDI' to console...
000014EC  43F9 0000218F            491          LEA     ANDI,A1     *Loads ANDI into address register A1
000014F2  103C 000E                492          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014F6  4E4F                     493          TRAP    #15         *Displays Message
000014F8                           494          
000014F8                           495          
000014F8                           496          *Should have a valid ANDI op code. Set data up for EA.
000014F8                           497          
000014F8                           498          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014F8  4282                     499          CLR.L   D2
000014FA  3407                     500          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014FC  C47C 003C                501          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001500  E60A                     502          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001502                           503                  
00001502                           504          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001502  4283                     505          CLR.L   D3
00001504  3607                     506          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001506  C67C 0007                507          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000150A                           508          
0000150A  4EF9 00001510            509          JMP     EA_ANDI
00001510                           510  
00001510                           511  EA_ANDI
00001510                           512          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
00001510                           513          *and D3 holds the EA register.
00001510                           514          
00001510                           515          *Determine how much data to read in, depending on the size of the operation
00001510                           516          *output the size of the operation and the immediate data to console
00001510  4EB9 00001762            517          JSR     WrapperSizeImmediate
00001516                           518          
00001516                           519          *manually output a comma here...
00001516  43F9 0000225D            520          LEA     Comma,A1        *Loads Comma into address register A1
0000151C  103C 000E                521          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001520  4E4F                     522          TRAP    #15             *Displays Message        
00001522                           523          
00001522                           524          *Determine which EA mode and thus Register/Mem Address this instruction used
00001522  B43C 0000                525          CMP.B   #$00,D2
00001526  6700 0300                526          BEQ     DataRegMode *If EA mode is a data register, output that
0000152A                           527          
0000152A  B43C 0002                528          CMP.B   #$02,D2
0000152E  6700 0308                529          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001532                           530          
00001532  B43C 0003                531          CMP.B   #$03,D2
00001536  6700 0310                532          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000153A                           533          
0000153A  B43C 0004                534          CMP.B   #$04,D2
0000153E  6700 0318                535          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001542                           536          
00001542  B43C 0007                537          CMP.B   #$07,D2
00001546  6700 0320                538          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000154A                           539          
0000154A                           540          *If the ea mode isn't equal to any of these, it is an invalid EA
0000154A  4EF9 00001BDC            541          JMP     BADEACODE
00001550                           542          
00001550                           543  
00001550                           544  *Now we know this instruction is exactly EORI, lets set everything up for EA.
00001550                           545  IS_EORI
00001550                           546          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001550                           547          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001550  4281                     548          CLR.L   D1
00001552  3207                     549          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001554  C27C 00C0                550          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001558  EC09                     551          LSR.B   #$06,D1     *Shift the size bits into LSB
0000155A                           552          
0000155A  B23C 0003                553          CMP.B   #$03,D1     *Compare the size bits to $3
0000155E  6700 066C                554          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001562                           555          
00001562                           556          *Output 'EORI' to console...
00001562  43F9 00002194            557          LEA     EORI,A1     *Loads EORI into address register A1
00001568  103C 000E                558          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000156C  4E4F                     559          TRAP    #15         *Displays Message
0000156E                           560          
0000156E                           561          
0000156E                           562          *Should have a valid EORI op code. Set data up for EA.
0000156E                           563          
0000156E                           564          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000156E  4282                     565          CLR.L   D2
00001570  3407                     566          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001572  C47C 003C                567          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001576  E60A                     568          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001578                           569                  
00001578                           570          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001578  4283                     571          CLR.L   D3
0000157A  3607                     572          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000157C  C67C 0007                573          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001580                           574          
00001580  4EF9 00001586            575          JMP     EA_EORI
00001586                           576  
00001586                           577  EA_EORI
00001586                           578          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
00001586                           579          *and D3 holds the EA register.
00001586                           580          
00001586                           581          *Determine how much data to read in, depending on the size of the operation
00001586                           582          *output the size of the operation and the immediate data to console
00001586  4EB9 00001762            583          JSR     WrapperSizeImmediate
0000158C                           584          
0000158C                           585          *manually output a comma here...
0000158C  43F9 0000225D            586          LEA     Comma,A1        *Loads Comma into address register A1
00001592  103C 000E                587          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001596  4E4F                     588          TRAP    #15             *Displays Message        
00001598                           589          
00001598                           590          *Determine which EA mode and thus Register/Mem Address this instruction used
00001598  B43C 0000                591          CMP.B   #$00,D2
0000159C  6700 028A                592          BEQ     DataRegMode *If EA mode is a data register, output that
000015A0                           593          
000015A0  B43C 0002                594          CMP.B   #$02,D2
000015A4  6700 0292                595          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015A8                           596          
000015A8  B43C 0003                597          CMP.B   #$03,D2
000015AC  6700 029A                598          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015B0                           599          
000015B0  B43C 0004                600          CMP.B   #$04,D2
000015B4  6700 02A2                601          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015B8                           602          
000015B8  B43C 0007                603          CMP.B   #$07,D2
000015BC  6700 02AA                604          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015C0                           605          
000015C0                           606          *If the ea mode isn't equal to any of these, it is an invalid EA
000015C0  4EF9 00001BDC            607          JMP     BADEACODE
000015C6                           608  
000015C6                           609  
000015C6                           610  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015C6                           611  * everything up for EA if is a legit instruction.
000015C6                           612  IS_BCHG_D
000015C6                           613          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015C6                           614          *invalid, branch to BADOPCODE
000015C6  3007                     615          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015C8  0800 0007                616          BTST.L  #$07,D0
000015CC  6600 05FE                617          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015D0  0800 0006                618          BTST.L  #$06,D0
000015D4  6700 05F6                619          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000015D8                           620          
000015D8                           621          *Output 'BCHG' to console...
000015D8  43F9 00002199            622          LEA     BCHG,A1         *Loads BCHG into address register A1
000015DE  103C 000E                623          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015E2  4E4F                     624          TRAP    #15             *Displays Message
000015E4                           625                  
000015E4                           626                  
000015E4                           627          *Should have a valid BCHG op code. Set data up for EA.
000015E4                           628  
000015E4                           629          *Set D1 to the EA source register located in bits 11-9 of the instruction
000015E4  4281                     630          CLR.L   D1
000015E6  3207                     631          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015E8  C27C 0E00                632          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
000015EC  E009                     633          LSR.B   #$08,D1     *Shift the EA source register bits into LSB
000015EE  E209                     634          LSR.B   #$01,D1
000015F0                           635  
000015F0                           636          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015F0  4282                     637          CLR.L   D2
000015F2  3407                     638          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000015F4  C47C 003C                639          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000015F8  E60A                     640          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000015FA                           641                  
000015FA                           642          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000015FA  4283                     643          CLR.L   D3
000015FC  3607                     644          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000015FE  C67C 0007                645          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001602                           646  
00001602  4EF9 00001608            647          JMP     EA_BCHG_D
00001608                           648  
00001608                           649  EA_BCHG_D
00001608                           650          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001608                           651          *D2 holds the EA mode, and D3 holds the EA register.
00001608                           652          
00001608                           653          *Determine the size of this BCHG instruction. Output the correct size...
00001608  4EB9 000017E4            654          JSR     BCHGSizeHelper
0000160E                           655          
0000160E                           656          *output the source register to console, flag D6 with a 1 so we come back...
0000160E  48E7 0200                657          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
00001612  48E7 1000                658          MOVEM.L D3,-(SP)    *Push EA destination register into stack            
00001616  1C3C 0001                659          MOVE.B  #$01,D6     *Flag D6
0000161A  1601                     660          MOVE.B  D1,D3       *Move source register into D3
0000161C  4EB9 00001828            661          JSR     DataRegMode
00001622  4CDF 0008                662          MOVEM.L (SP)+,D3    *Pull destination register back into D3
00001626  4CDF 0040                663          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
0000162A                           664          
0000162A                           665          *manually output a comma here...
0000162A  43F9 0000225D            666          LEA     Comma,A1        *Loads Comma into address register A1
00001630  103C 000E                667          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001634  4E4F                     668          TRAP    #15             *Displays Message
00001636                           669          
00001636                           670          *Determine which EA mode and thus Register/Mem Address this instruction used
00001636  B43C 0000                671          CMP.B   #$00,D2
0000163A  6700 01EC                672          BEQ     DataRegMode *If EA mode is a data register, output that
0000163E                           673          
0000163E  B43C 0002                674          CMP.B   #$02,D2
00001642  6700 01F4                675          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001646                           676          
00001646  B43C 0003                677          CMP.B   #$03,D2
0000164A  6700 01FC                678          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000164E                           679          
0000164E  B43C 0004                680          CMP.B   #$04,D2
00001652  6700 0204                681          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001656                           682          
00001656  B43C 0007                683          CMP.B   #$07,D2
0000165A  6700 020C                684          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000165E                           685          
0000165E                           686          *If the ea mode isn't equal to any of these, it is an invalid EA
0000165E  4EF9 00001BDC            687          JMP     BADEACODE
00001664                           688  
00001664                           689  
00001664                           690  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
00001664                           691  IS_BCHG_S
00001664                           692          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
00001664                           693          *invalid, branch to BADOPCODE
00001664  3007                     694          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
00001666  0800 0007                695          BTST.L  #$07,D0
0000166A  6600 0560                696          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
0000166E  0800 0006                697          BTST.L  #$06,D0
00001672  6700 0558                698          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
00001676                           699          
00001676                           700          *Output 'BCHG' to console...
00001676  43F9 00002199            701          LEA     BCHG,A1         *Loads BCHG into address register A1
0000167C  103C 000E                702          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001680  4E4F                     703          TRAP    #15             *Displays Message
00001682                           704          
00001682                           705          
00001682                           706          *Should have a valid BCHG op code. Set data up for EA.
00001682                           707          
00001682                           708          *Move #$00 into D1, BCHG_S's immediate data is always in byte size
00001682  4281                     709          CLR.L   D1
00001684  323C 0000                710          MOVE.W  #$00,D1
00001688                           711  
00001688                           712          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001688  4282                     713          CLR.L   D2
0000168A  3407                     714          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000168C  C47C 003C                715          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001690  E60A                     716          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001692                           717                  
00001692                           718          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001692  4283                     719          CLR.L   D3
00001694  3607                     720          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001696  C67C 0007                721          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000169A                           722  
0000169A  4EF9 000016A0            723          JMP     EA_BCHG_S
000016A0                           724  
000016A0                           725  EA_BCHG_S
000016A0                           726          *Decode the ea bits of BCHG(static). Assuming D2 holds the EA mode, and 
000016A0                           727          *D3 holds the EA register.
000016A0                           728          
000016A0                           729          *Determine the size of this BCHG instruction. Output the correct size...
000016A0  4EB9 000017E4            730          JSR     BCHGSizeHelper                
000016A6                           731          
000016A6                           732          *output the immediate data of this operation to console (always byte)...
000016A6  4EB9 00001814            733          JSR     BCHGImmediate
000016AC                           734          
000016AC                           735          *manually output a comma here...
000016AC  43F9 0000225D            736          LEA     Comma,A1        *Loads Comma into address register A1
000016B2  103C 000E                737          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016B6  4E4F                     738          TRAP    #15             *Displays Message
000016B8                           739          
000016B8                           740          *Determine which EA mode and thus Register/Mem Address this instruction used
000016B8  B43C 0000                741          CMP.B   #$00,D2
000016BC  6700 016A                742          BEQ     DataRegMode *If EA mode is a data register, output that
000016C0                           743          
000016C0  B43C 0002                744          CMP.B   #$02,D2
000016C4  6700 0172                745          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016C8                           746          
000016C8  B43C 0003                747          CMP.B   #$03,D2
000016CC  6700 017A                748          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016D0                           749          
000016D0  B43C 0004                750          CMP.B   #$04,D2
000016D4  6700 0182                751          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000016D8                           752          
000016D8  B43C 0007                753          CMP.B   #$07,D2
000016DC  6700 018A                754          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000016E0                           755          
000016E0                           756          *If the ea mode isn't equal to any of these, it is an invalid EA
000016E0  4EF9 00001BDC            757          JMP     BADEACODE
000016E6                           758  
000016E6                           759  
000016E6                           760  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000016E6                           761  IS_CMPI
000016E6                           762          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000016E6                           763          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000016E6  4281                     764          CLR.L   D1
000016E8  3207                     765          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000016EA  C27C 00C0                766          AND.W   #$00C0,D1   *Mask out everything but the size bits
000016EE  EC09                     767          LSR.B   #$06,D1     *Shift the size bits into LSB
000016F0                           768          
000016F0  B23C 0003                769          CMP.B   #$03,D1     *Compare the size bits to $3
000016F4  6700 04D6                770          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000016F8                           771          
000016F8                           772          *Output 'CMPI' to console...
000016F8  43F9 0000219E            773          LEA     CMPI,A1     *Loads CMPI into address register A1
000016FE  103C 000E                774          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001702  4E4F                     775          TRAP    #15         *Displays Message
00001704                           776          
00001704                           777          
00001704                           778          *Should have a valid CMPI op code. Set data up for EA.
00001704                           779          
00001704                           780          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001704  4282                     781          CLR.L   D2
00001706  3407                     782          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001708  C47C 003C                783          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
0000170C  E60A                     784          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000170E                           785                  
0000170E                           786          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000170E  4283                     787          CLR.L   D3
00001710  3607                     788          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001712  C67C 0007                789          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001716                           790          
00001716  4EF9 0000171C            791          JMP     EA_CMPI
0000171C                           792  
0000171C                           793  EA_CMPI
0000171C                           794          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
0000171C                           795          *and D3 holds the EA register.
0000171C                           796          
0000171C                           797          *Determine how much data to read in, depending on the size of the operation
0000171C                           798          *output the size of the operation and the immediate data to console
0000171C  4EB9 00001762            799          JSR     WrapperSizeImmediate
00001722                           800          
00001722                           801          *manually output a comma here...
00001722  43F9 0000225D            802          LEA     Comma,A1        *Loads Comma into address register A1
00001728  103C 000E                803          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000172C  4E4F                     804          TRAP    #15             *Displays Message
0000172E                           805          
0000172E                           806          *Determine which EA mode and thus Register/Mem Address this instruction used
0000172E  B43C 0000                807          CMP.B   #$00,D2
00001732  6700 00F4                808          BEQ     DataRegMode *If EA mode is a data register, output that
00001736                           809          
00001736  B43C 0002                810          CMP.B   #$02,D2
0000173A  6700 00FC                811          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000173E                           812          
0000173E  B43C 0003                813          CMP.B   #$03,D2
00001742  6700 0104                814          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001746                           815          
00001746  B43C 0004                816          CMP.B   #$04,D2
0000174A  6700 010C                817          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000174E                           818          
0000174E  B43C 0007                819          CMP.B   #$07,D2
00001752  6700 0114                820          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001756                           821          
00001756                           822          *If the ea mode isn't equal to any of these, it is an invalid EA
00001756  4EF9 00001BDC            823          JMP     BADEACODE
0000175C                           824  
0000175C                           825          
0000175C                           826  *STARTS WITH 0001, MOVE.B-----------------------------------
0000175C                           827  BUCKET_0001
0000175C  =00000001                828  BUCKET0001_BITS EQU $1
0000175C                           829          
0000175C                           830          *some code...
0000175C                           831  
0000175C                           832  
0000175C                           833  *STARTS WITH 0010, MOVE.L-----------------------------------
0000175C                           834  BUCKET_0010
0000175C  =00000002                835  BUCKET0010_BITS EQU $2
0000175C                           836  
0000175C                           837          *some code...
0000175C                           838  
0000175C                           839  
0000175C                           840  *STARTS WITH 0011, MOVE.W-----------------------------------
0000175C                           841  BUCKET_0011
0000175C  =00000003                842  BUCKET0011_BITS EQU $3
0000175C                           843  
0000175C                           844          *some code...
0000175C                           845  
0000175C                           846  
0000175C                           847  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
0000175C                           848  BUCKET_0100
0000175C  =00000004                849  BUCKET0100_BITS EQU $4
0000175C                           850  
0000175C                           851          *some code...
0000175C                           852  
0000175C                           853  
0000175C                           854  *STARTS WITH 0101, SUBQ-------------------------------------
0000175C                           855  BUCKET_0101
0000175C  =00000005                856  BUCKET0101_BITS EQU $5
0000175C                           857  
0000175C                           858          *some code...
0000175C                           859  
0000175C                           860  
0000175C                           861  *STARTS WITH 0110, BCC--------------------------------------
0000175C                           862  BUCKET_0110
0000175C  =00000006                863  BUCKET0110_BITS EQU $6
0000175C                           864  
0000175C                           865          *some code...
0000175C                           866  
0000175C                           867  
0000175C                           868  *STARTS WITH 1000, DIVU-------------------------------------
0000175C                           869  BUCKET_1000
0000175C  =00000008                870  BUCKET1000_BITS EQU $8
0000175C                           871  
0000175C                           872          *some code...
0000175C                           873  
0000175C                           874  
0000175C                           875  *STARTS WITH 1001, SUBA-------------------------------------
0000175C                           876  BUCKET_1001
0000175C  =00000009                877  BUCKET1001_BITS EQU $9
0000175C                           878  
0000175C                           879          *some code...
0000175C                           880  
0000175C                           881  
0000175C                           882  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
0000175C                           883  BUCKET_1011
0000175C  =0000000B                884  BUCKET1011_BITS EQU $B
0000175C                           885  
0000175C                           886          *some code...
0000175C                           887  
0000175C                           888  
0000175C                           889  *STARTS WITH 1100, MULS(W) | AND----------------------------
0000175C                           890  BUCKET_1100
0000175C  =0000000C                891  BUCKET1100_BITS EQU $C
0000175C                           892  
0000175C                           893          *some code...
0000175C                           894  
0000175C                           895  
0000175C                           896  *STARTS WITH 1101, ADD | ADDA-------------------------------
0000175C                           897  BUCKET_1101
0000175C  =0000000D                898  BUCKET1101_BITS EQU $D
0000175C                           899  
0000175C                           900          *some code...
0000175C                           901  
0000175C                           902  
0000175C                           903  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
0000175C                           904  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
0000175C                           905  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
0000175C                           906  BUCKET_1110
0000175C  =0000000E                907  BUCKET1110_BITS EQU $E     
0000175C                           908  
0000175C                           909          *some code...
0000175C                           910  
0000175C                           911  
0000175C                           912  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
0000175C                           913  *for this disassembler, jump to BADOPCODE and let I/O take care of it
0000175C  4EF9 00001BCC            914          JMP     BADOPCODE  
00001762                           915          
00001762                           916  
00001762                           917  *-----------------------------------------------------------        
00001762                           918  * EA operation size decoding functionality for immediate data
00001762                           919  *-----------------------------------------------------------   
00001762                           920  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001762                           921  WrapperSizeImmediate
00001762  4284                     922          CLR.L   D4
00001764                           923          *Depending on the EA Register, choose which size to decode
00001764  B23C 0000                924          CMP.B   #$00,D1
00001768  6700 0014                925          BEQ     ByteSizeImmediate
0000176C                           926          
0000176C  B23C 0001                927          CMP.B   #$01,D1
00001770  6700 002E                928          BEQ     WordSizeImmediate
00001774                           929  
00001774  B23C 0002                930          CMP.B   #$02,D1
00001778  6700 0048                931          BEQ     LongSizeImmediate
0000177C                           932          
0000177C                           933  *Used to get back to what we were doing, after dealing with the specific size
0000177C                           934  WrapperSizeImmediateEnd
0000177C  4E75                     935          RTS
0000177E                           936          
0000177E                           937  ByteSizeImmediate
0000177E  3818                     938          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
00001780                           939          
00001780                           940          *Output '.B' to console...
00001780  43F9 000021A3            941          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001786  103C 000E                942          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000178A  4E4F                     943          TRAP    #15         *Displays Message
0000178C                           944          
0000178C                           945          *Output '#$' just before the immediate data
0000178C  43F9 00002262            946          LEA     ShaBang,A1
00001792  103C 000E                947          MOVE.B  #14,D0
00001796  4E4F                     948          TRAP    #15  
00001798                           949          
00001798                           950          *output the immediate data to console with the hex-ascii converter
00001798  4EB8 11E6                951          JSR     HEXASCII
0000179C                           952                  
0000179C  4EF8 177C                953          JMP     WrapperSizeImmediateEnd
000017A0                           954                  
000017A0                           955  WordSizeImmediate
000017A0  3818                     956          MOVE.W  (A0)+,D4    *read in next word, data is that word
000017A2                           957          
000017A2                           958          *Output '.W' to console...
000017A2  43F9 000021AA            959          LEA     WordSize,A1 *Loads WordSize into address register A1
000017A8  103C 000E                960          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000017AC  4E4F                     961          TRAP    #15         *Displays Message
000017AE                           962          
000017AE                           963          *Output '#$' just before the immediate data
000017AE  43F9 00002262            964          LEA     ShaBang,A1
000017B4  103C 000E                965          MOVE.B  #14,D0
000017B8  4E4F                     966          TRAP    #15  
000017BA                           967          
000017BA                           968          *output the immediate data to console with the hex-ascii converter
000017BA  4EB8 11E6                969          JSR     HEXASCII
000017BE                           970          
000017BE  4EF8 177C                971          JMP     WrapperSizeImmediateEnd
000017C2                           972                  
000017C2                           973  LongSizeImmediate
000017C2  2818                     974          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
000017C4                           975          
000017C4                           976          *Output '.L' to console...
000017C4  43F9 000021B1            977          LEA     LongSize,A1 *Loads LongSize into address register A1
000017CA  103C 000E                978          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000017CE  4E4F                     979          TRAP    #15         *Displays Message
000017D0                           980          
000017D0                           981          *Output '#$' just before the immediate data
000017D0  43F9 00002262            982          LEA     ShaBang,A1
000017D6  103C 000E                983          MOVE.B  #14,D0
000017DA  4E4F                     984          TRAP    #15  
000017DC                           985          
000017DC                           986          *output the immediate data to console with the hex-ascii converter
000017DC  4EB8 11E6                987          JSR     HEXASCII
000017E0                           988          
000017E0  4EF8 177C                989          JMP     WrapperSizeImmediateEnd        
000017E4                           990  
000017E4                           991  
000017E4                           992  *-----------------------------------------------------------        
000017E4                           993  * BCHG Size decoding functionality
000017E4                           994  *----------------------------------------------------------- 
000017E4                           995  BCHGSizeHelper
000017E4                           996          *Determine if the EA mode is a data register. If so, output '.L' to console...
000017E4  B43C 0000                997          CMP.B   #$00,D2
000017E8  6700 000A                998          BEQ     BCHGLongSize
000017EC                           999          
000017EC                          1000          *If the EA mode isn't a data register, WE MUST output a '.B' to console...
000017EC  4EF9 00001804           1001          JMP     BCHGByteSize
000017F2                          1002          
000017F2                          1003  *Used to get back to what we were doing, after dealing with the specific size
000017F2                          1004  BCHGSizeHelperEnd
000017F2  4E75                    1005          RTS  
000017F4                          1006          
000017F4                          1007  BCHGLongSize
000017F4                          1008          *Output '.L' to console...
000017F4  43F9 000021B1           1009          LEA     LongSize,A1 *Loads LongSize into address register A1
000017FA  103C 000E               1010          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000017FE  4E4F                    1011          TRAP    #15         *Displays Message
00001800                          1012  
00001800  4EF8 17F2               1013          JMP     BCHGSizeHelperEnd
00001804                          1014          
00001804                          1015  BCHGByteSize
00001804                          1016          *Output '.B' to console...
00001804  43F9 000021A3           1017          LEA     ByteSize,A1 *Loads ByteSize into address register A1
0000180A  103C 000E               1018          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000180E  4E4F                    1019          TRAP    #15         *Displays Message   
00001810                          1020          
00001810  4EF8 17F2               1021          JMP     BCHGSizeHelperEnd
00001814                          1022          
00001814                          1023  *Output the immediate data for a BCHG(static). Data is always byte size.
00001814                          1024  BCHGImmediate
00001814  3818                    1025          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word        
00001816                          1026          
00001816                          1027          *Output '#$' just before the immediate data
00001816  43F9 00002262           1028          LEA     ShaBang,A1
0000181C  103C 000E               1029          MOVE.B  #14,D0
00001820  4E4F                    1030          TRAP    #15  
00001822                          1031          
00001822                          1032          *output the immediate data to console with the hex-ascii converter
00001822  4EB8 11E6               1033          JSR     HEXASCII
00001826                          1034                  
00001826  4E75                    1035          RTS        
00001828                          1036  
00001828                          1037  
00001828                          1038  *-----------------------------------------------------------        
00001828                          1039  * EA Mode/EA Register decoding functionality
00001828                          1040  *-----------------------------------------------------------        
00001828                          1041  DataRegMode
00001828                          1042          *Depending on the EA Register, output a different register number
00001828  4EB9 00001878           1043          JSR     WrapperDataReg        
0000182E                          1044          
0000182E                          1045          *if this was called for a destination decoding then we are done decoding this        
0000182E                          1046          *instruction, go get the next instruction
0000182E  BC3C 0001               1047          CMP.B   #$01,D6
00001832  6600 FB38               1048          BNE     GRAB_NEXT_OP
00001836                          1049          
00001836                          1050          *else this was a source decoding, rts back to we can keep decoding
00001836  4E75                    1051          RTS
00001838                          1052  
00001838                          1053  AddrDirectMode
00001838                          1054          *some code...
00001838                          1055  
00001838                          1056  AddrIndirectMode
00001838                          1057          *Depending on the EA Register, output a different register number
00001838  4EB9 0000193A           1058          JSR     WrapperAddrIndirect
0000183E                          1059                          
0000183E                          1060          *if this was called for a destination decoding then we are done decoding this        
0000183E                          1061          *instruction, go get the next instruction
0000183E  BC3C 0001               1062          CMP.B   #$01,D6
00001842  6600 FB28               1063          BNE     GRAB_NEXT_OP
00001846                          1064          
00001846                          1065          *else this was a source decoding, rts back to we can keep decoding
00001846  4E75                    1066          RTS
00001848                          1067  
00001848                          1068  AddrIndirectPostMode
00001848                          1069          *Depending on the EA Register, output a different register number
00001848  4EB9 000019FC           1070          JSR     WrapperAddrIndirectPost
0000184E                          1071  
0000184E                          1072          *if this was called for a destination decoding then we are done decoding this        
0000184E                          1073          *instruction, go get the next instruction
0000184E  BC3C 0001               1074          CMP.B   #$01,D6
00001852  6600 FB18               1075          BNE     GRAB_NEXT_OP
00001856                          1076          
00001856                          1077          *else this was a source decoding, rts back to we can keep decoding
00001856  4E75                    1078          RTS
00001858                          1079  
00001858                          1080  AddrIndirectPreMode
00001858                          1081          *Depending on the EA Register, output a different register number
00001858  4EB9 00001ABE           1082          JSR     WrapperAddrIndirectPre
0000185E                          1083  
0000185E                          1084          *if this was called for a destination decoding then we are done decoding this        
0000185E                          1085          *instruction, go get the next instruction
0000185E  BC3C 0001               1086          CMP.B   #$01,D6
00001862  6600 FB08               1087          BNE     GRAB_NEXT_OP
00001866                          1088          
00001866                          1089          *else this was a source decoding, rts back to we can keep decoding
00001866  4E75                    1090          RTS
00001868                          1091  
00001868                          1092  AddrAbsoluteMode
00001868                          1093          *Depending on the EA Register, output a different register number
00001868  4EB9 00001B80           1094          JSR     WrapperAddrAbsolute        
0000186E                          1095  
0000186E                          1096          *if this was called for a destination decoding then we are done decoding this        
0000186E                          1097          *instruction, go get the next instruction
0000186E  BC3C 0001               1098          CMP.B   #$01,D6
00001872  6600 FAF8               1099          BNE     GRAB_NEXT_OP
00001876                          1100          
00001876                          1101          *else this was a source decoding, rts back to we can keep decoding
00001876  4E75                    1102          RTS
00001878                          1103          
00001878                          1104  ImmediateDataMode
00001878                          1105          *some code        
00001878                          1106          
00001878                          1107          
00001878                          1108  *-----------------------------------------------------------        
00001878                          1109  * Output logic for all Data Registers (0-7)
00001878                          1110  *-----------------------------------------------------------
00001878                          1111  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001878                          1112  WrapperDataReg
00001878                          1113          *Depending on the EA destination register, output a different register number
00001878  B63C 0000               1114          CMP.B   #$00,D3
0000187C  6700 003C               1115          BEQ     DataReg0
00001880                          1116          
00001880  B63C 0001               1117          CMP.B   #$01,D3
00001884  6700 0044               1118          BEQ     DataReg1
00001888                          1119          
00001888  B63C 0002               1120          CMP.B   #$02,D3
0000188C  6700 004C               1121          BEQ     DataReg2
00001890                          1122          
00001890  B63C 0003               1123          CMP.B   #$03,D3
00001894  6700 0054               1124          BEQ     DataReg3
00001898                          1125          
00001898  B63C 0004               1126          CMP.B   #$04,D3
0000189C  6700 005C               1127          BEQ     DataReg4
000018A0                          1128          
000018A0  B63C 0005               1129          CMP.B   #$05,D3
000018A4  6700 0064               1130          BEQ     DataReg5
000018A8                          1131          
000018A8  B63C 0006               1132          CMP.B   #$06,D3
000018AC  6700 006C               1133          BEQ     DataReg6
000018B0                          1134          
000018B0  B63C 0007               1135          CMP.B   #$07,D3
000018B4  6700 0074               1136          BEQ     DataReg7        
000018B8                          1137  
000018B8                          1138  *Used to get back to 'DataRegMode', after dealing with the specific register
000018B8                          1139  WrapperDataRegEnd
000018B8  4E75                    1140          RTS
000018BA                          1141  
000018BA                          1142  DataReg0
000018BA                          1143          *Output the specific data register...
000018BA  43F9 000021B8           1144          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
000018C0  103C 000E               1145          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000018C4  4E4F                    1146          TRAP    #15             *Displays Message   
000018C6                          1147          
000018C6  4EF8 18B8               1148          JMP     WrapperDataRegEnd
000018CA                          1149  
000018CA                          1150  DataReg1
000018CA  43F9 000021BB           1151          LEA     OutDataReg1,A1
000018D0  103C 000E               1152          MOVE.B  #14,D0
000018D4  4E4F                    1153          TRAP    #15
000018D6                          1154          
000018D6  4EF8 18B8               1155          JMP     WrapperDataRegEnd
000018DA                          1156  
000018DA                          1157  DataReg2
000018DA  43F9 000021BE           1158          LEA     OutDataReg2,A1
000018E0  103C 000E               1159          MOVE.B  #14,D0
000018E4  4E4F                    1160          TRAP    #15
000018E6                          1161  
000018E6  4EF8 18B8               1162          JMP     WrapperDataRegEnd
000018EA                          1163      
000018EA                          1164  DataReg3
000018EA  43F9 000021C1           1165          LEA     OutDataReg3,A1
000018F0  103C 000E               1166          MOVE.B  #14,D0
000018F4  4E4F                    1167          TRAP    #15
000018F6                          1168  
000018F6  4EF8 18B8               1169          JMP     WrapperDataRegEnd
000018FA                          1170          
000018FA                          1171  DataReg4
000018FA  43F9 000021C4           1172          LEA     OutDataReg4,A1
00001900  103C 000E               1173          MOVE.B  #14,D0
00001904  4E4F                    1174          TRAP    #15
00001906                          1175  
00001906  4EF8 18B8               1176          JMP     WrapperDataRegEnd
0000190A                          1177                 
0000190A                          1178  DataReg5
0000190A  43F9 000021C7           1179          LEA     OutDataReg5,A1
00001910  103C 000E               1180          MOVE.B  #14,D0
00001914  4E4F                    1181          TRAP    #15
00001916                          1182  
00001916  4EF8 18B8               1183          JMP     WrapperDataRegEnd
0000191A                          1184          
0000191A                          1185  DataReg6
0000191A  43F9 000021CA           1186          LEA     OutDataReg6,A1 A1
00001920  103C 000E               1187          MOVE.B  #14,D0
00001924  4E4F                    1188          TRAP    #15
00001926                          1189  
00001926  4EF8 18B8               1190          JMP     WrapperDataRegEnd
0000192A                          1191          
0000192A                          1192  DataReg7
0000192A  43F9 000021CD           1193          LEA     OutDataReg7,A1
00001930  103C 000E               1194          MOVE.B  #14,D0
00001934  4E4F                    1195          TRAP    #15
00001936                          1196          
00001936  4EF8 18B8               1197          JMP     WrapperDataRegEnd
0000193A                          1198  
0000193A                          1199  
0000193A                          1200  *-----------------------------------------------------------        
0000193A                          1201  * Output logic for all Address Indirect Registers (0-7)
0000193A                          1202  *-----------------------------------------------------------     
0000193A                          1203  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
0000193A                          1204  WrapperAddrIndirect
0000193A                          1205          *Depending on the EA Register, output a different register number
0000193A  B63C 0000               1206          CMP.B   #$00,D3
0000193E  6700 003C               1207          BEQ     AddrIndReg0
00001942                          1208          
00001942  B63C 0001               1209          CMP.B   #$01,D3
00001946  6700 0044               1210          BEQ     AddrIndReg1
0000194A                          1211          
0000194A  B63C 0002               1212          CMP.B   #$02,D3
0000194E  6700 004C               1213          BEQ     AddrIndReg2
00001952                          1214          
00001952  B63C 0003               1215          CMP.B   #$03,D3
00001956  6700 0054               1216          BEQ     AddrIndReg3
0000195A                          1217          
0000195A  B63C 0004               1218          CMP.B   #$04,D3
0000195E  6700 005C               1219          BEQ     AddrIndReg4
00001962                          1220          
00001962  B63C 0005               1221          CMP.B   #$05,D3
00001966  6700 0064               1222          BEQ     AddrIndReg5
0000196A                          1223          
0000196A  B63C 0006               1224          CMP.B   #$06,D3
0000196E  6700 006C               1225          BEQ     AddrIndReg6
00001972                          1226          
00001972  B63C 0007               1227          CMP.B   #$07,D3
00001976  6700 0074               1228          BEQ     AddrIndReg7
0000197A                          1229  
0000197A                          1230  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
0000197A                          1231  WrapperAddrIndirectEnd
0000197A  4E75                    1232          RTS        
0000197C                          1233  
0000197C                          1234  AddrIndReg0
0000197C                          1235          *Output the specific address indirect register...
0000197C  43F9 000021D0           1236          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001982  103C 000E               1237          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001986  4E4F                    1238          TRAP    #15                 *Displays Message        
00001988                          1239          
00001988  4EF8 197A               1240          JMP     WrapperAddrIndirectEnd
0000198C                          1241  
0000198C                          1242  AddrIndReg1
0000198C  43F9 000021D5           1243          LEA     OutAddrIndReg1,A1
00001992  103C 000E               1244          MOVE.B  #14,D0
00001996  4E4F                    1245          TRAP    #15
00001998                          1246          
00001998  4EF8 197A               1247          JMP     WrapperAddrIndirectEnd
0000199C                          1248  
0000199C                          1249  AddrIndReg2
0000199C  43F9 000021DA           1250          LEA     OutAddrIndReg2,A1
000019A2  103C 000E               1251          MOVE.B  #14,D0
000019A6  4E4F                    1252          TRAP    #15
000019A8                          1253          
000019A8  4EF8 197A               1254          JMP     WrapperAddrIndirectEnd
000019AC                          1255  
000019AC                          1256  AddrIndReg3
000019AC  43F9 000021DF           1257          LEA     OutAddrIndReg3,A1
000019B2  103C 000E               1258          MOVE.B  #14,D0
000019B6  4E4F                    1259          TRAP    #15
000019B8                          1260          
000019B8  4EF8 197A               1261          JMP     WrapperAddrIndirectEnd
000019BC                          1262  
000019BC                          1263  AddrIndReg4
000019BC  43F9 000021E4           1264          LEA     OutAddrIndReg4,A1
000019C2  103C 000E               1265          MOVE.B  #14,D0
000019C6  4E4F                    1266          TRAP    #15
000019C8                          1267          
000019C8  4EF8 197A               1268          JMP     WrapperAddrIndirectEnd
000019CC                          1269  
000019CC                          1270  AddrIndReg5
000019CC  43F9 000021E9           1271          LEA     OutAddrIndReg5,A1
000019D2  103C 000E               1272          MOVE.B  #14,D0
000019D6  4E4F                    1273          TRAP    #15
000019D8                          1274          
000019D8  4EF8 197A               1275          JMP     WrapperAddrIndirectEnd
000019DC                          1276  
000019DC                          1277  AddrIndReg6
000019DC  43F9 000021EE           1278          LEA     OutAddrIndReg6,A1
000019E2  103C 000E               1279          MOVE.B  #14,D0
000019E6  4E4F                    1280          TRAP    #15
000019E8                          1281          
000019E8  4EF8 197A               1282          JMP     WrapperAddrIndirectEnd
000019EC                          1283  
000019EC                          1284  AddrIndReg7
000019EC  43F9 000021F3           1285          LEA     OutAddrIndReg7,A1
000019F2  103C 000E               1286          MOVE.B  #14,D0
000019F6  4E4F                    1287          TRAP    #15
000019F8                          1288          
000019F8  4EF8 197A               1289          JMP     WrapperAddrIndirectEnd
000019FC                          1290          
000019FC                          1291          
000019FC                          1292  *-----------------------------------------------------------        
000019FC                          1293  * Output logic for all Address Indirect Post Increment Registers (0-7)
000019FC                          1294  *-----------------------------------------------------------     
000019FC                          1295  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000019FC                          1296  WrapperAddrIndirectPost
000019FC                          1297          *Depending on the EA Register, output a different register number
000019FC  B63C 0000               1298          CMP.B   #$00,D3
00001A00  6700 003C               1299          BEQ     AddrIndPoReg0
00001A04                          1300          
00001A04  B63C 0001               1301          CMP.B   #$01,D3
00001A08  6700 0044               1302          BEQ     AddrIndPoReg1
00001A0C                          1303          
00001A0C  B63C 0002               1304          CMP.B   #$02,D3
00001A10  6700 004C               1305          BEQ     AddrIndPoReg2
00001A14                          1306          
00001A14  B63C 0003               1307          CMP.B   #$03,D3
00001A18  6700 0054               1308          BEQ     AddrIndPoReg3
00001A1C                          1309          
00001A1C  B63C 0004               1310          CMP.B   #$04,D3
00001A20  6700 005C               1311          BEQ     AddrIndPoReg4
00001A24                          1312          
00001A24  B63C 0005               1313          CMP.B   #$05,D3
00001A28  6700 0064               1314          BEQ     AddrIndPoReg5
00001A2C                          1315          
00001A2C  B63C 0006               1316          CMP.B   #$06,D3
00001A30  6700 006C               1317          BEQ     AddrIndPoReg6
00001A34                          1318          
00001A34  B63C 0007               1319          CMP.B   #$07,D3
00001A38  6700 0074               1320          BEQ     AddrIndPoReg7
00001A3C                          1321  
00001A3C                          1322  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
00001A3C                          1323  WrapperAddrIndirectPostEnd
00001A3C  4E75                    1324          RTS        
00001A3E                          1325  
00001A3E                          1326  AddrIndPoReg0
00001A3E                          1327          *Output the specific address indirect post register...
00001A3E  43F9 000021F8           1328          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001A44  103C 000E               1329          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001A48  4E4F                    1330          TRAP    #15                 *Displays Message        
00001A4A                          1331          
00001A4A  4EF8 1A3C               1332          JMP     WrapperAddrIndirectPostEnd
00001A4E                          1333  
00001A4E                          1334  AddrIndPoReg1
00001A4E  43F9 000021FE           1335          LEA     OutAddrIndPoReg1,A1
00001A54  103C 000E               1336          MOVE.B  #14,D0
00001A58  4E4F                    1337          TRAP    #15
00001A5A                          1338          
00001A5A  4EF8 1A3C               1339          JMP     WrapperAddrIndirectPostEnd
00001A5E                          1340  
00001A5E                          1341  AddrIndPoReg2
00001A5E  43F9 00002204           1342          LEA     OutAddrIndPoReg2,A1
00001A64  103C 000E               1343          MOVE.B  #14,D0
00001A68  4E4F                    1344          TRAP    #15
00001A6A                          1345          
00001A6A  4EF8 1A3C               1346          JMP     WrapperAddrIndirectPostEnd
00001A6E                          1347  
00001A6E                          1348  AddrIndPoReg3
00001A6E  43F9 0000220A           1349          LEA     OutAddrIndPoReg3,A1
00001A74  103C 000E               1350          MOVE.B  #14,D0
00001A78  4E4F                    1351          TRAP    #15
00001A7A                          1352          
00001A7A  4EF8 1A3C               1353          JMP     WrapperAddrIndirectPostEnd
00001A7E                          1354  
00001A7E                          1355  AddrIndPoReg4
00001A7E  43F9 00002210           1356          LEA     OutAddrIndPoReg4,A1
00001A84  103C 000E               1357          MOVE.B  #14,D0
00001A88  4E4F                    1358          TRAP    #15
00001A8A                          1359          
00001A8A  4EF8 1A3C               1360          JMP     WrapperAddrIndirectPostEnd
00001A8E                          1361  
00001A8E                          1362  AddrIndPoReg5
00001A8E  43F9 00002216           1363          LEA     OutAddrIndPoReg5,A1
00001A94  103C 000E               1364          MOVE.B  #14,D0
00001A98  4E4F                    1365          TRAP    #15
00001A9A                          1366          
00001A9A  4EF8 1A3C               1367          JMP     WrapperAddrIndirectPostEnd
00001A9E                          1368  
00001A9E                          1369  AddrIndPoReg6
00001A9E  43F9 0000221C           1370          LEA     OutAddrIndPoReg6,A1
00001AA4  103C 000E               1371          MOVE.B  #14,D0
00001AA8  4E4F                    1372          TRAP    #15
00001AAA                          1373          
00001AAA  4EF8 1A3C               1374          JMP     WrapperAddrIndirectPostEnd
00001AAE                          1375  
00001AAE                          1376  AddrIndPoReg7
00001AAE  43F9 00002222           1377          LEA     OutAddrIndPoReg7,A1
00001AB4  103C 000E               1378          MOVE.B  #14,D0
00001AB8  4E4F                    1379          TRAP    #15
00001ABA                          1380          
00001ABA  4EF8 1A3C               1381          JMP     WrapperAddrIndirectPostEnd
00001ABE                          1382  
00001ABE                          1383  
00001ABE                          1384  *-----------------------------------------------------------        
00001ABE                          1385  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001ABE                          1386  *-----------------------------------------------------------     
00001ABE                          1387  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001ABE                          1388  WrapperAddrIndirectPre
00001ABE                          1389          *Depending on the EA Register, output a different register number
00001ABE  B63C 0000               1390          CMP.B   #$00,D3
00001AC2  6700 003C               1391          BEQ     AddrIndPrReg0
00001AC6                          1392          
00001AC6  B63C 0001               1393          CMP.B   #$01,D3
00001ACA  6700 0044               1394          BEQ     AddrIndPrReg1
00001ACE                          1395          
00001ACE  B63C 0002               1396          CMP.B   #$02,D3
00001AD2  6700 004C               1397          BEQ     AddrIndPrReg2
00001AD6                          1398          
00001AD6  B63C 0003               1399          CMP.B   #$03,D3
00001ADA  6700 0054               1400          BEQ     AddrIndPrReg3
00001ADE                          1401          
00001ADE  B63C 0004               1402          CMP.B   #$04,D3
00001AE2  6700 005C               1403          BEQ     AddrIndPrReg4
00001AE6                          1404          
00001AE6  B63C 0005               1405          CMP.B   #$05,D3
00001AEA  6700 0064               1406          BEQ     AddrIndPrReg5
00001AEE                          1407          
00001AEE  B63C 0006               1408          CMP.B   #$06,D3
00001AF2  6700 006C               1409          BEQ     AddrIndPrReg6
00001AF6                          1410          
00001AF6  B63C 0007               1411          CMP.B   #$07,D3
00001AFA  6700 0074               1412          BEQ     AddrIndPrReg7
00001AFE                          1413  
00001AFE                          1414  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001AFE                          1415  WrapperAddrIndirectPreEnd
00001AFE  4E75                    1416          RTS        
00001B00                          1417  
00001B00                          1418  AddrIndPrReg0
00001B00                          1419          *Output the specific address indirect post register...
00001B00  43F9 00002228           1420          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001B06  103C 000E               1421          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001B0A  4E4F                    1422          TRAP    #15                 *Displays Message        
00001B0C                          1423          
00001B0C  4EF8 1AFE               1424          JMP     WrapperAddrIndirectPreEnd
00001B10                          1425  
00001B10                          1426  AddrIndPrReg1
00001B10  43F9 0000222E           1427          LEA     OutAddrIndPrReg1,A1
00001B16  103C 000E               1428          MOVE.B  #14,D0
00001B1A  4E4F                    1429          TRAP    #15
00001B1C                          1430          
00001B1C  4EF8 1AFE               1431          JMP     WrapperAddrIndirectPreEnd
00001B20                          1432  
00001B20                          1433  AddrIndPrReg2
00001B20  43F9 00002234           1434          LEA     OutAddrIndPrReg2,A1
00001B26  103C 000E               1435          MOVE.B  #14,D0
00001B2A  4E4F                    1436          TRAP    #15
00001B2C                          1437          
00001B2C  4EF8 1AFE               1438          JMP     WrapperAddrIndirectPreEnd
00001B30                          1439  
00001B30                          1440  AddrIndPrReg3
00001B30  43F9 0000223A           1441          LEA     OutAddrIndPrReg3,A1
00001B36  103C 000E               1442          MOVE.B  #14,D0
00001B3A  4E4F                    1443          TRAP    #15
00001B3C                          1444          
00001B3C  4EF8 1AFE               1445          JMP     WrapperAddrIndirectPreEnd
00001B40                          1446  
00001B40                          1447  AddrIndPrReg4
00001B40  43F9 00002240           1448          LEA     OutAddrIndPrReg4,A1
00001B46  103C 000E               1449          MOVE.B  #14,D0
00001B4A  4E4F                    1450          TRAP    #15
00001B4C                          1451          
00001B4C  4EF8 1AFE               1452          JMP     WrapperAddrIndirectPreEnd
00001B50                          1453  
00001B50                          1454  AddrIndPrReg5
00001B50  43F9 00002246           1455          LEA     OutAddrIndPrReg5,A1
00001B56  103C 000E               1456          MOVE.B  #14,D0
00001B5A  4E4F                    1457          TRAP    #15
00001B5C                          1458          
00001B5C  4EF8 1AFE               1459          JMP     WrapperAddrIndirectPreEnd
00001B60                          1460  
00001B60                          1461  AddrIndPrReg6
00001B60  43F9 0000224C           1462          LEA     OutAddrIndPrReg6,A1
00001B66  103C 000E               1463          MOVE.B  #14,D0
00001B6A  4E4F                    1464          TRAP    #15
00001B6C                          1465          
00001B6C  4EF8 1AFE               1466          JMP     WrapperAddrIndirectPreEnd
00001B70                          1467  
00001B70                          1468  AddrIndPrReg7
00001B70  43F9 00002252           1469          LEA     OutAddrIndPrReg7,A1
00001B76  103C 000E               1470          MOVE.B  #14,D0
00001B7A  4E4F                    1471          TRAP    #15
00001B7C                          1472          
00001B7C  4EF8 1AFE               1473          JMP     WrapperAddrIndirectPreEnd
00001B80                          1474  
00001B80                          1475  
00001B80                          1476  *-----------------------------------------------------------        
00001B80                          1477  * Output logic for absolute memory addressing (0-7)
00001B80                          1478  *-----------------------------------------------------------     
00001B80                          1479  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001B80                          1480  WrapperAddrAbsolute
00001B80  4284                    1481          CLR.L   D4
00001B82                          1482          *Depending on the EA Register, choose which size to decode
00001B82  B63C 0000               1483          CMP.B   #$00,D3
00001B86  6700 000C               1484          BEQ     WordSizeAbsolute
00001B8A                          1485  
00001B8A  B63C 0001               1486          CMP.B   #$01,D3
00001B8E  6700 0020               1487          BEQ     LongSizeAbsolute
00001B92                          1488          
00001B92                          1489  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001B92                          1490  WrapperAddrAbsoluteEnd
00001B92  4E75                    1491          RTS
00001B94                          1492  
00001B94                          1493  WordSizeAbsolute        
00001B94  3818                    1494          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001B96                          1495          
00001B96                          1496          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001B96  4281                    1497          CLR.L   D1
00001B98  123C 0001               1498          MOVE.B  #$01,D1     
00001B9C                          1499              
00001B9C                          1500          *Output ',$' just after source operand
00001B9C  43F9 00002265           1501          LEA     Bang,A1
00001BA2  103C 000E               1502          MOVE.B  #14,D0
00001BA6  4E4F                    1503          TRAP    #15
00001BA8                          1504              
00001BA8                          1505          *output the absolute mem address to console with the hex-ascii converter
00001BA8  4EB8 11E6               1506          JSR     HEXASCII        
00001BAC                          1507          
00001BAC  4EF8 1B92               1508          JMP     WrapperAddrAbsoluteEnd
00001BB0                          1509  
00001BB0                          1510  LongSizeAbsolute
00001BB0  2818                    1511          MOVE.L  (A0)+,D4    *read in next long, data is that long
00001BB2                          1512                  
00001BB2                          1513          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001BB2  4281                    1514          CLR.L   D1
00001BB4  123C 0010               1515          MOVE.B  #$10,D1
00001BB8                          1516                  
00001BB8                          1517          *Output ',$' just after source operand
00001BB8  43F9 00002265           1518          LEA     Bang,A1
00001BBE  103C 000E               1519          MOVE.B  #14,D0
00001BC2  4E4F                    1520          TRAP    #15  
00001BC4                          1521          
00001BC4                          1522          *output the absolute mem address to console with the hex-ascii converter
00001BC4  4EB8 11E6               1523          JSR     HEXASCII
00001BC8                          1524          
00001BC8  4EF8 1B92               1525          JMP     WrapperAddrAbsoluteEnd
00001BCC                          1526          
00001BCC                          1527  
00001BCC                          1528  *-----------------------------------------------------------        
00001BCC                          1529  * Current handling of bad op/ea codes. Should be revisited.
00001BCC                          1530  *----------------------------------------------------------- 
00001BCC                          1531  BADOPCODE
00001BCC                          1532          *We found a bad op code, output some error to the screen, jump to the 
00001BCC                          1533          *next instruction in memory.
00001BCC                          1534          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001BCC                          1535          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001BCC                          1536          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001BCC                          1537          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001BCC                          1538          *i/o and error message code...
00001BCC  43F9 0000226E           1539          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001BD2  103C 000E               1540          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001BD6  4E4F                    1541          TRAP    #15         *Displays Message
00001BD8  4EF8 136C               1542          JMP     GRAB_NEXT_OP
00001BDC                          1543                  
00001BDC                          1544  BADEACODE
00001BDC                          1545          *We found a bad ea code, output some error to the screen, jump to the
00001BDC                          1546          *next instruction in memory.
00001BDC                          1547          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001BDC                          1548          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001BDC  43F9 00002267           1549          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001BE2  103C 000E               1550          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001BE6  4E4F                    1551          TRAP    #15         *Displays Message
00001BE8  4EF8 136C               1552          JMP     GRAB_NEXT_OP
00001BEC                          1553          
00001BEC                          1554          
00001BEC                          1555  *-----------------------------------------------------------        
00001BEC                          1556  * End of Disassembler
00001BEC                          1557  *-----------------------------------------------------------    
00001BEC                          1558  
00001BEC  4E72 2700               1559  DONE    STOP    #$2700  *What does this do? Why was it added?
00001BF0                          1560  
00001BF0  103C 0009               1561  THEEND  MOVE.B  #9,D0
00001BF4  4E4F                    1562          TRAP    #15             Halt Simulator        
00001BF6                          1563          
00001BF6                          1564       
00001BF6                          1565  *-----------------------------------------------------------        
00001BF6                          1566  * Output stuff
00001BF6                          1567  *-----------------------------------------------------------     
00001BF6  =0000000D               1568  CR      EQU     $0D             ASCII code for Carriage Return
00001BF6  =0000000A               1569  LF      EQU     $0A             ASCII code for Line Feed
00001BF6= 2D 2D 2D 2D 2D 2D ...   1570  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001C35= 7C 7C 20 20 20 20 ...   1571              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001C74= 2D 2D 2D 2D 2D 2D ...   1572              DC.B    '-------------------------------------------------------------',CR,LF
00001CB3= 2A 2A 2A 2A 2A 2A ...   1573              DC.B    '*************************************************************',CR,LF
00001CF2= 2A 2A 2A 2A 2A 2A ...   1574              DC.B    '*************************************************************',CR,LF
00001D31= 2A 2A 2A 2A 2A 2A ...   1575              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001D70= 2A 2A 2A 2A 2A 2A ...   1576              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001DAF= 2A 2A 2A 2A 2A 2A ...   1577              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001DEE= 2A 2A 2A 2A 2A 2A ...   1578              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001E2D= 2A 2A 2A 2A 2A 2A ...   1579              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001E6C= 2A 2A 2A 2A 2A 2A ...   1580              DC.B    '*************************************************************',CR,LF
00001EAB= 2A 2A 2A 2A 2A 2A ...   1581              DC.B    '*************************************************************',CR,LF
00001EEA= 2A 20 20 20 20 20 ...   1582              DC.B    '*                                                           *',CR,LF
00001F29= 2A 20 41 75 74 68 ...   1583              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001F68= 2A 20 20 20 20 20 ...   1584              DC.B    '*                                                           *',CR,LF
00001FA7= 2A 2A 2A 2A 2A 2A ...   1585              DC.B    '*************************************************************',CR,LF,CR,LF
00001FE8= 53 74 61 72 74 69 ...   1586              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00002005                          1587              
00002005= 57 6F 75 6C 64 20 ...   1588  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00002036                          1589  
00002036= 20 0D 0A                1590  GETSTRTADDR DC.B    ' ',CR,LF
00002039= 50 6C 65 61 73 65 ...   1591              DC.B    'Please type in your starting address request: ',0
00002068                          1592              
00002068= 20 0D 0A                1593  GETENDADDR  DC.B    ' ',CR,LF
0000206B= 50 6C 65 61 73 65 ...   1594              DC.B    'Please type in your ending address request: ',0
00002098                          1595              
00002098= 20 0D 0A                1596  QUES_CONT   DC.B    ' ',CR,LF
0000209B= 57 6F 75 6C 64 20 ...   1597              DC.B    'Would you like to continue (Y/N)? ',0
000020BE                          1598              
000020BE= 20 0D 0A                1599  QUIT_MSG    DC.B    ' ',CR,LF
000020C1= 57 6F 75 6C 64 20 ...   1600              DC.B    'Would you like to quit (Y/N)? ',0
000020E0                          1601  
000020E0                          1602  *****************************************************
000020E0                          1603  * I/O storages - assuming users knows what to do.
000020E0                          1604  *****************************************************
000020E0                          1605  CMD_HLD     DS.B    30
000020FE                          1606  CMD_SZ      DS.B    30
0000211C                          1607  STADDR      DS.B    10
00002126                          1608  STADDRSZ    DS.B    10
00002130                          1609  PROGST      DS.L    1
00002134                          1610  ENDADDR     DS.B    10
0000213E                          1611  ENDADDRSZ   DS.B    10
00002148                          1612  PROGEND     DS.L    1
0000214C                          1613  CONT        DS.B    30
0000216A                          1614  *****************************************************
0000216A                          1615  
0000216A                          1616  *Table for 0-9 && A-F
0000216A= 30 00                   1617  PRNT0   DC.B    '0',0
0000216C= 31 00                   1618  PRNT1   DC.B    '1',0
0000216E= 32 00                   1619  PRNT2   DC.B    '2',0
00002170= 33 00                   1620  PRNT3   DC.B    '3',0
00002172= 34 00                   1621  PRNT4   DC.B    '4',0
00002174= 35 00                   1622  PRNT5   DC.B    '5',0
00002176= 36 00                   1623  PRNT6   DC.B    '6',0
00002178= 37 00                   1624  PRNT7   DC.B    '7',0
0000217A= 38 00                   1625  PRNT8   DC.B    '8',0
0000217C= 39 00                   1626  PRNT9   DC.B    '9',0
0000217E= 41 00                   1627  PRNTA   DC.B    'A',0
00002180= 42 00                   1628  PRNTB   DC.B    'B',0
00002182= 43 00                   1629  PRNTC   DC.B    'C',0
00002184= 44 00                   1630  PRNTD   DC.B    'D',0
00002186= 45 00                   1631  PRNTE   DC.B    'E',0
00002188= 46 00                   1632  PRNTF   DC.B    'F',0
0000218A                          1633  
0000218A                          1634  *output for all OPCODEs
0000218A= 41 44 44 49 00          1635  ADDI    DC.B    'ADDI',0
0000218F= 41 4E 44 49 00          1636  ANDI    DC.B    'ANDI',0
00002194= 45 4F 52 49 00          1637  EORI    DC.B    'EORI',0
00002199= 42 43 48 47 00          1638  BCHG    DC.B    'BCHG',0
0000219E= 43 4D 50 49 00          1639  CMPI    DC.B    'CMPI',0
000021A3                          1640  
000021A3                          1641  *output for the size of the operation
000021A3= 2E 42 20 20 20 20 00    1642  ByteSize    DC.B    '.B    ',0
000021AA= 2E 57 20 20 20 20 00    1643  WordSize    DC.B    '.W    ',0
000021B1= 2E 4C 20 20 20 20 00    1644  LongSize    DC.B    '.L    ',0
000021B8                          1645  
000021B8                          1646  *output for all destination data registers (0-7)
000021B8= 44 30 00                1647  OutDataReg0 DC.B    'D0',0
000021BB= 44 31 00                1648  OutDataReg1 DC.B    'D1',0
000021BE= 44 32 00                1649  OutDataReg2 DC.B    'D2',0
000021C1= 44 33 00                1650  OutDataReg3 DC.B    'D3',0
000021C4= 44 34 00                1651  OutDataReg4 DC.B    'D4',0
000021C7= 44 35 00                1652  OutDataReg5 DC.B    'D5',0
000021CA= 44 36 00                1653  OutDataReg6 DC.B    'D6',0
000021CD= 44 37 00                1654  OutDataReg7 DC.B    'D7',0
000021D0                          1655          
000021D0                          1656  *output for all address indirect registers (0-7)
000021D0= 28 41 30 29 00          1657  OutAddrIndReg0  DC.B    '(A0)',0
000021D5= 28 41 31 29 00          1658  OutAddrIndReg1  DC.B    '(A1)',0
000021DA= 28 41 32 29 00          1659  OutAddrIndReg2  DC.B    '(A2)',0
000021DF= 28 41 33 29 00          1660  OutAddrIndReg3  DC.B    '(A3)',0
000021E4= 28 41 34 29 00          1661  OutAddrIndReg4  DC.B    '(A4)',0
000021E9= 28 41 35 29 00          1662  OutAddrIndReg5  DC.B    '(A5)',0
000021EE= 28 41 36 29 00          1663  OutAddrIndReg6  DC.B    '(A6)',0
000021F3= 28 41 37 29 00          1664  OutAddrIndReg7  DC.B    '(A7)',0
000021F8                          1665  
000021F8                          1666  *output for all address indirect post registers (0-7)
000021F8= 28 41 30 29 2B 00       1667  OutAddrIndPoReg0    DC.B    '(A0)+',0
000021FE= 28 41 31 29 2B 00       1668  OutAddrIndPoReg1    DC.B    '(A1)+',0
00002204= 28 41 32 29 2B 00       1669  OutAddrIndPoReg2    DC.B    '(A2)+',0
0000220A= 28 41 33 29 2B 00       1670  OutAddrIndPoReg3    DC.B    '(A3)+',0
00002210= 28 41 34 29 2B 00       1671  OutAddrIndPoReg4    DC.B    '(A4)+',0
00002216= 28 41 35 29 2B 00       1672  OutAddrIndPoReg5    DC.B    '(A5)+',0
0000221C= 28 41 36 29 2B 00       1673  OutAddrIndPoReg6    DC.B    '(A6)+',0
00002222= 28 41 37 29 2B 00       1674  OutAddrIndPoReg7    DC.B    '(A7)+',0
00002228                          1675  
00002228                          1676  *output for all address indirect pre registers (0-7)
00002228= 2D 28 41 30 29 00       1677  OutAddrIndPrReg0    DC.B    '-(A0)',0
0000222E= 2D 28 41 31 29 00       1678  OutAddrIndPrReg1    DC.B    '-(A1)',0
00002234= 2D 28 41 32 29 00       1679  OutAddrIndPrReg2    DC.B    '-(A2)',0
0000223A= 2D 28 41 33 29 00       1680  OutAddrIndPrReg3    DC.B    '-(A3)',0
00002240= 2D 28 41 34 29 00       1681  OutAddrIndPrReg4    DC.B    '-(A4)',0
00002246= 2D 28 41 35 29 00       1682  OutAddrIndPrReg5    DC.B    '-(A5)',0
0000224C= 2D 28 41 36 29 00       1683  OutAddrIndPrReg6    DC.B    '-(A6)',0
00002252= 2D 28 41 37 29 00       1684  OutAddrIndPrReg7    DC.B    '-(A7)',0
00002258                          1685  
00002258                          1686  *output for a tab only (4 spaces)
00002258= 20 20 20 20 00          1687  Tab DC.B    '    ',0
0000225D                          1688  
0000225D                          1689  *output for a comma only
0000225D= 2C 00                   1690  Comma   DC.B    ',',0
0000225F                          1691  
0000225F                          1692  *output for a new line only
0000225F= 0D 0A 00                1693  NewLine DC.B    CR,LF,0
00002262                          1694  
00002262                          1695  *output for a '#$' and '$' only
00002262= 23 24 00                1696  ShaBang DC.B    '#$',0
00002265= 24 00                   1697  Bang    DC.B    '$',0
00002267                          1698  
00002267                          1699  *current output for error messages
00002267= 42 41 44 20 45 41 00    1700  BADEAMSG    DC.B    'BAD EA',0
0000226E= 42 41 44 20 4F 50 00    1701  BADOPMSG    DC.B    'BAD OP',0
00002275= 49 6D 70 72 6F 70 ...   1702  INV_MSG     DC.B    'Improper command.',CR,LF,0
00002289= 49 6E 76 61 6C 69 ...   1703  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
000022A2= 49 6E 76 61 6C 69 ...   1704  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
000022B9                          1705  
000022B9                          1706          
000022B9                          1707          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                218A
ADDRABSOLUTEMODE    1868
ADDRDIRECTMODE      1838
ADDRINDIRECTMODE    1838
ADDRINDIRECTPOSTMODE  1848
ADDRINDIRECTPREMODE  1858
ADDRINDPOREG0       1A3E
ADDRINDPOREG1       1A4E
ADDRINDPOREG2       1A5E
ADDRINDPOREG3       1A6E
ADDRINDPOREG4       1A7E
ADDRINDPOREG5       1A8E
ADDRINDPOREG6       1A9E
ADDRINDPOREG7       1AAE
ADDRINDPRREG0       1B00
ADDRINDPRREG1       1B10
ADDRINDPRREG2       1B20
ADDRINDPRREG3       1B30
ADDRINDPRREG4       1B40
ADDRINDPRREG5       1B50
ADDRINDPRREG6       1B60
ADDRINDPRREG7       1B70
ADDRINDREG0         197C
ADDRINDREG1         198C
ADDRINDREG2         199C
ADDRINDREG3         19AC
ADDRINDREG4         19BC
ADDRINDREG5         19CC
ADDRINDREG6         19DC
ADDRINDREG7         19EC
ANDI                218F
ASCIIHEX            1174
ASCIIHEX1           1178
BADEACODE           1BDC
BADEAMSG            2267
BADOPCODE           1BCC
BADOPMSG            226E
BANG                2265
BCHG                2199
BCHGBYTESIZE        1804
BCHGIMMEDIATE       1814
BCHGLONGSIZE        17F4
BCHGSIZEHELPER      17E4
BCHGSIZEHELPEREND   17F2
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         140E
BUCKET_0001         175C
BUCKET_0010         175C
BUCKET_0011         175C
BUCKET_0100         175C
BUCKET_0101         175C
BUCKET_0110         175C
BUCKET_1000         175C
BUCKET_1001         175C
BUCKET_1011         175C
BUCKET_1100         175C
BUCKET_1101         175C
BUCKET_1110         175C
BYTESIZE            21A3
BYTESIZEIMMEDIATE   177E
CHECK               11EA
CHECKEND1           10FA
CHECKSTRT1          10E4
CHECK_LOWN          112C
CHECK_LOWY          111A
CHECK_N             13E8
CHECK_UPN           1124
CHECK_UPY           1110
CHECK_Y             13DA
CHNG_SZB            121C
CHNG_SZL            1202
CHNG_SZW            1236
CMD_HLD             20E0
CMD_SZ              20FE
CMPI                219E
COMMA               225D
CONT                214C
CONT_Q              13A8
CONV_LOL            11D4
CONV_LOOP           1250
CONV_NUM            11C0
CONV_UPL            11CA
CR                  D
DATAREG0            18BA
DATAREG1            18CA
DATAREG2            18DA
DATAREG3            18EA
DATAREG4            18FA
DATAREG5            190A
DATAREG6            191A
DATAREG7            192A
DATAREGMODE         1828
DONE                1BEC
EA_ADDI             149A
EA_ANDI             1510
EA_BCHG_D           1608
EA_BCHG_S           16A0
EA_CMPI             171C
EA_EORI             1586
ENDADDR             2134
ENDADDRSZ           213E
EORI                2194
EXITSUB             11E0
EXIT_CONV           12D6
GETENDADDR          2068
GETSTRTADDR         2036
GET_END             108C
GET_STRT            103E
GRAB_NEXT_OP        136C
HEXASCII            11E6
HEXASCIIREG         11FE
IMMEDIATEDATAMODE   1878
INV2                13F8
INVALID1            1134
INVENDMSG           22A2
INVSTRTMSG          2289
INV_END1            1160
INV_MSG             2275
INV_STRT1           114C
IS_ADDI             1464
IS_ANDI             14DA
IS_BCHG_D           15C6
IS_BCHG_S           1664
IS_CMPI             16E6
IS_EORI             1550
LF                  A
LONGSIZE            21B1
LONGSIZEABSOLUTE    1BB0
LONGSIZEIMMEDIATE   17C2
LOOP_1              1014
LOOP_B              1220
LOOP_L              1206
LOOP_W              123A
MAX_LINE            F
MESSAGE             1BF6
NEWLINE             225F
NUM_0               12E4
NUM_1               12EC
NUM_2               12F4
NUM_3               12FC
NUM_4               1304
NUM_5               130C
NUM_6               1314
NUM_7               131C
NUM_8               1324
NUM_9               132C
NUM_A               1334
NUM_B               133C
NUM_C               1344
NUM_D               134C
NUM_E               1354
NUM_F               135C
OUTADDRINDPOREG0    21F8
OUTADDRINDPOREG1    21FE
OUTADDRINDPOREG2    2204
OUTADDRINDPOREG3    220A
OUTADDRINDPOREG4    2210
OUTADDRINDPOREG5    2216
OUTADDRINDPOREG6    221C
OUTADDRINDPOREG7    2222
OUTADDRINDPRREG0    2228
OUTADDRINDPRREG1    222E
OUTADDRINDPRREG2    2234
OUTADDRINDPRREG3    223A
OUTADDRINDPRREG4    2240
OUTADDRINDPRREG5    2246
OUTADDRINDPRREG6    224C
OUTADDRINDPRREG7    2252
OUTADDRINDREG0      21D0
OUTADDRINDREG1      21D5
OUTADDRINDREG2      21DA
OUTADDRINDREG3      21DF
OUTADDRINDREG4      21E4
OUTADDRINDREG5      21E9
OUTADDRINDREG6      21EE
OUTADDRINDREG7      21F3
OUTDATAREG0         21B8
OUTDATAREG1         21BB
OUTDATAREG2         21BE
OUTDATAREG3         21C1
OUTDATAREG4         21C4
OUTDATAREG5         21C7
OUTDATAREG6         21CA
OUTDATAREG7         21CD
PRINT_NUM           12DC
PRNT0               216A
PRNT1               216C
PRNT2               216E
PRNT3               2170
PRNT4               2172
PRNT5               2174
PRNT6               2176
PRNT7               2178
PRNT8               217A
PRNT9               217C
PRNTA               217E
PRNTB               2180
PRNTC               2182
PRNTD               2184
PRNTE               2186
PRNTF               2188
PROGEND             2148
PROGST              2130
QUES_CONT           2098
QUIT_MSG            20BE
SHABANG             2262
STACK               7000
STADDR              211C
STADDRSZ            2126
START               1000
STARTASSEM          2005
ST_ADDR             7FC6
ST_BAD              11DE
TAB                 2258
THEEND              1BF0
WORDSIZE            21AA
WORDSIZEABSOLUTE    1B94
WORDSIZEIMMEDIATE   17A0
WRAPPERADDRABSOLUTE  1B80
WRAPPERADDRABSOLUTEEND  1B92
WRAPPERADDRINDIRECT  193A
WRAPPERADDRINDIRECTEND  197A
WRAPPERADDRINDIRECTPOST  19FC
WRAPPERADDRINDIRECTPOSTEND  1A3C
WRAPPERADDRINDIRECTPRE  1ABE
WRAPPERADDRINDIRECTPREEND  1AFE
WRAPPERDATAREG      1878
WRAPPERDATAREGEND   18B8
WRAPPERSIZEIMMEDIATE  1762
WRAPPERSIZEIMMEDIATEEND  177C
