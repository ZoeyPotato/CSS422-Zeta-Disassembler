00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 7:16:45 PM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/14/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. After specifying
00000000                             7  * where the program to be disassembled is located, this program will disassemble
00000000                             8  * instructions of that program, and output the contents to console.
00000000                             9  *
00000000                            10  * For use with the EASy68K Emulator. To run, open this program in the emulator.
00000000                            11  * Hit 'F9' to execute. In the execution window, open the test input file, and press
00000000                            12  * 'F9' to run the program.
00000000                            13  *
00000000                            14  * This program will not disassemble every 68k instruction, only a subset of instructions
00000000                            15  * that we have currently implemented. See corresponding documentation for more details.
00000000                            16  *-------------------------------------------------------------
00000000  =00007FC6                 17  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 18  STACK       EQU $7000   *Stack location
00000000  =0000000F                 19  MAX_LINE    EQU 15      *Maximum number of instructions that can be displayed
00001000                            20  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 21              LEA stack,SP
00001004  3C3C 000F                 22              MOVE    #MAX_LINE,D6
00001008                            23  
00001008                            24  
00001008                            25  *-----------------------------------------------------------
00001008                            26  * Start of I/O
00001008                            27  *-----------------------------------------------------------            
00001008  43F9 00001DC0             28              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 29              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      30              TRAP    #15         *Displays Message
00001014                            31          
00001014  303C 0000                 32  loop_1      MOVE    #0,D0       
00001018  43F9 000021CF             33              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 34              MOVE.B  #14,D0
00001022  4E4F                      35              TRAP    #15    
00001024  303C 0002                 36              MOVE    #2,D0
00001028  43F9 000022AA             37              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      38              TRAP    #15
00001030  0C01 0001                 39              CMPI.B  #01,D1
00001034  6600 00FE                 40              BNE     INVALID1
00001038  4EB9 00001110             41              JSR     CHECK_UPY
0000103E                            42              
0000103E                            43              
0000103E                            44  *-----------------------------------------------------------
0000103E                            45  * I/O: Check Start Address
0000103E                            46  *
0000103E                            47  * Make sure that start address starts after allocated 
0000103E                            48  * memory addresses. Else, it will print out a message 
0000103E                            49  * saying that requested address is invalid & prompts the
0000103E                            50  * user again for the starting address.
0000103E                            51  *-----------------------------------------------------------
0000103E  43F9 00002200             52  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001044  103C 000E                 53              MOVE.B  #14,D0
00001048  4E4F                      54              TRAP    #15
0000104A  43F9 000022E6             55              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001050  3239 000022F0             56              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001056  303C 0002                 57              MOVE    #2,D0           *Get start address
0000105A  4E4F                      58              TRAP    #15
0000105C  4EB9 000010E4             59              JSR     CHECKSTRT1
00001062  4287                      60              CLR.L   D7
00001064  4EB9 00001174             61              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106A  0C03 0001                 62              CMPI.B  #01,D3      *Check if there was a bad start
0000106E  6700 00DC                 63              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001072  0C87 00007FC6             64              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001078  6D00 00D2                 65              BLT     INV_STRT1   *Asks for another start address if invalid
0000107C  0C87 00FFFFFE             66              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001082  6C00 00C8                 67              BGE     INV_STRT1
00001086  23C7 000022FA             68              MOVE.L  D7,PROGST
0000108C                            69  
0000108C  43F9 00002232             70  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001092  103C 000E                 71              MOVE.B  #14,D0
00001096  4E4F                      72              TRAP    #15
00001098  43F9 000022FE             73              LEA     ENDADDR,A1      *Buffer to hold end address
0000109E  3239 00002308             74              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A4  303C 0002                 75              MOVE    #2,D0
000010A8  4E4F                      76              TRAP    #15
000010AA  4EB9 000010FA             77              JSR     CHECKEND1
000010B0  4287                      78              CLR.L   D7
000010B2  4EB9 00001174             79              JSR     ASCIIHEX
000010B8  0C03 0001                 80              CMPI.B  #01,D3
000010BC  6700 00A2                 81              BEQ     INV_END1
000010C0  0C87 000022FA             82              CMPI.L  #PROGST,D7
000010C6  6D00 0098                 83              BLT     INV_END1
000010CA  0C87 00FFFFFF             84              CMPI.L  #$00FFFFFF,D7
000010D0  6C00 008E                 85              BGE     INV_END1
000010D4  23C7 00002312             86              MOVE.L  D7,PROGEND
000010DA  2079 000022FA             87              MOVEA.L PROGST,A0
000010E0  6000 028A                 88              BRA     GRAB_NEXT_OP            
000010E4                            89                          
000010E4  0C81 00000008             90  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EA  6E00 0060                 91              BGT     INV_STRT1
000010EE  0C81 00000000             92              CMPI.L  #00,D1
000010F4  6300 0056                 93              BLS     INV_STRT1
000010F8  4E75                      94              RTS         
000010FA                            95              
000010FA  0C81 00000008             96  CHECKEND1   CMPI.L  #08,D1
00001100  6E00 005E                 97              BGT     INV_END1
00001104  0C81 00000000             98              CMPI.L  #00,D1
0000110A  6300 0054                 99              BLS     INV_END1
0000110E  4E75                     100              RTS
00001110                           101  
00001110                           102  
00001110                           103  *-----------------------------------------------------------
00001110                           104  * I/O: Input check for Y, y, N, n
00001110                           105  *-----------------------------------------------------------
00001110  0C11 0059                106  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001114  6600 0004                107              BNE     CHECK_LOWY
00001118  4E75                     108              RTS
0000111A  0C11 0079                109  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
0000111E  6600 0004                110              BNE     CHECK_UPN
00001122  4E75                     111              RTS
00001124  0C11 004E                112  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001128  6700 0C8C                113              BEQ     DONE
0000112C                           114              
0000112C  0C11 006E                115  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001130  6700 0C84                116              BEQ     DONE
00001134                           117              
00001134  163C 0000                118  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001138  303C 0000                119              MOVE    #0,D0       *Prints invalid command msg if not found
0000113C  43F9 00002484            120              LEA     INV_MSG,A1
00001142  303C 000E                121              MOVE    #14,D0
00001146  4E4F                     122              TRAP    #15
00001148  6000 FECA                123              BRA     loop_1
0000114C                           124              
0000114C  43F9 00002498            125  INV_STRT1   LEA     INVSTRTMSG,A1
00001152  103C 000E                126              MOVE.B  #14,D0
00001156  4E4F                     127              TRAP    #15
00001158  163C 0000                128              MOVE.B  #00,D3      *Reset flag
0000115C  6000 FEE0                129              BRA     GET_STRT        
00001160                           130              
00001160  43F9 000024B1            131  INV_END1    LEA     INVENDMSG,A1
00001166  103C 000E                132              MOVE.B  #14,D0
0000116A  4E4F                     133              TRAP    #15
0000116C  163C 0000                134              MOVE.B  #00,D3      *Reset flag
00001170  6000 FF1A                135              BRA     GET_END
00001174                           136              
00001174                           137              
00001174                           138  *-----------------------------------------------------------
00001174                           139  * ASCII to Hex converter
00001174                           140  *
00001174                           141  * Checks and converts the ASCII value to the hex equivalent
00001174                           142  *-----------------------------------------------------------
00001174  48E7 6000                143  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001178  0C01 0000                144  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000117C  6700 0062                145              BEQ     exitSub     *Exit subroutine 
00001180  5301                     146              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001182  E99F                     147              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001184  1419                     148              MOVE.B  (A1)+,D2    *Takes the first char
00001186  0C02 0024                149              CMPI.B  #$24,D2     *See if the first char is $
0000118A  67EC                     150              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000118C  0C02 0030                151              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001190  6D00 004C                152              BLT     st_bad      *Put error message
00001194  0C02 0039                153              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001198  6F00 0026                154              BLE     CONV_NUM    *Convert to number, if so
0000119C  0C02 0041                155              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A0  6D00 003C                156              BLT     st_bad      *Put error message
000011A4  0C02 0046                157              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011A8  6F00 0020                158              BLE     CONV_UpL    *Convert to hex
000011AC  0C02 0061                159              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B0  6D00 002C                160              BLT     st_bad
000011B4  0C02 0066                161              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011B8  6F00 001A                162              BLE     CONV_LoL    
000011BC  6E00 0020                163              BGT     st_bad      *Puts error message for anything greater than f value
000011C0                           164              
000011C0  0402 0030                165  CONV_NUM    SUBI.B  #$30,D2
000011C4  8E02                     166              OR.B    D2,D7
000011C6  4EF8 1178                167              JMP     ASCIIHEX1
000011CA  0402 0037                168  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011CE  8E02                     169              OR.B    D2,D7
000011D0  4EF8 1178                170              JMP     ASCIIHEX1
000011D4  0402 0057                171  CONV_LoL    SUBI.B  #$57,D2
000011D8  8E02                     172              OR.B    D2,D7
000011DA  4EF8 1178                173              JMP     ASCIIHEX1   
000011DE                           174  
000011DE  5203                     175  st_bad      ADDI.B  #01,D3
000011E0  4CDF 0006                176  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E4  4E75                     177              RTS
000011E6                           178              
000011E6                           179              
000011E6                           180  *-----------------------------------------------------------
000011E6                           181  * Hex to ASCII converter
000011E6                           182  *-----------------------------------------------------------
000011E6  48E7 4C00                183  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EA  0C01 0000                184  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011EE  6700 002C                185              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F2  B27C 0001                186              CMP.W   #01,D1          
000011F6  6700 003E                187              BEQ     CHNG_SZW
000011FA  6000 0006                188              BRA     CHNG_SZL        
000011FE                           189  
000011FE  48E7 4C00                190  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001202  123C 0008                191  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
00001206  0C01 0000                192  LOOP_L      CMPI.B  #00,D1
0000120A  6700 00CA                193              BEQ     EXIT_CONV
0000120E  5301                     194              SUBI.B  #01,D1
00001210  E99C                     195              ROL.L   #4,D4           * Shift it for next bit
00001212  2A04                     196              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001214  4EB9 00001250            197              JSR     CONV_LOOP
0000121A  60EA                     198              BRA     LOOP_L      
0000121C                           199  
0000121C  123C 0002                200  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001220  0C01 0000                201  LOOP_B      CMPI.B  #00,D1
00001224  6700 00B0                202              BEQ     EXIT_CONV
00001228  5301                     203              SUBI.B  #01,D1
0000122A  E91C                     204              ROL.B   #4,D4           * Shift it for next bit
0000122C  2A04                     205              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000122E  4EB9 00001250            206              JSR     CONV_LOOP
00001234  60EA                     207              BRA     LOOP_B
00001236                           208              
00001236  123C 0004                209  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123A  0C01 0000                210  LOOP_W      CMPI.B  #00,D1
0000123E  6700 0096                211              BEQ     EXIT_CONV
00001242  5301                     212              SUBI.B  #01,D1
00001244  E95C                     213              ROL.W   #4,D4           * Shift it for next bit
00001246  2A04                     214              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001248  4EB9 00001250            215              JSR     CONV_LOOP
0000124E  60EA                     216              BRA     LOOP_W
00001250                           217  
00001250  0285 0000000F            218  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001256  0C05 0000                219              CMPI.B  #$0,D5
0000125A  6700 0088                220              BEQ     NUM_0
0000125E  0C05 0001                221              CMPI.B  #$1,D5
00001262  6700 0088                222              BEQ     NUM_1
00001266  0C05 0002                223              CMPI.B  #$2,D5
0000126A  6700 0088                224              BEQ     NUM_2
0000126E  0C05 0003                225              CMPI.B  #$3,D5
00001272  6700 0088                226              BEQ     NUM_3
00001276  0C05 0004                227              CMPI.B  #$4,D5
0000127A  6700 0088                228              BEQ     NUM_4
0000127E  0C05 0005                229              CMPI.B  #$5,D5
00001282  6700 0088                230              BEQ     NUM_5
00001286  0C05 0006                231              CMPI.B  #$6,D5
0000128A  6700 0088                232              BEQ     NUM_6
0000128E  0C05 0007                233              CMPI.B  #$7,D5
00001292  6700 0088                234              BEQ     NUM_7
00001296  0C05 0008                235              CMPI.B  #$8,D5
0000129A  6700 0088                236              BEQ     NUM_8
0000129E  0C05 0009                237              CMPI.B  #$9,D5
000012A2  6700 0088                238              BEQ     NUM_9
000012A6  0C05 000A                239              CMPI.B  #$A,D5
000012AA  6700 0088                240              BEQ     NUM_A
000012AE  0C05 000B                241              CMPI.B  #$B,D5
000012B2  6700 0088                242              BEQ     NUM_B
000012B6  0C05 000C                243              CMPI.B  #$C,D5
000012BA  6700 0088                244              BEQ     NUM_C
000012BE  0C05 000D                245              CMPI.B  #$D,D5
000012C2  6700 0088                246              BEQ     NUM_D
000012C6  0C05 000E                247              CMPI.B  #$E,D5
000012CA  6700 0088                248              BEQ     NUM_E
000012CE  0C05 000F                249              CMPI.B  #$F,D5
000012D2  6700 0088                250              BEQ     NUM_F
000012D6                           251              
000012D6  4CDF 0032                252  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DA  4E75                     253              RTS
000012DC                           254              
000012DC  303C 000E                255  PRINT_NUM   MOVE    #14,D0
000012E0  4E4F                     256              TRAP    #15
000012E2  4E75                     257              RTS
000012E4  43F9 00002334            258  NUM_0       LEA     PRNT0,A1
000012EA  60F0                     259              BRA     PRINT_NUM
000012EC  43F9 00002336            260  NUM_1       LEA     PRNT1,A1
000012F2  60E8                     261              BRA     PRINT_NUM
000012F4  43F9 00002338            262  NUM_2       LEA     PRNT2,A1
000012FA  60E0                     263              BRA     PRINT_NUM
000012FC  43F9 0000233A            264  NUM_3       LEA     PRNT3,A1
00001302  60D8                     265              BRA     PRINT_NUM
00001304  43F9 0000233C            266  NUM_4       LEA     PRNT4,A1
0000130A  60D0                     267              BRA     PRINT_NUM
0000130C  43F9 0000233E            268  NUM_5       LEA     PRNT5,A1
00001312  60C8                     269              BRA     PRINT_NUM
00001314  43F9 00002340            270  NUM_6       LEA     PRNT6,A1
0000131A  60C0                     271              BRA     PRINT_NUM
0000131C  43F9 00002342            272  NUM_7       LEA     PRNT7,A1
00001322  60B8                     273              BRA     PRINT_NUM
00001324  43F9 00002344            274  NUM_8       LEA     PRNT8,A1
0000132A  60B0                     275              BRA     PRINT_NUM
0000132C  43F9 00002346            276  NUM_9       LEA     PRNT9,A1
00001332  60A8                     277              BRA     PRINT_NUM
00001334  43F9 00002348            278  NUM_A       LEA     PRNTA,A1
0000133A  60A0                     279              BRA     PRINT_NUM
0000133C  43F9 0000234A            280  NUM_B       LEA     PRNTB,A1
00001342  6098                     281              BRA     PRINT_NUM
00001344  43F9 0000234C            282  NUM_C       LEA     PRNTC,A1
0000134A  6090                     283              BRA     PRINT_NUM
0000134C  43F9 0000234E            284  NUM_D       LEA     PRNTD,A1
00001352  6088                     285              BRA     PRINT_NUM
00001354  43F9 00002350            286  NUM_E       LEA     PRNTE,A1
0000135A  6080                     287              BRA     PRINT_NUM
0000135C  43F9 00002352            288  NUM_F       LEA     PRNTF,A1
00001362  6000 FF78                289              BRA     PRINT_NUM
00001366                           290  
00001366                           291  
00001366                           292  *-----------------------------------------------------------        
00001366                           293  * Start of Disassembler
00001366                           294  *-----------------------------------------------------------
00001366                           295          *FOR DEBUGGING ONLY!!!
00001366  207C 00007FC6            296          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000136C                           297          
0000136C                           298  GRAB_NEXT_OP
0000136C                           299          *Check and see if A0 == end of test address. If so, we need to end.
0000136C  2E08                     300          MOVE.L  A0,D7
0000136E  2479 00002312            301          MOVEA.L PROGEND,A2
00001374  BE8A                     302          CMP.L   A2,D7       * Check and see if A0 == end of test address. 
00001376  0C86 00000000            303          CMPI.L  #00,D6      * Check if max line of instructions output on console is reached
0000137C  6700 0032                304          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
00001380  5306                     305          SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
00001382                           306  
00001382                           307          *Output a newline to console...        
00001382  43F9 0000246E            308          LEA     NewLine,A1  *Loads NewLine into address register A1
00001388  103C 000E                309          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000138C  4E4F                     310          TRAP    #15         *Displays Message
0000138E                           311  
0000138E                           312          *Output the address of this instruction to console...
0000138E  2808                     313          MOVE.L  A0,D4
00001390  4EB8 11FE                314          JSR     HEXASCIIREG
00001394                           315          
00001394                           316          *Output a tab (4 spaces) to console, just after the address...
00001394  43F9 00002467            317          LEA     Tab,A1  *Loads Tab into address register A1
0000139A  103C 000E                318          MOVE.B  #14,D0  *Moves the number 14 into data register D0
0000139E  4E4F                     319          TRAP    #15     *Displays Message
000013A0                           320          
000013A0                           321          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
000013A0                           322          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
000013A0                           323          *data that may be associated with the instruction.
000013A0                           324          *Post increment addr, A0 will point to the start of next instruction or will 
000013A0                           325          *point to the start of any immed/abso data with this current instruction
000013A0  4280                     326          CLR.L   D0
000013A2  3018                     327          MOVE.W  (A0)+,D0
000013A4                           328          *Copy the word data we just moved into D0 into D7. We are copying this data
000013A4                           329          *So we always have a copy of the WHOLE instruction somewhere
000013A4  4287                     330          CLR.L   D7
000013A6  3E00                     331          MOVE.W  D0,D7
000013A8                           332          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000013A8                           333          *four bits of the instruction. Once we have just the first four bits, we can
000013A8                           334          *begin to see which 'bucket'/category this instruction falls into. 
000013A8  E048                     335          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013AA  E848                     336          LSR.W   #$04,D0
000013AC                           337          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013AC                           338          *list of buckets until we find which one this instruction falls into.
000013AC  6000 0068                339          BRA     BUCKET_0000     * Start with 0000
000013B0                           340  
000013B0                           341  
000013B0                           342  *-----------------------------------------------------------        
000013B0                           343  * Question Prompts
000013B0                           344  *-----------------------------------------------------------        
000013B0  43F9 00002262            345  CONT_Q      LEA     QUES_CONT,A1
000013B6  303C 000E                346              MOVE    #14,D0
000013BA  4E4F                     347              TRAP    #15
000013BC  43F9 00002316            348              LEA     CONT,A1     *Need to store Y/N
000013C2  303C 0002                349              MOVE    #2,D0
000013C6  4E4F                     350              TRAP    #15
000013C8  0C01 0001                351              CMPI.B  #01,D1
000013CC  6600 FD66                352              BNE     INVALID1
000013D0  0C39 0059 00002316       353              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013D8  6600 0008                354              BNE     CHECK_Y
000013DC  3C3C 000F                355              MOVE    #MAX_LINE,D6    *Resets counter
000013E0  4E75                     356              RTS
000013E2  0C11 0079                357  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
000013E6  6600 0008                358              BNE     CHECK_N
000013EA  3C3C 000F                359              MOVE    #MAX_LINE,D6    *Resets counter
000013EE  4E75                     360              RTS
000013F0  0C11 004E                361  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
000013F4  6700 FC1E                362              BEQ     loop_1
000013F8  0C11 006E                363              CMPI.B  #$6E,(A1)   *Checks for lowercase n
000013FC  6700 FC16                364              BEQ     loop_1      
00001400                           365  
00001400  163C 0000                366  INV2        MOVE.B  #0,D3       *Reset bad flag
00001404  303C 0000                367              MOVE    #0,D0       *Prints invalid command msg if not found
00001408  43F9 00002484            368              LEA     INV_MSG,A1
0000140E  303C 000E                369              MOVE    #14,D0
00001412  4E4F                     370              TRAP    #15
00001414  609A                     371              BRA     CONT_Q
00001416                           372  
00001416                           373  *-----------------------------------------------------------        
00001416                           374  * Bucket 0000:
00001416                           375  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
00001416                           376  *                   BCHG(dynamic) | BCHG (static) | CMPI----
00001416                           377  *-----------------------------------------------------------
00001416                           378  BUCKET_0000
00001416  =00000000                379  BUCKET0000_BITS EQU $0
00001416  4281                     380          CLR.L   D1
00001418                           381          *Load the first 4 bits (really a byte) of BUCKET0 into D1
00001418  123C 0000                382          MOVE.B  #BUCKET0000_BITS,D1
0000141C                           383          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0000. 
0000141C                           384          *If equal, continue decoding. If not, branch to next bucket.
0000141C  B200                     385          CMP.B   D0,D1
0000141E  6600 0344                386          BNE     BUCKET_0001
00001422                           387  
00001422                           388          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001422                           389          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001422  3007                     390          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001424  0800 0008                391          BTST.L  #$08,D0
00001428  6600 01A4                392          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to IS_BCHG_D
0000142C                           393          
0000142C                           394          *Now we can check bits 11-8 in the instruction and branch to different op-codes
0000142C                           395          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
0000142C  E048                     396          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
0000142E  0880 0004                397          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001432  0880 0005                398          BCLR.L  #$05,D0
00001436  0880 0006                399          BCLR.L  #$06,D0
0000143A  0880 0007                400          BCLR.L  #$07,D0
0000143E                           401          
0000143E                           402          *Perform compares with these 4 bits to see which specific instruction it is.
0000143E  B03C 0006                403          CMP.B   #$06,D0 *Is this an ADDI?
00001442  6700 0028                404          BEQ     IS_ADDI
00001446  B03C 0002                405          CMP.B   #$02,D0 *Is this an ANDI?
0000144A  6700 0096                406          BEQ     IS_ANDI
0000144E  B03C 000A                407          CMP.B   #$0A,D0 *Is this an EORI?
00001452  6700 0104                408          BEQ     IS_EORI
00001456  B03C 0008                409          CMP.B   #$08,D0 *Is this a BCHG(static)?
0000145A  6700 0210                410          BEQ     IS_BCHG_S
0000145E  B03C 000C                411          CMP.B   #$0C,D0 *Is this a CMPI?
00001462  6700 028A                412          BEQ     IS_CMPI
00001466                           413          
00001466                           414          *If we get through all of the compares without finding the specific instruction,
00001466                           415          *then this instruction is either not in our list of OP CODES to decode, or is an
00001466                           416          *invalid instruction/syntax.
00001466  4EF9 00001D96            417          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
0000146C                           418          
0000146C                           419          
0000146C                           420  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
0000146C                           421  IS_ADDI
0000146C                           422          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000146C                           423          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000146C  4281                     424          CLR.L   D1
0000146E  3207                     425          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001470  C27C 00C0                426          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001474  EC09                     427          LSR.B   #$06,D1     *Shift the size bits into LSB
00001476                           428          
00001476  B23C 0003                429          CMP.B   #$03,D1     *Compare the size bits to $3
0000147A  6700 091A                430          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000147E                           431          
0000147E                           432          *Output 'ADDI' to console...
0000147E  43F9 00002354            433          LEA     ADDI,A1     *Loads ADDI into address register A1
00001484  103C 000E                434          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001488  4E4F                     435          TRAP    #15         *Displays Message
0000148A                           436          
0000148A                           437          
0000148A                           438          *Should have a valid ADDI op code. Set data up for EA.
0000148A                           439          
0000148A                           440          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000148A  4282                     441          CLR.L   D2
0000148C  3407                     442          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000148E  C47C 0038                443          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001492  E60A                     444          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001494                           445                  
00001494                           446          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001494  4283                     447          CLR.L   D3
00001496  3607                     448          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001498  C67C 0007                449          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000149C                           450          
0000149C  4EF9 000014A2            451          JMP     EA_ADDI
000014A2                           452  
000014A2                           453  EA_ADDI
000014A2                           454          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
000014A2                           455          *and D3 holds the EA register.
000014A2                           456          
000014A2                           457          *Determine how much data to read in, depending on the size of the operation
000014A2                           458          *output the size of the operation and the immediate data to console
000014A2  4EB9 00001836            459          JSR     WrapperSizeImmediate
000014A8                           460          
000014A8                           461          *manually output a comma here...
000014A8  43F9 0000246C            462          LEA     Comma,A1        *Loads Comma into address register A1
000014AE  103C 000E                463          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014B2  4E4F                     464          TRAP    #15             *Displays Message        
000014B4                           465          
000014B4                           466          *Determine which EA mode and thus Register/Mem Address this instruction used
000014B4  B43C 0000                467          CMP.B   #$00,D2
000014B8  6700 0456                468          BEQ     DataRegMode *If EA mode is a data register, output that
000014BC                           469          
000014BC  B43C 0002                470          CMP.B   #$02,D2
000014C0  6700 046E                471          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014C4                           472          
000014C4  B43C 0003                473          CMP.B   #$03,D2
000014C8  6700 0476                474          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014CC                           475          
000014CC  B43C 0004                476          CMP.B   #$04,D2
000014D0  6700 047E                477          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014D4                           478          
000014D4  B43C 0007                479          CMP.B   #$07,D2
000014D8  6700 0486                480          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014DC                           481          
000014DC                           482          *If the ea mode isn't equal to any of these, it is an invalid EA
000014DC  4EF9 00001DA6            483          JMP     BADEACODE                               
000014E2                           484          
000014E2                           485  
000014E2                           486  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000014E2                           487  IS_ANDI
000014E2                           488          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014E2                           489          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014E2  4281                     490          CLR.L   D1
000014E4  3207                     491          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014E6  C27C 00C0                492          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014EA  EC09                     493          LSR.B   #$06,D1     *Shift the size bits into LSB
000014EC                           494          
000014EC  B23C 0003                495          CMP.B   #$03,D1     *Compare the size bits to $3
000014F0  6700 08A4                496          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014F4                           497          
000014F4                           498          *Output 'ANDI' to console...
000014F4  43F9 00002359            499          LEA     ANDI,A1     *Loads ANDI into address register A1
000014FA  103C 000E                500          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014FE  4E4F                     501          TRAP    #15         *Displays Message
00001500                           502          
00001500                           503          
00001500                           504          *Should have a valid ANDI op code. Set data up for EA.
00001500                           505          
00001500                           506          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001500  4282                     507          CLR.L   D2
00001502  3407                     508          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001504  C47C 0038                509          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001508  E60A                     510          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000150A                           511                  
0000150A                           512          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000150A  4283                     513          CLR.L   D3
0000150C  3607                     514          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000150E  C67C 0007                515          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001512                           516          
00001512  4EF9 00001518            517          JMP     EA_ANDI
00001518                           518  
00001518                           519  EA_ANDI
00001518                           520          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
00001518                           521          *and D3 holds the EA register.
00001518                           522          
00001518                           523          *Determine how much data to read in, depending on the size of the operation
00001518                           524          *output the size of the operation and the immediate data to console
00001518  4EB9 00001836            525          JSR     WrapperSizeImmediate
0000151E                           526          
0000151E                           527          *manually output a comma here...
0000151E  43F9 0000246C            528          LEA     Comma,A1        *Loads Comma into address register A1
00001524  103C 000E                529          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001528  4E4F                     530          TRAP    #15             *Displays Message        
0000152A                           531          
0000152A                           532          *Determine which EA mode and thus Register/Mem Address this instruction used
0000152A  B43C 0000                533          CMP.B   #$00,D2
0000152E  6700 03E0                534          BEQ     DataRegMode *If EA mode is a data register, output that
00001532                           535          
00001532  B43C 0002                536          CMP.B   #$02,D2
00001536  6700 03F8                537          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000153A                           538          
0000153A  B43C 0003                539          CMP.B   #$03,D2
0000153E  6700 0400                540          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001542                           541          
00001542  B43C 0004                542          CMP.B   #$04,D2
00001546  6700 0408                543          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000154A                           544          
0000154A  B43C 0007                545          CMP.B   #$07,D2
0000154E  6700 0410                546          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001552                           547          
00001552                           548          *If the ea mode isn't equal to any of these, it is an invalid EA
00001552  4EF9 00001DA6            549          JMP     BADEACODE
00001558                           550          
00001558                           551  
00001558                           552  *Now we know this instruction is exactly EORI, lets set everything up for EA.
00001558                           553  IS_EORI
00001558                           554          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001558                           555          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001558  4281                     556          CLR.L   D1
0000155A  3207                     557          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000155C  C27C 00C0                558          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001560  EC09                     559          LSR.B   #$06,D1     *Shift the size bits into LSB
00001562                           560          
00001562  B23C 0003                561          CMP.B   #$03,D1     *Compare the size bits to $3
00001566  6700 082E                562          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000156A                           563          
0000156A                           564          *Output 'EORI' to console...
0000156A  43F9 0000235E            565          LEA     EORI,A1     *Loads EORI into address register A1
00001570  103C 000E                566          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001574  4E4F                     567          TRAP    #15         *Displays Message
00001576                           568          
00001576                           569          
00001576                           570          *Should have a valid EORI op code. Set data up for EA.
00001576                           571          
00001576                           572          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001576  4282                     573          CLR.L   D2
00001578  3407                     574          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000157A  C47C 0038                575          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
0000157E  E60A                     576          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001580                           577                  
00001580                           578          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001580  4283                     579          CLR.L   D3
00001582  3607                     580          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001584  C67C 0007                581          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001588                           582          
00001588  4EF9 0000158E            583          JMP     EA_EORI
0000158E                           584  
0000158E                           585  EA_EORI
0000158E                           586          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
0000158E                           587          *and D3 holds the EA register.
0000158E                           588          
0000158E                           589          *Determine how much data to read in, depending on the size of the operation
0000158E                           590          *output the size of the operation and the immediate data to console
0000158E  4EB9 00001836            591          JSR     WrapperSizeImmediate
00001594                           592          
00001594                           593          *manually output a comma here...
00001594  43F9 0000246C            594          LEA     Comma,A1        *Loads Comma into address register A1
0000159A  103C 000E                595          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000159E  4E4F                     596          TRAP    #15             *Displays Message        
000015A0                           597          
000015A0                           598          *Determine which EA mode and thus Register/Mem Address this instruction used
000015A0  B43C 0000                599          CMP.B   #$00,D2
000015A4  6700 036A                600          BEQ     DataRegMode *If EA mode is a data register, output that
000015A8                           601          
000015A8  B43C 0002                602          CMP.B   #$02,D2
000015AC  6700 0382                603          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015B0                           604          
000015B0  B43C 0003                605          CMP.B   #$03,D2
000015B4  6700 038A                606          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015B8                           607          
000015B8  B43C 0004                608          CMP.B   #$04,D2
000015BC  6700 0392                609          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015C0                           610          
000015C0  B43C 0007                611          CMP.B   #$07,D2
000015C4  6700 039A                612          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015C8                           613          
000015C8                           614          *If the ea mode isn't equal to any of these, it is an invalid EA
000015C8  4EF9 00001DA6            615          JMP     BADEACODE
000015CE                           616  
000015CE                           617  
000015CE                           618  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015CE                           619  *everything up for EA, if is a legit instruction.
000015CE                           620  IS_BCHG_D
000015CE                           621          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015CE                           622          *invalid, branch to BADOPCODE
000015CE  3007                     623          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015D0  0800 0007                624          BTST.L  #$07,D0
000015D4  6600 07C0                625          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015D8  0800 0006                626          BTST.L  #$06,D0
000015DC  6700 07B8                627          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000015E0                           628          
000015E0                           629          *Output 'BCHG' to console...
000015E0  43F9 00002363            630          LEA     BCHG,A1         *Loads BCHG into address register A1
000015E6  103C 000E                631          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015EA  4E4F                     632          TRAP    #15             *Displays Message
000015EC                           633                  
000015EC                           634                  
000015EC                           635          *Should have a valid BCHG op code. Set data up for EA.
000015EC                           636  
000015EC                           637          *Set D1 to the EA source register located in bits 11-9 of the instruction
000015EC  4281                     638          CLR.L   D1
000015EE  3207                     639          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015F0  C27C 0E00                640          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
000015F4  E049                     641          LSR.W   #$08,D1     *Shift the EA source register bits into LSB
000015F6  E249                     642          LSR.W   #$01,D1
000015F8                           643  
000015F8                           644          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015F8  4282                     645          CLR.L   D2
000015FA  3407                     646          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000015FC  C47C 0038                647          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001600  E60A                     648          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001602                           649                  
00001602                           650          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001602  4283                     651          CLR.L   D3
00001604  3607                     652          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001606  C67C 0007                653          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000160A                           654  
0000160A  4EF9 00001610            655          JMP     EA_BCHG_D
00001610                           656  
00001610                           657  EA_BCHG_D
00001610                           658          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001610                           659          *D2 holds the EA mode, and D3 holds the EA register.
00001610                           660          
00001610                           661          *Determine the size of this BCHG instruction. Output the correct size...
00001610  4EB9 000018B8            662          JSR     BCHGSizeHelper
00001616                           663          
00001616                           664          *output the source register to console, flag D6 with a 1 so we come back...
00001616  48E7 0200                665          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
0000161A  48E7 1000                666          MOVEM.L D3,-(SP)    *Push EA destination register into stack            
0000161E  1C3C 0001                667          MOVE.B  #$01,D6     *Flag D6
00001622  1601                     668          MOVE.B  D1,D3       *Move source register into D3
00001624  4EB9 00001910            669          JSR     DataRegMode
0000162A  4CDF 0008                670          MOVEM.L (SP)+,D3    *Pull destination register back into D3
0000162E  4CDF 0040                671          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001632                           672          
00001632                           673          *manually output a comma here...
00001632  43F9 0000246C            674          LEA     Comma,A1        *Loads Comma into address register A1
00001638  103C 000E                675          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000163C  4E4F                     676          TRAP    #15             *Displays Message
0000163E                           677          
0000163E                           678          *Determine which EA mode and thus Register/Mem Address this instruction used
0000163E  B43C 0000                679          CMP.B   #$00,D2
00001642  6700 02CC                680          BEQ     DataRegMode *If EA mode is a data register, output that
00001646                           681          
00001646  B43C 0002                682          CMP.B   #$02,D2
0000164A  6700 02E4                683          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000164E                           684          
0000164E  B43C 0003                685          CMP.B   #$03,D2
00001652  6700 02EC                686          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001656                           687          
00001656  B43C 0004                688          CMP.B   #$04,D2
0000165A  6700 02F4                689          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000165E                           690          
0000165E  B43C 0007                691          CMP.B   #$07,D2
00001662  6700 02FC                692          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001666                           693          
00001666                           694          *If the ea mode isn't equal to any of these, it is an invalid EA
00001666  4EF9 00001DA6            695          JMP     BADEACODE
0000166C                           696  
0000166C                           697  
0000166C                           698  *Found a possible BCHG(static) instruction. Verify its bit integrity and then set up
0000166C                           699  *everything up for EA, if is a legit instruction.
0000166C                           700  IS_BCHG_S
0000166C                           701          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
0000166C                           702          *invalid, branch to BADOPCODE
0000166C  3007                     703          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
0000166E  0800 0007                704          BTST.L  #$07,D0
00001672  6600 0722                705          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
00001676  0800 0006                706          BTST.L  #$06,D0
0000167A  6700 071A                707          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
0000167E                           708          
0000167E                           709          *Output 'BCHG' to console...
0000167E  43F9 00002363            710          LEA     BCHG,A1         *Loads BCHG into address register A1
00001684  103C 000E                711          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001688  4E4F                     712          TRAP    #15             *Displays Message
0000168A                           713          
0000168A                           714          
0000168A                           715          *Should have a valid BCHG op code. Set data up for EA.
0000168A                           716          
0000168A                           717          *Move #$00 into D1, BCHG_S's immediate data is always in byte size
0000168A  4281                     718          CLR.L   D1
0000168C  323C 0000                719          MOVE.W  #$00,D1
00001690                           720  
00001690                           721          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001690  4282                     722          CLR.L   D2
00001692  3407                     723          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001694  C47C 0038                724          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001698  E60A                     725          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000169A                           726                  
0000169A                           727          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000169A  4283                     728          CLR.L   D3
0000169C  3607                     729          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000169E  C67C 0007                730          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000016A2                           731  
000016A2  4EF9 000016A8            732          JMP     EA_BCHG_S
000016A8                           733  
000016A8                           734  EA_BCHG_S
000016A8                           735          *Decode the ea bits of BCHG(static). Assuming D2 holds the EA mode, and 
000016A8                           736          *D3 holds the EA register.
000016A8                           737          
000016A8                           738          *Determine the size of this BCHG instruction. Output the correct size...
000016A8  4EB9 000018B8            739          JSR     BCHGSizeHelper                
000016AE                           740          
000016AE                           741          *output the immediate data of this operation to console (always byte)...
000016AE  4EB9 000018E8            742          JSR     BCHGImmediate
000016B4                           743          
000016B4                           744          *manually output a comma here...
000016B4  43F9 0000246C            745          LEA     Comma,A1        *Loads Comma into address register A1
000016BA  103C 000E                746          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016BE  4E4F                     747          TRAP    #15             *Displays Message
000016C0                           748          
000016C0                           749          *Determine which EA mode and thus Register/Mem Address this instruction used
000016C0  B43C 0000                750          CMP.B   #$00,D2
000016C4  6700 024A                751          BEQ     DataRegMode *If EA mode is a data register, output that
000016C8                           752          
000016C8  B43C 0002                753          CMP.B   #$02,D2
000016CC  6700 0262                754          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016D0                           755          
000016D0  B43C 0003                756          CMP.B   #$03,D2
000016D4  6700 026A                757          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016D8                           758          
000016D8  B43C 0004                759          CMP.B   #$04,D2
000016DC  6700 0272                760          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000016E0                           761          
000016E0  B43C 0007                762          CMP.B   #$07,D2
000016E4  6700 027A                763          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000016E8                           764          
000016E8                           765          *If the ea mode isn't equal to any of these, it is an invalid EA
000016E8  4EF9 00001DA6            766          JMP     BADEACODE
000016EE                           767  
000016EE                           768  
000016EE                           769  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000016EE                           770  IS_CMPI
000016EE                           771          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000016EE                           772          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000016EE  4281                     773          CLR.L   D1
000016F0  3207                     774          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000016F2  C27C 00C0                775          AND.W   #$00C0,D1   *Mask out everything but the size bits
000016F6  EC09                     776          LSR.B   #$06,D1     *Shift the size bits into LSB
000016F8                           777          
000016F8  B23C 0003                778          CMP.B   #$03,D1     *Compare the size bits to $3
000016FC  6700 0698                779          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001700                           780          
00001700                           781          *Output 'CMPI' to console...
00001700  43F9 00002368            782          LEA     CMPI,A1     *Loads CMPI into address register A1
00001706  103C 000E                783          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000170A  4E4F                     784          TRAP    #15         *Displays Message
0000170C                           785          
0000170C                           786          
0000170C                           787          *Should have a valid CMPI op code. Set data up for EA.
0000170C                           788          
0000170C                           789          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000170C  4282                     790          CLR.L   D2
0000170E  3407                     791          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001710  C47C 0038                792          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
00001714  E60A                     793          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001716                           794                  
00001716                           795          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001716  4283                     796          CLR.L   D3
00001718  3607                     797          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000171A  C67C 0007                798          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000171E                           799          
0000171E  4EF9 00001724            800          JMP     EA_CMPI
00001724                           801  
00001724                           802  EA_CMPI
00001724                           803          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
00001724                           804          *and D3 holds the EA register.
00001724                           805          
00001724                           806          *Determine how much data to read in, depending on the size of the operation
00001724                           807          *output the size of the operation and the immediate data to console
00001724  4EB9 00001836            808          JSR     WrapperSizeImmediate
0000172A                           809          
0000172A                           810          *manually output a comma here...
0000172A  43F9 0000246C            811          LEA     Comma,A1        *Loads Comma into address register A1
00001730  103C 000E                812          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001734  4E4F                     813          TRAP    #15             *Displays Message
00001736                           814          
00001736                           815          *Determine which EA mode and thus Register/Mem Address this instruction used
00001736  B43C 0000                816          CMP.B   #$00,D2
0000173A  6700 01D4                817          BEQ     DataRegMode *If EA mode is a data register, output that
0000173E                           818          
0000173E  B43C 0002                819          CMP.B   #$02,D2
00001742  6700 01EC                820          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001746                           821          
00001746  B43C 0003                822          CMP.B   #$03,D2
0000174A  6700 01F4                823          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000174E                           824          
0000174E  B43C 0004                825          CMP.B   #$04,D2
00001752  6700 01FC                826          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001756                           827          
00001756  B43C 0007                828          CMP.B   #$07,D2
0000175A  6700 0204                829          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000175E                           830          
0000175E                           831          *If the ea mode isn't equal to any of these, it is an invalid EA
0000175E  4EF9 00001DA6            832          JMP     BADEACODE
00001764                           833        
00001764                           834    
00001764                           835  *STARTS WITH 0001, MOVE.B-----------------------------------
00001764                           836  BUCKET_0001
00001764  =00000001                837  BUCKET0001_BITS EQU $1
00001764                           838          
00001764                           839          *some code...
00001764                           840  
00001764                           841  
00001764                           842  *STARTS WITH 0010, MOVE.L-----------------------------------
00001764                           843  BUCKET_0010
00001764  =00000002                844  BUCKET0010_BITS EQU $2
00001764                           845  
00001764                           846          *some code...
00001764                           847  
00001764                           848  
00001764                           849  *STARTS WITH 0011, MOVE.W-----------------------------------
00001764                           850  BUCKET_0011
00001764  =00000003                851  BUCKET0011_BITS EQU $3
00001764                           852  
00001764                           853          *some code...
00001764                           854  
00001764                           855  
00001764                           856  *-----------------------------------------------------------        
00001764                           857  * Bucket 0100:
00001764                           858  * STARTS WITH 0100, MOVEM | MULS(L)-------------------------
00001764                           859  *                   LEA | CLR | JSR | RTS-------------------
00001764                           860  *-----------------------------------------------------------
00001764                           861  BUCKET_0100
00001764  =00000004                862  BUCKET0100_BITS EQU $4
00001764  4281                     863          CLR.L   D1
00001766                           864          *Load the first 4 bits (really a byte) of BUCKET0 into D1
00001766  123C 0004                865          MOVE.B  #BUCKET0100_BITS,D1
0000176A                           866          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0100. 
0000176A                           867          *If equal, continue decoding. If not, branch to next bucket.
0000176A  B200                     868          CMP.B   D0,D1
0000176C  6600 00C2                869          BNE     BUCKET_0101
00001770                           870  
00001770                           871          *Test the 8th bit in this instruction, if it is 1, then it is an LEA 
00001770                           872          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1.
00001770  3007                     873          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001772  0800 0008                874          BTST.L  #$08,D0
00001776  6600 0040                875          BNE     IS_LEA  *If the zbit was 0 (the 8th bit is 1), branch to IS_LEA
0000177A                           876  
0000177A                           877          *Some codes in this bucket can be determined by only bits 11-8, but some need
0000177A                           878          *11-6 to be unambiguous with others. First, solve codes that need bits 11-6...           
0000177A  C07C 0FC0                879          AND.W   #$0FC0,D0   *Mask out everything but bits 11-6
0000177E  EC48                     880          LSR.W   #$06,D0     *Move bits 11-6 into LSB position
00001780                           881          
00001780                           882          *Check bits 11-6 in the instruction and branch to different op-codes depending 
00001780                           883          *on what the bits equal, without ambiguity
00001780  B03C 0033                884          CMP.B   #$33,D0 *Is this a MOVEM(long)?
00001784  6700 0032                885          BEQ     IS_MOVEM
00001788  B03C 0030                886          CMP.B   #$30,D0 *Is this a MULS(long)?
0000178C  6700 002A                887          BEQ     IS_MULS_L
00001790  B03C 003A                888          CMP.B   #$3A,D0 *Is this a JSR?
00001794  6700 009A                889          BEQ     IS_JSR
00001798  B03C 0039                890          CMP.B   #$39,D0 *Is this a RTS?
0000179C  6700 0092                891          BEQ     IS_RTS
000017A0                           892  
000017A0                           893          *Now we can use only bits 11-8 and branch to different op-codes only needing these
000017A0                           894          *four bits to be unambiguous
000017A0  E448                     895          LSR.W   #$02,D0 *Shift the 7-6 bits out, leaving only 11-8        
000017A2  B03C 0008                896          CMP.B   #$08,D0 *Is this a MOVEM(word)?
000017A6  6700 0010                897          BEQ     IS_MOVEM
000017AA  B03C 0002                898          CMP.B   #$02,D0 *Is this a CLR?
000017AE  6700 0080                899          BEQ     IS_CLR
000017B2                           900          
000017B2                           901          *If we get through all of the compares without finding the specific instruction,
000017B2                           902          *then this instruction is either not in our list of OP CODES to decode, or is an
000017B2                           903          *invalid instruction/syntax.
000017B2  4EF9 00001D96            904          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000017B8                           905  
000017B8                           906  
000017B8                           907  *Now we know this instruction is exactly MOVEM, lets set everything up for EA.
000017B8                           908  IS_MOVEM
000017B8                           909  
000017B8                           910  EA_MOVEM
000017B8                           911  
000017B8                           912  
000017B8                           913  *Now we know this instruction is exactly IS_MULS_L, lets set everything up for EA.
000017B8                           914  IS_MULS_L
000017B8                           915  
000017B8                           916  EA_MULS_L
000017B8                           917  
000017B8                           918  
000017B8                           919  *Now we know this instruction is exactly LEA, lets set everything up for EA.
000017B8                           920  IS_LEA
000017B8                           921          *Check bits 7 and 6, these should be 1 and 1. If not, this instruction is
000017B8                           922          *invalid, branch to BADOPCODE
000017B8  3007                     923          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000017BA  0800 0007                924          BTST.L  #$07,D0
000017BE  6700 05D6                925          BEQ     BADOPCODE  *If the zbit was 1 (the 7th bit is 0), branch to BADOPCODE
000017C2  0800 0006                926          BTST.L  #$06,D0
000017C6  6700 05CE                927          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000017CA                           928          
000017CA                           929          *Output 'LEA' to console...
000017CA  43F9 00002378            930          LEA     LEA,A1         *Loads LEA into address register A1
000017D0  103C 000E                931          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000017D4  4E4F                     932          TRAP    #15             *Displays Message
000017D6                           933          
000017D6                           934          
000017D6                           935          *Should have a valid LEA op code. Set data up for EA.      
000017D6                           936          
000017D6                           937          *Set D1 to the EA destination register located in bits 11-9 of the instruction
000017D6  4281                     938          CLR.L   D1
000017D8  3207                     939          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000017DA  C27C 0E00                940          AND.W   #$0E00,D1   *Mask out everything but the EA destination register bits
000017DE  E049                     941          LSR.W   #$08,D1     *Shift the EA destination register bits into LSB
000017E0  E249                     942          LSR.W   #$01,D1
000017E2                           943  
000017E2                           944          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000017E2  4282                     945          CLR.L   D2
000017E4  3407                     946          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000017E6  C47C 0038                947          AND.W   #$0038,D2   *Mask out everything but the EA mode bits
000017EA  E60A                     948          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000017EC                           949                  
000017EC                           950          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000017EC  4283                     951          CLR.L   D3
000017EE  3607                     952          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000017F0  C67C 0007                953          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000017F4                           954  
000017F4  4EF9 000017FA            955          JMP     EA_LEA       
000017FA                           956  
000017FA                           957  EA_LEA
000017FA                           958          *Decode the ea bits of LEA. Assuming D2 holds the EA mode, and D3 holds the EA 
000017FA                           959          *register.                                        
000017FA                           960          
000017FA                           961          *Determine which EA mode and thus Register/Mem Address this instruction used
000017FA  48E7 0200                962          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
000017FE  1C3C 0001                963          MOVE.B  #$01,D6     *Flag D6 so that we come back
00001802                           964          
00001802  B43C 0002                965          CMP.B   #$02,D2
00001806  6700 00F4                966          BEQ     LEA_AddrIndirectWrapper *If EA mode is an addr indirect, output that
0000180A                           967          
0000180A  B43C 0007                968          CMP.B   #$07,D2
0000180E  6700 00F6                969          BEQ     LEA_AddrAbsoluteWrapper *If EA mode is an addr absolute word/long, output that
00001812                           970  
00001812                           971  EA_LEA_WrapperEnd        
00001812  4CDF 0040                972          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001816                           973                  
00001816                           974          *manually output a comma here...
00001816  43F9 0000246C            975          LEA     Comma,A1        *Loads Comma into address register A1
0000181C  103C 000E                976          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001820  4E4F                     977          TRAP    #15             *Displays Message
00001822                           978          
00001822                           979          *output the destination address register to console
00001822                           980          *Overwrite the EA register with destination register (no longer need D3 at this point)
00001822  1601                     981          MOVE.B  D1,D3
00001824  4EB9 00001920            982          JSR     AddrRegMode
0000182A                           983          
0000182A                           984          *If the ea mode isn't equal to any of these, it is an invalid EA
0000182A  4EF9 00001DA6            985          JMP     BADEACODE
00001830                           986          
00001830                           987          
00001830                           988  *Now we know this instruction is exactly CLR, lets set everything up for EA.
00001830                           989  IS_CLR
00001830                           990  
00001830                           991  EA_CLR
00001830                           992  
00001830                           993  
00001830                           994  *Now we know this instruction is exactly JSR, lets set everything up for EA.
00001830                           995  IS_JSR
00001830                           996  
00001830                           997  EA_JSR
00001830                           998  
00001830                           999  
00001830                          1000  *Now we know this instruction is exactly RTS, lets set everything up for EA.
00001830                          1001  IS_RTS
00001830                          1002  
00001830                          1003  EA_RTS
00001830                          1004  
00001830                          1005  
00001830                          1006  *STARTS WITH 0101, SUBQ-------------------------------------
00001830                          1007  BUCKET_0101
00001830  =00000005               1008  BUCKET0101_BITS EQU $5
00001830                          1009  
00001830                          1010          *some code...
00001830                          1011  
00001830                          1012  
00001830                          1013  *STARTS WITH 0110, BCC--------------------------------------
00001830                          1014  BUCKET_0110
00001830  =00000006               1015  BUCKET0110_BITS EQU $6
00001830                          1016  
00001830                          1017          *some code...
00001830                          1018  
00001830                          1019  
00001830                          1020  *STARTS WITH 1000, DIVU-------------------------------------
00001830                          1021  BUCKET_1000
00001830  =00000008               1022  BUCKET1000_BITS EQU $8
00001830                          1023  
00001830                          1024          *some code...
00001830                          1025  
00001830                          1026  
00001830                          1027  *STARTS WITH 1001, SUBA-------------------------------------
00001830                          1028  BUCKET_1001
00001830  =00000009               1029  BUCKET1001_BITS EQU $9
00001830                          1030  
00001830                          1031          *some code...
00001830                          1032  
00001830                          1033  
00001830                          1034  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
00001830                          1035  BUCKET_1011
00001830  =0000000B               1036  BUCKET1011_BITS EQU $B
00001830                          1037  
00001830                          1038          *some code...
00001830                          1039  
00001830                          1040  
00001830                          1041  *STARTS WITH 1100, MULS(W) | AND----------------------------
00001830                          1042  BUCKET_1100
00001830  =0000000C               1043  BUCKET1100_BITS EQU $C
00001830                          1044  
00001830                          1045          *some code...
00001830                          1046  
00001830                          1047  
00001830                          1048  *STARTS WITH 1101, ADD | ADDA-------------------------------
00001830                          1049  BUCKET_1101
00001830  =0000000D               1050  BUCKET1101_BITS EQU $D
00001830                          1051  
00001830                          1052          *some code...
00001830                          1053  
00001830                          1054  
00001830                          1055  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
00001830                          1056  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
00001830                          1057  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
00001830                          1058  BUCKET_1110
00001830  =0000000E               1059  BUCKET1110_BITS EQU $E     
00001830                          1060  
00001830                          1061          *some code...
00001830                          1062  
00001830                          1063  
00001830                          1064  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
00001830                          1065  *for this disassembler, jump to BADOPCODE and let I/O take care of it
00001830  4EF9 00001D96           1066          JMP     BADOPCODE  
00001836                          1067          
00001836                          1068  
00001836                          1069  *-----------------------------------------------------------        
00001836                          1070  * EA operation size decoding functionality for immediate data
00001836                          1071  *-----------------------------------------------------------   
00001836                          1072  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001836                          1073  WrapperSizeImmediate
00001836  4284                    1074          CLR.L   D4
00001838                          1075          *Depending on the EA Register, choose which size to decode
00001838  B23C 0000               1076          CMP.B   #$00,D1
0000183C  6700 0014               1077          BEQ     ByteSizeImmediate
00001840                          1078          
00001840  B23C 0001               1079          CMP.B   #$01,D1
00001844  6700 002E               1080          BEQ     WordSizeImmediate
00001848                          1081  
00001848  B23C 0002               1082          CMP.B   #$02,D1
0000184C  6700 0048               1083          BEQ     LongSizeImmediate
00001850                          1084          
00001850                          1085  *Used to get back to what we were doing, after dealing with the specific size
00001850                          1086  WrapperSizeImmediateEnd
00001850  4E75                    1087          RTS
00001852                          1088          
00001852                          1089  ByteSizeImmediate
00001852  3818                    1090          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
00001854                          1091          
00001854                          1092          *Output '.B' to console...
00001854  43F9 0000239A           1093          LEA     ByteSize,A1 *Loads ByteSize into address register A1
0000185A  103C 000E               1094          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000185E  4E4F                    1095          TRAP    #15         *Displays Message
00001860                          1096          
00001860                          1097          *Output '#$' just before the immediate data
00001860  43F9 00002471           1098          LEA     ShaBang,A1
00001866  103C 000E               1099          MOVE.B  #14,D0
0000186A  4E4F                    1100          TRAP    #15  
0000186C                          1101          
0000186C                          1102          *output the immediate data to console with the hex-ascii converter
0000186C  4EB8 11E6               1103          JSR     HEXASCII
00001870                          1104                  
00001870  4EF8 1850               1105          JMP     WrapperSizeImmediateEnd
00001874                          1106                  
00001874                          1107  WordSizeImmediate
00001874  3818                    1108          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001876                          1109          
00001876                          1110          *Output '.W' to console...
00001876  43F9 000023A1           1111          LEA     WordSize,A1 *Loads WordSize into address register A1
0000187C  103C 000E               1112          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001880  4E4F                    1113          TRAP    #15         *Displays Message
00001882                          1114          
00001882                          1115          *Output '#$' just before the immediate data
00001882  43F9 00002471           1116          LEA     ShaBang,A1
00001888  103C 000E               1117          MOVE.B  #14,D0
0000188C  4E4F                    1118          TRAP    #15  
0000188E                          1119          
0000188E                          1120          *output the immediate data to console with the hex-ascii converter
0000188E  4EB8 11E6               1121          JSR     HEXASCII
00001892                          1122          
00001892  4EF8 1850               1123          JMP     WrapperSizeImmediateEnd
00001896                          1124                  
00001896                          1125  LongSizeImmediate
00001896  2818                    1126          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
00001898                          1127          
00001898                          1128          *Output '.L' to console...
00001898  43F9 000023A8           1129          LEA     LongSize,A1 *Loads LongSize into address register A1
0000189E  103C 000E               1130          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018A2  4E4F                    1131          TRAP    #15         *Displays Message
000018A4                          1132          
000018A4                          1133          *Output '#$' just before the immediate data
000018A4  43F9 00002471           1134          LEA     ShaBang,A1
000018AA  103C 000E               1135          MOVE.B  #14,D0
000018AE  4E4F                    1136          TRAP    #15  
000018B0                          1137          
000018B0                          1138          *output the immediate data to console with the hex-ascii converter
000018B0  4EB8 11E6               1139          JSR     HEXASCII
000018B4                          1140          
000018B4  4EF8 1850               1141          JMP     WrapperSizeImmediateEnd        
000018B8                          1142  
000018B8                          1143  
000018B8                          1144  *-----------------------------------------------------------        
000018B8                          1145  * BCHG Size decoding functionality
000018B8                          1146  *----------------------------------------------------------- 
000018B8                          1147  BCHGSizeHelper
000018B8                          1148          *Determine if the EA mode is a data register. If so, output '.L' to console...
000018B8  B43C 0000               1149          CMP.B   #$00,D2
000018BC  6700 000A               1150          BEQ     BCHGLongSize
000018C0                          1151          
000018C0                          1152          *If the EA mode isn't a data register, WE MUST output a '.B' to console...
000018C0  4EF9 000018D8           1153          JMP     BCHGByteSize
000018C6                          1154          
000018C6                          1155  *Used to get back to what we were doing, after dealing with the specific size
000018C6                          1156  BCHGSizeHelperEnd
000018C6  4E75                    1157          RTS  
000018C8                          1158          
000018C8                          1159  BCHGLongSize
000018C8                          1160          *Output '.L' to console...
000018C8  43F9 000023A8           1161          LEA     LongSize,A1 *Loads LongSize into address register A1
000018CE  103C 000E               1162          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018D2  4E4F                    1163          TRAP    #15         *Displays Message
000018D4                          1164  
000018D4  4EF8 18C6               1165          JMP     BCHGSizeHelperEnd
000018D8                          1166          
000018D8                          1167  BCHGByteSize
000018D8                          1168          *Output '.B' to console...
000018D8  43F9 0000239A           1169          LEA     ByteSize,A1 *Loads ByteSize into address register A1
000018DE  103C 000E               1170          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000018E2  4E4F                    1171          TRAP    #15         *Displays Message   
000018E4                          1172          
000018E4  4EF8 18C6               1173          JMP     BCHGSizeHelperEnd
000018E8                          1174          
000018E8                          1175  *Output the immediate data for a BCHG(static). Data is always byte size.
000018E8                          1176  BCHGImmediate
000018E8  3818                    1177          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word        
000018EA                          1178          
000018EA                          1179          *Output '#$' just before the immediate data
000018EA  43F9 00002471           1180          LEA     ShaBang,A1
000018F0  103C 000E               1181          MOVE.B  #14,D0
000018F4  4E4F                    1182          TRAP    #15  
000018F6                          1183          
000018F6                          1184          *output the immediate data to console with the hex-ascii converter
000018F6  4EB8 11E6               1185          JSR     HEXASCII
000018FA                          1186                  
000018FA  4E75                    1187          RTS        
000018FC                          1188  
000018FC                          1189  
000018FC                          1190  *-----------------------------------------------------------        
000018FC                          1191  * LEA Wrappers to conform to design of EA mode/register as destination operand. 
000018FC                          1192  * LEA is weird in that its EA mode/register is used as a source operand.
000018FC                          1193  *-----------------------------------------------------------        
000018FC                          1194  *This conforms LEA to the JSR requirement of AddrIndirectMode. JMPs back to LEA after the JSR.
000018FC                          1195  LEA_AddrIndirectWrapper
000018FC  4EB9 00001930           1196          JSR     AddrIndirectMode
00001902                          1197          
00001902  4EF8 1812               1198          JMP     EA_LEA_WrapperEnd
00001906                          1199          
00001906                          1200  *This conforms LEA to the JSR requirement of AddrAbsoluteMode. JMPs back to LEA after the JSR.
00001906                          1201  LEA_AddrAbsoluteWrapper
00001906  4EB9 00001960           1202          JSR     AddrAbsoluteMode
0000190C                          1203          
0000190C  4EF8 1812               1204          JMP     EA_LEA_WrapperEnd
00001910                          1205  
00001910                          1206  
00001910                          1207  *-----------------------------------------------------------        
00001910                          1208  * EA Mode/EA Register decoding functionality
00001910                          1209  *-----------------------------------------------------------        
00001910                          1210  DataRegMode
00001910                          1211          *Depending on the EA Register, output a different register number
00001910  4EB9 00001970           1212          JSR     WrapperDataReg        
00001916                          1213          
00001916                          1214          *if this was called for a destination decoding then we are done decoding this        
00001916                          1215          *instruction, go get the next instruction
00001916  BC3C 0001               1216          CMP.B   #$01,D6
0000191A  6600 FA50               1217          BNE     GRAB_NEXT_OP
0000191E                          1218          
0000191E                          1219          *else this was a source decoding, rts back to we can keep decoding
0000191E  4E75                    1220          RTS
00001920                          1221  
00001920                          1222  AddrRegMode
00001920  4EB9 00001A32           1223          JSR     WrapperAddrReg
00001926                          1224          
00001926                          1225          *if this was called for a destination decoding then we are done decoding this        
00001926                          1226          *instruction, go get the next instruction
00001926  BC3C 0001               1227          CMP.B   #$01,D6
0000192A  6600 FA40               1228          BNE     GRAB_NEXT_OP
0000192E                          1229          
0000192E                          1230          *else this was a source decoding, rts back to we can keep decoding
0000192E  4E75                    1231          RTS
00001930                          1232  
00001930                          1233  AddrIndirectMode
00001930                          1234          *Depending on the EA Register, output a different register number
00001930  4EB9 00001AF4           1235          JSR     WrapperAddrIndirect
00001936                          1236                          
00001936                          1237          *if this was called for a destination decoding then we are done decoding this        
00001936                          1238          *instruction, go get the next instruction
00001936  BC3C 0001               1239          CMP.B   #$01,D6
0000193A  6600 FA30               1240          BNE     GRAB_NEXT_OP
0000193E                          1241          
0000193E                          1242          *else this was a source decoding, rts back to we can keep decoding
0000193E  4E75                    1243          RTS
00001940                          1244  
00001940                          1245  AddrIndirectPostMode
00001940                          1246          *Depending on the EA Register, output a different register number
00001940  4EB9 00001BB6           1247          JSR     WrapperAddrIndirectPost
00001946                          1248  
00001946                          1249          *if this was called for a destination decoding then we are done decoding this        
00001946                          1250          *instruction, go get the next instruction
00001946  BC3C 0001               1251          CMP.B   #$01,D6
0000194A  6600 FA20               1252          BNE     GRAB_NEXT_OP
0000194E                          1253          
0000194E                          1254          *else this was a source decoding, rts back to we can keep decoding
0000194E  4E75                    1255          RTS
00001950                          1256  
00001950                          1257  AddrIndirectPreMode
00001950                          1258          *Depending on the EA Register, output a different register number
00001950  4EB9 00001C78           1259          JSR     WrapperAddrIndirectPre
00001956                          1260  
00001956                          1261          *if this was called for a destination decoding then we are done decoding this        
00001956                          1262          *instruction, go get the next instruction
00001956  BC3C 0001               1263          CMP.B   #$01,D6
0000195A  6600 FA10               1264          BNE     GRAB_NEXT_OP
0000195E                          1265          
0000195E                          1266          *else this was a source decoding, rts back to we can keep decoding
0000195E  4E75                    1267          RTS
00001960                          1268  
00001960                          1269  AddrAbsoluteMode
00001960                          1270          *Depending on the EA Register, output a different register number
00001960  4EB9 00001D3A           1271          JSR     WrapperAddrAbsolute        
00001966                          1272  
00001966                          1273          *if this was called for a destination decoding then we are done decoding this        
00001966                          1274          *instruction, go get the next instruction
00001966  BC3C 0001               1275          CMP.B   #$01,D6
0000196A  6600 FA00               1276          BNE     GRAB_NEXT_OP
0000196E                          1277          
0000196E                          1278          *else this was a source decoding, rts back to we can keep decoding
0000196E  4E75                    1279          RTS
00001970                          1280          
00001970                          1281  ImmediateDataMode
00001970                          1282          *some code        
00001970                          1283          
00001970                          1284          
00001970                          1285  *-----------------------------------------------------------        
00001970                          1286  * Output logic for all Data Registers (0-7)
00001970                          1287  *-----------------------------------------------------------
00001970                          1288  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001970                          1289  WrapperDataReg
00001970                          1290          *Depending on the EA destination register, output a different register number
00001970  B63C 0000               1291          CMP.B   #$00,D3
00001974  6700 003C               1292          BEQ     DataReg0
00001978                          1293          
00001978  B63C 0001               1294          CMP.B   #$01,D3
0000197C  6700 0044               1295          BEQ     DataReg1
00001980                          1296          
00001980  B63C 0002               1297          CMP.B   #$02,D3
00001984  6700 004C               1298          BEQ     DataReg2
00001988                          1299          
00001988  B63C 0003               1300          CMP.B   #$03,D3
0000198C  6700 0054               1301          BEQ     DataReg3
00001990                          1302          
00001990  B63C 0004               1303          CMP.B   #$04,D3
00001994  6700 005C               1304          BEQ     DataReg4
00001998                          1305          
00001998  B63C 0005               1306          CMP.B   #$05,D3
0000199C  6700 0064               1307          BEQ     DataReg5
000019A0                          1308          
000019A0  B63C 0006               1309          CMP.B   #$06,D3
000019A4  6700 006C               1310          BEQ     DataReg6
000019A8                          1311          
000019A8  B63C 0007               1312          CMP.B   #$07,D3
000019AC  6700 0074               1313          BEQ     DataReg7        
000019B0                          1314  
000019B0                          1315  *Used to get back to 'DataRegMode', after dealing with the specific register
000019B0                          1316  WrapperDataRegEnd
000019B0  4E75                    1317          RTS
000019B2                          1318  
000019B2                          1319  DataReg0
000019B2                          1320          *Output the specific data register...
000019B2  43F9 000023AF           1321          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
000019B8  103C 000E               1322          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000019BC  4E4F                    1323          TRAP    #15             *Displays Message   
000019BE                          1324          
000019BE  4EF8 19B0               1325          JMP     WrapperDataRegEnd
000019C2                          1326  
000019C2                          1327  DataReg1
000019C2  43F9 000023B2           1328          LEA     OutDataReg1,A1
000019C8  103C 000E               1329          MOVE.B  #14,D0
000019CC  4E4F                    1330          TRAP    #15
000019CE                          1331          
000019CE  4EF8 19B0               1332          JMP     WrapperDataRegEnd
000019D2                          1333  
000019D2                          1334  DataReg2
000019D2  43F9 000023B5           1335          LEA     OutDataReg2,A1
000019D8  103C 000E               1336          MOVE.B  #14,D0
000019DC  4E4F                    1337          TRAP    #15
000019DE                          1338  
000019DE  4EF8 19B0               1339          JMP     WrapperDataRegEnd
000019E2                          1340      
000019E2                          1341  DataReg3
000019E2  43F9 000023B8           1342          LEA     OutDataReg3,A1
000019E8  103C 000E               1343          MOVE.B  #14,D0
000019EC  4E4F                    1344          TRAP    #15
000019EE                          1345  
000019EE  4EF8 19B0               1346          JMP     WrapperDataRegEnd
000019F2                          1347          
000019F2                          1348  DataReg4
000019F2  43F9 000023BB           1349          LEA     OutDataReg4,A1
000019F8  103C 000E               1350          MOVE.B  #14,D0
000019FC  4E4F                    1351          TRAP    #15
000019FE                          1352  
000019FE  4EF8 19B0               1353          JMP     WrapperDataRegEnd
00001A02                          1354                 
00001A02                          1355  DataReg5
00001A02  43F9 000023BE           1356          LEA     OutDataReg5,A1
00001A08  103C 000E               1357          MOVE.B  #14,D0
00001A0C  4E4F                    1358          TRAP    #15
00001A0E                          1359  
00001A0E  4EF8 19B0               1360          JMP     WrapperDataRegEnd
00001A12                          1361          
00001A12                          1362  DataReg6
00001A12  43F9 000023C1           1363          LEA     OutDataReg6,A1 A1
00001A18  103C 000E               1364          MOVE.B  #14,D0
00001A1C  4E4F                    1365          TRAP    #15
00001A1E                          1366  
00001A1E  4EF8 19B0               1367          JMP     WrapperDataRegEnd
00001A22                          1368          
00001A22                          1369  DataReg7
00001A22  43F9 000023C4           1370          LEA     OutDataReg7,A1
00001A28  103C 000E               1371          MOVE.B  #14,D0
00001A2C  4E4F                    1372          TRAP    #15
00001A2E                          1373          
00001A2E  4EF8 19B0               1374          JMP     WrapperDataRegEnd
00001A32                          1375  
00001A32                          1376  
00001A32                          1377  *-----------------------------------------------------------        
00001A32                          1378  * Output logic for all Address Registers (0-7)
00001A32                          1379  *-----------------------------------------------------------     
00001A32                          1380  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001A32                          1381  WrapperAddrReg
00001A32                          1382          *Depending on the EA Register, output a different register number
00001A32  B63C 0000               1383          CMP.B   #$00,D3
00001A36  6700 003C               1384          BEQ     AddrReg0
00001A3A                          1385          
00001A3A  B63C 0001               1386          CMP.B   #$01,D3
00001A3E  6700 0044               1387          BEQ     AddrReg1
00001A42                          1388          
00001A42  B63C 0002               1389          CMP.B   #$02,D3
00001A46  6700 004C               1390          BEQ     AddrReg2
00001A4A                          1391          
00001A4A  B63C 0003               1392          CMP.B   #$03,D3
00001A4E  6700 0054               1393          BEQ     AddrReg3
00001A52                          1394          
00001A52  B63C 0004               1395          CMP.B   #$04,D3
00001A56  6700 005C               1396          BEQ     AddrReg4
00001A5A                          1397          
00001A5A  B63C 0005               1398          CMP.B   #$05,D3
00001A5E  6700 0064               1399          BEQ     AddrReg5
00001A62                          1400          
00001A62  B63C 0006               1401          CMP.B   #$06,D3
00001A66  6700 006C               1402          BEQ     AddrReg6
00001A6A                          1403          
00001A6A  B63C 0007               1404          CMP.B   #$07,D3
00001A6E  6700 0074               1405          BEQ     AddrReg7
00001A72                          1406  
00001A72                          1407  *Used to get back to 'AddrRegMode', after dealing with the specific register
00001A72                          1408  WrapperAddrRegEnd
00001A72  4E75                    1409          RTS        
00001A74                          1410  
00001A74                          1411  AddrReg0
00001A74                          1412          *Output the specific address indirect register...
00001A74  43F9 000023C7           1413          LEA     OutAddrReg0,A1      *Loads AddrReg0 into address register A1
00001A7A  103C 000E               1414          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001A7E  4E4F                    1415          TRAP    #15                 *Displays Message        
00001A80                          1416          
00001A80  4EF8 1A72               1417          JMP     WrapperAddrRegEnd
00001A84                          1418  
00001A84                          1419  AddrReg1
00001A84  43F9 000023CA           1420          LEA     OutAddrReg1,A1
00001A8A  103C 000E               1421          MOVE.B  #14,D0
00001A8E  4E4F                    1422          TRAP    #15
00001A90                          1423          
00001A90  4EF8 1A72               1424          JMP     WrapperAddrRegEnd
00001A94                          1425  
00001A94                          1426  AddrReg2
00001A94  43F9 000023CD           1427          LEA     OutAddrReg2,A1
00001A9A  103C 000E               1428          MOVE.B  #14,D0
00001A9E  4E4F                    1429          TRAP    #15
00001AA0                          1430          
00001AA0  4EF8 1A72               1431          JMP     WrapperAddrRegEnd
00001AA4                          1432  
00001AA4                          1433  AddrReg3
00001AA4  43F9 000023D0           1434          LEA     OutAddrReg3,A1
00001AAA  103C 000E               1435          MOVE.B  #14,D0
00001AAE  4E4F                    1436          TRAP    #15
00001AB0                          1437          
00001AB0  4EF8 1A72               1438          JMP     WrapperAddrRegEnd
00001AB4                          1439  
00001AB4                          1440  AddrReg4
00001AB4  43F9 000023D3           1441          LEA     OutAddrReg4,A1
00001ABA  103C 000E               1442          MOVE.B  #14,D0
00001ABE  4E4F                    1443          TRAP    #15
00001AC0                          1444          
00001AC0  4EF8 1A72               1445          JMP     WrapperAddrRegEnd
00001AC4                          1446  
00001AC4                          1447  AddrReg5
00001AC4  43F9 000023D6           1448          LEA     OutAddrReg5,A1
00001ACA  103C 000E               1449          MOVE.B  #14,D0
00001ACE  4E4F                    1450          TRAP    #15
00001AD0                          1451          
00001AD0  4EF8 1A72               1452          JMP     WrapperAddrRegEnd
00001AD4                          1453  
00001AD4                          1454  AddrReg6
00001AD4  43F9 000023D9           1455          LEA     OutAddrReg6,A1
00001ADA  103C 000E               1456          MOVE.B  #14,D0
00001ADE  4E4F                    1457          TRAP    #15
00001AE0                          1458          
00001AE0  4EF8 1A72               1459          JMP     WrapperAddrRegEnd
00001AE4                          1460  
00001AE4                          1461  AddrReg7
00001AE4  43F9 000023DC           1462          LEA     OutAddrReg7,A1
00001AEA  103C 000E               1463          MOVE.B  #14,D0
00001AEE  4E4F                    1464          TRAP    #15
00001AF0                          1465          
00001AF0  4EF8 1A72               1466          JMP     WrapperAddrRegEnd
00001AF4                          1467  
00001AF4                          1468  
00001AF4                          1469  *-----------------------------------------------------------        
00001AF4                          1470  * Output logic for all Address Indirect Registers (0-7)
00001AF4                          1471  *-----------------------------------------------------------     
00001AF4                          1472  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001AF4                          1473  WrapperAddrIndirect
00001AF4                          1474          *Depending on the EA Register, output a different register number
00001AF4  B63C 0000               1475          CMP.B   #$00,D3
00001AF8  6700 003C               1476          BEQ     AddrIndReg0
00001AFC                          1477          
00001AFC  B63C 0001               1478          CMP.B   #$01,D3
00001B00  6700 0044               1479          BEQ     AddrIndReg1
00001B04                          1480          
00001B04  B63C 0002               1481          CMP.B   #$02,D3
00001B08  6700 004C               1482          BEQ     AddrIndReg2
00001B0C                          1483          
00001B0C  B63C 0003               1484          CMP.B   #$03,D3
00001B10  6700 0054               1485          BEQ     AddrIndReg3
00001B14                          1486          
00001B14  B63C 0004               1487          CMP.B   #$04,D3
00001B18  6700 005C               1488          BEQ     AddrIndReg4
00001B1C                          1489          
00001B1C  B63C 0005               1490          CMP.B   #$05,D3
00001B20  6700 0064               1491          BEQ     AddrIndReg5
00001B24                          1492          
00001B24  B63C 0006               1493          CMP.B   #$06,D3
00001B28  6700 006C               1494          BEQ     AddrIndReg6
00001B2C                          1495          
00001B2C  B63C 0007               1496          CMP.B   #$07,D3
00001B30  6700 0074               1497          BEQ     AddrIndReg7
00001B34                          1498  
00001B34                          1499  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
00001B34                          1500  WrapperAddrIndirectEnd
00001B34  4E75                    1501          RTS        
00001B36                          1502  
00001B36                          1503  AddrIndReg0
00001B36                          1504          *Output the specific address indirect register...
00001B36  43F9 000023DF           1505          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001B3C  103C 000E               1506          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001B40  4E4F                    1507          TRAP    #15                 *Displays Message        
00001B42                          1508          
00001B42  4EF8 1B34               1509          JMP     WrapperAddrIndirectEnd
00001B46                          1510  
00001B46                          1511  AddrIndReg1
00001B46  43F9 000023E4           1512          LEA     OutAddrIndReg1,A1
00001B4C  103C 000E               1513          MOVE.B  #14,D0
00001B50  4E4F                    1514          TRAP    #15
00001B52                          1515          
00001B52  4EF8 1B34               1516          JMP     WrapperAddrIndirectEnd
00001B56                          1517  
00001B56                          1518  AddrIndReg2
00001B56  43F9 000023E9           1519          LEA     OutAddrIndReg2,A1
00001B5C  103C 000E               1520          MOVE.B  #14,D0
00001B60  4E4F                    1521          TRAP    #15
00001B62                          1522          
00001B62  4EF8 1B34               1523          JMP     WrapperAddrIndirectEnd
00001B66                          1524  
00001B66                          1525  AddrIndReg3
00001B66  43F9 000023EE           1526          LEA     OutAddrIndReg3,A1
00001B6C  103C 000E               1527          MOVE.B  #14,D0
00001B70  4E4F                    1528          TRAP    #15
00001B72                          1529          
00001B72  4EF8 1B34               1530          JMP     WrapperAddrIndirectEnd
00001B76                          1531  
00001B76                          1532  AddrIndReg4
00001B76  43F9 000023F3           1533          LEA     OutAddrIndReg4,A1
00001B7C  103C 000E               1534          MOVE.B  #14,D0
00001B80  4E4F                    1535          TRAP    #15
00001B82                          1536          
00001B82  4EF8 1B34               1537          JMP     WrapperAddrIndirectEnd
00001B86                          1538  
00001B86                          1539  AddrIndReg5
00001B86  43F9 000023F8           1540          LEA     OutAddrIndReg5,A1
00001B8C  103C 000E               1541          MOVE.B  #14,D0
00001B90  4E4F                    1542          TRAP    #15
00001B92                          1543          
00001B92  4EF8 1B34               1544          JMP     WrapperAddrIndirectEnd
00001B96                          1545  
00001B96                          1546  AddrIndReg6
00001B96  43F9 000023FD           1547          LEA     OutAddrIndReg6,A1
00001B9C  103C 000E               1548          MOVE.B  #14,D0
00001BA0  4E4F                    1549          TRAP    #15
00001BA2                          1550          
00001BA2  4EF8 1B34               1551          JMP     WrapperAddrIndirectEnd
00001BA6                          1552  
00001BA6                          1553  AddrIndReg7
00001BA6  43F9 00002402           1554          LEA     OutAddrIndReg7,A1
00001BAC  103C 000E               1555          MOVE.B  #14,D0
00001BB0  4E4F                    1556          TRAP    #15
00001BB2                          1557          
00001BB2  4EF8 1B34               1558          JMP     WrapperAddrIndirectEnd
00001BB6                          1559          
00001BB6                          1560          
00001BB6                          1561  *-----------------------------------------------------------        
00001BB6                          1562  * Output logic for all Address Indirect Post Increment Registers (0-7)
00001BB6                          1563  *-----------------------------------------------------------     
00001BB6                          1564  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001BB6                          1565  WrapperAddrIndirectPost
00001BB6                          1566          *Depending on the EA Register, output a different register number
00001BB6  B63C 0000               1567          CMP.B   #$00,D3
00001BBA  6700 003C               1568          BEQ     AddrIndPoReg0
00001BBE                          1569          
00001BBE  B63C 0001               1570          CMP.B   #$01,D3
00001BC2  6700 0044               1571          BEQ     AddrIndPoReg1
00001BC6                          1572          
00001BC6  B63C 0002               1573          CMP.B   #$02,D3
00001BCA  6700 004C               1574          BEQ     AddrIndPoReg2
00001BCE                          1575          
00001BCE  B63C 0003               1576          CMP.B   #$03,D3
00001BD2  6700 0054               1577          BEQ     AddrIndPoReg3
00001BD6                          1578          
00001BD6  B63C 0004               1579          CMP.B   #$04,D3
00001BDA  6700 005C               1580          BEQ     AddrIndPoReg4
00001BDE                          1581          
00001BDE  B63C 0005               1582          CMP.B   #$05,D3
00001BE2  6700 0064               1583          BEQ     AddrIndPoReg5
00001BE6                          1584          
00001BE6  B63C 0006               1585          CMP.B   #$06,D3
00001BEA  6700 006C               1586          BEQ     AddrIndPoReg6
00001BEE                          1587          
00001BEE  B63C 0007               1588          CMP.B   #$07,D3
00001BF2  6700 0074               1589          BEQ     AddrIndPoReg7
00001BF6                          1590  
00001BF6                          1591  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
00001BF6                          1592  WrapperAddrIndirectPostEnd
00001BF6  4E75                    1593          RTS        
00001BF8                          1594  
00001BF8                          1595  AddrIndPoReg0
00001BF8                          1596          *Output the specific address indirect post register...
00001BF8  43F9 00002407           1597          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001BFE  103C 000E               1598          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001C02  4E4F                    1599          TRAP    #15                 *Displays Message        
00001C04                          1600          
00001C04  4EF8 1BF6               1601          JMP     WrapperAddrIndirectPostEnd
00001C08                          1602  
00001C08                          1603  AddrIndPoReg1
00001C08  43F9 0000240D           1604          LEA     OutAddrIndPoReg1,A1
00001C0E  103C 000E               1605          MOVE.B  #14,D0
00001C12  4E4F                    1606          TRAP    #15
00001C14                          1607          
00001C14  4EF8 1BF6               1608          JMP     WrapperAddrIndirectPostEnd
00001C18                          1609  
00001C18                          1610  AddrIndPoReg2
00001C18  43F9 00002413           1611          LEA     OutAddrIndPoReg2,A1
00001C1E  103C 000E               1612          MOVE.B  #14,D0
00001C22  4E4F                    1613          TRAP    #15
00001C24                          1614          
00001C24  4EF8 1BF6               1615          JMP     WrapperAddrIndirectPostEnd
00001C28                          1616  
00001C28                          1617  AddrIndPoReg3
00001C28  43F9 00002419           1618          LEA     OutAddrIndPoReg3,A1
00001C2E  103C 000E               1619          MOVE.B  #14,D0
00001C32  4E4F                    1620          TRAP    #15
00001C34                          1621          
00001C34  4EF8 1BF6               1622          JMP     WrapperAddrIndirectPostEnd
00001C38                          1623  
00001C38                          1624  AddrIndPoReg4
00001C38  43F9 0000241F           1625          LEA     OutAddrIndPoReg4,A1
00001C3E  103C 000E               1626          MOVE.B  #14,D0
00001C42  4E4F                    1627          TRAP    #15
00001C44                          1628          
00001C44  4EF8 1BF6               1629          JMP     WrapperAddrIndirectPostEnd
00001C48                          1630  
00001C48                          1631  AddrIndPoReg5
00001C48  43F9 00002425           1632          LEA     OutAddrIndPoReg5,A1
00001C4E  103C 000E               1633          MOVE.B  #14,D0
00001C52  4E4F                    1634          TRAP    #15
00001C54                          1635          
00001C54  4EF8 1BF6               1636          JMP     WrapperAddrIndirectPostEnd
00001C58                          1637  
00001C58                          1638  AddrIndPoReg6
00001C58  43F9 0000242B           1639          LEA     OutAddrIndPoReg6,A1
00001C5E  103C 000E               1640          MOVE.B  #14,D0
00001C62  4E4F                    1641          TRAP    #15
00001C64                          1642          
00001C64  4EF8 1BF6               1643          JMP     WrapperAddrIndirectPostEnd
00001C68                          1644  
00001C68                          1645  AddrIndPoReg7
00001C68  43F9 00002431           1646          LEA     OutAddrIndPoReg7,A1
00001C6E  103C 000E               1647          MOVE.B  #14,D0
00001C72  4E4F                    1648          TRAP    #15
00001C74                          1649          
00001C74  4EF8 1BF6               1650          JMP     WrapperAddrIndirectPostEnd
00001C78                          1651  
00001C78                          1652  
00001C78                          1653  *-----------------------------------------------------------        
00001C78                          1654  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001C78                          1655  *-----------------------------------------------------------     
00001C78                          1656  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001C78                          1657  WrapperAddrIndirectPre
00001C78                          1658          *Depending on the EA Register, output a different register number
00001C78  B63C 0000               1659          CMP.B   #$00,D3
00001C7C  6700 003C               1660          BEQ     AddrIndPrReg0
00001C80                          1661          
00001C80  B63C 0001               1662          CMP.B   #$01,D3
00001C84  6700 0044               1663          BEQ     AddrIndPrReg1
00001C88                          1664          
00001C88  B63C 0002               1665          CMP.B   #$02,D3
00001C8C  6700 004C               1666          BEQ     AddrIndPrReg2
00001C90                          1667          
00001C90  B63C 0003               1668          CMP.B   #$03,D3
00001C94  6700 0054               1669          BEQ     AddrIndPrReg3
00001C98                          1670          
00001C98  B63C 0004               1671          CMP.B   #$04,D3
00001C9C  6700 005C               1672          BEQ     AddrIndPrReg4
00001CA0                          1673          
00001CA0  B63C 0005               1674          CMP.B   #$05,D3
00001CA4  6700 0064               1675          BEQ     AddrIndPrReg5
00001CA8                          1676          
00001CA8  B63C 0006               1677          CMP.B   #$06,D3
00001CAC  6700 006C               1678          BEQ     AddrIndPrReg6
00001CB0                          1679          
00001CB0  B63C 0007               1680          CMP.B   #$07,D3
00001CB4  6700 0074               1681          BEQ     AddrIndPrReg7
00001CB8                          1682  
00001CB8                          1683  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001CB8                          1684  WrapperAddrIndirectPreEnd
00001CB8  4E75                    1685          RTS        
00001CBA                          1686  
00001CBA                          1687  AddrIndPrReg0
00001CBA                          1688          *Output the specific address indirect post register...
00001CBA  43F9 00002437           1689          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001CC0  103C 000E               1690          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001CC4  4E4F                    1691          TRAP    #15                 *Displays Message        
00001CC6                          1692          
00001CC6  4EF8 1CB8               1693          JMP     WrapperAddrIndirectPreEnd
00001CCA                          1694  
00001CCA                          1695  AddrIndPrReg1
00001CCA  43F9 0000243D           1696          LEA     OutAddrIndPrReg1,A1
00001CD0  103C 000E               1697          MOVE.B  #14,D0
00001CD4  4E4F                    1698          TRAP    #15
00001CD6                          1699          
00001CD6  4EF8 1CB8               1700          JMP     WrapperAddrIndirectPreEnd
00001CDA                          1701  
00001CDA                          1702  AddrIndPrReg2
00001CDA  43F9 00002443           1703          LEA     OutAddrIndPrReg2,A1
00001CE0  103C 000E               1704          MOVE.B  #14,D0
00001CE4  4E4F                    1705          TRAP    #15
00001CE6                          1706          
00001CE6  4EF8 1CB8               1707          JMP     WrapperAddrIndirectPreEnd
00001CEA                          1708  
00001CEA                          1709  AddrIndPrReg3
00001CEA  43F9 00002449           1710          LEA     OutAddrIndPrReg3,A1
00001CF0  103C 000E               1711          MOVE.B  #14,D0
00001CF4  4E4F                    1712          TRAP    #15
00001CF6                          1713          
00001CF6  4EF8 1CB8               1714          JMP     WrapperAddrIndirectPreEnd
00001CFA                          1715  
00001CFA                          1716  AddrIndPrReg4
00001CFA  43F9 0000244F           1717          LEA     OutAddrIndPrReg4,A1
00001D00  103C 000E               1718          MOVE.B  #14,D0
00001D04  4E4F                    1719          TRAP    #15
00001D06                          1720          
00001D06  4EF8 1CB8               1721          JMP     WrapperAddrIndirectPreEnd
00001D0A                          1722  
00001D0A                          1723  AddrIndPrReg5
00001D0A  43F9 00002455           1724          LEA     OutAddrIndPrReg5,A1
00001D10  103C 000E               1725          MOVE.B  #14,D0
00001D14  4E4F                    1726          TRAP    #15
00001D16                          1727          
00001D16  4EF8 1CB8               1728          JMP     WrapperAddrIndirectPreEnd
00001D1A                          1729  
00001D1A                          1730  AddrIndPrReg6
00001D1A  43F9 0000245B           1731          LEA     OutAddrIndPrReg6,A1
00001D20  103C 000E               1732          MOVE.B  #14,D0
00001D24  4E4F                    1733          TRAP    #15
00001D26                          1734          
00001D26  4EF8 1CB8               1735          JMP     WrapperAddrIndirectPreEnd
00001D2A                          1736  
00001D2A                          1737  AddrIndPrReg7
00001D2A  43F9 00002461           1738          LEA     OutAddrIndPrReg7,A1
00001D30  103C 000E               1739          MOVE.B  #14,D0
00001D34  4E4F                    1740          TRAP    #15
00001D36                          1741          
00001D36  4EF8 1CB8               1742          JMP     WrapperAddrIndirectPreEnd
00001D3A                          1743  
00001D3A                          1744  
00001D3A                          1745  *-----------------------------------------------------------        
00001D3A                          1746  * Output logic for absolute memory addressing (0-7)
00001D3A                          1747  *-----------------------------------------------------------     
00001D3A                          1748  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001D3A                          1749  WrapperAddrAbsolute
00001D3A  4284                    1750          CLR.L   D4
00001D3C                          1751          *Depending on the EA Register, choose which size to decode
00001D3C  B63C 0000               1752          CMP.B   #$00,D3
00001D40  6700 000C               1753          BEQ     WordSizeAbsolute
00001D44                          1754  
00001D44  B63C 0001               1755          CMP.B   #$01,D3
00001D48  6700 0028               1756          BEQ     LongSizeAbsolute
00001D4C                          1757          
00001D4C                          1758  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001D4C                          1759  WrapperAddrAbsoluteEnd
00001D4C  4E75                    1760          RTS
00001D4E                          1761  
00001D4E                          1762  WordSizeAbsolute        
00001D4E  3818                    1763          MOVE.W  (A0)+,D4    *read in next word, data is that word        
00001D50                          1764              
00001D50                          1765          *Output ',$' just after source operand
00001D50  43F9 00002474           1766          LEA     Bang,A1
00001D56  103C 000E               1767          MOVE.B  #14,D0
00001D5A  4E4F                    1768          TRAP    #15
00001D5C                          1769              
00001D5C                          1770          *Push D1 into stack, in case something was using it
00001D5C  48E7 4000               1771          MOVEM.L D1,-(SP)
00001D60                          1772          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001D60  4281                    1773          CLR.L   D1
00001D62  123C 0001               1774          MOVE.B  #$01,D1
00001D66                          1775              
00001D66                          1776          *output the absolute mem address to console with the hex-ascii converter
00001D66  4EB8 11E6               1777          JSR     HEXASCII
00001D6A  4CDF 0002               1778          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001D6E                          1779          
00001D6E  4EF8 1D4C               1780          JMP     WrapperAddrAbsoluteEnd
00001D72                          1781  
00001D72                          1782  LongSizeAbsolute
00001D72  2818                    1783          MOVE.L  (A0)+,D4    *read in next long, data is that long                
00001D74                          1784                  
00001D74                          1785          *Output ',$' just after source operand
00001D74  43F9 00002474           1786          LEA     Bang,A1
00001D7A  103C 000E               1787          MOVE.B  #14,D0
00001D7E  4E4F                    1788          TRAP    #15  
00001D80                          1789          
00001D80                          1790          *Push D1 into stack, in case something was using it
00001D80  48E7 4000               1791          MOVEM.L D1,-(SP)
00001D84                          1792          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001D84  4281                    1793          CLR.L   D1
00001D86  123C 0010               1794          MOVE.B  #$10,D1
00001D8A                          1795              
00001D8A                          1796          *output the absolute mem address to console with the hex-ascii converter
00001D8A  4EB8 11E6               1797          JSR     HEXASCII
00001D8E  4CDF 0002               1798          MOVEM.L (SP)+,D1    *Pull D1 back out from the stack
00001D92                          1799          
00001D92  4EF8 1D4C               1800          JMP     WrapperAddrAbsoluteEnd
00001D96                          1801          
00001D96                          1802  
00001D96                          1803  *-----------------------------------------------------------        
00001D96                          1804  * Current handling of bad op/ea codes. Should be revisited.
00001D96                          1805  *----------------------------------------------------------- 
00001D96                          1806  BADOPCODE
00001D96                          1807          *We found a bad op code, output some error to the screen, jump to the 
00001D96                          1808          *next instruction in memory.
00001D96                          1809          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001D96                          1810          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001D96                          1811          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001D96                          1812          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001D96                          1813          *i/o and error message code...
00001D96  43F9 0000247D           1814          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001D9C  103C 000E               1815          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001DA0  4E4F                    1816          TRAP    #15         *Displays Message
00001DA2  4EF8 136C               1817          JMP     GRAB_NEXT_OP
00001DA6                          1818                  
00001DA6                          1819  BADEACODE
00001DA6                          1820          *We found a bad ea code, output some error to the screen, jump to the
00001DA6                          1821          *next instruction in memory.
00001DA6                          1822          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001DA6                          1823          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001DA6  43F9 00002476           1824          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001DAC  103C 000E               1825          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001DB0  4E4F                    1826          TRAP    #15         *Displays Message
00001DB2  4EF8 136C               1827          JMP     GRAB_NEXT_OP
00001DB6                          1828          
00001DB6                          1829          
00001DB6                          1830  *-----------------------------------------------------------        
00001DB6                          1831  * End of Disassembler
00001DB6                          1832  *-----------------------------------------------------------    
00001DB6                          1833  
00001DB6  4E72 2700               1834  DONE    STOP    #$2700  *What does this do? Why was it added?
00001DBA                          1835  
00001DBA  103C 0009               1836  THEEND  MOVE.B  #9,D0
00001DBE  4E4F                    1837          TRAP    #15             Halt Simulator        
00001DC0                          1838          
00001DC0                          1839       
00001DC0                          1840  *-----------------------------------------------------------        
00001DC0                          1841  * Output stuff
00001DC0                          1842  *-----------------------------------------------------------     
00001DC0  =0000000D               1843  CR      EQU     $0D             ASCII code for Carriage Return
00001DC0  =0000000A               1844  LF      EQU     $0A             ASCII code for Line Feed
00001DC0= 2D 2D 2D 2D 2D 2D ...   1845  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001DFF= 7C 7C 20 20 20 20 ...   1846              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001E3E= 2D 2D 2D 2D 2D 2D ...   1847              DC.B    '-------------------------------------------------------------',CR,LF
00001E7D= 2A 2A 2A 2A 2A 2A ...   1848              DC.B    '*************************************************************',CR,LF
00001EBC= 2A 2A 2A 2A 2A 2A ...   1849              DC.B    '*************************************************************',CR,LF
00001EFB= 2A 2A 2A 2A 2A 2A ...   1850              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001F3A= 2A 2A 2A 2A 2A 2A ...   1851              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001F79= 2A 2A 2A 2A 2A 2A ...   1852              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001FB8= 2A 2A 2A 2A 2A 2A ...   1853              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001FF7= 2A 2A 2A 2A 2A 2A ...   1854              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00002036= 2A 2A 2A 2A 2A 2A ...   1855              DC.B    '*************************************************************',CR,LF
00002075= 2A 2A 2A 2A 2A 2A ...   1856              DC.B    '*************************************************************',CR,LF
000020B4= 2A 20 20 20 20 20 ...   1857              DC.B    '*                                                           *',CR,LF
000020F3= 2A 20 41 75 74 68 ...   1858              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00002132= 2A 20 20 20 20 20 ...   1859              DC.B    '*                                                           *',CR,LF
00002171= 2A 2A 2A 2A 2A 2A ...   1860              DC.B    '*************************************************************',CR,LF,CR,LF
000021B2= 53 74 61 72 74 69 ...   1861              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
000021CF                          1862              
000021CF= 57 6F 75 6C 64 20 ...   1863  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00002200                          1864  
00002200= 20 0D 0A                1865  GETSTRTADDR DC.B    ' ',CR,LF
00002203= 50 6C 65 61 73 65 ...   1866              DC.B    'Please type in your starting address request: ',0
00002232                          1867              
00002232= 20 0D 0A                1868  GETENDADDR  DC.B    ' ',CR,LF
00002235= 50 6C 65 61 73 65 ...   1869              DC.B    'Please type in your ending address request: ',0
00002262                          1870              
00002262= 20 0D 0A                1871  QUES_CONT   DC.B    ' ',CR,LF
00002265= 57 6F 75 6C 64 20 ...   1872              DC.B    'Would you like to continue (Y/N)? ',0
00002288                          1873              
00002288= 20 0D 0A                1874  QUIT_MSG    DC.B    ' ',CR,LF
0000228B= 57 6F 75 6C 64 20 ...   1875              DC.B    'Would you like to quit (Y/N)? ',0
000022AA                          1876  
000022AA                          1877  *****************************************************
000022AA                          1878  * I/O storages - assuming users knows what to do.
000022AA                          1879  *****************************************************
000022AA                          1880  CMD_HLD     DS.B    30
000022C8                          1881  CMD_SZ      DS.B    30
000022E6                          1882  STADDR      DS.B    10
000022F0                          1883  STADDRSZ    DS.B    10
000022FA                          1884  PROGST      DS.L    1
000022FE                          1885  ENDADDR     DS.B    10
00002308                          1886  ENDADDRSZ   DS.B    10
00002312                          1887  PROGEND     DS.L    1
00002316                          1888  CONT        DS.B    30
00002334                          1889  *****************************************************
00002334                          1890  
00002334                          1891  *Table for 0-9 && A-F
00002334= 30 00                   1892  PRNT0   DC.B    '0',0
00002336= 31 00                   1893  PRNT1   DC.B    '1',0
00002338= 32 00                   1894  PRNT2   DC.B    '2',0
0000233A= 33 00                   1895  PRNT3   DC.B    '3',0
0000233C= 34 00                   1896  PRNT4   DC.B    '4',0
0000233E= 35 00                   1897  PRNT5   DC.B    '5',0
00002340= 36 00                   1898  PRNT6   DC.B    '6',0
00002342= 37 00                   1899  PRNT7   DC.B    '7',0
00002344= 38 00                   1900  PRNT8   DC.B    '8',0
00002346= 39 00                   1901  PRNT9   DC.B    '9',0
00002348= 41 00                   1902  PRNTA   DC.B    'A',0
0000234A= 42 00                   1903  PRNTB   DC.B    'B',0
0000234C= 43 00                   1904  PRNTC   DC.B    'C',0
0000234E= 44 00                   1905  PRNTD   DC.B    'D',0
00002350= 45 00                   1906  PRNTE   DC.B    'E',0
00002352= 46 00                   1907  PRNTF   DC.B    'F',0
00002354                          1908  
00002354                          1909  *output for all OPCODEs
00002354                          1910  *Bucket 0000
00002354= 41 44 44 49 00          1911  ADDI    DC.B    'ADDI',0
00002359= 41 4E 44 49 00          1912  ANDI    DC.B    'ANDI',0
0000235E= 45 4F 52 49 00          1913  EORI    DC.B    'EORI',0
00002363= 42 43 48 47 00          1914  BCHG    DC.B    'BCHG',0
00002368= 43 4D 50 49 00          1915  CMPI    DC.B    'CMPI',0
0000236D                          1916  *Bucket 0100
0000236D= 4D 4F 56 45 4D 00       1917  MOVEM   DC.B    'MOVEM',0
00002373= 4D 55 4C 53 00          1918  MULS    DC.B    'MULS',0
00002378= 4C 45 41 20 20 20 ...   1919  LEA     DC.B    'LEA      ',0   *Need spaces here since LEA has no size
00002382= 43 4C 52 00             1920  CLR     DC.B    'CLR',0
00002386= 4A 53 52 20 20 20 ...   1921  JSR     DC.B    'JSR      ',0   *Need spaces here since JSR has no size
00002390= 52 54 53 20 20 20 ...   1922  RTS     DC.B    'RTS      ',0   *Need spaces here since RTS has no size
0000239A                          1923  
0000239A                          1924  *output for the size of the operation
0000239A= 2E 42 20 20 20 20 00    1925  ByteSize    DC.B    '.B    ',0
000023A1= 2E 57 20 20 20 20 00    1926  WordSize    DC.B    '.W    ',0
000023A8= 2E 4C 20 20 20 20 00    1927  LongSize    DC.B    '.L    ',0
000023AF                          1928  
000023AF                          1929  *output for all data registers (0-7)
000023AF= 44 30 00                1930  OutDataReg0 DC.B    'D0',0
000023B2= 44 31 00                1931  OutDataReg1 DC.B    'D1',0
000023B5= 44 32 00                1932  OutDataReg2 DC.B    'D2',0
000023B8= 44 33 00                1933  OutDataReg3 DC.B    'D3',0
000023BB= 44 34 00                1934  OutDataReg4 DC.B    'D4',0
000023BE= 44 35 00                1935  OutDataReg5 DC.B    'D5',0
000023C1= 44 36 00                1936  OutDataReg6 DC.B    'D6',0
000023C4= 44 37 00                1937  OutDataReg7 DC.B    'D7',0
000023C7                          1938  
000023C7                          1939  *output for all address registers (0-7)
000023C7= 41 30 00                1940  OutAddrReg0 DC.B    'A0',0
000023CA= 41 31 00                1941  OutAddrReg1 DC.B    'A1',0
000023CD= 41 32 00                1942  OutAddrReg2 DC.B    'A2',0
000023D0= 41 33 00                1943  OutAddrReg3 DC.B    'A3',0
000023D3= 41 34 00                1944  OutAddrReg4 DC.B    'A4',0
000023D6= 41 35 00                1945  OutAddrReg5 DC.B    'A5',0
000023D9= 41 36 00                1946  OutAddrReg6 DC.B    'A6',0
000023DC= 41 37 00                1947  OutAddrReg7 DC.B    'A7',0
000023DF                          1948          
000023DF                          1949  *output for all address indirect registers (0-7)
000023DF= 28 41 30 29 00          1950  OutAddrIndReg0  DC.B    '(A0)',0
000023E4= 28 41 31 29 00          1951  OutAddrIndReg1  DC.B    '(A1)',0
000023E9= 28 41 32 29 00          1952  OutAddrIndReg2  DC.B    '(A2)',0
000023EE= 28 41 33 29 00          1953  OutAddrIndReg3  DC.B    '(A3)',0
000023F3= 28 41 34 29 00          1954  OutAddrIndReg4  DC.B    '(A4)',0
000023F8= 28 41 35 29 00          1955  OutAddrIndReg5  DC.B    '(A5)',0
000023FD= 28 41 36 29 00          1956  OutAddrIndReg6  DC.B    '(A6)',0
00002402= 28 41 37 29 00          1957  OutAddrIndReg7  DC.B    '(A7)',0
00002407                          1958  
00002407                          1959  *output for all address indirect post registers (0-7)
00002407= 28 41 30 29 2B 00       1960  OutAddrIndPoReg0    DC.B    '(A0)+',0
0000240D= 28 41 31 29 2B 00       1961  OutAddrIndPoReg1    DC.B    '(A1)+',0
00002413= 28 41 32 29 2B 00       1962  OutAddrIndPoReg2    DC.B    '(A2)+',0
00002419= 28 41 33 29 2B 00       1963  OutAddrIndPoReg3    DC.B    '(A3)+',0
0000241F= 28 41 34 29 2B 00       1964  OutAddrIndPoReg4    DC.B    '(A4)+',0
00002425= 28 41 35 29 2B 00       1965  OutAddrIndPoReg5    DC.B    '(A5)+',0
0000242B= 28 41 36 29 2B 00       1966  OutAddrIndPoReg6    DC.B    '(A6)+',0
00002431= 28 41 37 29 2B 00       1967  OutAddrIndPoReg7    DC.B    '(A7)+',0
00002437                          1968  
00002437                          1969  *output for all address indirect pre registers (0-7)
00002437= 2D 28 41 30 29 00       1970  OutAddrIndPrReg0    DC.B    '-(A0)',0
0000243D= 2D 28 41 31 29 00       1971  OutAddrIndPrReg1    DC.B    '-(A1)',0
00002443= 2D 28 41 32 29 00       1972  OutAddrIndPrReg2    DC.B    '-(A2)',0
00002449= 2D 28 41 33 29 00       1973  OutAddrIndPrReg3    DC.B    '-(A3)',0
0000244F= 2D 28 41 34 29 00       1974  OutAddrIndPrReg4    DC.B    '-(A4)',0
00002455= 2D 28 41 35 29 00       1975  OutAddrIndPrReg5    DC.B    '-(A5)',0
0000245B= 2D 28 41 36 29 00       1976  OutAddrIndPrReg6    DC.B    '-(A6)',0
00002461= 2D 28 41 37 29 00       1977  OutAddrIndPrReg7    DC.B    '-(A7)',0
00002467                          1978  
00002467                          1979  *output for a tab only (4 spaces)
00002467= 20 20 20 20 00          1980  Tab DC.B    '    ',0
0000246C                          1981  
0000246C                          1982  *output for a comma only
0000246C= 2C 00                   1983  Comma   DC.B    ',',0
0000246E                          1984  
0000246E                          1985  *output for a new line only
0000246E= 0D 0A 00                1986  NewLine DC.B    CR,LF,0
00002471                          1987  
00002471                          1988  *output for a '#$' and '$' only
00002471= 23 24 00                1989  ShaBang DC.B    '#$',0
00002474= 24 00                   1990  Bang    DC.B    '$',0
00002476                          1991  
00002476                          1992  *current output for error messages
00002476= 42 41 44 20 45 41 00    1993  BADEAMSG    DC.B    'BAD EA',0
0000247D= 42 41 44 20 4F 50 00    1994  BADOPMSG    DC.B    'BAD OP',0
00002484= 49 6D 70 72 6F 70 ...   1995  INV_MSG     DC.B    'Improper command.',CR,LF,0
00002498= 49 6E 76 61 6C 69 ...   1996  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
000024B1= 49 6E 76 61 6C 69 ...   1997  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
000024C8                          1998  
000024C8                          1999          
000024C8                          2000          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                2354
ADDRABSOLUTEMODE    1960
ADDRINDIRECTMODE    1930
ADDRINDIRECTPOSTMODE  1940
ADDRINDIRECTPREMODE  1950
ADDRINDPOREG0       1BF8
ADDRINDPOREG1       1C08
ADDRINDPOREG2       1C18
ADDRINDPOREG3       1C28
ADDRINDPOREG4       1C38
ADDRINDPOREG5       1C48
ADDRINDPOREG6       1C58
ADDRINDPOREG7       1C68
ADDRINDPRREG0       1CBA
ADDRINDPRREG1       1CCA
ADDRINDPRREG2       1CDA
ADDRINDPRREG3       1CEA
ADDRINDPRREG4       1CFA
ADDRINDPRREG5       1D0A
ADDRINDPRREG6       1D1A
ADDRINDPRREG7       1D2A
ADDRINDREG0         1B36
ADDRINDREG1         1B46
ADDRINDREG2         1B56
ADDRINDREG3         1B66
ADDRINDREG4         1B76
ADDRINDREG5         1B86
ADDRINDREG6         1B96
ADDRINDREG7         1BA6
ADDRREG0            1A74
ADDRREG1            1A84
ADDRREG2            1A94
ADDRREG3            1AA4
ADDRREG4            1AB4
ADDRREG5            1AC4
ADDRREG6            1AD4
ADDRREG7            1AE4
ADDRREGMODE         1920
ANDI                2359
ASCIIHEX            1174
ASCIIHEX1           1178
BADEACODE           1DA6
BADEAMSG            2476
BADOPCODE           1D96
BADOPMSG            247D
BANG                2474
BCHG                2363
BCHGBYTESIZE        18D8
BCHGIMMEDIATE       18E8
BCHGLONGSIZE        18C8
BCHGSIZEHELPER      18B8
BCHGSIZEHELPEREND   18C6
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         1416
BUCKET_0001         1764
BUCKET_0010         1764
BUCKET_0011         1764
BUCKET_0100         1764
BUCKET_0101         1830
BUCKET_0110         1830
BUCKET_1000         1830
BUCKET_1001         1830
BUCKET_1011         1830
BUCKET_1100         1830
BUCKET_1101         1830
BUCKET_1110         1830
BYTESIZE            239A
BYTESIZEIMMEDIATE   1852
CHECK               11EA
CHECKEND1           10FA
CHECKSTRT1          10E4
CHECK_LOWN          112C
CHECK_LOWY          111A
CHECK_N             13F0
CHECK_UPN           1124
CHECK_UPY           1110
CHECK_Y             13E2
CHNG_SZB            121C
CHNG_SZL            1202
CHNG_SZW            1236
CLR                 2382
CMD_HLD             22AA
CMD_SZ              22C8
CMPI                2368
COMMA               246C
CONT                2316
CONT_Q              13B0
CONV_LOL            11D4
CONV_LOOP           1250
CONV_NUM            11C0
CONV_UPL            11CA
CR                  D
DATAREG0            19B2
DATAREG1            19C2
DATAREG2            19D2
DATAREG3            19E2
DATAREG4            19F2
DATAREG5            1A02
DATAREG6            1A12
DATAREG7            1A22
DATAREGMODE         1910
DONE                1DB6
EA_ADDI             14A2
EA_ANDI             1518
EA_BCHG_D           1610
EA_BCHG_S           16A8
EA_CLR              1830
EA_CMPI             1724
EA_EORI             158E
EA_JSR              1830
EA_LEA              17FA
EA_LEA_WRAPPEREND   1812
EA_MOVEM            17B8
EA_MULS_L           17B8
EA_RTS              1830
ENDADDR             22FE
ENDADDRSZ           2308
EORI                235E
EXITSUB             11E0
EXIT_CONV           12D6
GETENDADDR          2232
GETSTRTADDR         2200
GET_END             108C
GET_STRT            103E
GRAB_NEXT_OP        136C
HEXASCII            11E6
HEXASCIIREG         11FE
IMMEDIATEDATAMODE   1970
INV2                1400
INVALID1            1134
INVENDMSG           24B1
INVSTRTMSG          2498
INV_END1            1160
INV_MSG             2484
INV_STRT1           114C
IS_ADDI             146C
IS_ANDI             14E2
IS_BCHG_D           15CE
IS_BCHG_S           166C
IS_CLR              1830
IS_CMPI             16EE
IS_EORI             1558
IS_JSR              1830
IS_LEA              17B8
IS_MOVEM            17B8
IS_MULS_L           17B8
IS_RTS              1830
JSR                 2386
LEA                 2378
LEA_ADDRABSOLUTEWRAPPER  1906
LEA_ADDRINDIRECTWRAPPER  18FC
LF                  A
LONGSIZE            23A8
LONGSIZEABSOLUTE    1D72
LONGSIZEIMMEDIATE   1896
LOOP_1              1014
LOOP_B              1220
LOOP_L              1206
LOOP_W              123A
MAX_LINE            F
MESSAGE             1DC0
MOVEM               236D
MULS                2373
NEWLINE             246E
NUM_0               12E4
NUM_1               12EC
NUM_2               12F4
NUM_3               12FC
NUM_4               1304
NUM_5               130C
NUM_6               1314
NUM_7               131C
NUM_8               1324
NUM_9               132C
NUM_A               1334
NUM_B               133C
NUM_C               1344
NUM_D               134C
NUM_E               1354
NUM_F               135C
OUTADDRINDPOREG0    2407
OUTADDRINDPOREG1    240D
OUTADDRINDPOREG2    2413
OUTADDRINDPOREG3    2419
OUTADDRINDPOREG4    241F
OUTADDRINDPOREG5    2425
OUTADDRINDPOREG6    242B
OUTADDRINDPOREG7    2431
OUTADDRINDPRREG0    2437
OUTADDRINDPRREG1    243D
OUTADDRINDPRREG2    2443
OUTADDRINDPRREG3    2449
OUTADDRINDPRREG4    244F
OUTADDRINDPRREG5    2455
OUTADDRINDPRREG6    245B
OUTADDRINDPRREG7    2461
OUTADDRINDREG0      23DF
OUTADDRINDREG1      23E4
OUTADDRINDREG2      23E9
OUTADDRINDREG3      23EE
OUTADDRINDREG4      23F3
OUTADDRINDREG5      23F8
OUTADDRINDREG6      23FD
OUTADDRINDREG7      2402
OUTADDRREG0         23C7
OUTADDRREG1         23CA
OUTADDRREG2         23CD
OUTADDRREG3         23D0
OUTADDRREG4         23D3
OUTADDRREG5         23D6
OUTADDRREG6         23D9
OUTADDRREG7         23DC
OUTDATAREG0         23AF
OUTDATAREG1         23B2
OUTDATAREG2         23B5
OUTDATAREG3         23B8
OUTDATAREG4         23BB
OUTDATAREG5         23BE
OUTDATAREG6         23C1
OUTDATAREG7         23C4
PRINT_NUM           12DC
PRNT0               2334
PRNT1               2336
PRNT2               2338
PRNT3               233A
PRNT4               233C
PRNT5               233E
PRNT6               2340
PRNT7               2342
PRNT8               2344
PRNT9               2346
PRNTA               2348
PRNTB               234A
PRNTC               234C
PRNTD               234E
PRNTE               2350
PRNTF               2352
PROGEND             2312
PROGST              22FA
QUES_CONT           2262
QUIT_MSG            2288
RTS                 2390
SHABANG             2471
STACK               7000
STADDR              22E6
STADDRSZ            22F0
START               1000
STARTASSEM          21CF
ST_ADDR             7FC6
ST_BAD              11DE
TAB                 2467
THEEND              1DBA
WORDSIZE            23A1
WORDSIZEABSOLUTE    1D4E
WORDSIZEIMMEDIATE   1874
WRAPPERADDRABSOLUTE  1D3A
WRAPPERADDRABSOLUTEEND  1D4C
WRAPPERADDRINDIRECT  1AF4
WRAPPERADDRINDIRECTEND  1B34
WRAPPERADDRINDIRECTPOST  1BB6
WRAPPERADDRINDIRECTPOSTEND  1BF6
WRAPPERADDRINDIRECTPRE  1C78
WRAPPERADDRINDIRECTPREEND  1CB8
WRAPPERADDRREG      1A32
WRAPPERADDRREGEND   1A72
WRAPPERDATAREG      1970
WRAPPERDATAREGEND   19B0
WRAPPERSIZEIMMEDIATE  1836
WRAPPERSIZEIMMEDIATEEND  1850
