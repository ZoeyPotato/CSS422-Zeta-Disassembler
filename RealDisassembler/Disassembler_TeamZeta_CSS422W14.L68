00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/14/2014 5:43:08 PM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/14/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. After specifying
00000000                             7  * where the program to be disassembled is located, this program will disassemble
00000000                             8  * instructions of that program, and output the contents to console.
00000000                             9  *
00000000                            10  * For use with the EASy68K Emulator. To run, open this program in the emulator.
00000000                            11  * Hit 'F9' to execute. In the execution window, open the test input file, and press
00000000                            12  * 'F9' to run the program.
00000000                            13  *
00000000                            14  * This program will not disassemble every 68k instruction, only a subset of instructions
00000000                            15  * that we have currently implemented. See corresponding documentation for more details.
00000000                            16  *-------------------------------------------------------------
00000000  =00007FC6                 17  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 18  STACK       EQU $7000   *Stack location
00000000  =0000000F                 19  MAX_LINE    EQU 15      *Maximum number of instructions that can be displayed
00001000                            20  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 21              LEA stack,SP
00001004  3C3C 000F                 22              MOVE    #MAX_LINE,D6
00001008                            23  
00001008                            24  
00001008                            25  *-----------------------------------------------------------
00001008                            26  * Start of I/O
00001008                            27  *-----------------------------------------------------------            
00001008  43F9 00001C52             28              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 29              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      30              TRAP    #15         *Displays Message
00001014                            31          
00001014  303C 0000                 32  loop_1      MOVE    #0,D0       
00001018  43F9 00002061             33              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 34              MOVE.B  #14,D0
00001022  4E4F                      35              TRAP    #15    
00001024  303C 0002                 36              MOVE    #2,D0
00001028  43F9 0000213C             37              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      38              TRAP    #15
00001030  0C01 0001                 39              CMPI.B  #01,D1
00001034  6600 00FE                 40              BNE     INVALID1
00001038  4EB9 00001110             41              JSR     CHECK_UPY
0000103E                            42              
0000103E                            43              
0000103E                            44  *-----------------------------------------------------------
0000103E                            45  * I/O: Check Start Address
0000103E                            46  *
0000103E                            47  * Make sure that start address starts after allocated 
0000103E                            48  * memory addresses. Else, it will print out a message 
0000103E                            49  * saying that requested address is invalid & prompts the
0000103E                            50  * user again for the starting address.
0000103E                            51  *-----------------------------------------------------------
0000103E  43F9 00002092             52  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001044  103C 000E                 53              MOVE.B  #14,D0
00001048  4E4F                      54              TRAP    #15
0000104A  43F9 00002178             55              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001050  3239 00002182             56              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001056  303C 0002                 57              MOVE    #2,D0           *Get start address
0000105A  4E4F                      58              TRAP    #15
0000105C  4EB9 000010E4             59              JSR     CHECKSTRT1
00001062  4287                      60              CLR.L   D7
00001064  4EB9 00001174             61              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106A  0C03 0001                 62              CMPI.B  #01,D3      *Check if there was a bad start
0000106E  6700 00DC                 63              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001072  0C87 00007FC6             64              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001078  6D00 00D2                 65              BLT     INV_STRT1   *Asks for another start address if invalid
0000107C  0C87 00FFFFFE             66              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001082  6C00 00C8                 67              BGE     INV_STRT1
00001086  23C7 0000218C             68              MOVE.L  D7,PROGST
0000108C                            69  
0000108C  43F9 000020C4             70  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001092  103C 000E                 71              MOVE.B  #14,D0
00001096  4E4F                      72              TRAP    #15
00001098  43F9 00002190             73              LEA     ENDADDR,A1      *Buffer to hold end address
0000109E  3239 0000219A             74              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A4  303C 0002                 75              MOVE    #2,D0
000010A8  4E4F                      76              TRAP    #15
000010AA  4EB9 000010FA             77              JSR     CHECKEND1
000010B0  4287                      78              CLR.L   D7
000010B2  4EB9 00001174             79              JSR     ASCIIHEX
000010B8  0C03 0001                 80              CMPI.B  #01,D3
000010BC  6700 00A2                 81              BEQ     INV_END1
000010C0  0C87 0000218C             82              CMPI.L  #PROGST,D7
000010C6  6D00 0098                 83              BLT     INV_END1
000010CA  0C87 00FFFFFF             84              CMPI.L  #$00FFFFFF,D7
000010D0  6C00 008E                 85              BGE     INV_END1
000010D4  23C7 000021A4             86              MOVE.L  D7,PROGEND
000010DA  2079 0000218C             87              MOVEA.L PROGST,A0
000010E0  6000 028A                 88              BRA     GRAB_NEXT_OP            
000010E4                            89                          
000010E4  0C81 00000008             90  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EA  6E00 0060                 91              BGT     INV_STRT1
000010EE  0C81 00000000             92              CMPI.L  #00,D1
000010F4  6300 0056                 93              BLS     INV_STRT1
000010F8  4E75                      94              RTS         
000010FA                            95              
000010FA  0C81 00000008             96  CHECKEND1   CMPI.L  #08,D1
00001100  6E00 005E                 97              BGT     INV_END1
00001104  0C81 00000000             98              CMPI.L  #00,D1
0000110A  6300 0054                 99              BLS     INV_END1
0000110E  4E75                     100              RTS
00001110                           101  
00001110                           102  
00001110                           103  *-----------------------------------------------------------
00001110                           104  * I/O: Input check for Y, y, N, n
00001110                           105  *-----------------------------------------------------------
00001110  0C11 0059                106  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001114  6600 0004                107              BNE     CHECK_LOWY
00001118  4E75                     108              RTS
0000111A  0C11 0079                109  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
0000111E  6600 0004                110              BNE     CHECK_UPN
00001122  4E75                     111              RTS
00001124  0C11 004E                112  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001128  6700 0B1E                113              BEQ     DONE
0000112C                           114              
0000112C  0C11 006E                115  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001130  6700 0B16                116              BEQ     DONE
00001134                           117              
00001134  163C 0000                118  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001138  303C 0000                119              MOVE    #0,D0       *Prints invalid command msg if not found
0000113C  43F9 000022D1            120              LEA     INV_MSG,A1
00001142  303C 000E                121              MOVE    #14,D0
00001146  4E4F                     122              TRAP    #15
00001148  6000 FECA                123              BRA     loop_1
0000114C                           124              
0000114C  43F9 000022E5            125  INV_STRT1   LEA     INVSTRTMSG,A1
00001152  103C 000E                126              MOVE.B  #14,D0
00001156  4E4F                     127              TRAP    #15
00001158  163C 0000                128              MOVE.B  #00,D3      *Reset flag
0000115C  6000 FEE0                129              BRA     GET_STRT        
00001160                           130              
00001160  43F9 000022FE            131  INV_END1    LEA     INVENDMSG,A1
00001166  103C 000E                132              MOVE.B  #14,D0
0000116A  4E4F                     133              TRAP    #15
0000116C  163C 0000                134              MOVE.B  #00,D3      *Reset flag
00001170  6000 FF1A                135              BRA     GET_END
00001174                           136              
00001174                           137              
00001174                           138  *-----------------------------------------------------------
00001174                           139  * ASCII to Hex converter
00001174                           140  *
00001174                           141  * Checks and converts the ASCII value to the hex equivalent
00001174                           142  *-----------------------------------------------------------
00001174  48E7 6000                143  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001178  0C01 0000                144  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000117C  6700 0062                145              BEQ     exitSub     *Exit subroutine 
00001180  5301                     146              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001182  E99F                     147              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001184  1419                     148              MOVE.B  (A1)+,D2    *Takes the first char
00001186  0C02 0024                149              CMPI.B  #$24,D2     *See if the first char is $
0000118A  67EC                     150              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000118C  0C02 0030                151              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001190  6D00 004C                152              BLT     st_bad      *Put error message
00001194  0C02 0039                153              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001198  6F00 0026                154              BLE     CONV_NUM    *Convert to number, if so
0000119C  0C02 0041                155              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A0  6D00 003C                156              BLT     st_bad      *Put error message
000011A4  0C02 0046                157              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011A8  6F00 0020                158              BLE     CONV_UpL    *Convert to hex
000011AC  0C02 0061                159              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B0  6D00 002C                160              BLT     st_bad
000011B4  0C02 0066                161              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011B8  6F00 001A                162              BLE     CONV_LoL    
000011BC  6E00 0020                163              BGT     st_bad      *Puts error message for anything greater than f value
000011C0                           164              
000011C0  0402 0030                165  CONV_NUM    SUBI.B  #$30,D2
000011C4  8E02                     166              OR.B    D2,D7
000011C6  4EF8 1178                167              JMP     ASCIIHEX1
000011CA  0402 0037                168  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011CE  8E02                     169              OR.B    D2,D7
000011D0  4EF8 1178                170              JMP     ASCIIHEX1
000011D4  0402 0057                171  CONV_LoL    SUBI.B  #$57,D2
000011D8  8E02                     172              OR.B    D2,D7
000011DA  4EF8 1178                173              JMP     ASCIIHEX1   
000011DE                           174  
000011DE  5203                     175  st_bad      ADDI.B  #01,D3
000011E0  4CDF 0006                176  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E4  4E75                     177              RTS
000011E6                           178              
000011E6                           179              
000011E6                           180  *-----------------------------------------------------------
000011E6                           181  * Hex to ASCII converter
000011E6                           182  *-----------------------------------------------------------
000011E6  48E7 4C00                183  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EA  0C01 0000                184  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011EE  6700 002C                185              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F2  B27C 0001                186              CMP.W   #01,D1          
000011F6  6700 003E                187              BEQ     CHNG_SZW
000011FA  6000 0006                188              BRA     CHNG_SZL        
000011FE                           189  
000011FE  48E7 4C00                190  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001202  123C 0008                191  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
00001206  0C01 0000                192  LOOP_L      CMPI.B  #00,D1
0000120A  6700 00CA                193              BEQ     EXIT_CONV
0000120E  5301                     194              SUBI.B  #01,D1
00001210  E99C                     195              ROL.L   #4,D4           * Shift it for next bit
00001212  2A04                     196              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001214  4EB9 00001250            197              JSR     CONV_LOOP
0000121A  60EA                     198              BRA     LOOP_L      
0000121C                           199  
0000121C  123C 0002                200  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001220  0C01 0000                201  LOOP_B      CMPI.B  #00,D1
00001224  6700 00B0                202              BEQ     EXIT_CONV
00001228  5301                     203              SUBI.B  #01,D1
0000122A  E91C                     204              ROL.B   #4,D4           * Shift it for next bit
0000122C  2A04                     205              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000122E  4EB9 00001250            206              JSR     CONV_LOOP
00001234  60EA                     207              BRA     LOOP_B
00001236                           208              
00001236  123C 0004                209  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123A  0C01 0000                210  LOOP_W      CMPI.B  #00,D1
0000123E  6700 0096                211              BEQ     EXIT_CONV
00001242  5301                     212              SUBI.B  #01,D1
00001244  E95C                     213              ROL.W   #4,D4           * Shift it for next bit
00001246  2A04                     214              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001248  4EB9 00001250            215              JSR     CONV_LOOP
0000124E  60EA                     216              BRA     LOOP_W
00001250                           217  
00001250  0285 0000000F            218  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001256  0C05 0000                219              CMPI.B  #$0,D5
0000125A  6700 0088                220              BEQ     NUM_0
0000125E  0C05 0001                221              CMPI.B  #$1,D5
00001262  6700 0088                222              BEQ     NUM_1
00001266  0C05 0002                223              CMPI.B  #$2,D5
0000126A  6700 0088                224              BEQ     NUM_2
0000126E  0C05 0003                225              CMPI.B  #$3,D5
00001272  6700 0088                226              BEQ     NUM_3
00001276  0C05 0004                227              CMPI.B  #$4,D5
0000127A  6700 0088                228              BEQ     NUM_4
0000127E  0C05 0005                229              CMPI.B  #$5,D5
00001282  6700 0088                230              BEQ     NUM_5
00001286  0C05 0006                231              CMPI.B  #$6,D5
0000128A  6700 0088                232              BEQ     NUM_6
0000128E  0C05 0007                233              CMPI.B  #$7,D5
00001292  6700 0088                234              BEQ     NUM_7
00001296  0C05 0008                235              CMPI.B  #$8,D5
0000129A  6700 0088                236              BEQ     NUM_8
0000129E  0C05 0009                237              CMPI.B  #$9,D5
000012A2  6700 0088                238              BEQ     NUM_9
000012A6  0C05 000A                239              CMPI.B  #$A,D5
000012AA  6700 0088                240              BEQ     NUM_A
000012AE  0C05 000B                241              CMPI.B  #$B,D5
000012B2  6700 0088                242              BEQ     NUM_B
000012B6  0C05 000C                243              CMPI.B  #$C,D5
000012BA  6700 0088                244              BEQ     NUM_C
000012BE  0C05 000D                245              CMPI.B  #$D,D5
000012C2  6700 0088                246              BEQ     NUM_D
000012C6  0C05 000E                247              CMPI.B  #$E,D5
000012CA  6700 0088                248              BEQ     NUM_E
000012CE  0C05 000F                249              CMPI.B  #$F,D5
000012D2  6700 0088                250              BEQ     NUM_F
000012D6                           251              
000012D6  4CDF 0032                252  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DA  4E75                     253              RTS
000012DC                           254              
000012DC  303C 000E                255  PRINT_NUM   MOVE    #14,D0
000012E0  4E4F                     256              TRAP    #15
000012E2  4E75                     257              RTS
000012E4  43F9 000021C6            258  NUM_0       LEA     PRNT0,A1
000012EA  60F0                     259              BRA     PRINT_NUM
000012EC  43F9 000021C8            260  NUM_1       LEA     PRNT1,A1
000012F2  60E8                     261              BRA     PRINT_NUM
000012F4  43F9 000021CA            262  NUM_2       LEA     PRNT2,A1
000012FA  60E0                     263              BRA     PRINT_NUM
000012FC  43F9 000021CC            264  NUM_3       LEA     PRNT3,A1
00001302  60D8                     265              BRA     PRINT_NUM
00001304  43F9 000021CE            266  NUM_4       LEA     PRNT4,A1
0000130A  60D0                     267              BRA     PRINT_NUM
0000130C  43F9 000021D0            268  NUM_5       LEA     PRNT5,A1
00001312  60C8                     269              BRA     PRINT_NUM
00001314  43F9 000021D2            270  NUM_6       LEA     PRNT6,A1
0000131A  60C0                     271              BRA     PRINT_NUM
0000131C  43F9 000021D4            272  NUM_7       LEA     PRNT7,A1
00001322  60B8                     273              BRA     PRINT_NUM
00001324  43F9 000021D6            274  NUM_8       LEA     PRNT8,A1
0000132A  60B0                     275              BRA     PRINT_NUM
0000132C  43F9 000021D8            276  NUM_9       LEA     PRNT9,A1
00001332  60A8                     277              BRA     PRINT_NUM
00001334  43F9 000021DA            278  NUM_A       LEA     PRNTA,A1
0000133A  60A0                     279              BRA     PRINT_NUM
0000133C  43F9 000021DC            280  NUM_B       LEA     PRNTB,A1
00001342  6098                     281              BRA     PRINT_NUM
00001344  43F9 000021DE            282  NUM_C       LEA     PRNTC,A1
0000134A  6090                     283              BRA     PRINT_NUM
0000134C  43F9 000021E0            284  NUM_D       LEA     PRNTD,A1
00001352  6088                     285              BRA     PRINT_NUM
00001354  43F9 000021E2            286  NUM_E       LEA     PRNTE,A1
0000135A  6080                     287              BRA     PRINT_NUM
0000135C  43F9 000021E4            288  NUM_F       LEA     PRNTF,A1
00001362  6000 FF78                289              BRA     PRINT_NUM
00001366                           290  
00001366                           291  
00001366                           292  *-----------------------------------------------------------        
00001366                           293  * Start of Disassembler
00001366                           294  *-----------------------------------------------------------
00001366                           295          *FOR DEBUGGING ONLY!!!
00001366  207C 00007FC6            296          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000136C                           297          
0000136C                           298  GRAB_NEXT_OP
0000136C                           299          *Check and see if A0 == end of test address. If so, we need to end.
0000136C  2E08                     300          MOVE.L  A0,D7
0000136E  2479 000021A4            301          MOVEA.L PROGEND,A2
00001374  BE8A                     302          CMP.L   A2,D7       * Check and see if A0 == end of test address. 
00001376  0C86 00000000            303          CMPI.L  #00,D6      * Check if max line of instructions output on console is reached
0000137C  6700 0032                304          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
00001380  5306                     305          SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
00001382                           306  
00001382                           307          *Output a newline to console...        
00001382  43F9 000022BB            308          LEA     NewLine,A1  *Loads NewLine into address register A1
00001388  103C 000E                309          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000138C  4E4F                     310          TRAP    #15         *Displays Message
0000138E                           311  
0000138E                           312          *Output the address of this instruction to console...
0000138E  2808                     313          MOVE.L  A0,D4
00001390  4EB8 11FE                314          JSR     HEXASCIIREG
00001394                           315          
00001394                           316          *Output a tab (4 spaces) to console, just after the address...
00001394  43F9 000022B4            317          LEA     Tab,A1  *Loads Tab into address register A1
0000139A  103C 000E                318          MOVE.B  #14,D0  *Moves the number 14 into data register D0
0000139E  4E4F                     319          TRAP    #15     *Displays Message
000013A0                           320          
000013A0                           321          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
000013A0                           322          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
000013A0                           323          *data that may be associated with the instruction.
000013A0                           324          *Post increment addr, A0 will point to the start of next instruction or will 
000013A0                           325          *point to the start of any immed/abso data with this current instruction
000013A0  4280                     326          CLR.L   D0
000013A2  3018                     327          MOVE.W  (A0)+,D0
000013A4                           328          *Copy the word data we just moved into D0 into D7. We are copying this data
000013A4                           329          *So we always have a copy of the WHOLE instruction somewhere
000013A4  4287                     330          CLR.L   D7
000013A6  3E00                     331          MOVE.W  D0,D7
000013A8                           332          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000013A8                           333          *four bits of the instruction. Once we have just the first four bits, we can
000013A8                           334          *begin to see which 'bucket'/category this instruction falls into. 
000013A8  E048                     335          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013AA  E848                     336          LSR.W   #$04,D0
000013AC                           337          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013AC                           338          *list of buckets until we find which one this instruction falls into.
000013AC  6000 0068                339          BRA     BUCKET_0000     * Start with 0000
000013B0                           340  
000013B0                           341  
000013B0                           342  *-----------------------------------------------------------        
000013B0                           343  * Question Prompts
000013B0                           344  *-----------------------------------------------------------        
000013B0  43F9 000020F4            345  CONT_Q      LEA     QUES_CONT,A1
000013B6  303C 000E                346              MOVE    #14,D0
000013BA  4E4F                     347              TRAP    #15
000013BC  43F9 000021A8            348              LEA     CONT,A1     *Need to store Y/N
000013C2  303C 0002                349              MOVE    #2,D0
000013C6  4E4F                     350              TRAP    #15
000013C8  0C01 0001                351              CMPI.B  #01,D1
000013CC  6600 FD66                352              BNE     INVALID1
000013D0  0C39 0059 000021A8       353              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013D8  6600 0008                354              BNE     CHECK_Y
000013DC  3C3C 000F                355              MOVE    #MAX_LINE,D6    *Resets counter
000013E0  4E75                     356              RTS
000013E2  0C11 0079                357  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
000013E6  6600 0008                358              BNE     CHECK_N
000013EA  3C3C 000F                359              MOVE    #MAX_LINE,D6    *Resets counter
000013EE  4E75                     360              RTS
000013F0  0C11 004E                361  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
000013F4  6700 FC1E                362              BEQ     loop_1
000013F8  0C11 006E                363              CMPI.B  #$6E,(A1)   *Checks for lowercase n
000013FC  6700 FC16                364              BEQ     loop_1      
00001400                           365  
00001400  163C 0000                366  INV2        MOVE.B  #0,D3       *Reset bad flag
00001404  303C 0000                367              MOVE    #0,D0       *Prints invalid command msg if not found
00001408  43F9 000022D1            368              LEA     INV_MSG,A1
0000140E  303C 000E                369              MOVE    #14,D0
00001412  4E4F                     370              TRAP    #15
00001414  609A                     371              BRA     CONT_Q
00001416                           372  
00001416                           373  *-----------------------------------------------------------        
00001416                           374  * Bucket 0000:
00001416                           375  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
00001416                           376  *                   BCHG(dynamic) | BCHG (static) | CMPI----
00001416                           377  *-----------------------------------------------------------
00001416                           378  BUCKET_0000
00001416  =00000000                379  BUCKET0000_BITS EQU $0
00001416  4281                     380          CLR.L   D1
00001418                           381          *Load the first 4 bits (really a byte) of BUCKET0 into D1
00001418  123C 0000                382          MOVE.B  #BUCKET0000_BITS,D1
0000141C                           383          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0000. 
0000141C                           384          *If equal, continue decoding. If not, branch to next bucket.
0000141C  B200                     385          CMP.B   D0,D1
0000141E  6600 0344                386          BNE     BUCKET_0001
00001422                           387  
00001422                           388          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001422                           389          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001422  3007                     390          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001424  0800 0008                391          BTST.L  #$08,D0
00001428  6600 01A4                392          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to IS_BCHG_D
0000142C                           393          
0000142C                           394          *Now we can check bits 11-8 in the instruction and branch to different op-codes
0000142C                           395          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
0000142C  E048                     396          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
0000142E  0880 0004                397          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001432  0880 0005                398          BCLR.L  #$05,D0
00001436  0880 0006                399          BCLR.L  #$06,D0
0000143A  0880 0007                400          BCLR.L  #$07,D0
0000143E                           401          
0000143E                           402          *Perform compares with these 4 bits to see which specific instruction it is.
0000143E  B03C 0006                403          CMP.B   #$06,D0 *Is this an ADDI?
00001442  6700 0028                404          BEQ     IS_ADDI
00001446  B03C 0002                405          CMP.B   #$02,D0 *Is this an ANDI?
0000144A  6700 0096                406          BEQ     IS_ANDI
0000144E  B03C 000A                407          CMP.B   #$0A,D0 *Is this an EORI?
00001452  6700 0104                408          BEQ     IS_EORI
00001456  B03C 0008                409          CMP.B   #$08,D0 *Is this a BCHG(static)?
0000145A  6700 0210                410          BEQ     IS_BCHG_S
0000145E  B03C 000C                411          CMP.B   #$0C,D0 *Is this a CMPI?
00001462  6700 028A                412          BEQ     IS_CMPI
00001466                           413          
00001466                           414          *If we get through all of the compares without finding the specific instruction,
00001466                           415          *then this instruction is either not in our list of OP CODES to decode, or is an
00001466                           416          *invalid instruction/syntax.
00001466  4EF9 00001C28            417          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
0000146C                           418          
0000146C                           419          
0000146C                           420  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
0000146C                           421  IS_ADDI
0000146C                           422          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000146C                           423          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000146C  4281                     424          CLR.L   D1
0000146E  3207                     425          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001470  C27C 00C0                426          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001474  EC09                     427          LSR.B   #$06,D1     *Shift the size bits into LSB
00001476                           428          
00001476  B23C 0003                429          CMP.B   #$03,D1     *Compare the size bits to $3
0000147A  6700 07AC                430          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000147E                           431          
0000147E                           432          *Output 'ADDI' to console...
0000147E  43F9 000021E6            433          LEA     ADDI,A1     *Loads ADDI into address register A1
00001484  103C 000E                434          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001488  4E4F                     435          TRAP    #15         *Displays Message
0000148A                           436          
0000148A                           437          
0000148A                           438          *Should have a valid ADDI op code. Set data up for EA.
0000148A                           439          
0000148A                           440          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000148A  4282                     441          CLR.L   D2
0000148C  3407                     442          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000148E  C47C 003C                443          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001492  E60A                     444          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001494                           445                  
00001494                           446          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001494  4283                     447          CLR.L   D3
00001496  3607                     448          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001498  C67C 0007                449          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000149C                           450          
0000149C  4EF9 000014A2            451          JMP     EA_ADDI
000014A2                           452  
000014A2                           453  EA_ADDI
000014A2                           454          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
000014A2                           455          *and D3 holds the EA register.
000014A2                           456          
000014A2                           457          *Determine how much data to read in, depending on the size of the operation
000014A2                           458          *output the size of the operation and the immediate data to console
000014A2  4EB9 000017BE            459          JSR     WrapperSizeImmediate
000014A8                           460          
000014A8                           461          *manually output a comma here...
000014A8  43F9 000022B9            462          LEA     Comma,A1        *Loads Comma into address register A1
000014AE  103C 000E                463          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014B2  4E4F                     464          TRAP    #15             *Displays Message        
000014B4                           465          
000014B4                           466          *Determine which EA mode and thus Register/Mem Address this instruction used
000014B4  B43C 0000                467          CMP.B   #$00,D2
000014B8  6700 03CA                468          BEQ     DataRegMode *If EA mode is a data register, output that
000014BC                           469          
000014BC  B43C 0002                470          CMP.B   #$02,D2
000014C0  6700 03D2                471          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014C4                           472          
000014C4  B43C 0003                473          CMP.B   #$03,D2
000014C8  6700 03DA                474          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014CC                           475          
000014CC  B43C 0004                476          CMP.B   #$04,D2
000014D0  6700 03E2                477          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014D4                           478          
000014D4  B43C 0007                479          CMP.B   #$07,D2
000014D8  6700 03EA                480          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014DC                           481          
000014DC                           482          *If the ea mode isn't equal to any of these, it is an invalid EA
000014DC  4EF9 00001C38            483          JMP     BADEACODE                               
000014E2                           484          
000014E2                           485  
000014E2                           486  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000014E2                           487  IS_ANDI
000014E2                           488          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014E2                           489          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014E2  4281                     490          CLR.L   D1
000014E4  3207                     491          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014E6  C27C 00C0                492          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014EA  EC09                     493          LSR.B   #$06,D1     *Shift the size bits into LSB
000014EC                           494          
000014EC  B23C 0003                495          CMP.B   #$03,D1     *Compare the size bits to $3
000014F0  6700 0736                496          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014F4                           497          
000014F4                           498          *Output 'ANDI' to console...
000014F4  43F9 000021EB            499          LEA     ANDI,A1     *Loads ANDI into address register A1
000014FA  103C 000E                500          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014FE  4E4F                     501          TRAP    #15         *Displays Message
00001500                           502          
00001500                           503          
00001500                           504          *Should have a valid ANDI op code. Set data up for EA.
00001500                           505          
00001500                           506          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001500  4282                     507          CLR.L   D2
00001502  3407                     508          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001504  C47C 003C                509          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001508  E60A                     510          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000150A                           511                  
0000150A                           512          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000150A  4283                     513          CLR.L   D3
0000150C  3607                     514          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000150E  C67C 0007                515          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001512                           516          
00001512  4EF9 00001518            517          JMP     EA_ANDI
00001518                           518  
00001518                           519  EA_ANDI
00001518                           520          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
00001518                           521          *and D3 holds the EA register.
00001518                           522          
00001518                           523          *Determine how much data to read in, depending on the size of the operation
00001518                           524          *output the size of the operation and the immediate data to console
00001518  4EB9 000017BE            525          JSR     WrapperSizeImmediate
0000151E                           526          
0000151E                           527          *manually output a comma here...
0000151E  43F9 000022B9            528          LEA     Comma,A1        *Loads Comma into address register A1
00001524  103C 000E                529          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001528  4E4F                     530          TRAP    #15             *Displays Message        
0000152A                           531          
0000152A                           532          *Determine which EA mode and thus Register/Mem Address this instruction used
0000152A  B43C 0000                533          CMP.B   #$00,D2
0000152E  6700 0354                534          BEQ     DataRegMode *If EA mode is a data register, output that
00001532                           535          
00001532  B43C 0002                536          CMP.B   #$02,D2
00001536  6700 035C                537          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000153A                           538          
0000153A  B43C 0003                539          CMP.B   #$03,D2
0000153E  6700 0364                540          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001542                           541          
00001542  B43C 0004                542          CMP.B   #$04,D2
00001546  6700 036C                543          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000154A                           544          
0000154A  B43C 0007                545          CMP.B   #$07,D2
0000154E  6700 0374                546          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001552                           547          
00001552                           548          *If the ea mode isn't equal to any of these, it is an invalid EA
00001552  4EF9 00001C38            549          JMP     BADEACODE
00001558                           550          
00001558                           551  
00001558                           552  *Now we know this instruction is exactly EORI, lets set everything up for EA.
00001558                           553  IS_EORI
00001558                           554          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001558                           555          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001558  4281                     556          CLR.L   D1
0000155A  3207                     557          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000155C  C27C 00C0                558          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001560  EC09                     559          LSR.B   #$06,D1     *Shift the size bits into LSB
00001562                           560          
00001562  B23C 0003                561          CMP.B   #$03,D1     *Compare the size bits to $3
00001566  6700 06C0                562          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000156A                           563          
0000156A                           564          *Output 'EORI' to console...
0000156A  43F9 000021F0            565          LEA     EORI,A1     *Loads EORI into address register A1
00001570  103C 000E                566          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001574  4E4F                     567          TRAP    #15         *Displays Message
00001576                           568          
00001576                           569          
00001576                           570          *Should have a valid EORI op code. Set data up for EA.
00001576                           571          
00001576                           572          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001576  4282                     573          CLR.L   D2
00001578  3407                     574          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000157A  C47C 003C                575          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
0000157E  E60A                     576          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001580                           577                  
00001580                           578          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001580  4283                     579          CLR.L   D3
00001582  3607                     580          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001584  C67C 0007                581          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001588                           582          
00001588  4EF9 0000158E            583          JMP     EA_EORI
0000158E                           584  
0000158E                           585  EA_EORI
0000158E                           586          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
0000158E                           587          *and D3 holds the EA register.
0000158E                           588          
0000158E                           589          *Determine how much data to read in, depending on the size of the operation
0000158E                           590          *output the size of the operation and the immediate data to console
0000158E  4EB9 000017BE            591          JSR     WrapperSizeImmediate
00001594                           592          
00001594                           593          *manually output a comma here...
00001594  43F9 000022B9            594          LEA     Comma,A1        *Loads Comma into address register A1
0000159A  103C 000E                595          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000159E  4E4F                     596          TRAP    #15             *Displays Message        
000015A0                           597          
000015A0                           598          *Determine which EA mode and thus Register/Mem Address this instruction used
000015A0  B43C 0000                599          CMP.B   #$00,D2
000015A4  6700 02DE                600          BEQ     DataRegMode *If EA mode is a data register, output that
000015A8                           601          
000015A8  B43C 0002                602          CMP.B   #$02,D2
000015AC  6700 02E6                603          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015B0                           604          
000015B0  B43C 0003                605          CMP.B   #$03,D2
000015B4  6700 02EE                606          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015B8                           607          
000015B8  B43C 0004                608          CMP.B   #$04,D2
000015BC  6700 02F6                609          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015C0                           610          
000015C0  B43C 0007                611          CMP.B   #$07,D2
000015C4  6700 02FE                612          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015C8                           613          
000015C8                           614          *If the ea mode isn't equal to any of these, it is an invalid EA
000015C8  4EF9 00001C38            615          JMP     BADEACODE
000015CE                           616  
000015CE                           617  
000015CE                           618  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015CE                           619  *everything up for EA, if is a legit instruction.
000015CE                           620  IS_BCHG_D
000015CE                           621          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015CE                           622          *invalid, branch to BADOPCODE
000015CE  3007                     623          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015D0  0800 0007                624          BTST.L  #$07,D0
000015D4  6600 0652                625          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015D8  0800 0006                626          BTST.L  #$06,D0
000015DC  6700 064A                627          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000015E0                           628          
000015E0                           629          *Output 'BCHG' to console...
000015E0  43F9 000021F5            630          LEA     BCHG,A1         *Loads BCHG into address register A1
000015E6  103C 000E                631          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015EA  4E4F                     632          TRAP    #15             *Displays Message
000015EC                           633                  
000015EC                           634                  
000015EC                           635          *Should have a valid BCHG op code. Set data up for EA.
000015EC                           636  
000015EC                           637          *Set D1 to the EA source register located in bits 11-9 of the instruction
000015EC  4281                     638          CLR.L   D1
000015EE  3207                     639          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015F0  C27C 0E00                640          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
000015F4  E009                     641          LSR.B   #$08,D1     *Shift the EA source register bits into LSB
000015F6  E209                     642          LSR.B   #$01,D1
000015F8                           643  
000015F8                           644          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015F8  4282                     645          CLR.L   D2
000015FA  3407                     646          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000015FC  C47C 003C                647          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001600  E60A                     648          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001602                           649                  
00001602                           650          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001602  4283                     651          CLR.L   D3
00001604  3607                     652          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001606  C67C 0007                653          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000160A                           654  
0000160A  4EF9 00001610            655          JMP     EA_BCHG_D
00001610                           656  
00001610                           657  EA_BCHG_D
00001610                           658          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001610                           659          *D2 holds the EA mode, and D3 holds the EA register.
00001610                           660          
00001610                           661          *Determine the size of this BCHG instruction. Output the correct size...
00001610  4EB9 00001840            662          JSR     BCHGSizeHelper
00001616                           663          
00001616                           664          *output the source register to console, flag D6 with a 1 so we come back...
00001616  48E7 0200                665          MOVEM.L D6,-(SP)    *Push D6 into stack (line counter)
0000161A  48E7 1000                666          MOVEM.L D3,-(SP)    *Push EA destination register into stack            
0000161E  1C3C 0001                667          MOVE.B  #$01,D6     *Flag D6
00001622  1601                     668          MOVE.B  D1,D3       *Move source register into D3
00001624  4EB9 00001884            669          JSR     DataRegMode
0000162A  4CDF 0008                670          MOVEM.L (SP)+,D3    *Pull destination register back into D3
0000162E  4CDF 0040                671          MOVEM.L (SP)+,D6    *Pull the line counter back into D6
00001632                           672          
00001632                           673          *manually output a comma here...
00001632  43F9 000022B9            674          LEA     Comma,A1        *Loads Comma into address register A1
00001638  103C 000E                675          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000163C  4E4F                     676          TRAP    #15             *Displays Message
0000163E                           677          
0000163E                           678          *Determine which EA mode and thus Register/Mem Address this instruction used
0000163E  B43C 0000                679          CMP.B   #$00,D2
00001642  6700 0240                680          BEQ     DataRegMode *If EA mode is a data register, output that
00001646                           681          
00001646  B43C 0002                682          CMP.B   #$02,D2
0000164A  6700 0248                683          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
0000164E                           684          
0000164E  B43C 0003                685          CMP.B   #$03,D2
00001652  6700 0250                686          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001656                           687          
00001656  B43C 0004                688          CMP.B   #$04,D2
0000165A  6700 0258                689          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
0000165E                           690          
0000165E  B43C 0007                691          CMP.B   #$07,D2
00001662  6700 0260                692          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001666                           693          
00001666                           694          *If the ea mode isn't equal to any of these, it is an invalid EA
00001666  4EF9 00001C38            695          JMP     BADEACODE
0000166C                           696  
0000166C                           697  
0000166C                           698  *Found a possible BCHG(static) instruction. Verify its bit integrity and then set up
0000166C                           699  *everything up for EA, if is a legit instruction.
0000166C                           700  IS_BCHG_S
0000166C                           701          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
0000166C                           702          *invalid, branch to BADOPCODE
0000166C  3007                     703          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
0000166E  0800 0007                704          BTST.L  #$07,D0
00001672  6600 05B4                705          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
00001676  0800 0006                706          BTST.L  #$06,D0
0000167A  6700 05AC                707          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
0000167E                           708          
0000167E                           709          *Output 'BCHG' to console...
0000167E  43F9 000021F5            710          LEA     BCHG,A1         *Loads BCHG into address register A1
00001684  103C 000E                711          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001688  4E4F                     712          TRAP    #15             *Displays Message
0000168A                           713          
0000168A                           714          
0000168A                           715          *Should have a valid BCHG op code. Set data up for EA.
0000168A                           716          
0000168A                           717          *Move #$00 into D1, BCHG_S's immediate data is always in byte size
0000168A  4281                     718          CLR.L   D1
0000168C  323C 0000                719          MOVE.W  #$00,D1
00001690                           720  
00001690                           721          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001690  4282                     722          CLR.L   D2
00001692  3407                     723          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001694  C47C 003C                724          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001698  E60A                     725          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000169A                           726                  
0000169A                           727          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000169A  4283                     728          CLR.L   D3
0000169C  3607                     729          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000169E  C67C 0007                730          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000016A2                           731  
000016A2  4EF9 000016A8            732          JMP     EA_BCHG_S
000016A8                           733  
000016A8                           734  EA_BCHG_S
000016A8                           735          *Decode the ea bits of BCHG(static). Assuming D2 holds the EA mode, and 
000016A8                           736          *D3 holds the EA register.
000016A8                           737          
000016A8                           738          *Determine the size of this BCHG instruction. Output the correct size...
000016A8  4EB9 00001840            739          JSR     BCHGSizeHelper                
000016AE                           740          
000016AE                           741          *output the immediate data of this operation to console (always byte)...
000016AE  4EB9 00001870            742          JSR     BCHGImmediate
000016B4                           743          
000016B4                           744          *manually output a comma here...
000016B4  43F9 000022B9            745          LEA     Comma,A1        *Loads Comma into address register A1
000016BA  103C 000E                746          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016BE  4E4F                     747          TRAP    #15             *Displays Message
000016C0                           748          
000016C0                           749          *Determine which EA mode and thus Register/Mem Address this instruction used
000016C0  B43C 0000                750          CMP.B   #$00,D2
000016C4  6700 01BE                751          BEQ     DataRegMode *If EA mode is a data register, output that
000016C8                           752          
000016C8  B43C 0002                753          CMP.B   #$02,D2
000016CC  6700 01C6                754          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016D0                           755          
000016D0  B43C 0003                756          CMP.B   #$03,D2
000016D4  6700 01CE                757          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016D8                           758          
000016D8  B43C 0004                759          CMP.B   #$04,D2
000016DC  6700 01D6                760          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000016E0                           761          
000016E0  B43C 0007                762          CMP.B   #$07,D2
000016E4  6700 01DE                763          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000016E8                           764          
000016E8                           765          *If the ea mode isn't equal to any of these, it is an invalid EA
000016E8  4EF9 00001C38            766          JMP     BADEACODE
000016EE                           767  
000016EE                           768  
000016EE                           769  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000016EE                           770  IS_CMPI
000016EE                           771          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000016EE                           772          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000016EE  4281                     773          CLR.L   D1
000016F0  3207                     774          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000016F2  C27C 00C0                775          AND.W   #$00C0,D1   *Mask out everything but the size bits
000016F6  EC09                     776          LSR.B   #$06,D1     *Shift the size bits into LSB
000016F8                           777          
000016F8  B23C 0003                778          CMP.B   #$03,D1     *Compare the size bits to $3
000016FC  6700 052A                779          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001700                           780          
00001700                           781          *Output 'CMPI' to console...
00001700  43F9 000021FA            782          LEA     CMPI,A1     *Loads CMPI into address register A1
00001706  103C 000E                783          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000170A  4E4F                     784          TRAP    #15         *Displays Message
0000170C                           785          
0000170C                           786          
0000170C                           787          *Should have a valid CMPI op code. Set data up for EA.
0000170C                           788          
0000170C                           789          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000170C  4282                     790          CLR.L   D2
0000170E  3407                     791          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001710  C47C 003C                792          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001714  E60A                     793          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001716                           794                  
00001716                           795          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001716  4283                     796          CLR.L   D3
00001718  3607                     797          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000171A  C67C 0007                798          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000171E                           799          
0000171E  4EF9 00001724            800          JMP     EA_CMPI
00001724                           801  
00001724                           802  EA_CMPI
00001724                           803          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
00001724                           804          *and D3 holds the EA register.
00001724                           805          
00001724                           806          *Determine how much data to read in, depending on the size of the operation
00001724                           807          *output the size of the operation and the immediate data to console
00001724  4EB9 000017BE            808          JSR     WrapperSizeImmediate
0000172A                           809          
0000172A                           810          *manually output a comma here...
0000172A  43F9 000022B9            811          LEA     Comma,A1        *Loads Comma into address register A1
00001730  103C 000E                812          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001734  4E4F                     813          TRAP    #15             *Displays Message
00001736                           814          
00001736                           815          *Determine which EA mode and thus Register/Mem Address this instruction used
00001736  B43C 0000                816          CMP.B   #$00,D2
0000173A  6700 0148                817          BEQ     DataRegMode *If EA mode is a data register, output that
0000173E                           818          
0000173E  B43C 0002                819          CMP.B   #$02,D2
00001742  6700 0150                820          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001746                           821          
00001746  B43C 0003                822          CMP.B   #$03,D2
0000174A  6700 0158                823          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000174E                           824          
0000174E  B43C 0004                825          CMP.B   #$04,D2
00001752  6700 0160                826          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001756                           827          
00001756  B43C 0007                828          CMP.B   #$07,D2
0000175A  6700 0168                829          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000175E                           830          
0000175E                           831          *If the ea mode isn't equal to any of these, it is an invalid EA
0000175E  4EF9 00001C38            832          JMP     BADEACODE
00001764                           833        
00001764                           834    
00001764                           835  *STARTS WITH 0001, MOVE.B-----------------------------------
00001764                           836  BUCKET_0001
00001764  =00000001                837  BUCKET0001_BITS EQU $1
00001764                           838          
00001764                           839          *some code...
00001764                           840  
00001764                           841  
00001764                           842  *STARTS WITH 0010, MOVE.L-----------------------------------
00001764                           843  BUCKET_0010
00001764  =00000002                844  BUCKET0010_BITS EQU $2
00001764                           845  
00001764                           846          *some code...
00001764                           847  
00001764                           848  
00001764                           849  *STARTS WITH 0011, MOVE.W-----------------------------------
00001764                           850  BUCKET_0011
00001764  =00000003                851  BUCKET0011_BITS EQU $3
00001764                           852  
00001764                           853          *some code...
00001764                           854  
00001764                           855  
00001764                           856  *-----------------------------------------------------------        
00001764                           857  * Bucket 0100:
00001764                           858  * STARTS WITH 0100, MOVEM | MULS(L)-------------------------
00001764                           859  *                   LEA | CLR | JSR | RTS-------------------
00001764                           860  *-----------------------------------------------------------
00001764                           861  BUCKET_0100
00001764  =00000004                862  BUCKET0100_BITS EQU $4
00001764  4281                     863          CLR.L   D1
00001766                           864          *Load the first 4 bits (really a byte) of BUCKET0 into D1
00001766  123C 0004                865          MOVE.B  #BUCKET0100_BITS,D1
0000176A                           866          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0100. 
0000176A                           867          *If equal, continue decoding. If not, branch to next bucket.
0000176A  B200                     868          CMP.B   D0,D1
0000176C  6600 004A                869          BNE     BUCKET_0101
00001770                           870  
00001770                           871          *Test the 8th bit in this instruction, if it is 1, then it is an LEA 
00001770                           872          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1.
00001770  3007                     873          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
00001772  0800 0008                874          BTST.L  #$08,D0
00001776  6600 0040                875          BNE     IS_LEA  *If the zbit was 0 (the 8th bit is 1), branch to IS_LEA
0000177A                           876  
0000177A                           877          *Some codes in this bucket can be determined by only bits 11-8, but some need
0000177A                           878          *11-6 to be unambiguous with others. First, solve codes that need bits 11-6...           
0000177A  C07C 0FC0                879          AND.W   #$0FC0,D0   *Mask out everything but bits 11-6
0000177E  EC48                     880          LSR.W   #$06,D0     *Move bits 11-6 into LSB position
00001780                           881          
00001780                           882          *Check bits 11-6 in the instruction and branch to different op-codes depending 
00001780                           883          *on what the bits equal, without ambiguity
00001780  B03C 0033                884          CMP.B   #$33,D0 *Is this a MOVEM(long)?
00001784  6700 0032                885          BEQ     IS_MOVEM
00001788  B03C 0030                886          CMP.B   #$30,D0 *Is this a MULS(long)?
0000178C  6700 002A                887          BEQ     IS_MULS_L
00001790  B03C 003A                888          CMP.B   #$3A,D0 *Is this a JSR?
00001794  6700 0022                889          BEQ     IS_JSR
00001798  B03C 0039                890          CMP.B   #$39,D0 *Is this a RTS?
0000179C  6700 001A                891          BEQ     IS_RTS
000017A0                           892  
000017A0                           893          *Now we can use only bits 11-8 and branch to different op-codes only needing these
000017A0                           894          *four bits to be unambiguous
000017A0  E448                     895          LSR.W   #$02,D0 *Shift the 7-6 bits out, leaving only 11-8        
000017A2  B03C 0008                896          CMP.B   #$08,D0 *Is this a MOVEM(word)?
000017A6  6700 0010                897          BEQ     IS_MOVEM
000017AA  B03C 0002                898          CMP.B   #$02,D0 *Is this a CLR?
000017AE  6700 0008                899          BEQ     IS_CLR
000017B2                           900          
000017B2                           901          *If we get through all of the compares without finding the specific instruction,
000017B2                           902          *then this instruction is either not in our list of OP CODES to decode, or is an
000017B2                           903          *invalid instruction/syntax.
000017B2  4EF9 00001C28            904          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
000017B8                           905  
000017B8                           906  
000017B8                           907  *Now we know this instruction is exactly MOVEM, lets set everything up for EA.
000017B8                           908  IS_MOVEM
000017B8                           909  
000017B8                           910  EA_MOVEM
000017B8                           911  
000017B8                           912  
000017B8                           913  *Now we know this instruction is exactly IS_MULS_L, lets set everything up for EA.
000017B8                           914  IS_MULS_L
000017B8                           915  
000017B8                           916  EA_MULS_L
000017B8                           917  
000017B8                           918  
000017B8                           919  *Now we know this instruction is exactly LEA, lets set everything up for EA.
000017B8                           920  IS_LEA
000017B8                           921  
000017B8                           922  EA_LEA
000017B8                           923  
000017B8                           924  
000017B8                           925  *Now we know this instruction is exactly CLR, lets set everything up for EA.
000017B8                           926  IS_CLR
000017B8                           927  
000017B8                           928  EA_CLR
000017B8                           929  
000017B8                           930  
000017B8                           931  *Now we know this instruction is exactly JSR, lets set everything up for EA.
000017B8                           932  IS_JSR
000017B8                           933  
000017B8                           934  EA_JSR
000017B8                           935  
000017B8                           936  
000017B8                           937  *Now we know this instruction is exactly RTS, lets set everything up for EA.
000017B8                           938  IS_RTS
000017B8                           939  
000017B8                           940  EA_RTS
000017B8                           941  
000017B8                           942  
000017B8                           943  *STARTS WITH 0101, SUBQ-------------------------------------
000017B8                           944  BUCKET_0101
000017B8  =00000005                945  BUCKET0101_BITS EQU $5
000017B8                           946  
000017B8                           947          *some code...
000017B8                           948  
000017B8                           949  
000017B8                           950  *STARTS WITH 0110, BCC--------------------------------------
000017B8                           951  BUCKET_0110
000017B8  =00000006                952  BUCKET0110_BITS EQU $6
000017B8                           953  
000017B8                           954          *some code...
000017B8                           955  
000017B8                           956  
000017B8                           957  *STARTS WITH 1000, DIVU-------------------------------------
000017B8                           958  BUCKET_1000
000017B8  =00000008                959  BUCKET1000_BITS EQU $8
000017B8                           960  
000017B8                           961          *some code...
000017B8                           962  
000017B8                           963  
000017B8                           964  *STARTS WITH 1001, SUBA-------------------------------------
000017B8                           965  BUCKET_1001
000017B8  =00000009                966  BUCKET1001_BITS EQU $9
000017B8                           967  
000017B8                           968          *some code...
000017B8                           969  
000017B8                           970  
000017B8                           971  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000017B8                           972  BUCKET_1011
000017B8  =0000000B                973  BUCKET1011_BITS EQU $B
000017B8                           974  
000017B8                           975          *some code...
000017B8                           976  
000017B8                           977  
000017B8                           978  *STARTS WITH 1100, MULS(W) | AND----------------------------
000017B8                           979  BUCKET_1100
000017B8  =0000000C                980  BUCKET1100_BITS EQU $C
000017B8                           981  
000017B8                           982          *some code...
000017B8                           983  
000017B8                           984  
000017B8                           985  *STARTS WITH 1101, ADD | ADDA-------------------------------
000017B8                           986  BUCKET_1101
000017B8  =0000000D                987  BUCKET1101_BITS EQU $D
000017B8                           988  
000017B8                           989          *some code...
000017B8                           990  
000017B8                           991  
000017B8                           992  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000017B8                           993  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000017B8                           994  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000017B8                           995  BUCKET_1110
000017B8  =0000000E                996  BUCKET1110_BITS EQU $E     
000017B8                           997  
000017B8                           998          *some code...
000017B8                           999  
000017B8                          1000  
000017B8                          1001  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000017B8                          1002  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000017B8  4EF9 00001C28           1003          JMP     BADOPCODE  
000017BE                          1004          
000017BE                          1005  
000017BE                          1006  *-----------------------------------------------------------        
000017BE                          1007  * EA operation size decoding functionality for immediate data
000017BE                          1008  *-----------------------------------------------------------   
000017BE                          1009  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
000017BE                          1010  WrapperSizeImmediate
000017BE  4284                    1011          CLR.L   D4
000017C0                          1012          *Depending on the EA Register, choose which size to decode
000017C0  B23C 0000               1013          CMP.B   #$00,D1
000017C4  6700 0014               1014          BEQ     ByteSizeImmediate
000017C8                          1015          
000017C8  B23C 0001               1016          CMP.B   #$01,D1
000017CC  6700 002E               1017          BEQ     WordSizeImmediate
000017D0                          1018  
000017D0  B23C 0002               1019          CMP.B   #$02,D1
000017D4  6700 0048               1020          BEQ     LongSizeImmediate
000017D8                          1021          
000017D8                          1022  *Used to get back to what we were doing, after dealing with the specific size
000017D8                          1023  WrapperSizeImmediateEnd
000017D8  4E75                    1024          RTS
000017DA                          1025          
000017DA                          1026  ByteSizeImmediate
000017DA  3818                    1027          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
000017DC                          1028          
000017DC                          1029          *Output '.B' to console...
000017DC  43F9 000021FF           1030          LEA     ByteSize,A1 *Loads ByteSize into address register A1
000017E2  103C 000E               1031          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000017E6  4E4F                    1032          TRAP    #15         *Displays Message
000017E8                          1033          
000017E8                          1034          *Output '#$' just before the immediate data
000017E8  43F9 000022BE           1035          LEA     ShaBang,A1
000017EE  103C 000E               1036          MOVE.B  #14,D0
000017F2  4E4F                    1037          TRAP    #15  
000017F4                          1038          
000017F4                          1039          *output the immediate data to console with the hex-ascii converter
000017F4  4EB8 11E6               1040          JSR     HEXASCII
000017F8                          1041                  
000017F8  4EF8 17D8               1042          JMP     WrapperSizeImmediateEnd
000017FC                          1043                  
000017FC                          1044  WordSizeImmediate
000017FC  3818                    1045          MOVE.W  (A0)+,D4    *read in next word, data is that word
000017FE                          1046          
000017FE                          1047          *Output '.W' to console...
000017FE  43F9 00002206           1048          LEA     WordSize,A1 *Loads WordSize into address register A1
00001804  103C 000E               1049          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001808  4E4F                    1050          TRAP    #15         *Displays Message
0000180A                          1051          
0000180A                          1052          *Output '#$' just before the immediate data
0000180A  43F9 000022BE           1053          LEA     ShaBang,A1
00001810  103C 000E               1054          MOVE.B  #14,D0
00001814  4E4F                    1055          TRAP    #15  
00001816                          1056          
00001816                          1057          *output the immediate data to console with the hex-ascii converter
00001816  4EB8 11E6               1058          JSR     HEXASCII
0000181A                          1059          
0000181A  4EF8 17D8               1060          JMP     WrapperSizeImmediateEnd
0000181E                          1061                  
0000181E                          1062  LongSizeImmediate
0000181E  2818                    1063          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
00001820                          1064          
00001820                          1065          *Output '.L' to console...
00001820  43F9 0000220D           1066          LEA     LongSize,A1 *Loads LongSize into address register A1
00001826  103C 000E               1067          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000182A  4E4F                    1068          TRAP    #15         *Displays Message
0000182C                          1069          
0000182C                          1070          *Output '#$' just before the immediate data
0000182C  43F9 000022BE           1071          LEA     ShaBang,A1
00001832  103C 000E               1072          MOVE.B  #14,D0
00001836  4E4F                    1073          TRAP    #15  
00001838                          1074          
00001838                          1075          *output the immediate data to console with the hex-ascii converter
00001838  4EB8 11E6               1076          JSR     HEXASCII
0000183C                          1077          
0000183C  4EF8 17D8               1078          JMP     WrapperSizeImmediateEnd        
00001840                          1079  
00001840                          1080  
00001840                          1081  *-----------------------------------------------------------        
00001840                          1082  * BCHG Size decoding functionality
00001840                          1083  *----------------------------------------------------------- 
00001840                          1084  BCHGSizeHelper
00001840                          1085          *Determine if the EA mode is a data register. If so, output '.L' to console...
00001840  B43C 0000               1086          CMP.B   #$00,D2
00001844  6700 000A               1087          BEQ     BCHGLongSize
00001848                          1088          
00001848                          1089          *If the EA mode isn't a data register, WE MUST output a '.B' to console...
00001848  4EF9 00001860           1090          JMP     BCHGByteSize
0000184E                          1091          
0000184E                          1092  *Used to get back to what we were doing, after dealing with the specific size
0000184E                          1093  BCHGSizeHelperEnd
0000184E  4E75                    1094          RTS  
00001850                          1095          
00001850                          1096  BCHGLongSize
00001850                          1097          *Output '.L' to console...
00001850  43F9 0000220D           1098          LEA     LongSize,A1 *Loads LongSize into address register A1
00001856  103C 000E               1099          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000185A  4E4F                    1100          TRAP    #15         *Displays Message
0000185C                          1101  
0000185C  4EF8 184E               1102          JMP     BCHGSizeHelperEnd
00001860                          1103          
00001860                          1104  BCHGByteSize
00001860                          1105          *Output '.B' to console...
00001860  43F9 000021FF           1106          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001866  103C 000E               1107          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000186A  4E4F                    1108          TRAP    #15         *Displays Message   
0000186C                          1109          
0000186C  4EF8 184E               1110          JMP     BCHGSizeHelperEnd
00001870                          1111          
00001870                          1112  *Output the immediate data for a BCHG(static). Data is always byte size.
00001870                          1113  BCHGImmediate
00001870  3818                    1114          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word        
00001872                          1115          
00001872                          1116          *Output '#$' just before the immediate data
00001872  43F9 000022BE           1117          LEA     ShaBang,A1
00001878  103C 000E               1118          MOVE.B  #14,D0
0000187C  4E4F                    1119          TRAP    #15  
0000187E                          1120          
0000187E                          1121          *output the immediate data to console with the hex-ascii converter
0000187E  4EB8 11E6               1122          JSR     HEXASCII
00001882                          1123                  
00001882  4E75                    1124          RTS        
00001884                          1125  
00001884                          1126  
00001884                          1127  *-----------------------------------------------------------        
00001884                          1128  * EA Mode/EA Register decoding functionality
00001884                          1129  *-----------------------------------------------------------        
00001884                          1130  DataRegMode
00001884                          1131          *Depending on the EA Register, output a different register number
00001884  4EB9 000018D4           1132          JSR     WrapperDataReg        
0000188A                          1133          
0000188A                          1134          *if this was called for a destination decoding then we are done decoding this        
0000188A                          1135          *instruction, go get the next instruction
0000188A  BC3C 0001               1136          CMP.B   #$01,D6
0000188E  6600 FADC               1137          BNE     GRAB_NEXT_OP
00001892                          1138          
00001892                          1139          *else this was a source decoding, rts back to we can keep decoding
00001892  4E75                    1140          RTS
00001894                          1141  
00001894                          1142  AddrDirectMode
00001894                          1143          *some code...
00001894                          1144  
00001894                          1145  AddrIndirectMode
00001894                          1146          *Depending on the EA Register, output a different register number
00001894  4EB9 00001996           1147          JSR     WrapperAddrIndirect
0000189A                          1148                          
0000189A                          1149          *if this was called for a destination decoding then we are done decoding this        
0000189A                          1150          *instruction, go get the next instruction
0000189A  BC3C 0001               1151          CMP.B   #$01,D6
0000189E  6600 FACC               1152          BNE     GRAB_NEXT_OP
000018A2                          1153          
000018A2                          1154          *else this was a source decoding, rts back to we can keep decoding
000018A2  4E75                    1155          RTS
000018A4                          1156  
000018A4                          1157  AddrIndirectPostMode
000018A4                          1158          *Depending on the EA Register, output a different register number
000018A4  4EB9 00001A58           1159          JSR     WrapperAddrIndirectPost
000018AA                          1160  
000018AA                          1161          *if this was called for a destination decoding then we are done decoding this        
000018AA                          1162          *instruction, go get the next instruction
000018AA  BC3C 0001               1163          CMP.B   #$01,D6
000018AE  6600 FABC               1164          BNE     GRAB_NEXT_OP
000018B2                          1165          
000018B2                          1166          *else this was a source decoding, rts back to we can keep decoding
000018B2  4E75                    1167          RTS
000018B4                          1168  
000018B4                          1169  AddrIndirectPreMode
000018B4                          1170          *Depending on the EA Register, output a different register number
000018B4  4EB9 00001B1A           1171          JSR     WrapperAddrIndirectPre
000018BA                          1172  
000018BA                          1173          *if this was called for a destination decoding then we are done decoding this        
000018BA                          1174          *instruction, go get the next instruction
000018BA  BC3C 0001               1175          CMP.B   #$01,D6
000018BE  6600 FAAC               1176          BNE     GRAB_NEXT_OP
000018C2                          1177          
000018C2                          1178          *else this was a source decoding, rts back to we can keep decoding
000018C2  4E75                    1179          RTS
000018C4                          1180  
000018C4                          1181  AddrAbsoluteMode
000018C4                          1182          *Depending on the EA Register, output a different register number
000018C4  4EB9 00001BDC           1183          JSR     WrapperAddrAbsolute        
000018CA                          1184  
000018CA                          1185          *if this was called for a destination decoding then we are done decoding this        
000018CA                          1186          *instruction, go get the next instruction
000018CA  BC3C 0001               1187          CMP.B   #$01,D6
000018CE  6600 FA9C               1188          BNE     GRAB_NEXT_OP
000018D2                          1189          
000018D2                          1190          *else this was a source decoding, rts back to we can keep decoding
000018D2  4E75                    1191          RTS
000018D4                          1192          
000018D4                          1193  ImmediateDataMode
000018D4                          1194          *some code        
000018D4                          1195          
000018D4                          1196          
000018D4                          1197  *-----------------------------------------------------------        
000018D4                          1198  * Output logic for all Data Registers (0-7)
000018D4                          1199  *-----------------------------------------------------------
000018D4                          1200  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000018D4                          1201  WrapperDataReg
000018D4                          1202          *Depending on the EA destination register, output a different register number
000018D4  B63C 0000               1203          CMP.B   #$00,D3
000018D8  6700 003C               1204          BEQ     DataReg0
000018DC                          1205          
000018DC  B63C 0001               1206          CMP.B   #$01,D3
000018E0  6700 0044               1207          BEQ     DataReg1
000018E4                          1208          
000018E4  B63C 0002               1209          CMP.B   #$02,D3
000018E8  6700 004C               1210          BEQ     DataReg2
000018EC                          1211          
000018EC  B63C 0003               1212          CMP.B   #$03,D3
000018F0  6700 0054               1213          BEQ     DataReg3
000018F4                          1214          
000018F4  B63C 0004               1215          CMP.B   #$04,D3
000018F8  6700 005C               1216          BEQ     DataReg4
000018FC                          1217          
000018FC  B63C 0005               1218          CMP.B   #$05,D3
00001900  6700 0064               1219          BEQ     DataReg5
00001904                          1220          
00001904  B63C 0006               1221          CMP.B   #$06,D3
00001908  6700 006C               1222          BEQ     DataReg6
0000190C                          1223          
0000190C  B63C 0007               1224          CMP.B   #$07,D3
00001910  6700 0074               1225          BEQ     DataReg7        
00001914                          1226  
00001914                          1227  *Used to get back to 'DataRegMode', after dealing with the specific register
00001914                          1228  WrapperDataRegEnd
00001914  4E75                    1229          RTS
00001916                          1230  
00001916                          1231  DataReg0
00001916                          1232          *Output the specific data register...
00001916  43F9 00002214           1233          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
0000191C  103C 000E               1234          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001920  4E4F                    1235          TRAP    #15             *Displays Message   
00001922                          1236          
00001922  4EF8 1914               1237          JMP     WrapperDataRegEnd
00001926                          1238  
00001926                          1239  DataReg1
00001926  43F9 00002217           1240          LEA     OutDataReg1,A1
0000192C  103C 000E               1241          MOVE.B  #14,D0
00001930  4E4F                    1242          TRAP    #15
00001932                          1243          
00001932  4EF8 1914               1244          JMP     WrapperDataRegEnd
00001936                          1245  
00001936                          1246  DataReg2
00001936  43F9 0000221A           1247          LEA     OutDataReg2,A1
0000193C  103C 000E               1248          MOVE.B  #14,D0
00001940  4E4F                    1249          TRAP    #15
00001942                          1250  
00001942  4EF8 1914               1251          JMP     WrapperDataRegEnd
00001946                          1252      
00001946                          1253  DataReg3
00001946  43F9 0000221D           1254          LEA     OutDataReg3,A1
0000194C  103C 000E               1255          MOVE.B  #14,D0
00001950  4E4F                    1256          TRAP    #15
00001952                          1257  
00001952  4EF8 1914               1258          JMP     WrapperDataRegEnd
00001956                          1259          
00001956                          1260  DataReg4
00001956  43F9 00002220           1261          LEA     OutDataReg4,A1
0000195C  103C 000E               1262          MOVE.B  #14,D0
00001960  4E4F                    1263          TRAP    #15
00001962                          1264  
00001962  4EF8 1914               1265          JMP     WrapperDataRegEnd
00001966                          1266                 
00001966                          1267  DataReg5
00001966  43F9 00002223           1268          LEA     OutDataReg5,A1
0000196C  103C 000E               1269          MOVE.B  #14,D0
00001970  4E4F                    1270          TRAP    #15
00001972                          1271  
00001972  4EF8 1914               1272          JMP     WrapperDataRegEnd
00001976                          1273          
00001976                          1274  DataReg6
00001976  43F9 00002226           1275          LEA     OutDataReg6,A1 A1
0000197C  103C 000E               1276          MOVE.B  #14,D0
00001980  4E4F                    1277          TRAP    #15
00001982                          1278  
00001982  4EF8 1914               1279          JMP     WrapperDataRegEnd
00001986                          1280          
00001986                          1281  DataReg7
00001986  43F9 00002229           1282          LEA     OutDataReg7,A1
0000198C  103C 000E               1283          MOVE.B  #14,D0
00001990  4E4F                    1284          TRAP    #15
00001992                          1285          
00001992  4EF8 1914               1286          JMP     WrapperDataRegEnd
00001996                          1287  
00001996                          1288  
00001996                          1289  *-----------------------------------------------------------        
00001996                          1290  * Output logic for all Address Indirect Registers (0-7)
00001996                          1291  *-----------------------------------------------------------     
00001996                          1292  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001996                          1293  WrapperAddrIndirect
00001996                          1294          *Depending on the EA Register, output a different register number
00001996  B63C 0000               1295          CMP.B   #$00,D3
0000199A  6700 003C               1296          BEQ     AddrIndReg0
0000199E                          1297          
0000199E  B63C 0001               1298          CMP.B   #$01,D3
000019A2  6700 0044               1299          BEQ     AddrIndReg1
000019A6                          1300          
000019A6  B63C 0002               1301          CMP.B   #$02,D3
000019AA  6700 004C               1302          BEQ     AddrIndReg2
000019AE                          1303          
000019AE  B63C 0003               1304          CMP.B   #$03,D3
000019B2  6700 0054               1305          BEQ     AddrIndReg3
000019B6                          1306          
000019B6  B63C 0004               1307          CMP.B   #$04,D3
000019BA  6700 005C               1308          BEQ     AddrIndReg4
000019BE                          1309          
000019BE  B63C 0005               1310          CMP.B   #$05,D3
000019C2  6700 0064               1311          BEQ     AddrIndReg5
000019C6                          1312          
000019C6  B63C 0006               1313          CMP.B   #$06,D3
000019CA  6700 006C               1314          BEQ     AddrIndReg6
000019CE                          1315          
000019CE  B63C 0007               1316          CMP.B   #$07,D3
000019D2  6700 0074               1317          BEQ     AddrIndReg7
000019D6                          1318  
000019D6                          1319  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
000019D6                          1320  WrapperAddrIndirectEnd
000019D6  4E75                    1321          RTS        
000019D8                          1322  
000019D8                          1323  AddrIndReg0
000019D8                          1324          *Output the specific address indirect register...
000019D8  43F9 0000222C           1325          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
000019DE  103C 000E               1326          MOVE.B  #14,D0              *Moves the number 14 into data register D0
000019E2  4E4F                    1327          TRAP    #15                 *Displays Message        
000019E4                          1328          
000019E4  4EF8 19D6               1329          JMP     WrapperAddrIndirectEnd
000019E8                          1330  
000019E8                          1331  AddrIndReg1
000019E8  43F9 00002231           1332          LEA     OutAddrIndReg1,A1
000019EE  103C 000E               1333          MOVE.B  #14,D0
000019F2  4E4F                    1334          TRAP    #15
000019F4                          1335          
000019F4  4EF8 19D6               1336          JMP     WrapperAddrIndirectEnd
000019F8                          1337  
000019F8                          1338  AddrIndReg2
000019F8  43F9 00002236           1339          LEA     OutAddrIndReg2,A1
000019FE  103C 000E               1340          MOVE.B  #14,D0
00001A02  4E4F                    1341          TRAP    #15
00001A04                          1342          
00001A04  4EF8 19D6               1343          JMP     WrapperAddrIndirectEnd
00001A08                          1344  
00001A08                          1345  AddrIndReg3
00001A08  43F9 0000223B           1346          LEA     OutAddrIndReg3,A1
00001A0E  103C 000E               1347          MOVE.B  #14,D0
00001A12  4E4F                    1348          TRAP    #15
00001A14                          1349          
00001A14  4EF8 19D6               1350          JMP     WrapperAddrIndirectEnd
00001A18                          1351  
00001A18                          1352  AddrIndReg4
00001A18  43F9 00002240           1353          LEA     OutAddrIndReg4,A1
00001A1E  103C 000E               1354          MOVE.B  #14,D0
00001A22  4E4F                    1355          TRAP    #15
00001A24                          1356          
00001A24  4EF8 19D6               1357          JMP     WrapperAddrIndirectEnd
00001A28                          1358  
00001A28                          1359  AddrIndReg5
00001A28  43F9 00002245           1360          LEA     OutAddrIndReg5,A1
00001A2E  103C 000E               1361          MOVE.B  #14,D0
00001A32  4E4F                    1362          TRAP    #15
00001A34                          1363          
00001A34  4EF8 19D6               1364          JMP     WrapperAddrIndirectEnd
00001A38                          1365  
00001A38                          1366  AddrIndReg6
00001A38  43F9 0000224A           1367          LEA     OutAddrIndReg6,A1
00001A3E  103C 000E               1368          MOVE.B  #14,D0
00001A42  4E4F                    1369          TRAP    #15
00001A44                          1370          
00001A44  4EF8 19D6               1371          JMP     WrapperAddrIndirectEnd
00001A48                          1372  
00001A48                          1373  AddrIndReg7
00001A48  43F9 0000224F           1374          LEA     OutAddrIndReg7,A1
00001A4E  103C 000E               1375          MOVE.B  #14,D0
00001A52  4E4F                    1376          TRAP    #15
00001A54                          1377          
00001A54  4EF8 19D6               1378          JMP     WrapperAddrIndirectEnd
00001A58                          1379          
00001A58                          1380          
00001A58                          1381  *-----------------------------------------------------------        
00001A58                          1382  * Output logic for all Address Indirect Post Increment Registers (0-7)
00001A58                          1383  *-----------------------------------------------------------     
00001A58                          1384  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001A58                          1385  WrapperAddrIndirectPost
00001A58                          1386          *Depending on the EA Register, output a different register number
00001A58  B63C 0000               1387          CMP.B   #$00,D3
00001A5C  6700 003C               1388          BEQ     AddrIndPoReg0
00001A60                          1389          
00001A60  B63C 0001               1390          CMP.B   #$01,D3
00001A64  6700 0044               1391          BEQ     AddrIndPoReg1
00001A68                          1392          
00001A68  B63C 0002               1393          CMP.B   #$02,D3
00001A6C  6700 004C               1394          BEQ     AddrIndPoReg2
00001A70                          1395          
00001A70  B63C 0003               1396          CMP.B   #$03,D3
00001A74  6700 0054               1397          BEQ     AddrIndPoReg3
00001A78                          1398          
00001A78  B63C 0004               1399          CMP.B   #$04,D3
00001A7C  6700 005C               1400          BEQ     AddrIndPoReg4
00001A80                          1401          
00001A80  B63C 0005               1402          CMP.B   #$05,D3
00001A84  6700 0064               1403          BEQ     AddrIndPoReg5
00001A88                          1404          
00001A88  B63C 0006               1405          CMP.B   #$06,D3
00001A8C  6700 006C               1406          BEQ     AddrIndPoReg6
00001A90                          1407          
00001A90  B63C 0007               1408          CMP.B   #$07,D3
00001A94  6700 0074               1409          BEQ     AddrIndPoReg7
00001A98                          1410  
00001A98                          1411  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
00001A98                          1412  WrapperAddrIndirectPostEnd
00001A98  4E75                    1413          RTS        
00001A9A                          1414  
00001A9A                          1415  AddrIndPoReg0
00001A9A                          1416          *Output the specific address indirect post register...
00001A9A  43F9 00002254           1417          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001AA0  103C 000E               1418          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001AA4  4E4F                    1419          TRAP    #15                 *Displays Message        
00001AA6                          1420          
00001AA6  4EF8 1A98               1421          JMP     WrapperAddrIndirectPostEnd
00001AAA                          1422  
00001AAA                          1423  AddrIndPoReg1
00001AAA  43F9 0000225A           1424          LEA     OutAddrIndPoReg1,A1
00001AB0  103C 000E               1425          MOVE.B  #14,D0
00001AB4  4E4F                    1426          TRAP    #15
00001AB6                          1427          
00001AB6  4EF8 1A98               1428          JMP     WrapperAddrIndirectPostEnd
00001ABA                          1429  
00001ABA                          1430  AddrIndPoReg2
00001ABA  43F9 00002260           1431          LEA     OutAddrIndPoReg2,A1
00001AC0  103C 000E               1432          MOVE.B  #14,D0
00001AC4  4E4F                    1433          TRAP    #15
00001AC6                          1434          
00001AC6  4EF8 1A98               1435          JMP     WrapperAddrIndirectPostEnd
00001ACA                          1436  
00001ACA                          1437  AddrIndPoReg3
00001ACA  43F9 00002266           1438          LEA     OutAddrIndPoReg3,A1
00001AD0  103C 000E               1439          MOVE.B  #14,D0
00001AD4  4E4F                    1440          TRAP    #15
00001AD6                          1441          
00001AD6  4EF8 1A98               1442          JMP     WrapperAddrIndirectPostEnd
00001ADA                          1443  
00001ADA                          1444  AddrIndPoReg4
00001ADA  43F9 0000226C           1445          LEA     OutAddrIndPoReg4,A1
00001AE0  103C 000E               1446          MOVE.B  #14,D0
00001AE4  4E4F                    1447          TRAP    #15
00001AE6                          1448          
00001AE6  4EF8 1A98               1449          JMP     WrapperAddrIndirectPostEnd
00001AEA                          1450  
00001AEA                          1451  AddrIndPoReg5
00001AEA  43F9 00002272           1452          LEA     OutAddrIndPoReg5,A1
00001AF0  103C 000E               1453          MOVE.B  #14,D0
00001AF4  4E4F                    1454          TRAP    #15
00001AF6                          1455          
00001AF6  4EF8 1A98               1456          JMP     WrapperAddrIndirectPostEnd
00001AFA                          1457  
00001AFA                          1458  AddrIndPoReg6
00001AFA  43F9 00002278           1459          LEA     OutAddrIndPoReg6,A1
00001B00  103C 000E               1460          MOVE.B  #14,D0
00001B04  4E4F                    1461          TRAP    #15
00001B06                          1462          
00001B06  4EF8 1A98               1463          JMP     WrapperAddrIndirectPostEnd
00001B0A                          1464  
00001B0A                          1465  AddrIndPoReg7
00001B0A  43F9 0000227E           1466          LEA     OutAddrIndPoReg7,A1
00001B10  103C 000E               1467          MOVE.B  #14,D0
00001B14  4E4F                    1468          TRAP    #15
00001B16                          1469          
00001B16  4EF8 1A98               1470          JMP     WrapperAddrIndirectPostEnd
00001B1A                          1471  
00001B1A                          1472  
00001B1A                          1473  *-----------------------------------------------------------        
00001B1A                          1474  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
00001B1A                          1475  *-----------------------------------------------------------     
00001B1A                          1476  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001B1A                          1477  WrapperAddrIndirectPre
00001B1A                          1478          *Depending on the EA Register, output a different register number
00001B1A  B63C 0000               1479          CMP.B   #$00,D3
00001B1E  6700 003C               1480          BEQ     AddrIndPrReg0
00001B22                          1481          
00001B22  B63C 0001               1482          CMP.B   #$01,D3
00001B26  6700 0044               1483          BEQ     AddrIndPrReg1
00001B2A                          1484          
00001B2A  B63C 0002               1485          CMP.B   #$02,D3
00001B2E  6700 004C               1486          BEQ     AddrIndPrReg2
00001B32                          1487          
00001B32  B63C 0003               1488          CMP.B   #$03,D3
00001B36  6700 0054               1489          BEQ     AddrIndPrReg3
00001B3A                          1490          
00001B3A  B63C 0004               1491          CMP.B   #$04,D3
00001B3E  6700 005C               1492          BEQ     AddrIndPrReg4
00001B42                          1493          
00001B42  B63C 0005               1494          CMP.B   #$05,D3
00001B46  6700 0064               1495          BEQ     AddrIndPrReg5
00001B4A                          1496          
00001B4A  B63C 0006               1497          CMP.B   #$06,D3
00001B4E  6700 006C               1498          BEQ     AddrIndPrReg6
00001B52                          1499          
00001B52  B63C 0007               1500          CMP.B   #$07,D3
00001B56  6700 0074               1501          BEQ     AddrIndPrReg7
00001B5A                          1502  
00001B5A                          1503  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001B5A                          1504  WrapperAddrIndirectPreEnd
00001B5A  4E75                    1505          RTS        
00001B5C                          1506  
00001B5C                          1507  AddrIndPrReg0
00001B5C                          1508          *Output the specific address indirect post register...
00001B5C  43F9 00002284           1509          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001B62  103C 000E               1510          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001B66  4E4F                    1511          TRAP    #15                 *Displays Message        
00001B68                          1512          
00001B68  4EF8 1B5A               1513          JMP     WrapperAddrIndirectPreEnd
00001B6C                          1514  
00001B6C                          1515  AddrIndPrReg1
00001B6C  43F9 0000228A           1516          LEA     OutAddrIndPrReg1,A1
00001B72  103C 000E               1517          MOVE.B  #14,D0
00001B76  4E4F                    1518          TRAP    #15
00001B78                          1519          
00001B78  4EF8 1B5A               1520          JMP     WrapperAddrIndirectPreEnd
00001B7C                          1521  
00001B7C                          1522  AddrIndPrReg2
00001B7C  43F9 00002290           1523          LEA     OutAddrIndPrReg2,A1
00001B82  103C 000E               1524          MOVE.B  #14,D0
00001B86  4E4F                    1525          TRAP    #15
00001B88                          1526          
00001B88  4EF8 1B5A               1527          JMP     WrapperAddrIndirectPreEnd
00001B8C                          1528  
00001B8C                          1529  AddrIndPrReg3
00001B8C  43F9 00002296           1530          LEA     OutAddrIndPrReg3,A1
00001B92  103C 000E               1531          MOVE.B  #14,D0
00001B96  4E4F                    1532          TRAP    #15
00001B98                          1533          
00001B98  4EF8 1B5A               1534          JMP     WrapperAddrIndirectPreEnd
00001B9C                          1535  
00001B9C                          1536  AddrIndPrReg4
00001B9C  43F9 0000229C           1537          LEA     OutAddrIndPrReg4,A1
00001BA2  103C 000E               1538          MOVE.B  #14,D0
00001BA6  4E4F                    1539          TRAP    #15
00001BA8                          1540          
00001BA8  4EF8 1B5A               1541          JMP     WrapperAddrIndirectPreEnd
00001BAC                          1542  
00001BAC                          1543  AddrIndPrReg5
00001BAC  43F9 000022A2           1544          LEA     OutAddrIndPrReg5,A1
00001BB2  103C 000E               1545          MOVE.B  #14,D0
00001BB6  4E4F                    1546          TRAP    #15
00001BB8                          1547          
00001BB8  4EF8 1B5A               1548          JMP     WrapperAddrIndirectPreEnd
00001BBC                          1549  
00001BBC                          1550  AddrIndPrReg6
00001BBC  43F9 000022A8           1551          LEA     OutAddrIndPrReg6,A1
00001BC2  103C 000E               1552          MOVE.B  #14,D0
00001BC6  4E4F                    1553          TRAP    #15
00001BC8                          1554          
00001BC8  4EF8 1B5A               1555          JMP     WrapperAddrIndirectPreEnd
00001BCC                          1556  
00001BCC                          1557  AddrIndPrReg7
00001BCC  43F9 000022AE           1558          LEA     OutAddrIndPrReg7,A1
00001BD2  103C 000E               1559          MOVE.B  #14,D0
00001BD6  4E4F                    1560          TRAP    #15
00001BD8                          1561          
00001BD8  4EF8 1B5A               1562          JMP     WrapperAddrIndirectPreEnd
00001BDC                          1563  
00001BDC                          1564  
00001BDC                          1565  *-----------------------------------------------------------        
00001BDC                          1566  * Output logic for absolute memory addressing (0-7)
00001BDC                          1567  *-----------------------------------------------------------     
00001BDC                          1568  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001BDC                          1569  WrapperAddrAbsolute
00001BDC  4284                    1570          CLR.L   D4
00001BDE                          1571          *Depending on the EA Register, choose which size to decode
00001BDE  B63C 0000               1572          CMP.B   #$00,D3
00001BE2  6700 000C               1573          BEQ     WordSizeAbsolute
00001BE6                          1574  
00001BE6  B63C 0001               1575          CMP.B   #$01,D3
00001BEA  6700 0020               1576          BEQ     LongSizeAbsolute
00001BEE                          1577          
00001BEE                          1578  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001BEE                          1579  WrapperAddrAbsoluteEnd
00001BEE  4E75                    1580          RTS
00001BF0                          1581  
00001BF0                          1582  WordSizeAbsolute        
00001BF0  3818                    1583          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001BF2                          1584          
00001BF2                          1585          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001BF2  4281                    1586          CLR.L   D1
00001BF4  123C 0001               1587          MOVE.B  #$01,D1     
00001BF8                          1588              
00001BF8                          1589          *Output ',$' just after source operand
00001BF8  43F9 000022C1           1590          LEA     Bang,A1
00001BFE  103C 000E               1591          MOVE.B  #14,D0
00001C02  4E4F                    1592          TRAP    #15
00001C04                          1593              
00001C04                          1594          *output the absolute mem address to console with the hex-ascii converter
00001C04  4EB8 11E6               1595          JSR     HEXASCII        
00001C08                          1596          
00001C08  4EF8 1BEE               1597          JMP     WrapperAddrAbsoluteEnd
00001C0C                          1598  
00001C0C                          1599  LongSizeAbsolute
00001C0C  2818                    1600          MOVE.L  (A0)+,D4    *read in next long, data is that long
00001C0E                          1601                  
00001C0E                          1602          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001C0E  4281                    1603          CLR.L   D1
00001C10  123C 0010               1604          MOVE.B  #$10,D1
00001C14                          1605                  
00001C14                          1606          *Output ',$' just after source operand
00001C14  43F9 000022C1           1607          LEA     Bang,A1
00001C1A  103C 000E               1608          MOVE.B  #14,D0
00001C1E  4E4F                    1609          TRAP    #15  
00001C20                          1610          
00001C20                          1611          *output the absolute mem address to console with the hex-ascii converter
00001C20  4EB8 11E6               1612          JSR     HEXASCII
00001C24                          1613          
00001C24  4EF8 1BEE               1614          JMP     WrapperAddrAbsoluteEnd
00001C28                          1615          
00001C28                          1616  
00001C28                          1617  *-----------------------------------------------------------        
00001C28                          1618  * Current handling of bad op/ea codes. Should be revisited.
00001C28                          1619  *----------------------------------------------------------- 
00001C28                          1620  BADOPCODE
00001C28                          1621          *We found a bad op code, output some error to the screen, jump to the 
00001C28                          1622          *next instruction in memory.
00001C28                          1623          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001C28                          1624          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001C28                          1625          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001C28                          1626          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001C28                          1627          *i/o and error message code...
00001C28  43F9 000022CA           1628          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001C2E  103C 000E               1629          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001C32  4E4F                    1630          TRAP    #15         *Displays Message
00001C34  4EF8 136C               1631          JMP     GRAB_NEXT_OP
00001C38                          1632                  
00001C38                          1633  BADEACODE
00001C38                          1634          *We found a bad ea code, output some error to the screen, jump to the
00001C38                          1635          *next instruction in memory.
00001C38                          1636          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001C38                          1637          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001C38  43F9 000022C3           1638          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001C3E  103C 000E               1639          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001C42  4E4F                    1640          TRAP    #15         *Displays Message
00001C44  4EF8 136C               1641          JMP     GRAB_NEXT_OP
00001C48                          1642          
00001C48                          1643          
00001C48                          1644  *-----------------------------------------------------------        
00001C48                          1645  * End of Disassembler
00001C48                          1646  *-----------------------------------------------------------    
00001C48                          1647  
00001C48  4E72 2700               1648  DONE    STOP    #$2700  *What does this do? Why was it added?
00001C4C                          1649  
00001C4C  103C 0009               1650  THEEND  MOVE.B  #9,D0
00001C50  4E4F                    1651          TRAP    #15             Halt Simulator        
00001C52                          1652          
00001C52                          1653       
00001C52                          1654  *-----------------------------------------------------------        
00001C52                          1655  * Output stuff
00001C52                          1656  *-----------------------------------------------------------     
00001C52  =0000000D               1657  CR      EQU     $0D             ASCII code for Carriage Return
00001C52  =0000000A               1658  LF      EQU     $0A             ASCII code for Line Feed
00001C52= 2D 2D 2D 2D 2D 2D ...   1659  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001C91= 7C 7C 20 20 20 20 ...   1660              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001CD0= 2D 2D 2D 2D 2D 2D ...   1661              DC.B    '-------------------------------------------------------------',CR,LF
00001D0F= 2A 2A 2A 2A 2A 2A ...   1662              DC.B    '*************************************************************',CR,LF
00001D4E= 2A 2A 2A 2A 2A 2A ...   1663              DC.B    '*************************************************************',CR,LF
00001D8D= 2A 2A 2A 2A 2A 2A ...   1664              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001DCC= 2A 2A 2A 2A 2A 2A ...   1665              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001E0B= 2A 2A 2A 2A 2A 2A ...   1666              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001E4A= 2A 2A 2A 2A 2A 2A ...   1667              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001E89= 2A 2A 2A 2A 2A 2A ...   1668              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001EC8= 2A 2A 2A 2A 2A 2A ...   1669              DC.B    '*************************************************************',CR,LF
00001F07= 2A 2A 2A 2A 2A 2A ...   1670              DC.B    '*************************************************************',CR,LF
00001F46= 2A 20 20 20 20 20 ...   1671              DC.B    '*                                                           *',CR,LF
00001F85= 2A 20 41 75 74 68 ...   1672              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001FC4= 2A 20 20 20 20 20 ...   1673              DC.B    '*                                                           *',CR,LF
00002003= 2A 2A 2A 2A 2A 2A ...   1674              DC.B    '*************************************************************',CR,LF,CR,LF
00002044= 53 74 61 72 74 69 ...   1675              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00002061                          1676              
00002061= 57 6F 75 6C 64 20 ...   1677  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00002092                          1678  
00002092= 20 0D 0A                1679  GETSTRTADDR DC.B    ' ',CR,LF
00002095= 50 6C 65 61 73 65 ...   1680              DC.B    'Please type in your starting address request: ',0
000020C4                          1681              
000020C4= 20 0D 0A                1682  GETENDADDR  DC.B    ' ',CR,LF
000020C7= 50 6C 65 61 73 65 ...   1683              DC.B    'Please type in your ending address request: ',0
000020F4                          1684              
000020F4= 20 0D 0A                1685  QUES_CONT   DC.B    ' ',CR,LF
000020F7= 57 6F 75 6C 64 20 ...   1686              DC.B    'Would you like to continue (Y/N)? ',0
0000211A                          1687              
0000211A= 20 0D 0A                1688  QUIT_MSG    DC.B    ' ',CR,LF
0000211D= 57 6F 75 6C 64 20 ...   1689              DC.B    'Would you like to quit (Y/N)? ',0
0000213C                          1690  
0000213C                          1691  *****************************************************
0000213C                          1692  * I/O storages - assuming users knows what to do.
0000213C                          1693  *****************************************************
0000213C                          1694  CMD_HLD     DS.B    30
0000215A                          1695  CMD_SZ      DS.B    30
00002178                          1696  STADDR      DS.B    10
00002182                          1697  STADDRSZ    DS.B    10
0000218C                          1698  PROGST      DS.L    1
00002190                          1699  ENDADDR     DS.B    10
0000219A                          1700  ENDADDRSZ   DS.B    10
000021A4                          1701  PROGEND     DS.L    1
000021A8                          1702  CONT        DS.B    30
000021C6                          1703  *****************************************************
000021C6                          1704  
000021C6                          1705  *Table for 0-9 && A-F
000021C6= 30 00                   1706  PRNT0   DC.B    '0',0
000021C8= 31 00                   1707  PRNT1   DC.B    '1',0
000021CA= 32 00                   1708  PRNT2   DC.B    '2',0
000021CC= 33 00                   1709  PRNT3   DC.B    '3',0
000021CE= 34 00                   1710  PRNT4   DC.B    '4',0
000021D0= 35 00                   1711  PRNT5   DC.B    '5',0
000021D2= 36 00                   1712  PRNT6   DC.B    '6',0
000021D4= 37 00                   1713  PRNT7   DC.B    '7',0
000021D6= 38 00                   1714  PRNT8   DC.B    '8',0
000021D8= 39 00                   1715  PRNT9   DC.B    '9',0
000021DA= 41 00                   1716  PRNTA   DC.B    'A',0
000021DC= 42 00                   1717  PRNTB   DC.B    'B',0
000021DE= 43 00                   1718  PRNTC   DC.B    'C',0
000021E0= 44 00                   1719  PRNTD   DC.B    'D',0
000021E2= 45 00                   1720  PRNTE   DC.B    'E',0
000021E4= 46 00                   1721  PRNTF   DC.B    'F',0
000021E6                          1722  
000021E6                          1723  *output for all OPCODEs
000021E6= 41 44 44 49 00          1724  ADDI    DC.B    'ADDI',0
000021EB= 41 4E 44 49 00          1725  ANDI    DC.B    'ANDI',0
000021F0= 45 4F 52 49 00          1726  EORI    DC.B    'EORI',0
000021F5= 42 43 48 47 00          1727  BCHG    DC.B    'BCHG',0
000021FA= 43 4D 50 49 00          1728  CMPI    DC.B    'CMPI',0
000021FF                          1729  
000021FF                          1730  *output for the size of the operation
000021FF= 2E 42 20 20 20 20 00    1731  ByteSize    DC.B    '.B    ',0
00002206= 2E 57 20 20 20 20 00    1732  WordSize    DC.B    '.W    ',0
0000220D= 2E 4C 20 20 20 20 00    1733  LongSize    DC.B    '.L    ',0
00002214                          1734  
00002214                          1735  *output for all destination data registers (0-7)
00002214= 44 30 00                1736  OutDataReg0 DC.B    'D0',0
00002217= 44 31 00                1737  OutDataReg1 DC.B    'D1',0
0000221A= 44 32 00                1738  OutDataReg2 DC.B    'D2',0
0000221D= 44 33 00                1739  OutDataReg3 DC.B    'D3',0
00002220= 44 34 00                1740  OutDataReg4 DC.B    'D4',0
00002223= 44 35 00                1741  OutDataReg5 DC.B    'D5',0
00002226= 44 36 00                1742  OutDataReg6 DC.B    'D6',0
00002229= 44 37 00                1743  OutDataReg7 DC.B    'D7',0
0000222C                          1744          
0000222C                          1745  *output for all address indirect registers (0-7)
0000222C= 28 41 30 29 00          1746  OutAddrIndReg0  DC.B    '(A0)',0
00002231= 28 41 31 29 00          1747  OutAddrIndReg1  DC.B    '(A1)',0
00002236= 28 41 32 29 00          1748  OutAddrIndReg2  DC.B    '(A2)',0
0000223B= 28 41 33 29 00          1749  OutAddrIndReg3  DC.B    '(A3)',0
00002240= 28 41 34 29 00          1750  OutAddrIndReg4  DC.B    '(A4)',0
00002245= 28 41 35 29 00          1751  OutAddrIndReg5  DC.B    '(A5)',0
0000224A= 28 41 36 29 00          1752  OutAddrIndReg6  DC.B    '(A6)',0
0000224F= 28 41 37 29 00          1753  OutAddrIndReg7  DC.B    '(A7)',0
00002254                          1754  
00002254                          1755  *output for all address indirect post registers (0-7)
00002254= 28 41 30 29 2B 00       1756  OutAddrIndPoReg0    DC.B    '(A0)+',0
0000225A= 28 41 31 29 2B 00       1757  OutAddrIndPoReg1    DC.B    '(A1)+',0
00002260= 28 41 32 29 2B 00       1758  OutAddrIndPoReg2    DC.B    '(A2)+',0
00002266= 28 41 33 29 2B 00       1759  OutAddrIndPoReg3    DC.B    '(A3)+',0
0000226C= 28 41 34 29 2B 00       1760  OutAddrIndPoReg4    DC.B    '(A4)+',0
00002272= 28 41 35 29 2B 00       1761  OutAddrIndPoReg5    DC.B    '(A5)+',0
00002278= 28 41 36 29 2B 00       1762  OutAddrIndPoReg6    DC.B    '(A6)+',0
0000227E= 28 41 37 29 2B 00       1763  OutAddrIndPoReg7    DC.B    '(A7)+',0
00002284                          1764  
00002284                          1765  *output for all address indirect pre registers (0-7)
00002284= 2D 28 41 30 29 00       1766  OutAddrIndPrReg0    DC.B    '-(A0)',0
0000228A= 2D 28 41 31 29 00       1767  OutAddrIndPrReg1    DC.B    '-(A1)',0
00002290= 2D 28 41 32 29 00       1768  OutAddrIndPrReg2    DC.B    '-(A2)',0
00002296= 2D 28 41 33 29 00       1769  OutAddrIndPrReg3    DC.B    '-(A3)',0
0000229C= 2D 28 41 34 29 00       1770  OutAddrIndPrReg4    DC.B    '-(A4)',0
000022A2= 2D 28 41 35 29 00       1771  OutAddrIndPrReg5    DC.B    '-(A5)',0
000022A8= 2D 28 41 36 29 00       1772  OutAddrIndPrReg6    DC.B    '-(A6)',0
000022AE= 2D 28 41 37 29 00       1773  OutAddrIndPrReg7    DC.B    '-(A7)',0
000022B4                          1774  
000022B4                          1775  *output for a tab only (4 spaces)
000022B4= 20 20 20 20 00          1776  Tab DC.B    '    ',0
000022B9                          1777  
000022B9                          1778  *output for a comma only
000022B9= 2C 00                   1779  Comma   DC.B    ',',0
000022BB                          1780  
000022BB                          1781  *output for a new line only
000022BB= 0D 0A 00                1782  NewLine DC.B    CR,LF,0
000022BE                          1783  
000022BE                          1784  *output for a '#$' and '$' only
000022BE= 23 24 00                1785  ShaBang DC.B    '#$',0
000022C1= 24 00                   1786  Bang    DC.B    '$',0
000022C3                          1787  
000022C3                          1788  *current output for error messages
000022C3= 42 41 44 20 45 41 00    1789  BADEAMSG    DC.B    'BAD EA',0
000022CA= 42 41 44 20 4F 50 00    1790  BADOPMSG    DC.B    'BAD OP',0
000022D1= 49 6D 70 72 6F 70 ...   1791  INV_MSG     DC.B    'Improper command.',CR,LF,0
000022E5= 49 6E 76 61 6C 69 ...   1792  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
000022FE= 49 6E 76 61 6C 69 ...   1793  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
00002315                          1794  
00002315                          1795          
00002315                          1796          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                21E6
ADDRABSOLUTEMODE    18C4
ADDRDIRECTMODE      1894
ADDRINDIRECTMODE    1894
ADDRINDIRECTPOSTMODE  18A4
ADDRINDIRECTPREMODE  18B4
ADDRINDPOREG0       1A9A
ADDRINDPOREG1       1AAA
ADDRINDPOREG2       1ABA
ADDRINDPOREG3       1ACA
ADDRINDPOREG4       1ADA
ADDRINDPOREG5       1AEA
ADDRINDPOREG6       1AFA
ADDRINDPOREG7       1B0A
ADDRINDPRREG0       1B5C
ADDRINDPRREG1       1B6C
ADDRINDPRREG2       1B7C
ADDRINDPRREG3       1B8C
ADDRINDPRREG4       1B9C
ADDRINDPRREG5       1BAC
ADDRINDPRREG6       1BBC
ADDRINDPRREG7       1BCC
ADDRINDREG0         19D8
ADDRINDREG1         19E8
ADDRINDREG2         19F8
ADDRINDREG3         1A08
ADDRINDREG4         1A18
ADDRINDREG5         1A28
ADDRINDREG6         1A38
ADDRINDREG7         1A48
ANDI                21EB
ASCIIHEX            1174
ASCIIHEX1           1178
BADEACODE           1C38
BADEAMSG            22C3
BADOPCODE           1C28
BADOPMSG            22CA
BANG                22C1
BCHG                21F5
BCHGBYTESIZE        1860
BCHGIMMEDIATE       1870
BCHGLONGSIZE        1850
BCHGSIZEHELPER      1840
BCHGSIZEHELPEREND   184E
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         1416
BUCKET_0001         1764
BUCKET_0010         1764
BUCKET_0011         1764
BUCKET_0100         1764
BUCKET_0101         17B8
BUCKET_0110         17B8
BUCKET_1000         17B8
BUCKET_1001         17B8
BUCKET_1011         17B8
BUCKET_1100         17B8
BUCKET_1101         17B8
BUCKET_1110         17B8
BYTESIZE            21FF
BYTESIZEIMMEDIATE   17DA
CHECK               11EA
CHECKEND1           10FA
CHECKSTRT1          10E4
CHECK_LOWN          112C
CHECK_LOWY          111A
CHECK_N             13F0
CHECK_UPN           1124
CHECK_UPY           1110
CHECK_Y             13E2
CHNG_SZB            121C
CHNG_SZL            1202
CHNG_SZW            1236
CMD_HLD             213C
CMD_SZ              215A
CMPI                21FA
COMMA               22B9
CONT                21A8
CONT_Q              13B0
CONV_LOL            11D4
CONV_LOOP           1250
CONV_NUM            11C0
CONV_UPL            11CA
CR                  D
DATAREG0            1916
DATAREG1            1926
DATAREG2            1936
DATAREG3            1946
DATAREG4            1956
DATAREG5            1966
DATAREG6            1976
DATAREG7            1986
DATAREGMODE         1884
DONE                1C48
EA_ADDI             14A2
EA_ANDI             1518
EA_BCHG_D           1610
EA_BCHG_S           16A8
EA_CLR              17B8
EA_CMPI             1724
EA_EORI             158E
EA_JSR              17B8
EA_LEA              17B8
EA_MOVEM            17B8
EA_MULS_L           17B8
EA_RTS              17B8
ENDADDR             2190
ENDADDRSZ           219A
EORI                21F0
EXITSUB             11E0
EXIT_CONV           12D6
GETENDADDR          20C4
GETSTRTADDR         2092
GET_END             108C
GET_STRT            103E
GRAB_NEXT_OP        136C
HEXASCII            11E6
HEXASCIIREG         11FE
IMMEDIATEDATAMODE   18D4
INV2                1400
INVALID1            1134
INVENDMSG           22FE
INVSTRTMSG          22E5
INV_END1            1160
INV_MSG             22D1
INV_STRT1           114C
IS_ADDI             146C
IS_ANDI             14E2
IS_BCHG_D           15CE
IS_BCHG_S           166C
IS_CLR              17B8
IS_CMPI             16EE
IS_EORI             1558
IS_JSR              17B8
IS_LEA              17B8
IS_MOVEM            17B8
IS_MULS_L           17B8
IS_RTS              17B8
LF                  A
LONGSIZE            220D
LONGSIZEABSOLUTE    1C0C
LONGSIZEIMMEDIATE   181E
LOOP_1              1014
LOOP_B              1220
LOOP_L              1206
LOOP_W              123A
MAX_LINE            F
MESSAGE             1C52
NEWLINE             22BB
NUM_0               12E4
NUM_1               12EC
NUM_2               12F4
NUM_3               12FC
NUM_4               1304
NUM_5               130C
NUM_6               1314
NUM_7               131C
NUM_8               1324
NUM_9               132C
NUM_A               1334
NUM_B               133C
NUM_C               1344
NUM_D               134C
NUM_E               1354
NUM_F               135C
OUTADDRINDPOREG0    2254
OUTADDRINDPOREG1    225A
OUTADDRINDPOREG2    2260
OUTADDRINDPOREG3    2266
OUTADDRINDPOREG4    226C
OUTADDRINDPOREG5    2272
OUTADDRINDPOREG6    2278
OUTADDRINDPOREG7    227E
OUTADDRINDPRREG0    2284
OUTADDRINDPRREG1    228A
OUTADDRINDPRREG2    2290
OUTADDRINDPRREG3    2296
OUTADDRINDPRREG4    229C
OUTADDRINDPRREG5    22A2
OUTADDRINDPRREG6    22A8
OUTADDRINDPRREG7    22AE
OUTADDRINDREG0      222C
OUTADDRINDREG1      2231
OUTADDRINDREG2      2236
OUTADDRINDREG3      223B
OUTADDRINDREG4      2240
OUTADDRINDREG5      2245
OUTADDRINDREG6      224A
OUTADDRINDREG7      224F
OUTDATAREG0         2214
OUTDATAREG1         2217
OUTDATAREG2         221A
OUTDATAREG3         221D
OUTDATAREG4         2220
OUTDATAREG5         2223
OUTDATAREG6         2226
OUTDATAREG7         2229
PRINT_NUM           12DC
PRNT0               21C6
PRNT1               21C8
PRNT2               21CA
PRNT3               21CC
PRNT4               21CE
PRNT5               21D0
PRNT6               21D2
PRNT7               21D4
PRNT8               21D6
PRNT9               21D8
PRNTA               21DA
PRNTB               21DC
PRNTC               21DE
PRNTD               21E0
PRNTE               21E2
PRNTF               21E4
PROGEND             21A4
PROGST              218C
QUES_CONT           20F4
QUIT_MSG            211A
SHABANG             22BE
STACK               7000
STADDR              2178
STADDRSZ            2182
START               1000
STARTASSEM          2061
ST_ADDR             7FC6
ST_BAD              11DE
TAB                 22B4
THEEND              1C4C
WORDSIZE            2206
WORDSIZEABSOLUTE    1BF0
WORDSIZEIMMEDIATE   17FC
WRAPPERADDRABSOLUTE  1BDC
WRAPPERADDRABSOLUTEEND  1BEE
WRAPPERADDRINDIRECT  1996
WRAPPERADDRINDIRECTEND  19D6
WRAPPERADDRINDIRECTPOST  1A58
WRAPPERADDRINDIRECTPOSTEND  1A98
WRAPPERADDRINDIRECTPRE  1B1A
WRAPPERADDRINDIRECTPREEND  1B5A
WRAPPERDATAREG      18D4
WRAPPERDATAREGEND   1914
WRAPPERSIZEIMMEDIATE  17BE
WRAPPERSIZEIMMEDIATEEND  17D8
