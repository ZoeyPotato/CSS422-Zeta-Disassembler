00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.0
Created On: 3/14/2014 3:21:51 AM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/11/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC6                  9  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00000000  =0000000F                 11  MAX_LINE    EQU     15      *Maximum number of instructions that can be 
00001000                            12  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 13              LEA stack,SP
00001004  3C3C 000F                 14              MOVE    #MAX_LINE,D6
00001008                            15  
00001008                            16  
00001008                            17  *-----------------------------------------------------------
00001008                            18  * Start of I/O
00001008                            19  *-----------------------------------------------------------            
00001008  43F9 00001B40             20              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 21              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      22              TRAP    #15         *Displays Message
00001014                            23          
00001014  303C 0000                 24  loop_1      MOVE    #0,D0       
00001018  43F9 00001F4F             25              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 26              MOVE.B  #14,D0
00001022  4E4F                      27              TRAP    #15    
00001024  303C 0002                 28              MOVE    #2,D0
00001028  43F9 0000202A             29              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      30              TRAP    #15
00001030  0C01 0001                 31              CMPI.B  #01,D1
00001034  6600 00FE                 32              BNE     INVALID1
00001038  4EB9 00001110             33              JSR     CHECK_UPY
0000103E                            34  *-----------------------------------------------------------
0000103E                            35  *
0000103E                            36  * I/O: Check Start Address
0000103E                            37  *
0000103E                            38  * Make sure that start address starts after allocated 
0000103E                            39  * memory addresses. Else, it will print out a message 
0000103E                            40  * saying that requested address is invalid & prompts the
0000103E                            41  * user again for the starting address.
0000103E                            42  *-----------------------------------------------------------
0000103E  43F9 00001F80             43  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001044  103C 000E                 44              MOVE.B  #14,D0
00001048  4E4F                      45              TRAP    #15
0000104A  43F9 00002066             46              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001050  3239 00002070             47              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001056  303C 0002                 48              MOVE    #2,D0           *Get start address
0000105A  4E4F                      49              TRAP    #15
0000105C  4EB9 000010E4             50              JSR     CHECKSTRT1
00001062  4287                      51              CLR.L   D7
00001064  4EB9 00001174             52              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106A  0C03 0001                 53              CMPI.B  #01,D3      *Check if there was a bad start
0000106E  6700 00DC                 54              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001072  0C87 00007FC6             55              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001078  6D00 00D2                 56              BLT     INV_STRT1   *Asks for another start address if invalid
0000107C  0C87 00FFFFFE             57              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001082  6C00 00C8                 58              BGE     INV_STRT1
00001086  23C7 0000207A             59              MOVE.L  D7,PROGST
0000108C                            60  
0000108C  43F9 00001FB2             61  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001092  103C 000E                 62              MOVE.B  #14,D0
00001096  4E4F                      63              TRAP    #15
00001098  43F9 0000207E             64              LEA     ENDADDR,A1      *Buffer to hold end address
0000109E  3239 00002088             65              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A4  303C 0002                 66              MOVE    #2,D0
000010A8  4E4F                      67              TRAP    #15
000010AA  4EB9 000010FA             68              JSR     CHECKEND1
000010B0  4287                      69              CLR.L   D7
000010B2  4EB9 00001174             70              JSR     ASCIIHEX
000010B8  0C03 0001                 71              CMPI.B  #01,D3
000010BC  6700 00A2                 72              BEQ     INV_END1
000010C0  0C87 0000207A             73              CMPI.L  #PROGST,D7
000010C6  6D00 0098                 74              BLT     INV_END1
000010CA  0C87 00FFFFFF             75              CMPI.L  #$00FFFFFF,D7
000010D0  6C00 008E                 76              BGE     INV_END1
000010D4  23C7 00002092             77              MOVE.L  D7,PROGEND
000010DA  2079 0000207A             78              MOVEA.L PROGST,A0
000010E0  6000 028A                 79              BRA     GRAB_NEXT_OP            
000010E4                            80                          
000010E4  0C81 00000008             81  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EA  6E00 0060                 82              BGT     INV_STRT1
000010EE  0C81 00000000             83              CMPI.L  #00,D1
000010F4  6300 0056                 84              BLS     INV_STRT1
000010F8  4E75                      85              RTS         
000010FA                            86              
000010FA  0C81 00000008             87  CHECKEND1   CMPI.L  #08,D1
00001100  6E00 005E                 88              BGT     INV_END1
00001104  0C81 00000000             89              CMPI.L  #00,D1
0000110A  6300 0054                 90              BLS     INV_END1
0000110E  4E75                      91              RTS
00001110                            92  
00001110                            93  *-----------------------------------------------------------
00001110                            94  * I/O: Input check for Y, y, N, n
00001110                            95  *-----------------------------------------------------------
00001110  0C11 0059                 96  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001114  6600 0004                 97              BNE     CHECK_LOWY
00001118  4E75                      98              RTS
0000111A  0C11 0079                 99  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
0000111E  6600 0004                100              BNE     CHECK_UPN
00001122  4E75                     101              RTS
00001124  0C11 004E                102  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001128  6700 0A0C                103              BEQ     DONE
0000112C                           104              
0000112C  0C11 006E                105  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001130  6700 0A04                106              BEQ     DONE
00001134                           107              
00001134  163C 0000                108  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001138  303C 0000                109              MOVE    #0,D0       *Prints invalid command msg if not found
0000113C  43F9 00002203            110              LEA     INV_MSG,A1
00001142  303C 000E                111              MOVE    #14,D0
00001146  4E4F                     112              TRAP    #15
00001148  6000 FECA                113              BRA     loop_1
0000114C                           114              
0000114C  43F9 00002217            115  INV_STRT1   LEA     INVSTRTMSG,A1
00001152  103C 000E                116              MOVE.B  #14,D0
00001156  4E4F                     117              TRAP    #15
00001158  163C 0000                118              MOVE.B  #00,D3      *Reset flag
0000115C  6000 FEE0                119              BRA     GET_STRT        
00001160                           120              
00001160  43F9 00002230            121  INV_END1    LEA     INVENDMSG,A1
00001166  103C 000E                122              MOVE.B  #14,D0
0000116A  4E4F                     123              TRAP    #15
0000116C  163C 0000                124              MOVE.B  #00,D3      *Reset flag
00001170  6000 FF1A                125              BRA     GET_END
00001174                           126              
00001174                           127  *-----------------------------------------------------------
00001174                           128  * ASCII to Hex converter
00001174                           129  *
00001174                           130  * Checks and converts the ASCII value to the hex equivalent
00001174                           131  *-----------------------------------------------------------
00001174  48E7 6000                132  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001178  0C01 0000                133  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000117C  6700 0062                134              BEQ     exitSub     *Exit subroutine 
00001180  5301                     135              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001182  E99F                     136              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001184  1419                     137              MOVE.B  (A1)+,D2    *Takes the first char
00001186  0C02 0024                138              CMPI.B  #$24,D2     *See if the first char is $
0000118A  67EC                     139              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000118C  0C02 0030                140              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001190  6D00 004C                141              BLT     st_bad      *Put error message
00001194  0C02 0039                142              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001198  6F00 0026                143              BLE     CONV_NUM    *Convert to number, if so
0000119C  0C02 0041                144              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A0  6D00 003C                145              BLT     st_bad      *Put error message
000011A4  0C02 0046                146              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011A8  6F00 0020                147              BLE     CONV_UpL    *Convert to hex
000011AC  0C02 0061                148              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B0  6D00 002C                149              BLT     st_bad
000011B4  0C02 0066                150              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011B8  6F00 001A                151              BLE     CONV_LoL    
000011BC  6E00 0020                152              BGT     st_bad      *Puts error message for anything greater than f value
000011C0                           153              
000011C0  0402 0030                154  CONV_NUM    SUBI.B  #$30,D2
000011C4  8E02                     155              OR.B    D2,D7
000011C6  4EF8 1178                156              JMP     ASCIIHEX1
000011CA  0402 0037                157  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011CE  8E02                     158              OR.B    D2,D7
000011D0  4EF8 1178                159              JMP     ASCIIHEX1
000011D4  0402 0057                160  CONV_LoL    SUBI.B  #$57,D2
000011D8  8E02                     161              OR.B    D2,D7
000011DA  4EF8 1178                162              JMP     ASCIIHEX1   
000011DE                           163  
000011DE  5203                     164  st_bad      ADDI.B  #01,D3
000011E0  4CDF 0006                165  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E4  4E75                     166              RTS
000011E6                           167              
000011E6                           168  *-----------------------------------------------------------
000011E6                           169  * Hex to ASCII converter
000011E6                           170  *-----------------------------------------------------------
000011E6  48E7 4C00                171  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EA  0C01 0000                172  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011EE  6700 002C                173              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F2  B27C 0001                174              CMP.W   #01,D1          
000011F6  6700 003E                175              BEQ     CHNG_SZW
000011FA  6000 0006                176              BRA     CHNG_SZL        
000011FE                           177  
000011FE  48E7 4C00                178  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001202  123C 0008                179  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
00001206  0C01 0000                180  LOOP_L      CMPI.B  #00,D1
0000120A  6700 00CA                181              BEQ     EXIT_CONV
0000120E  5301                     182              SUBI.B  #01,D1
00001210  E99C                     183              ROL.L   #4,D4           * Shift it for next bit
00001212  2A04                     184              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001214  4EB9 00001250            185              JSR     CONV_LOOP
0000121A  60EA                     186              BRA     LOOP_L      
0000121C                           187  
0000121C  123C 0002                188  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001220  0C01 0000                189  LOOP_B      CMPI.B  #00,D1
00001224  6700 00B0                190              BEQ     EXIT_CONV
00001228  5301                     191              SUBI.B  #01,D1
0000122A  E91C                     192              ROL.B   #4,D4           * Shift it for next bit
0000122C  2A04                     193              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000122E  4EB9 00001250            194              JSR     CONV_LOOP
00001234  60EA                     195              BRA     LOOP_B
00001236                           196              
00001236  123C 0004                197  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123A  0C01 0000                198  LOOP_W      CMPI.B  #00,D1
0000123E  6700 0096                199              BEQ     EXIT_CONV
00001242  5301                     200              SUBI.B  #01,D1
00001244  E95C                     201              ROL.W   #4,D4           * Shift it for next bit
00001246  2A04                     202              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001248  4EB9 00001250            203              JSR     CONV_LOOP
0000124E  60EA                     204              BRA     LOOP_W
00001250                           205  
00001250  0285 0000000F            206  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001256  0C05 0000                207              CMPI.B  #$0,D5
0000125A  6700 0088                208              BEQ     NUM_0
0000125E  0C05 0001                209              CMPI.B  #$1,D5
00001262  6700 0088                210              BEQ     NUM_1
00001266  0C05 0002                211              CMPI.B  #$2,D5
0000126A  6700 0088                212              BEQ     NUM_2
0000126E  0C05 0003                213              CMPI.B  #$3,D5
00001272  6700 0088                214              BEQ     NUM_3
00001276  0C05 0004                215              CMPI.B  #$4,D5
0000127A  6700 0088                216              BEQ     NUM_4
0000127E  0C05 0005                217              CMPI.B  #$5,D5
00001282  6700 0088                218              BEQ     NUM_5
00001286  0C05 0006                219              CMPI.B  #$6,D5
0000128A  6700 0088                220              BEQ     NUM_6
0000128E  0C05 0007                221              CMPI.B  #$7,D5
00001292  6700 0088                222              BEQ     NUM_7
00001296  0C05 0008                223              CMPI.B  #$8,D5
0000129A  6700 0088                224              BEQ     NUM_8
0000129E  0C05 0009                225              CMPI.B  #$9,D5
000012A2  6700 0088                226              BEQ     NUM_9
000012A6  0C05 000A                227              CMPI.B  #$A,D5
000012AA  6700 0088                228              BEQ     NUM_A
000012AE  0C05 000B                229              CMPI.B  #$B,D5
000012B2  6700 0088                230              BEQ     NUM_B
000012B6  0C05 000C                231              CMPI.B  #$C,D5
000012BA  6700 0088                232              BEQ     NUM_C
000012BE  0C05 000D                233              CMPI.B  #$D,D5
000012C2  6700 0088                234              BEQ     NUM_D
000012C6  0C05 000E                235              CMPI.B  #$E,D5
000012CA  6700 0088                236              BEQ     NUM_E
000012CE  0C05 000F                237              CMPI.B  #$F,D5
000012D2  6700 0088                238              BEQ     NUM_F
000012D6                           239              
000012D6  4CDF 0032                240  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DA  4E75                     241              RTS
000012DC                           242              
000012DC  303C 000E                243  PRINT_NUM   MOVE    #14,D0
000012E0  4E4F                     244              TRAP    #15
000012E2  4E75                     245              RTS
000012E4  43F9 000020B4            246  NUM_0       LEA     PRNT0,A1
000012EA  60F0                     247              BRA     PRINT_NUM
000012EC  43F9 000020B6            248  NUM_1       LEA     PRNT1,A1
000012F2  60E8                     249              BRA     PRINT_NUM
000012F4  43F9 000020B8            250  NUM_2       LEA     PRNT2,A1
000012FA  60E0                     251              BRA     PRINT_NUM
000012FC  43F9 000020BA            252  NUM_3       LEA     PRNT3,A1
00001302  60D8                     253              BRA     PRINT_NUM
00001304  43F9 000020BC            254  NUM_4       LEA     PRNT4,A1
0000130A  60D0                     255              BRA     PRINT_NUM
0000130C  43F9 000020BE            256  NUM_5       LEA     PRNT5,A1
00001312  60C8                     257              BRA     PRINT_NUM
00001314  43F9 000020C0            258  NUM_6       LEA     PRNT6,A1
0000131A  60C0                     259              BRA     PRINT_NUM
0000131C  43F9 000020C2            260  NUM_7       LEA     PRNT7,A1
00001322  60B8                     261              BRA     PRINT_NUM
00001324  43F9 000020C4            262  NUM_8       LEA     PRNT8,A1
0000132A  60B0                     263              BRA     PRINT_NUM
0000132C  43F9 000020C6            264  NUM_9       LEA     PRNT9,A1
00001332  60A8                     265              BRA     PRINT_NUM
00001334  43F9 000020C8            266  NUM_A       LEA     PRNTA,A1
0000133A  60A0                     267              BRA     PRINT_NUM
0000133C  43F9 000020CA            268  NUM_B       LEA     PRNTB,A1
00001342  6098                     269              BRA     PRINT_NUM
00001344  43F9 000020CC            270  NUM_C       LEA     PRNTC,A1
0000134A  6090                     271              BRA     PRINT_NUM
0000134C  43F9 000020CE            272  NUM_D       LEA     PRNTD,A1
00001352  6088                     273              BRA     PRINT_NUM
00001354  43F9 000020D0            274  NUM_E       LEA     PRNTE,A1
0000135A  6080                     275              BRA     PRINT_NUM
0000135C  43F9 000020D2            276  NUM_F       LEA     PRNTF,A1
00001362  6000 FF78                277              BRA     PRINT_NUM
00001366                           278  
00001366                           279  *-----------------------------------------------------------        
00001366                           280  * Start of Disassembler
00001366                           281  *-----------------------------------------------------------
00001366                           282          *FOR DEBUGGING ONLY!!!
00001366  207C 00007FC6            283          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000136C                           284          
0000136C                           285  GRAB_NEXT_OP
0000136C  2E08                     286          MOVE.L  A0,D7       
0000136E  0C87 00002092            287          CMPI.L  #PROGEND,D7  *Check and see if A0 == end of test address. 
00001374  6700 FC9E                288          BEQ     loop_1      * Ask user if they want to do the disassembler again
00001378  0C86 00000000            289          CMPI.L  #00,D6      * Check if max line of instructions output on console is reached
0000137E  6700 0026                290          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
00001382  5306                     291          SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
00001384                           292          *Output the address of this instruction to console...
00001384  2808                     293          MOVE.L  A0,D4
00001386  4EB8 11FE                294          JSR     HEXASCIIREG
0000138A                           295          
0000138A                           296          *Output a tab (4 spaces) to console, just after the address...
0000138A  43F9 000021E2            297          LEA     Tab,A1  *Loads Tab into address register A1
00001390  103C 000E                298          MOVE.B  #14,D0  *Moves the number 14 into data register D0
00001394  4E4F                     299          TRAP    #15     *Displays Message
00001396                           300          
00001396                           301          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
00001396                           302          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
00001396                           303          *data that may be associated with the instruction.
00001396                           304          *Post increment addr, A0 will point to the start of next instruction or will 
00001396                           305          *point to the start of any immed/abso data with this current instruction
00001396  4280                     306          CLR.L   D0
00001398  3018                     307          MOVE.W  (A0)+,D0
0000139A                           308          *Copy the word data we just moved into D0 into D7. We are copying this data
0000139A                           309          *So we always have a copy of the WHOLE instruction somewhere
0000139A  4287                     310          CLR.L   D7
0000139C  3E00                     311          MOVE.W  D0,D7
0000139E                           312          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
0000139E                           313          *four bits of the instruction. Once we have just the first four bits, we can
0000139E                           314          *begin to see which 'bucket'/category this instruction falls into. 
0000139E  E048                     315          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013A0  E848                     316          LSR.W   #$04,D0
000013A2                           317          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013A2                           318          *list of buckets until we find which one this instruction falls into.
000013A2  6000 0068                319          BRA     BUCKET_0000     * Start with 0000
000013A6                           320  
000013A6                           321  *-----------------------------------------------------------        
000013A6                           322  * Question Prompts
000013A6                           323  *-----------------------------------------------------------        
000013A6  43F9 00001FE2            324  CONT_Q      LEA     QUES_CONT,A1
000013AC  303C 000E                325              MOVE    #14,D0
000013B0  4E4F                     326              TRAP    #15
000013B2  43F9 00002096            327              LEA     CONT,A1     *Need to store Y/N
000013B8  303C 0002                328              MOVE    #2,D0
000013BC  4E4F                     329              TRAP    #15
000013BE  0C01 0001                330              CMPI.B  #01,D1
000013C2  6600 FD70                331              BNE     INVALID1
000013C6  0C39 0059 00002096       332              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013CE  6600 0008                333              BNE     CHECK_Y
000013D2  3C3C 000F                334              MOVE    #MAX_LINE,D6    *Resets counter
000013D6  4E75                     335              RTS
000013D8  0C11 0079                336  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
000013DC  6600 0008                337              BNE     CHECK_N
000013E0  3C3C 000F                338              MOVE    #MAX_LINE,D6    *Resets counter
000013E4  4E75                     339              RTS
000013E6  0C11 004E                340  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
000013EA  6700 FC28                341              BEQ     loop_1
000013EE  0C11 006E                342              CMPI.B  #$6E,(A1)   *Checks for lowercase n
000013F2  6700 FC20                343              BEQ     loop_1      
000013F6                           344  
000013F6  163C 0000                345  INV2        MOVE.B  #0,D3       *Reset bad flag
000013FA  303C 0000                346              MOVE    #0,D0       *Prints invalid command msg if not found
000013FE  43F9 00002203            347              LEA     INV_MSG,A1
00001404  303C 000E                348              MOVE    #14,D0
00001408  4E4F                     349              TRAP    #15
0000140A  609A                     350              BRA     CONT_Q
0000140C                           351  
0000140C                           352  *-----------------------------------------------------------        
0000140C                           353  * Bucket 0000:
0000140C                           354  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
0000140C                           355  *                   BCHG(dynamic) | BCHG (static) | CMPI----
0000140C                           356  *-----------------------------------------------------------
0000140C                           357  BUCKET_0000
0000140C  =00000000                358  BUCKET0000_BITS EQU $0
0000140C  4281                     359          CLR.L   D1
0000140E                           360          *Load the first 4 bits (really a byte) of BUCKET0 into D1
0000140E  123C 0000                361          MOVE.B  #BUCKET0000_BITS,D1
00001412                           362          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
00001412                           363          *If equal, continue decoding. If not, branch to next bucket.
00001412  B200                     364          CMP.B   D0,D1
00001414  6600 02CE                365          BNE     BUCKET_0001
00001418                           366  
00001418                           367          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
00001418                           368          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
00001418  3007                     369          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
0000141A  0800 0008                370          BTST.L  #$08,D0
0000141E  6600 01A4                371          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
00001422                           372          
00001422                           373          *Now we can check bits 11-8 in the instruction and branch to different op-codes
00001422                           374          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
00001422  E048                     375          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001424  0880 0004                376          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
00001428  0880 0005                377          BCLR.L  #$05,D0
0000142C  0880 0006                378          BCLR.L  #$06,D0
00001430  0880 0007                379          BCLR.L  #$07,D0
00001434                           380          
00001434                           381          *Perform compares with these 4 bits to see which specific instruction it is.
00001434  B03C 0006                382          CMP.B   #$06,D0 *Is this an ADDI?
00001438  6700 0028                383          BEQ     IS_ADDI
0000143C  B03C 0002                384          CMP.B   #$02,D0 *Is this an ANDI?
00001440  6700 0096                385          BEQ     IS_ANDI
00001444  B03C 000A                386          CMP.B   #$0A,D0 *Is this an EORI?
00001448  6700 0104                387          BEQ     IS_EORI
0000144C  B03C 0008                388          CMP.B   #$08,D0 *Is this a BCHG(static)?
00001450  6700 0200                389          BEQ     IS_BCHG_S
00001454  B03C 000C                390          CMP.B   #$0C,D0 *Is this a CMPI?
00001458  6700 0214                391          BEQ     IS_CMPI
0000145C                           392          
0000145C                           393          *If we get through all of the compares without finding the specific instruction,
0000145C                           394          *then this instruction is either not in our list of OP CODES to decode, or is an
0000145C                           395          *invalid instruction/syntax.
0000145C  4EF9 00001B16            396          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
00001462                           397          
00001462                           398          
00001462                           399  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
00001462                           400  IS_ADDI
00001462                           401          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001462                           402          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001462  4281                     403          CLR.L   D1
00001464  3207                     404          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001466  C27C 00C0                405          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000146A  EC09                     406          LSR.B   #$06,D1     *Shift the size bits into LSB
0000146C                           407          
0000146C  B23C 0003                408          CMP.B   #$03,D1     *Compare the size bits to $3
00001470  6700 06A4                409          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001474                           410          
00001474                           411          *Output 'ADDI' to console...
00001474  43F9 000020D4            412          LEA     ADDI,A1     *Loads ADDI into address register A1
0000147A  103C 000E                413          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000147E  4E4F                     414          TRAP    #15         *Displays Message
00001480                           415          
00001480                           416          
00001480                           417          *Should have a valid ADDI op code. Set data up for EA.
00001480                           418          
00001480                           419          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001480  4282                     420          CLR.L   D2
00001482  3407                     421          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001484  C47C 003C                422          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001488  E60A                     423          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000148A                           424                  
0000148A                           425          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000148A  4283                     426          CLR.L   D3
0000148C  3607                     427          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000148E  C67C 0007                428          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001492                           429          
00001492  4EF9 00001498            430          JMP     EA_ADDI
00001498                           431  
00001498                           432  EA_ADDI
00001498                           433          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
00001498                           434          *and D3 holds the EA register.
00001498                           435          
00001498                           436          *Determine how much data to read in, depending on the size of the operation
00001498                           437          *output the size of the operation and the immediate data to console
00001498  4EB9 000016EA            438          JSR     WrapperSizeImmediate
0000149E                           439          
0000149E                           440          *manually output a comma here...
0000149E  43F9 000021E7            441          LEA     Comma,A1        *Loads Comma into address register A1
000014A4  103C 000E                442          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014A8  4E4F                     443          TRAP    #15             *Displays Message        
000014AA                           444          
000014AA                           445          *Determine which EA mode and thus Register/Mem Address this instruction used
000014AA  B43C 0000                446          CMP.B   #$00,D2
000014AE  6700 02BC                447          BEQ     DataRegMode *If EA mode is a data register, output that
000014B2                           448          
000014B2  B43C 0002                449          CMP.B   #$02,D2
000014B6  6700 02C4                450          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014BA                           451          
000014BA  B43C 0003                452          CMP.B   #$03,D2
000014BE  6700 02CC                453          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014C2                           454          
000014C2  B43C 0004                455          CMP.B   #$04,D2
000014C6  6700 02CE                456          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014CA                           457          
000014CA  B43C 0007                458          CMP.B   #$07,D2
000014CE  6700 02D0                459          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014D2                           460          
000014D2                           461          *If the ea mode isn't equal to any of these, it is an invalid EA
000014D2  4EF9 00001B26            462          JMP     BADEACODE                               
000014D8                           463          
000014D8                           464  
000014D8                           465  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000014D8                           466  IS_ANDI
000014D8                           467          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014D8                           468          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014D8  4281                     469          CLR.L   D1
000014DA  3207                     470          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014DC  C27C 00C0                471          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014E0  EC09                     472          LSR.B   #$06,D1     *Shift the size bits into LSB
000014E2                           473          
000014E2  B23C 0003                474          CMP.B   #$03,D1     *Compare the size bits to $3
000014E6  6700 062E                475          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014EA                           476          
000014EA                           477          *Output 'ANDI' to console...
000014EA  43F9 000020D9            478          LEA     ANDI,A1     *Loads ANDI into address register A1
000014F0  103C 000E                479          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014F4  4E4F                     480          TRAP    #15         *Displays Message
000014F6                           481          
000014F6                           482          
000014F6                           483          *Should have a valid ANDI op code. Set data up for EA.
000014F6                           484          
000014F6                           485          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014F6  4282                     486          CLR.L   D2
000014F8  3407                     487          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014FA  C47C 003C                488          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000014FE  E60A                     489          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001500                           490                  
00001500                           491          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001500  4283                     492          CLR.L   D3
00001502  3607                     493          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001504  C67C 0007                494          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001508                           495          
00001508  4EF9 0000150E            496          JMP     EA_ANDI
0000150E                           497  
0000150E                           498  EA_ANDI
0000150E                           499          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
0000150E                           500          *and D3 holds the EA register.
0000150E                           501          
0000150E                           502          *Determine how much data to read in, depending on the size of the operation
0000150E                           503          *output the size of the operation and the immediate data to console
0000150E  4EB9 000016EA            504          JSR     WrapperSizeImmediate
00001514                           505          
00001514                           506          *manually output a comma here...
00001514  43F9 000021E7            507          LEA     Comma,A1        *Loads Comma into address register A1
0000151A  103C 000E                508          MOVE.B  #14,D0          *Moves the number 14 into data register D0
0000151E  4E4F                     509          TRAP    #15             *Displays Message        
00001520                           510          
00001520                           511          *Determine which EA mode and thus Register/Mem Address this instruction used
00001520  B43C 0000                512          CMP.B   #$00,D2
00001524  6700 0246                513          BEQ     DataRegMode *If EA mode is a data register, output that
00001528                           514          
00001528  B43C 0002                515          CMP.B   #$02,D2
0000152C  6700 024E                516          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001530                           517          
00001530  B43C 0003                518          CMP.B   #$03,D2
00001534  6700 0256                519          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001538                           520          
00001538  B43C 0004                521          CMP.B   #$04,D2
0000153C  6700 0258                522          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001540                           523          
00001540  B43C 0007                524          CMP.B   #$07,D2
00001544  6700 025A                525          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001548                           526          
00001548                           527          *If the ea mode isn't equal to any of these, it is an invalid EA
00001548  4EF9 00001B26            528          JMP     BADEACODE
0000154E                           529          
0000154E                           530  
0000154E                           531  *Now we know this instruction is exactly EORI, lets set everything up for EA.
0000154E                           532  IS_EORI
0000154E                           533          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000154E                           534          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000154E  4281                     535          CLR.L   D1
00001550  3207                     536          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001552  C27C 00C0                537          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001556  EC09                     538          LSR.B   #$06,D1     *Shift the size bits into LSB
00001558                           539          
00001558  B23C 0003                540          CMP.B   #$03,D1     *Compare the size bits to $3
0000155C  6700 05B8                541          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001560                           542          
00001560                           543          *Output 'EORI' to console...
00001560  43F9 000020DE            544          LEA     EORI,A1     *Loads EORI into address register A1
00001566  103C 000E                545          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000156A  4E4F                     546          TRAP    #15         *Displays Message
0000156C                           547          
0000156C                           548          
0000156C                           549          *Should have a valid EORI op code. Set data up for EA.
0000156C                           550          
0000156C                           551          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000156C  4282                     552          CLR.L   D2
0000156E  3407                     553          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001570  C47C 003C                554          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001574  E60A                     555          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001576                           556                  
00001576                           557          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001576  4283                     558          CLR.L   D3
00001578  3607                     559          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000157A  C67C 0007                560          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000157E                           561          
0000157E  4EF9 00001584            562          JMP     EA_EORI
00001584                           563  
00001584                           564  EA_EORI
00001584                           565          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
00001584                           566          *and D3 holds the EA register.
00001584                           567          
00001584                           568          *Determine how much data to read in, depending on the size of the operation
00001584                           569          *output the size of the operation and the immediate data to console
00001584  4EB9 000016EA            570          JSR     WrapperSizeImmediate
0000158A                           571          
0000158A                           572          *manually output a comma here...
0000158A  43F9 000021E7            573          LEA     Comma,A1        *Loads Comma into address register A1
00001590  103C 000E                574          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001594  4E4F                     575          TRAP    #15             *Displays Message        
00001596                           576          
00001596                           577          *Determine which EA mode and thus Register/Mem Address this instruction used
00001596  B43C 0000                578          CMP.B   #$00,D2
0000159A  6700 01D0                579          BEQ     DataRegMode *If EA mode is a data register, output that
0000159E                           580          
0000159E  B43C 0002                581          CMP.B   #$02,D2
000015A2  6700 01D8                582          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015A6                           583          
000015A6  B43C 0003                584          CMP.B   #$03,D2
000015AA  6700 01E0                585          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015AE                           586          
000015AE  B43C 0004                587          CMP.B   #$04,D2
000015B2  6700 01E2                588          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015B6                           589          
000015B6  B43C 0007                590          CMP.B   #$07,D2
000015BA  6700 01E4                591          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015BE                           592          
000015BE                           593          *If the ea mode isn't equal to any of these, it is an invalid EA
000015BE  4EF9 00001B26            594          JMP     BADEACODE
000015C4                           595  
000015C4                           596  
000015C4                           597  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015C4                           598  * everything up for EA if is a legit instruction.
000015C4                           599  IS_BCHG_D
000015C4                           600          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015C4                           601          *invalid, branch to BADOPCODE
000015C4  3007                     602          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015C6  0800 0007                603          BTST.L  #$07,D0
000015CA  6600 054A                604          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015CE  0800 0006                605          BTST.L  #$06,D0
000015D2  6700 0542                606          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000015D6                           607          
000015D6                           608          *Output 'BCHG' to console...
000015D6  43F9 000020E3            609          LEA     BCHG,A1         *Loads BCHG into address register A1
000015DC  103C 000E                610          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015E0  4E4F                     611          TRAP    #15             *Displays Message
000015E2                           612                  
000015E2                           613                  
000015E2                           614          *Should have a valid BCHG op code. Set data up for EA.
000015E2                           615  
000015E2                           616          *Set D1 to the EA source register located in bits 11-9 of the instruction
000015E2  4281                     617          CLR.L   D1
000015E4  3207                     618          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015E6  C27C 0E00                619          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
000015EA  E009                     620          LSR.B   #$08,D1     *Shift the EA source register bits into LSB
000015EC  E209                     621          LSR.B   #$01,D1
000015EE                           622  
000015EE                           623          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015EE  4282                     624          CLR.L   D2
000015F0  3407                     625          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000015F2  C47C 003C                626          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000015F6  E60A                     627          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000015F8                           628                  
000015F8                           629          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000015F8  4283                     630          CLR.L   D3
000015FA  3607                     631          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
000015FC  C67C 0007                632          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001600                           633  
00001600  4EF9 00001606            634          JMP     EA_BCHG_D
00001606                           635  
00001606                           636  EA_BCHG_D
00001606                           637          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
00001606                           638          *D2 holds the EA mode, and D3 holds the EA register.
00001606                           639          
00001606                           640          *output the source register to console, flag D6 with a 1 so we come back...
00001606  48E7 0200                641          MOVEM.L  D6,-(SP)   *Push current contents of D6 into stack (line counter)
0000160A  1C3C 0001                642          MOVE.B  #$01,D6
0000160E  4EB9 0000176C            643          JSR     DataRegMode
00001614  4CDF 0040                644          MOVEM.L (SP)+,D6    *Pull current contents of stack back into D6
00001618                           645          
00001618                           646          *manually output a comma here...
00001618  43F9 000021E7            647          LEA     Comma,A1        *Loads Comma into address register A1
0000161E  103C 000E                648          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001622  4E4F                     649          TRAP    #15             *Displays Message
00001624                           650          
00001624                           651          *Determine which EA mode and thus Register/Mem Address this instruction used
00001624  B43C 0000                652          CMP.B   #$00,D2
00001628  6700 0142                653          BEQ     DataRegMode *If EA mode is a data register, output that
0000162C                           654          
0000162C  B43C 0002                655          CMP.B   #$02,D2
00001630  6700 014A                656          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001634                           657          
00001634  B43C 0003                658          CMP.B   #$03,D2
00001638  6700 0152                659          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000163C                           660          
0000163C  B43C 0004                661          CMP.B   #$04,D2
00001640  6700 0154                662          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001644                           663          
00001644  B43C 0007                664          CMP.B   #$07,D2
00001648  6700 0156                665          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000164C                           666          
0000164C                           667          *If the ea mode isn't equal to any of these, it is an invalid EA
0000164C  4EF9 00001B26            668          JMP     BADEACODE
00001652                           669  
00001652                           670  
00001652                           671  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
00001652                           672  IS_BCHG_S
00001652                           673          *TODO:Verify bits
00001652                           674  
00001652                           675          *Output 'BCHG' to console...
00001652  43F9 000020E3            676          LEA     BCHG,A1 *Loads FNDBCHG_S into address register A1
00001658  103C 000E                677          MOVE.B  #14,D0  *Moves the number 14 into data register D0
0000165C  4E4F                     678          TRAP    #15     *Displays Message
0000165E                           679          
0000165E                           680          *Should have a valid BCHG_S op code. Set data up for EA.
0000165E                           681          *TODO:
0000165E  163C 000E                682          MOVE.B  #14,D3
00001662  4EF9 00001668            683          JMP     EA_BCHG_S
00001668                           684  
00001668                           685  EA_BCHG_S
00001668  4EF9 00001B3A            686          JMP     THEEND  *For now just end
0000166E                           687  
0000166E                           688  
0000166E                           689  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
0000166E                           690  IS_CMPI
0000166E                           691          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000166E                           692          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000166E  4281                     693          CLR.L   D1
00001670  3207                     694          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001672  C27C 00C0                695          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001676  EC09                     696          LSR.B   #$06,D1     *Shift the size bits into LSB
00001678                           697          
00001678  B23C 0003                698          CMP.B   #$03,D1     *Compare the size bits to $3
0000167C  6700 0498                699          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001680                           700          
00001680                           701          *Output 'CMPI' to console...
00001680  43F9 000020E8            702          LEA     CMPI,A1     *Loads CMPI into address register A1
00001686  103C 000E                703          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000168A  4E4F                     704          TRAP    #15         *Displays Message
0000168C                           705          
0000168C                           706          
0000168C                           707          *Should have a valid CMPI op code. Set data up for EA.
0000168C                           708          
0000168C                           709          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
0000168C  4282                     710          CLR.L   D2
0000168E  3407                     711          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001690  C47C 003C                712          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001694  E60A                     713          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001696                           714                  
00001696                           715          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001696  4283                     716          CLR.L   D3
00001698  3607                     717          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000169A  C67C 0007                718          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000169E                           719          
0000169E  4EF9 000016A4            720          JMP     EA_CMPI
000016A4                           721  
000016A4                           722  EA_CMPI
000016A4                           723          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
000016A4                           724          *and D3 holds the EA register.
000016A4                           725          
000016A4                           726          *Determine how much data to read in, depending on the size of the operation
000016A4                           727          *output the size of the operation and the immediate data to console
000016A4  4EB9 000016EA            728          JSR     WrapperSizeImmediate
000016AA                           729          
000016AA                           730          *manually output a comma here...
000016AA  43F9 000021E7            731          LEA     Comma,A1        *Loads Comma into address register A1
000016B0  103C 000E                732          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016B4  4E4F                     733          TRAP    #15             *Displays Message
000016B6                           734          
000016B6                           735          *Determine which EA mode and thus Register/Mem Address this instruction used
000016B6  B43C 0000                736          CMP.B   #$00,D2
000016BA  6700 00B0                737          BEQ     DataRegMode *If EA mode is a data register, output that
000016BE                           738          
000016BE  B43C 0002                739          CMP.B   #$02,D2
000016C2  6700 00B8                740          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016C6                           741          
000016C6  B43C 0003                742          CMP.B   #$03,D2
000016CA  6700 00C0                743          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016CE                           744          
000016CE  B43C 0004                745          CMP.B   #$04,D2
000016D2  6700 00C2                746          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000016D6                           747          
000016D6  B43C 0007                748          CMP.B   #$07,D2
000016DA  6700 00C4                749          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000016DE                           750          
000016DE                           751          *If the ea mode isn't equal to any of these, it is an invalid EA
000016DE  4EF9 00001B26            752          JMP     BADEACODE
000016E4                           753  
000016E4                           754          
000016E4                           755  *STARTS WITH 0001, MOVE.B-----------------------------------
000016E4                           756  BUCKET_0001
000016E4  =00000001                757  BUCKET0001_BITS EQU $1
000016E4                           758          
000016E4                           759          *some code...
000016E4                           760  
000016E4                           761  
000016E4                           762  *STARTS WITH 0010, MOVE.L-----------------------------------
000016E4                           763  BUCKET_0010
000016E4  =00000002                764  BUCKET0010_BITS EQU $2
000016E4                           765  
000016E4                           766          *some code...
000016E4                           767  
000016E4                           768  
000016E4                           769  *STARTS WITH 0011, MOVE.W-----------------------------------
000016E4                           770  BUCKET_0011
000016E4  =00000003                771  BUCKET0011_BITS EQU $3
000016E4                           772  
000016E4                           773          *some code...
000016E4                           774  
000016E4                           775  
000016E4                           776  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
000016E4                           777  BUCKET_0100
000016E4  =00000004                778  BUCKET0100_BITS EQU $4
000016E4                           779  
000016E4                           780          *some code...
000016E4                           781  
000016E4                           782  
000016E4                           783  *STARTS WITH 0101, SUBQ-------------------------------------
000016E4                           784  BUCKET_0101
000016E4  =00000005                785  BUCKET0101_BITS EQU $5
000016E4                           786  
000016E4                           787          *some code...
000016E4                           788  
000016E4                           789  
000016E4                           790  *STARTS WITH 0110, BCC--------------------------------------
000016E4                           791  BUCKET_0110
000016E4  =00000006                792  BUCKET0110_BITS EQU $6
000016E4                           793  
000016E4                           794          *some code...
000016E4                           795  
000016E4                           796  
000016E4                           797  *STARTS WITH 1000, DIVU-------------------------------------
000016E4                           798  BUCKET_1000
000016E4  =00000008                799  BUCKET1000_BITS EQU $8
000016E4                           800  
000016E4                           801          *some code...
000016E4                           802  
000016E4                           803  
000016E4                           804  *STARTS WITH 1001, SUBA-------------------------------------
000016E4                           805  BUCKET_1001
000016E4  =00000009                806  BUCKET1001_BITS EQU $9
000016E4                           807  
000016E4                           808          *some code...
000016E4                           809  
000016E4                           810  
000016E4                           811  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000016E4                           812  BUCKET_1011
000016E4  =0000000B                813  BUCKET1011_BITS EQU $B
000016E4                           814  
000016E4                           815          *some code...
000016E4                           816  
000016E4                           817  
000016E4                           818  *STARTS WITH 1100, MULS(W) | AND----------------------------
000016E4                           819  BUCKET_1100
000016E4  =0000000C                820  BUCKET1100_BITS EQU $C
000016E4                           821  
000016E4                           822          *some code...
000016E4                           823  
000016E4                           824  
000016E4                           825  *STARTS WITH 1101, ADD | ADDA-------------------------------
000016E4                           826  BUCKET_1101
000016E4  =0000000D                827  BUCKET1101_BITS EQU $D
000016E4                           828  
000016E4                           829          *some code...
000016E4                           830  
000016E4                           831  
000016E4                           832  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000016E4                           833  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000016E4                           834  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000016E4                           835  BUCKET_1110
000016E4  =0000000E                836  BUCKET1110_BITS EQU $E     
000016E4                           837  
000016E4                           838          *some code...
000016E4                           839  
000016E4                           840  
000016E4                           841  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000016E4                           842  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000016E4  4EF9 00001B16            843          JMP     BADOPCODE  
000016EA                           844          
000016EA                           845  
000016EA                           846  *-----------------------------------------------------------        
000016EA                           847  * EA operation size decoding functionality
000016EA                           848  *-----------------------------------------------------------   
000016EA                           849  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
000016EA                           850  WrapperSizeImmediate
000016EA  4284                     851          CLR.L   D4
000016EC                           852          *Depending on the EA Register, choose which size to decode
000016EC  B23C 0000                853          CMP.B   #$00,D1
000016F0  6700 0014                854          BEQ     ByteSizeImmediate
000016F4                           855          
000016F4  B23C 0001                856          CMP.B   #$01,D1
000016F8  6700 002E                857          BEQ     WordSizeImmediate
000016FC                           858  
000016FC  B23C 0002                859          CMP.B   #$02,D1
00001700  6700 0048                860          BEQ     LongSizeImmediate
00001704                           861          
00001704                           862  *Used to get back to what we were doing, after dealing with the specific size
00001704                           863  WrapperSizeImmediateEnd
00001704  4E75                     864          RTS
00001706                           865          
00001706                           866  ByteSizeImmediate
00001706  3818                     867          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
00001708                           868          
00001708                           869          *Output '.B' to console...
00001708  43F9 000020ED            870          LEA     ByteSize,A1 *Loads ByteSize into address register A1
0000170E  103C 000E                871          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001712  4E4F                     872          TRAP    #15         *Displays Message
00001714                           873          
00001714                           874          *Output '#$' just before the immediate data
00001714  43F9 000021EC            875          LEA     ShaBang,A1
0000171A  103C 000E                876          MOVE.B  #14,D0
0000171E  4E4F                     877          TRAP    #15  
00001720                           878          
00001720                           879          *output the immediate data to console with the hex-ascii converter
00001720  4EB8 11E6                880          JSR     HEXASCII
00001724                           881                  
00001724  4EF8 1704                882          JMP     WrapperSizeImmediateEnd
00001728                           883                  
00001728                           884  WordSizeImmediate
00001728  3818                     885          MOVE.W  (A0)+,D4    *read in next word, data is that word
0000172A                           886          
0000172A                           887          *Output '.W' to console...
0000172A  43F9 000020F4            888          LEA     WordSize,A1 *Loads WordSize into address register A1
00001730  103C 000E                889          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001734  4E4F                     890          TRAP    #15         *Displays Message
00001736                           891          
00001736                           892          *Output '#$' just before the immediate data
00001736  43F9 000021EC            893          LEA     ShaBang,A1
0000173C  103C 000E                894          MOVE.B  #14,D0
00001740  4E4F                     895          TRAP    #15  
00001742                           896          
00001742                           897          *output the immediate data to console with the hex-ascii converter
00001742  4EB8 11E6                898          JSR     HEXASCII
00001746                           899          
00001746  4EF8 1704                900          JMP     WrapperSizeImmediateEnd
0000174A                           901                  
0000174A                           902  LongSizeImmediate
0000174A  2818                     903          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
0000174C                           904          
0000174C                           905          *Output '.L' to console...
0000174C  43F9 000020FB            906          LEA     LongSize,A1 *Loads LongSize into address register A1
00001752  103C 000E                907          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001756  4E4F                     908          TRAP    #15         *Displays Message
00001758                           909          
00001758                           910          *Output '#$' just before the immediate data
00001758  43F9 000021EC            911          LEA     ShaBang,A1
0000175E  103C 000E                912          MOVE.B  #14,D0
00001762  4E4F                     913          TRAP    #15  
00001764                           914          
00001764                           915          *output the immediate data to console with the hex-ascii converter
00001764  4EB8 11E6                916          JSR     HEXASCII
00001768                           917          
00001768  4EF8 1704                918          JMP     WrapperSizeImmediateEnd
0000176C                           919  
0000176C                           920  
0000176C                           921  *-----------------------------------------------------------        
0000176C                           922  * EA Mode/EA Register decoding functionality
0000176C                           923  *-----------------------------------------------------------        
0000176C                           924  DataRegMode
0000176C                           925          *Depending on the EA Register, output a different register number
0000176C  4EB9 000017AA            926          JSR     WrapperDataReg        
00001772                           927          
00001772                           928          *if this was called for a destination decoding then we are done decoding this        
00001772                           929          *instruction, go get the next instruction
00001772  BC3C 0001                930          CMP.B   #$01,D6
00001776  6600 FBF4                931          BNE     GRAB_NEXT_OP
0000177A                           932          
0000177A                           933          *else this was a source decoding, rts back to we can keep decoding
0000177A  4E75                     934          RTS
0000177C                           935  
0000177C                           936  AddrDirectMode
0000177C                           937          *some code...
0000177C                           938  
0000177C                           939  AddrIndirectMode
0000177C                           940          *Depending on the EA Register, output a different register number
0000177C  4EB9 0000186C            941          JSR     WrapperAddrIndirect
00001782                           942                          
00001782                           943          *if this was called for a destination decoding then we are done decoding this        
00001782                           944          *instruction, go get the next instruction
00001782  BC3C 0001                945          CMP.B   #$01,D6
00001786  6600 FBE4                946          BNE     GRAB_NEXT_OP
0000178A                           947          
0000178A                           948          *else this was a source decoding, rts back to we can keep decoding
0000178A  4E75                     949          RTS
0000178C                           950  
0000178C                           951  AddrIndirectPostMode
0000178C                           952          *Depending on the EA Register, output a different register number
0000178C  4EB9 0000192E            953          JSR     WrapperAddrIndirectPost
00001792                           954  
00001792                           955          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001792                           956          *some wrapper (i'll define later)
00001792                           957          
00001792                           958          *else this was a destination EA decoding, we can just go get the next instruction
00001792                           959          *since there is no more decoding to do for the current instruction
00001792  4EF8 136C                960          JMP     GRAB_NEXT_OP
00001796                           961  
00001796                           962  AddrIndirectPreMode
00001796                           963          *Depending on the EA Register, output a different register number
00001796  4EB9 000019F0            964          JSR     WrapperAddrIndirectPre
0000179C                           965  
0000179C                           966          *need to read some flag, if this was called from a source EA decoding then jmp to 
0000179C                           967          *some wrapper (i'll define later)
0000179C                           968          
0000179C                           969          *else this was a destination EA decoding, we can just go get the next instruction
0000179C                           970          *since there is no more decoding to do for the current instruction
0000179C  4EF8 136C                971          JMP     GRAB_NEXT_OP
000017A0                           972  
000017A0                           973  AddrAbsoluteMode
000017A0                           974          *Depending on the EA Register, output a different register number
000017A0  4EB9 00001AB2            975          JSR     WrapperAddrAbsolute        
000017A6                           976  
000017A6                           977          *need to read some flag, if this was called from a source EA decoding then jmp to 
000017A6                           978          *some wrapper (i'll define later)
000017A6                           979          
000017A6                           980          *else this was a destination EA decoding, we can just go get the next instruction
000017A6                           981          *since there is no more decoding to do for the current instruction
000017A6  4EF8 136C                982          JMP     GRAB_NEXT_OP
000017AA                           983          
000017AA                           984  ImmediateDataMode
000017AA                           985          *some code        
000017AA                           986          
000017AA                           987          
000017AA                           988  *-----------------------------------------------------------        
000017AA                           989  * Output logic for all Data Registers (0-7)
000017AA                           990  *-----------------------------------------------------------
000017AA                           991  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000017AA                           992  WrapperDataReg
000017AA                           993          *Depending on the EA destination register, output a different register number
000017AA  B63C 0000                994          CMP.B   #$00,D3
000017AE  6700 003C                995          BEQ     DataReg0
000017B2                           996          
000017B2  B63C 0001                997          CMP.B   #$01,D3
000017B6  6700 0044                998          BEQ     DataReg1
000017BA                           999          
000017BA  B63C 0002               1000          CMP.B   #$02,D3
000017BE  6700 004C               1001          BEQ     DataReg2
000017C2                          1002          
000017C2  B63C 0003               1003          CMP.B   #$03,D3
000017C6  6700 0054               1004          BEQ     DataReg3
000017CA                          1005          
000017CA  B63C 0004               1006          CMP.B   #$04,D3
000017CE  6700 005C               1007          BEQ     DataReg4
000017D2                          1008          
000017D2  B63C 0005               1009          CMP.B   #$05,D3
000017D6  6700 0064               1010          BEQ     DataReg5
000017DA                          1011          
000017DA  B63C 0006               1012          CMP.B   #$06,D3
000017DE  6700 006C               1013          BEQ     DataReg6
000017E2                          1014          
000017E2  B63C 0007               1015          CMP.B   #$07,D3
000017E6  6700 0074               1016          BEQ     DataReg7        
000017EA                          1017  
000017EA                          1018  *Used to get back to 'DataRegMode', after dealing with the specific register
000017EA                          1019  WrapperDataRegEnd
000017EA  4E75                    1020          RTS
000017EC                          1021  
000017EC                          1022  DataReg0
000017EC                          1023          *Output the specific data register...
000017EC  43F9 00002102           1024          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
000017F2  103C 000E               1025          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000017F6  4E4F                    1026          TRAP    #15             *Displays Message   
000017F8                          1027          
000017F8  4EF8 17EA               1028          JMP     WrapperDataRegEnd
000017FC                          1029  
000017FC                          1030  DataReg1
000017FC  43F9 00002107           1031          LEA     OutDataReg1,A1
00001802  103C 000E               1032          MOVE.B  #14,D0
00001806  4E4F                    1033          TRAP    #15
00001808                          1034          
00001808  4EF8 17EA               1035          JMP     WrapperDataRegEnd
0000180C                          1036  
0000180C                          1037  DataReg2
0000180C  43F9 0000210C           1038          LEA     OutDataReg2,A1
00001812  103C 000E               1039          MOVE.B  #14,D0
00001816  4E4F                    1040          TRAP    #15
00001818                          1041  
00001818  4EF8 17EA               1042          JMP     WrapperDataRegEnd
0000181C                          1043      
0000181C                          1044  DataReg3
0000181C  43F9 00002111           1045          LEA     OutDataReg3,A1
00001822  103C 000E               1046          MOVE.B  #14,D0
00001826  4E4F                    1047          TRAP    #15
00001828                          1048  
00001828  4EF8 17EA               1049          JMP     WrapperDataRegEnd
0000182C                          1050          
0000182C                          1051  DataReg4
0000182C  43F9 00002116           1052          LEA     OutDataReg4,A1
00001832  103C 000E               1053          MOVE.B  #14,D0
00001836  4E4F                    1054          TRAP    #15
00001838                          1055  
00001838  4EF8 17EA               1056          JMP     WrapperDataRegEnd
0000183C                          1057                 
0000183C                          1058  DataReg5
0000183C  43F9 0000211B           1059          LEA     OutDataReg5,A1
00001842  103C 000E               1060          MOVE.B  #14,D0
00001846  4E4F                    1061          TRAP    #15
00001848                          1062  
00001848  4EF8 17EA               1063          JMP     WrapperDataRegEnd
0000184C                          1064          
0000184C                          1065  DataReg6
0000184C  43F9 00002120           1066          LEA     OutDataReg6,A1 A1
00001852  103C 000E               1067          MOVE.B  #14,D0
00001856  4E4F                    1068          TRAP    #15
00001858                          1069  
00001858  4EF8 17EA               1070          JMP     WrapperDataRegEnd
0000185C                          1071          
0000185C                          1072  DataReg7
0000185C  43F9 00002125           1073          LEA     OutDataReg7,A1
00001862  103C 000E               1074          MOVE.B  #14,D0
00001866  4E4F                    1075          TRAP    #15
00001868                          1076          
00001868  4EF8 17EA               1077          JMP     WrapperDataRegEnd
0000186C                          1078  
0000186C                          1079  
0000186C                          1080  *-----------------------------------------------------------        
0000186C                          1081  * Output logic for all Address Indirect Registers (0-7)
0000186C                          1082  *-----------------------------------------------------------     
0000186C                          1083  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
0000186C                          1084  WrapperAddrIndirect
0000186C                          1085          *Depending on the EA Register, output a different register number
0000186C  B63C 0000               1086          CMP.B   #$00,D3
00001870  6700 003C               1087          BEQ     AddrIndReg0
00001874                          1088          
00001874  B63C 0001               1089          CMP.B   #$01,D3
00001878  6700 0044               1090          BEQ     AddrIndReg1
0000187C                          1091          
0000187C  B63C 0002               1092          CMP.B   #$02,D3
00001880  6700 004C               1093          BEQ     AddrIndReg2
00001884                          1094          
00001884  B63C 0003               1095          CMP.B   #$03,D3
00001888  6700 0054               1096          BEQ     AddrIndReg3
0000188C                          1097          
0000188C  B63C 0004               1098          CMP.B   #$04,D3
00001890  6700 005C               1099          BEQ     AddrIndReg4
00001894                          1100          
00001894  B63C 0005               1101          CMP.B   #$05,D3
00001898  6700 0064               1102          BEQ     AddrIndReg5
0000189C                          1103          
0000189C  B63C 0006               1104          CMP.B   #$06,D3
000018A0  6700 006C               1105          BEQ     AddrIndReg6
000018A4                          1106          
000018A4  B63C 0007               1107          CMP.B   #$07,D3
000018A8  6700 0074               1108          BEQ     AddrIndReg7
000018AC                          1109  
000018AC                          1110  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
000018AC                          1111  WrapperAddrIndirectEnd
000018AC  4E75                    1112          RTS        
000018AE                          1113  
000018AE                          1114  AddrIndReg0
000018AE                          1115          *Output the specific address indirect register...
000018AE  43F9 0000212A           1116          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
000018B4  103C 000E               1117          MOVE.B  #14,D0              *Moves the number 14 into data register D0
000018B8  4E4F                    1118          TRAP    #15                 *Displays Message        
000018BA                          1119          
000018BA  4EF8 18AC               1120          JMP     WrapperAddrIndirectEnd
000018BE                          1121  
000018BE                          1122  AddrIndReg1
000018BE  43F9 00002131           1123          LEA     OutAddrIndReg1,A1
000018C4  103C 000E               1124          MOVE.B  #14,D0
000018C8  4E4F                    1125          TRAP    #15
000018CA                          1126          
000018CA  4EF8 18AC               1127          JMP     WrapperAddrIndirectEnd
000018CE                          1128  
000018CE                          1129  AddrIndReg2
000018CE  43F9 00002138           1130          LEA     OutAddrIndReg2,A1
000018D4  103C 000E               1131          MOVE.B  #14,D0
000018D8  4E4F                    1132          TRAP    #15
000018DA                          1133          
000018DA  4EF8 18AC               1134          JMP     WrapperAddrIndirectEnd
000018DE                          1135  
000018DE                          1136  AddrIndReg3
000018DE  43F9 0000213F           1137          LEA     OutAddrIndReg3,A1
000018E4  103C 000E               1138          MOVE.B  #14,D0
000018E8  4E4F                    1139          TRAP    #15
000018EA                          1140          
000018EA  4EF8 18AC               1141          JMP     WrapperAddrIndirectEnd
000018EE                          1142  
000018EE                          1143  AddrIndReg4
000018EE  43F9 00002146           1144          LEA     OutAddrIndReg4,A1
000018F4  103C 000E               1145          MOVE.B  #14,D0
000018F8  4E4F                    1146          TRAP    #15
000018FA                          1147          
000018FA  4EF8 18AC               1148          JMP     WrapperAddrIndirectEnd
000018FE                          1149  
000018FE                          1150  AddrIndReg5
000018FE  43F9 0000214D           1151          LEA     OutAddrIndReg5,A1
00001904  103C 000E               1152          MOVE.B  #14,D0
00001908  4E4F                    1153          TRAP    #15
0000190A                          1154          
0000190A  4EF8 18AC               1155          JMP     WrapperAddrIndirectEnd
0000190E                          1156  
0000190E                          1157  AddrIndReg6
0000190E  43F9 00002154           1158          LEA     OutAddrIndReg6,A1
00001914  103C 000E               1159          MOVE.B  #14,D0
00001918  4E4F                    1160          TRAP    #15
0000191A                          1161          
0000191A  4EF8 18AC               1162          JMP     WrapperAddrIndirectEnd
0000191E                          1163  
0000191E                          1164  AddrIndReg7
0000191E  43F9 0000215B           1165          LEA     OutAddrIndReg7,A1
00001924  103C 000E               1166          MOVE.B  #14,D0
00001928  4E4F                    1167          TRAP    #15
0000192A                          1168          
0000192A  4EF8 18AC               1169          JMP     WrapperAddrIndirectEnd
0000192E                          1170          
0000192E                          1171          
0000192E                          1172  *-----------------------------------------------------------        
0000192E                          1173  * Output logic for all Address Indirect Post Increment Registers (0-7)
0000192E                          1174  *-----------------------------------------------------------     
0000192E                          1175  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
0000192E                          1176  WrapperAddrIndirectPost
0000192E                          1177          *Depending on the EA Register, output a different register number
0000192E  B63C 0000               1178          CMP.B   #$00,D3
00001932  6700 003C               1179          BEQ     AddrIndPoReg0
00001936                          1180          
00001936  B63C 0001               1181          CMP.B   #$01,D3
0000193A  6700 0044               1182          BEQ     AddrIndPoReg1
0000193E                          1183          
0000193E  B63C 0002               1184          CMP.B   #$02,D3
00001942  6700 004C               1185          BEQ     AddrIndPoReg2
00001946                          1186          
00001946  B63C 0003               1187          CMP.B   #$03,D3
0000194A  6700 0054               1188          BEQ     AddrIndPoReg3
0000194E                          1189          
0000194E  B63C 0004               1190          CMP.B   #$04,D3
00001952  6700 005C               1191          BEQ     AddrIndPoReg4
00001956                          1192          
00001956  B63C 0005               1193          CMP.B   #$05,D3
0000195A  6700 0064               1194          BEQ     AddrIndPoReg5
0000195E                          1195          
0000195E  B63C 0006               1196          CMP.B   #$06,D3
00001962  6700 006C               1197          BEQ     AddrIndPoReg6
00001966                          1198          
00001966  B63C 0007               1199          CMP.B   #$07,D3
0000196A  6700 0074               1200          BEQ     AddrIndPoReg7
0000196E                          1201  
0000196E                          1202  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
0000196E                          1203  WrapperAddrIndirectPostEnd
0000196E  4E75                    1204          RTS        
00001970                          1205  
00001970                          1206  AddrIndPoReg0
00001970                          1207          *Output the specific address indirect post register...
00001970  43F9 00002162           1208          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
00001976  103C 000E               1209          MOVE.B  #14,D0              *Moves the number 14 into data register D0
0000197A  4E4F                    1210          TRAP    #15                 *Displays Message        
0000197C                          1211          
0000197C  4EF8 196E               1212          JMP     WrapperAddrIndirectPostEnd
00001980                          1213  
00001980                          1214  AddrIndPoReg1
00001980  43F9 0000216A           1215          LEA     OutAddrIndPoReg1,A1
00001986  103C 000E               1216          MOVE.B  #14,D0
0000198A  4E4F                    1217          TRAP    #15
0000198C                          1218          
0000198C  4EF8 196E               1219          JMP     WrapperAddrIndirectPostEnd
00001990                          1220  
00001990                          1221  AddrIndPoReg2
00001990  43F9 00002172           1222          LEA     OutAddrIndPoReg2,A1
00001996  103C 000E               1223          MOVE.B  #14,D0
0000199A  4E4F                    1224          TRAP    #15
0000199C                          1225          
0000199C  4EF8 196E               1226          JMP     WrapperAddrIndirectPostEnd
000019A0                          1227  
000019A0                          1228  AddrIndPoReg3
000019A0  43F9 0000217A           1229          LEA     OutAddrIndPoReg3,A1
000019A6  103C 000E               1230          MOVE.B  #14,D0
000019AA  4E4F                    1231          TRAP    #15
000019AC                          1232          
000019AC  4EF8 196E               1233          JMP     WrapperAddrIndirectPostEnd
000019B0                          1234  
000019B0                          1235  AddrIndPoReg4
000019B0  43F9 00002182           1236          LEA     OutAddrIndPoReg4,A1
000019B6  103C 000E               1237          MOVE.B  #14,D0
000019BA  4E4F                    1238          TRAP    #15
000019BC                          1239          
000019BC  4EF8 196E               1240          JMP     WrapperAddrIndirectPostEnd
000019C0                          1241  
000019C0                          1242  AddrIndPoReg5
000019C0  43F9 0000218A           1243          LEA     OutAddrIndPoReg5,A1
000019C6  103C 000E               1244          MOVE.B  #14,D0
000019CA  4E4F                    1245          TRAP    #15
000019CC                          1246          
000019CC  4EF8 196E               1247          JMP     WrapperAddrIndirectPostEnd
000019D0                          1248  
000019D0                          1249  AddrIndPoReg6
000019D0  43F9 00002192           1250          LEA     OutAddrIndPoReg6,A1
000019D6  103C 000E               1251          MOVE.B  #14,D0
000019DA  4E4F                    1252          TRAP    #15
000019DC                          1253          
000019DC  4EF8 196E               1254          JMP     WrapperAddrIndirectPostEnd
000019E0                          1255  
000019E0                          1256  AddrIndPoReg7
000019E0  43F9 0000219A           1257          LEA     OutAddrIndPoReg7,A1
000019E6  103C 000E               1258          MOVE.B  #14,D0
000019EA  4E4F                    1259          TRAP    #15
000019EC                          1260          
000019EC  4EF8 196E               1261          JMP     WrapperAddrIndirectPostEnd
000019F0                          1262  
000019F0                          1263  
000019F0                          1264  *-----------------------------------------------------------        
000019F0                          1265  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
000019F0                          1266  *-----------------------------------------------------------     
000019F0                          1267  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000019F0                          1268  WrapperAddrIndirectPre
000019F0                          1269          *Depending on the EA Register, output a different register number
000019F0  B63C 0000               1270          CMP.B   #$00,D3
000019F4  6700 003C               1271          BEQ     AddrIndPrReg0
000019F8                          1272          
000019F8  B63C 0001               1273          CMP.B   #$01,D3
000019FC  6700 0044               1274          BEQ     AddrIndPrReg1
00001A00                          1275          
00001A00  B63C 0002               1276          CMP.B   #$02,D3
00001A04  6700 004C               1277          BEQ     AddrIndPrReg2
00001A08                          1278          
00001A08  B63C 0003               1279          CMP.B   #$03,D3
00001A0C  6700 0054               1280          BEQ     AddrIndPrReg3
00001A10                          1281          
00001A10  B63C 0004               1282          CMP.B   #$04,D3
00001A14  6700 005C               1283          BEQ     AddrIndPrReg4
00001A18                          1284          
00001A18  B63C 0005               1285          CMP.B   #$05,D3
00001A1C  6700 0064               1286          BEQ     AddrIndPrReg5
00001A20                          1287          
00001A20  B63C 0006               1288          CMP.B   #$06,D3
00001A24  6700 006C               1289          BEQ     AddrIndPrReg6
00001A28                          1290          
00001A28  B63C 0007               1291          CMP.B   #$07,D3
00001A2C  6700 0074               1292          BEQ     AddrIndPrReg7
00001A30                          1293  
00001A30                          1294  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001A30                          1295  WrapperAddrIndirectPreEnd
00001A30  4E75                    1296          RTS        
00001A32                          1297  
00001A32                          1298  AddrIndPrReg0
00001A32                          1299          *Output the specific address indirect post register...
00001A32  43F9 000021A2           1300          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001A38  103C 000E               1301          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001A3C  4E4F                    1302          TRAP    #15                 *Displays Message        
00001A3E                          1303          
00001A3E  4EF8 1A30               1304          JMP     WrapperAddrIndirectPreEnd
00001A42                          1305  
00001A42                          1306  AddrIndPrReg1
00001A42  43F9 000021AA           1307          LEA     OutAddrIndPrReg1,A1
00001A48  103C 000E               1308          MOVE.B  #14,D0
00001A4C  4E4F                    1309          TRAP    #15
00001A4E                          1310          
00001A4E  4EF8 1A30               1311          JMP     WrapperAddrIndirectPreEnd
00001A52                          1312  
00001A52                          1313  AddrIndPrReg2
00001A52  43F9 000021B2           1314          LEA     OutAddrIndPrReg2,A1
00001A58  103C 000E               1315          MOVE.B  #14,D0
00001A5C  4E4F                    1316          TRAP    #15
00001A5E                          1317          
00001A5E  4EF8 1A30               1318          JMP     WrapperAddrIndirectPreEnd
00001A62                          1319  
00001A62                          1320  AddrIndPrReg3
00001A62  43F9 000021BA           1321          LEA     OutAddrIndPrReg3,A1
00001A68  103C 000E               1322          MOVE.B  #14,D0
00001A6C  4E4F                    1323          TRAP    #15
00001A6E                          1324          
00001A6E  4EF8 1A30               1325          JMP     WrapperAddrIndirectPreEnd
00001A72                          1326  
00001A72                          1327  AddrIndPrReg4
00001A72  43F9 000021C2           1328          LEA     OutAddrIndPrReg4,A1
00001A78  103C 000E               1329          MOVE.B  #14,D0
00001A7C  4E4F                    1330          TRAP    #15
00001A7E                          1331          
00001A7E  4EF8 1A30               1332          JMP     WrapperAddrIndirectPreEnd
00001A82                          1333  
00001A82                          1334  AddrIndPrReg5
00001A82  43F9 000021CA           1335          LEA     OutAddrIndPrReg5,A1
00001A88  103C 000E               1336          MOVE.B  #14,D0
00001A8C  4E4F                    1337          TRAP    #15
00001A8E                          1338          
00001A8E  4EF8 1A30               1339          JMP     WrapperAddrIndirectPreEnd
00001A92                          1340  
00001A92                          1341  AddrIndPrReg6
00001A92  43F9 000021D2           1342          LEA     OutAddrIndPrReg6,A1
00001A98  103C 000E               1343          MOVE.B  #14,D0
00001A9C  4E4F                    1344          TRAP    #15
00001A9E                          1345          
00001A9E  4EF8 1A30               1346          JMP     WrapperAddrIndirectPreEnd
00001AA2                          1347  
00001AA2                          1348  AddrIndPrReg7
00001AA2  43F9 000021DA           1349          LEA     OutAddrIndPrReg7,A1
00001AA8  103C 000E               1350          MOVE.B  #14,D0
00001AAC  4E4F                    1351          TRAP    #15
00001AAE                          1352          
00001AAE  4EF8 1A30               1353          JMP     WrapperAddrIndirectPreEnd
00001AB2                          1354  
00001AB2                          1355  
00001AB2                          1356  *-----------------------------------------------------------        
00001AB2                          1357  * Output logic for absolute memory addressing (0-7)
00001AB2                          1358  *-----------------------------------------------------------     
00001AB2                          1359  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001AB2                          1360  WrapperAddrAbsolute
00001AB2  4284                    1361          CLR.L   D4
00001AB4                          1362          *Depending on the EA Register, choose which size to decode
00001AB4  B63C 0000               1363          CMP.B   #$00,D3
00001AB8  6700 000C               1364          BEQ     WordSizeAbsolute
00001ABC                          1365  
00001ABC  B63C 0001               1366          CMP.B   #$01,D3
00001AC0  6700 002C               1367          BEQ     LongSizeAbsolute
00001AC4                          1368          
00001AC4                          1369  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001AC4                          1370  WrapperAddrAbsoluteEnd
00001AC4  4E75                    1371          RTS
00001AC6                          1372  
00001AC6                          1373  WordSizeAbsolute        
00001AC6  3818                    1374          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001AC8                          1375          
00001AC8                          1376          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001AC8  4281                    1377          CLR.L   D1
00001ACA  123C 0001               1378          MOVE.B  #$01,D1     
00001ACE                          1379              
00001ACE                          1380          *Output ',$' just after source operand
00001ACE  43F9 000021EF           1381          LEA     Bang,A1
00001AD4  103C 000E               1382          MOVE.B  #14,D0
00001AD8  4E4F                    1383          TRAP    #15
00001ADA                          1384              
00001ADA                          1385          *output the absolute mem address to console with the hex-ascii converter
00001ADA  4EB8 11E6               1386          JSR     HEXASCII
00001ADE                          1387          
00001ADE                          1388          *Print a new line, since this should be the last piece of data for an instruction
00001ADE  43F9 000021E9           1389          LEA     NewLine,A1
00001AE4  103C 000E               1390          MOVE.B  #14,D0
00001AE8  4E4F                    1391          TRAP    #15
00001AEA                          1392          
00001AEA  4EF8 1AC4               1393          JMP     WrapperAddrAbsoluteEnd
00001AEE                          1394  
00001AEE                          1395  LongSizeAbsolute
00001AEE  2818                    1396          MOVE.L  (A0)+,D4    *read in next long, data is that long
00001AF0                          1397                  
00001AF0                          1398          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001AF0  4281                    1399          CLR.L   D1
00001AF2  123C 0010               1400          MOVE.B  #$10,D1
00001AF6                          1401                  
00001AF6                          1402          *Output ',$' just after source operand
00001AF6  43F9 000021EF           1403          LEA     Bang,A1
00001AFC  103C 000E               1404          MOVE.B  #14,D0
00001B00  4E4F                    1405          TRAP    #15  
00001B02                          1406          
00001B02                          1407          *output the absolute mem address to console with the hex-ascii converter
00001B02  4EB8 11E6               1408          JSR     HEXASCII
00001B06                          1409          
00001B06                          1410          *Print a new line, since this should be the last piece of data for an instruction
00001B06  43F9 000021E9           1411          LEA     NewLine,A1
00001B0C  103C 000E               1412          MOVE.B  #14,D0
00001B10  4E4F                    1413          TRAP    #15
00001B12                          1414  
00001B12  4EF8 1AC4               1415          JMP     WrapperAddrAbsoluteEnd
00001B16                          1416          
00001B16                          1417  
00001B16                          1418  *-----------------------------------------------------------        
00001B16                          1419  * Current handling of bad op/ea codes. Should be revisited.
00001B16                          1420  *----------------------------------------------------------- 
00001B16                          1421  BADOPCODE
00001B16                          1422          *We found a bad op code, output some error to the screen, jump to the 
00001B16                          1423          *next instruction in memory.
00001B16                          1424          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001B16                          1425          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001B16                          1426          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001B16                          1427          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001B16                          1428          *i/o and error message code...
00001B16  43F9 000021FA           1429          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001B1C  103C 000E               1430          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001B20  4E4F                    1431          TRAP    #15         *Displays Message
00001B22  4EF8 136C               1432          JMP     GRAB_NEXT_OP
00001B26                          1433                  
00001B26                          1434  BADEACODE
00001B26                          1435          *We found a bad ea code, output some error to the screen, jump to the
00001B26                          1436          *next instruction in memory.
00001B26                          1437          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001B26                          1438          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001B26  43F9 000021F1           1439          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001B2C  103C 000E               1440          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001B30  4E4F                    1441          TRAP    #15         *Displays Message
00001B32  4EF8 136C               1442          JMP     GRAB_NEXT_OP
00001B36                          1443          
00001B36                          1444          
00001B36                          1445  *-----------------------------------------------------------        
00001B36                          1446  * End of Disassembler
00001B36                          1447  *-----------------------------------------------------------    
00001B36                          1448  
00001B36  4E72 2700               1449  DONE    STOP    #$2700  *What does this do? Why was it added?
00001B3A                          1450  
00001B3A  103C 0009               1451  THEEND  MOVE.B  #9,D0
00001B3E  4E4F                    1452          TRAP    #15             Halt Simulator        
00001B40                          1453          
00001B40                          1454       
00001B40                          1455  *-----------------------------------------------------------        
00001B40                          1456  * Output stuff
00001B40                          1457  *-----------------------------------------------------------     
00001B40  =0000000D               1458  CR      EQU     $0D             ASCII code for Carriage Return
00001B40  =0000000A               1459  LF      EQU     $0A             ASCII code for Line Feed
00001B40= 2D 2D 2D 2D 2D 2D ...   1460  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001B7F= 7C 7C 20 20 20 20 ...   1461              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001BBE= 2D 2D 2D 2D 2D 2D ...   1462              DC.B    '-------------------------------------------------------------',CR,LF
00001BFD= 2A 2A 2A 2A 2A 2A ...   1463              DC.B    '*************************************************************',CR,LF
00001C3C= 2A 2A 2A 2A 2A 2A ...   1464              DC.B    '*************************************************************',CR,LF
00001C7B= 2A 2A 2A 2A 2A 2A ...   1465              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001CBA= 2A 2A 2A 2A 2A 2A ...   1466              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001CF9= 2A 2A 2A 2A 2A 2A ...   1467              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001D38= 2A 2A 2A 2A 2A 2A ...   1468              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001D77= 2A 2A 2A 2A 2A 2A ...   1469              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001DB6= 2A 2A 2A 2A 2A 2A ...   1470              DC.B    '*************************************************************',CR,LF
00001DF5= 2A 2A 2A 2A 2A 2A ...   1471              DC.B    '*************************************************************',CR,LF
00001E34= 2A 20 20 20 20 20 ...   1472              DC.B    '*                                                           *',CR,LF
00001E73= 2A 20 41 75 74 68 ...   1473              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001EB2= 2A 20 20 20 20 20 ...   1474              DC.B    '*                                                           *',CR,LF
00001EF1= 2A 2A 2A 2A 2A 2A ...   1475              DC.B    '*************************************************************',CR,LF,CR,LF
00001F32= 53 74 61 72 74 69 ...   1476              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001F4F                          1477              
00001F4F= 57 6F 75 6C 64 20 ...   1478  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001F80                          1479  
00001F80= 20 0D 0A                1480  GETSTRTADDR DC.B    ' ',CR,LF
00001F83= 50 6C 65 61 73 65 ...   1481              DC.B    'Please type in your starting address request: ',0
00001FB2                          1482              
00001FB2= 20 0D 0A                1483  GETENDADDR  DC.B    ' ',CR,LF
00001FB5= 50 6C 65 61 73 65 ...   1484              DC.B    'Please type in your ending address request: ',0
00001FE2                          1485              
00001FE2= 20 0D 0A                1486  QUES_CONT   DC.B    ' ',CR,LF
00001FE5= 57 6F 75 6C 64 20 ...   1487              DC.B    'Would you like to continue (Y/N)? ',0
00002008                          1488              
00002008= 20 0D 0A                1489  QUIT_MSG    DC.B    ' ',CR,LF
0000200B= 57 6F 75 6C 64 20 ...   1490              DC.B    'Would you like to quit (Y/N)? ',0
0000202A                          1491  
0000202A                          1492  *****************************************************
0000202A                          1493  * I/O storages - assuming users knows what to do.
0000202A                          1494  *****************************************************
0000202A                          1495  CMD_HLD     DS.B    30
00002048                          1496  CMD_SZ      DS.B    30
00002066                          1497  STADDR      DS.B    10
00002070                          1498  STADDRSZ    DS.B    10
0000207A                          1499  PROGST      DS.L    1
0000207E                          1500  ENDADDR     DS.B    10
00002088                          1501  ENDADDRSZ   DS.B    10
00002092                          1502  PROGEND     DS.L    1
00002096                          1503  CONT        DS.B    30
000020B4                          1504  *****************************************************
000020B4                          1505  
000020B4                          1506  *Table for 0-9 && A-F
000020B4= 30 00                   1507  PRNT0   DC.B    '0',0
000020B6= 31 00                   1508  PRNT1   DC.B    '1',0
000020B8= 32 00                   1509  PRNT2   DC.B    '2',0
000020BA= 33 00                   1510  PRNT3   DC.B    '3',0
000020BC= 34 00                   1511  PRNT4   DC.B    '4',0
000020BE= 35 00                   1512  PRNT5   DC.B    '5',0
000020C0= 36 00                   1513  PRNT6   DC.B    '6',0
000020C2= 37 00                   1514  PRNT7   DC.B    '7',0
000020C4= 38 00                   1515  PRNT8   DC.B    '8',0
000020C6= 39 00                   1516  PRNT9   DC.B    '9',0
000020C8= 41 00                   1517  PRNTA   DC.B    'A',0
000020CA= 42 00                   1518  PRNTB   DC.B    'B',0
000020CC= 43 00                   1519  PRNTC   DC.B    'C',0
000020CE= 44 00                   1520  PRNTD   DC.B    'D',0
000020D0= 45 00                   1521  PRNTE   DC.B    'E',0
000020D2= 46 00                   1522  PRNTF   DC.B    'F',0
000020D4                          1523  
000020D4                          1524  *output for all OPCODEs
000020D4= 41 44 44 49 00          1525  ADDI    DC.B    'ADDI',0
000020D9= 41 4E 44 49 00          1526  ANDI    DC.B    'ANDI',0
000020DE= 45 4F 52 49 00          1527  EORI    DC.B    'EORI',0
000020E3= 42 43 48 47 00          1528  BCHG    DC.B    'BCHG',0
000020E8= 43 4D 50 49 00          1529  CMPI    DC.B    'CMPI',0
000020ED                          1530  
000020ED                          1531  *output for the size of the operation
000020ED= 2E 42 20 20 20 20 00    1532  ByteSize    DC.B    '.B    ',0
000020F4= 2E 57 20 20 20 20 00    1533  WordSize    DC.B    '.W    ',0
000020FB= 2E 4C 20 20 20 20 00    1534  LongSize    DC.B    '.L    ',0
00002102                          1535  
00002102                          1536  *output for all destination data registers (0-7)
00002102= 44 30 0D 0A 00          1537  OutDataReg0 DC.B    'D0',CR,LF,0
00002107= 44 31 0D 0A 00          1538  OutDataReg1 DC.B    'D1',CR,LF,0
0000210C= 44 32 0D 0A 00          1539  OutDataReg2 DC.B    'D2',CR,LF,0
00002111= 44 33 0D 0A 00          1540  OutDataReg3 DC.B    'D3',CR,LF,0
00002116= 44 34 0D 0A 00          1541  OutDataReg4 DC.B    'D4',CR,LF,0
0000211B= 44 35 0D 0A 00          1542  OutDataReg5 DC.B    'D5',CR,LF,0
00002120= 44 36 0D 0A 00          1543  OutDataReg6 DC.B    'D6',CR,LF,0
00002125= 44 37 0D 0A 00          1544  OutDataReg7 DC.B    'D7',CR,LF,0
0000212A                          1545  
0000212A                          1546  *output for all address indirect registers (0-7)
0000212A= 28 41 30 29 0D 0A 00    1547  OutAddrIndReg0  DC.B    '(A0)',CR,LF,0
00002131= 28 41 31 29 0D 0A 00    1548  OutAddrIndReg1  DC.B    '(A1)',CR,LF,0
00002138= 28 41 32 29 0D 0A 00    1549  OutAddrIndReg2  DC.B    '(A2)',CR,LF,0
0000213F= 28 41 33 29 0D 0A 00    1550  OutAddrIndReg3  DC.B    '(A3)',CR,LF,0
00002146= 28 41 34 29 0D 0A 00    1551  OutAddrIndReg4  DC.B    '(A4)',CR,LF,0
0000214D= 28 41 35 29 0D 0A 00    1552  OutAddrIndReg5  DC.B    '(A5)',CR,LF,0
00002154= 28 41 36 29 0D 0A 00    1553  OutAddrIndReg6  DC.B    '(A6)',CR,LF,0
0000215B= 28 41 37 29 0D 0A 00    1554  OutAddrIndReg7  DC.B    '(A7)',CR,LF,0
00002162                          1555  
00002162                          1556  *output for all address indirect post registers (0-7)
00002162= 28 41 30 29 2B 0D ...   1557  OutAddrIndPoReg0    DC.B    '(A0)+',CR,LF,0
0000216A= 28 41 31 29 2B 0D ...   1558  OutAddrIndPoReg1    DC.B    '(A1)+',CR,LF,0
00002172= 28 41 32 29 2B 0D ...   1559  OutAddrIndPoReg2    DC.B    '(A2)+',CR,LF,0
0000217A= 28 41 33 29 2B 0D ...   1560  OutAddrIndPoReg3    DC.B    '(A3)+',CR,LF,0
00002182= 28 41 34 29 2B 0D ...   1561  OutAddrIndPoReg4    DC.B    '(A4)+',CR,LF,0
0000218A= 28 41 35 29 2B 0D ...   1562  OutAddrIndPoReg5    DC.B    '(A5)+',CR,LF,0
00002192= 28 41 36 29 2B 0D ...   1563  OutAddrIndPoReg6    DC.B    '(A6)+',CR,LF,0
0000219A= 28 41 37 29 2B 0D ...   1564  OutAddrIndPoReg7    DC.B    '(A7)+',CR,LF,0
000021A2                          1565  
000021A2                          1566  *output for all address indirect pre registers (0-7)
000021A2= 2D 28 41 30 29 0D ...   1567  OutAddrIndPrReg0    DC.B    '-(A0)',CR,LF,0
000021AA= 2D 28 41 31 29 0D ...   1568  OutAddrIndPrReg1    DC.B    '-(A1)',CR,LF,0
000021B2= 2D 28 41 32 29 0D ...   1569  OutAddrIndPrReg2    DC.B    '-(A2)',CR,LF,0
000021BA= 2D 28 41 33 29 0D ...   1570  OutAddrIndPrReg3    DC.B    '-(A3)',CR,LF,0
000021C2= 2D 28 41 34 29 0D ...   1571  OutAddrIndPrReg4    DC.B    '-(A4)',CR,LF,0
000021CA= 2D 28 41 35 29 0D ...   1572  OutAddrIndPrReg5    DC.B    '-(A5)',CR,LF,0
000021D2= 2D 28 41 36 29 0D ...   1573  OutAddrIndPrReg6    DC.B    '-(A6)',CR,LF,0
000021DA= 2D 28 41 37 29 0D ...   1574  OutAddrIndPrReg7    DC.B    '-(A7)',CR,LF,0
000021E2                          1575  
000021E2                          1576  *output for a tab only (4 spaces)
000021E2= 20 20 20 20 00          1577  Tab DC.B    '    ',0
000021E7                          1578  
000021E7                          1579  *output for a comma only
000021E7= 2C 00                   1580  Comma   DC.B    ',',0
000021E9                          1581  
000021E9                          1582  *output for a new line only
000021E9= 0D 0A 00                1583  NewLine DC.B    CR,LF,0
000021EC                          1584  
000021EC                          1585  *output for a '#$' and '$' only
000021EC= 23 24 00                1586  ShaBang DC.B    '#$',0
000021EF= 24 00                   1587  Bang    DC.B    '$',0
000021F1                          1588  
000021F1                          1589  *current output for error messages
000021F1= 42 41 44 20 45 41 ...   1590  BADEAMSG    DC.B    'BAD EA',CR,LF,0
000021FA= 42 41 44 20 4F 50 ...   1591  BADOPMSG    DC.B    'BAD OP',CR,LF,0
00002203= 49 6D 70 72 6F 70 ...   1592  INV_MSG     DC.B    'Improper command.',CR,LF,0
00002217= 49 6E 76 61 6C 69 ...   1593  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
00002230= 49 6E 76 61 6C 69 ...   1594  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
00002247                          1595  
00002247                          1596          
00002247                          1597          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                20D4
ADDRABSOLUTEMODE    17A0
ADDRDIRECTMODE      177C
ADDRINDIRECTMODE    177C
ADDRINDIRECTPOSTMODE  178C
ADDRINDIRECTPREMODE  1796
ADDRINDPOREG0       1970
ADDRINDPOREG1       1980
ADDRINDPOREG2       1990
ADDRINDPOREG3       19A0
ADDRINDPOREG4       19B0
ADDRINDPOREG5       19C0
ADDRINDPOREG6       19D0
ADDRINDPOREG7       19E0
ADDRINDPRREG0       1A32
ADDRINDPRREG1       1A42
ADDRINDPRREG2       1A52
ADDRINDPRREG3       1A62
ADDRINDPRREG4       1A72
ADDRINDPRREG5       1A82
ADDRINDPRREG6       1A92
ADDRINDPRREG7       1AA2
ADDRINDREG0         18AE
ADDRINDREG1         18BE
ADDRINDREG2         18CE
ADDRINDREG3         18DE
ADDRINDREG4         18EE
ADDRINDREG5         18FE
ADDRINDREG6         190E
ADDRINDREG7         191E
ANDI                20D9
ASCIIHEX            1174
ASCIIHEX1           1178
BADEACODE           1B26
BADEAMSG            21F1
BADOPCODE           1B16
BADOPMSG            21FA
BANG                21EF
BCHG                20E3
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         140C
BUCKET_0001         16E4
BUCKET_0010         16E4
BUCKET_0011         16E4
BUCKET_0100         16E4
BUCKET_0101         16E4
BUCKET_0110         16E4
BUCKET_1000         16E4
BUCKET_1001         16E4
BUCKET_1011         16E4
BUCKET_1100         16E4
BUCKET_1101         16E4
BUCKET_1110         16E4
BYTESIZE            20ED
BYTESIZEIMMEDIATE   1706
CHECK               11EA
CHECKEND1           10FA
CHECKSTRT1          10E4
CHECK_LOWN          112C
CHECK_LOWY          111A
CHECK_N             13E6
CHECK_UPN           1124
CHECK_UPY           1110
CHECK_Y             13D8
CHNG_SZB            121C
CHNG_SZL            1202
CHNG_SZW            1236
CMD_HLD             202A
CMD_SZ              2048
CMPI                20E8
COMMA               21E7
CONT                2096
CONT_Q              13A6
CONV_LOL            11D4
CONV_LOOP           1250
CONV_NUM            11C0
CONV_UPL            11CA
CR                  D
DATAREG0            17EC
DATAREG1            17FC
DATAREG2            180C
DATAREG3            181C
DATAREG4            182C
DATAREG5            183C
DATAREG6            184C
DATAREG7            185C
DATAREGMODE         176C
DONE                1B36
EA_ADDI             1498
EA_ANDI             150E
EA_BCHG_D           1606
EA_BCHG_S           1668
EA_CMPI             16A4
EA_EORI             1584
ENDADDR             207E
ENDADDRSZ           2088
EORI                20DE
EXITSUB             11E0
EXIT_CONV           12D6
GETENDADDR          1FB2
GETSTRTADDR         1F80
GET_END             108C
GET_STRT            103E
GRAB_NEXT_OP        136C
HEXASCII            11E6
HEXASCIIREG         11FE
IMMEDIATEDATAMODE   17AA
INV2                13F6
INVALID1            1134
INVENDMSG           2230
INVSTRTMSG          2217
INV_END1            1160
INV_MSG             2203
INV_STRT1           114C
IS_ADDI             1462
IS_ANDI             14D8
IS_BCHG_D           15C4
IS_BCHG_S           1652
IS_CMPI             166E
IS_EORI             154E
LF                  A
LONGSIZE            20FB
LONGSIZEABSOLUTE    1AEE
LONGSIZEIMMEDIATE   174A
LOOP_1              1014
LOOP_B              1220
LOOP_L              1206
LOOP_W              123A
MAX_LINE            F
MESSAGE             1B40
NEWLINE             21E9
NUM_0               12E4
NUM_1               12EC
NUM_2               12F4
NUM_3               12FC
NUM_4               1304
NUM_5               130C
NUM_6               1314
NUM_7               131C
NUM_8               1324
NUM_9               132C
NUM_A               1334
NUM_B               133C
NUM_C               1344
NUM_D               134C
NUM_E               1354
NUM_F               135C
OUTADDRINDPOREG0    2162
OUTADDRINDPOREG1    216A
OUTADDRINDPOREG2    2172
OUTADDRINDPOREG3    217A
OUTADDRINDPOREG4    2182
OUTADDRINDPOREG5    218A
OUTADDRINDPOREG6    2192
OUTADDRINDPOREG7    219A
OUTADDRINDPRREG0    21A2
OUTADDRINDPRREG1    21AA
OUTADDRINDPRREG2    21B2
OUTADDRINDPRREG3    21BA
OUTADDRINDPRREG4    21C2
OUTADDRINDPRREG5    21CA
OUTADDRINDPRREG6    21D2
OUTADDRINDPRREG7    21DA
OUTADDRINDREG0      212A
OUTADDRINDREG1      2131
OUTADDRINDREG2      2138
OUTADDRINDREG3      213F
OUTADDRINDREG4      2146
OUTADDRINDREG5      214D
OUTADDRINDREG6      2154
OUTADDRINDREG7      215B
OUTDATAREG0         2102
OUTDATAREG1         2107
OUTDATAREG2         210C
OUTDATAREG3         2111
OUTDATAREG4         2116
OUTDATAREG5         211B
OUTDATAREG6         2120
OUTDATAREG7         2125
PRINT_NUM           12DC
PRNT0               20B4
PRNT1               20B6
PRNT2               20B8
PRNT3               20BA
PRNT4               20BC
PRNT5               20BE
PRNT6               20C0
PRNT7               20C2
PRNT8               20C4
PRNT9               20C6
PRNTA               20C8
PRNTB               20CA
PRNTC               20CC
PRNTD               20CE
PRNTE               20D0
PRNTF               20D2
PROGEND             2092
PROGST              207A
QUES_CONT           1FE2
QUIT_MSG            2008
SHABANG             21EC
STACK               7000
STADDR              2066
STADDRSZ            2070
START               1000
STARTASSEM          1F4F
ST_ADDR             7FC6
ST_BAD              11DE
TAB                 21E2
THEEND              1B3A
WORDSIZE            20F4
WORDSIZEABSOLUTE    1AC6
WORDSIZEIMMEDIATE   1728
WRAPPERADDRABSOLUTE  1AB2
WRAPPERADDRABSOLUTEEND  1AC4
WRAPPERADDRINDIRECT  186C
WRAPPERADDRINDIRECTEND  18AC
WRAPPERADDRINDIRECTPOST  192E
WRAPPERADDRINDIRECTPOSTEND  196E
WRAPPERADDRINDIRECTPRE  19F0
WRAPPERADDRINDIRECTPREEND  1A30
WRAPPERDATAREG      17AA
WRAPPERDATAREGEND   17EA
WRAPPERSIZEIMMEDIATE  16EA
WRAPPERSIZEIMMEDIATEEND  1704
