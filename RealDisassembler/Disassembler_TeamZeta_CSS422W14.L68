00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 3/13/2014 2:18:41 AM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/11/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC0                  9  ST_ADDR     EQU $7FC0   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00001000                            11  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 12              LEA stack,SP
00001004                            13  
00001004                            14  
00001004                            15  *-----------------------------------------------------------
00001004                            16  * Start of I/O
00001004                            17  *-----------------------------------------------------------            
00001004  43F9 0000140A             18              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100A  103C 000E                 19              MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000100E  4E4F                      20              TRAP    #15         *Displays Message
00001010                            21          
00001010  303C 0000                 22  loop_1      MOVE    #0,D0       
00001014  43F9 00001819             23              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101A  103C 000E                 24              MOVE.B  #14,D0
0000101E  4E4F                      25              TRAP    #15    
00001020  303C 0002                 26              MOVE    #2,D0
00001024  43F9 000018CE             27              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102A                            28              *TRAP   #15
0000102A  6000 0002                 29              BRA     CHECK_UPY
0000102E                            30  
0000102E                            31  *-----------------------------------------------------------
0000102E                            32  * I/O: Input check for Y, y, N, n
0000102E                            33  *-----------------------------------------------------------
0000102E  0C11 0059                 34  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001032  6600 0006                 35              BNE     CHECK_LOWy
00001036  6700 0048                 36              BEQ     NXT_CMD
0000103A                            37              
0000103A  0C11 0079                 38  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
0000103E  6600 0006                 39              BNE     CHECK_UPN
00001042  6700 003C                 40              BEQ     NXT_CMD
00001046                            41              
00001046  0C11 004E                 42  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
0000104A  6700 03B4                 43              BEQ     DONE
0000104E  6600 0002                 44              BNE     CHECK_LOWn
00001052                            45              
00001052  0C11 006E                 46  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001056  6600 0006                 47              BNE     INVALID1
0000105A  6700 03A4                 48              BEQ     DONE
0000105E                            49              
0000105E  303C 0000                 50  INVALID1    MOVE    #0,D0       *Prints invalid command msg if not found
00001062  43F9 00001A0B             51              LEA     INV_MSG,A1
00001068  303C 000E                 52              MOVE    #14,D0
0000106C  4E4F                      53              TRAP    #15
0000106E                            54              *JMP        loop_1
0000106E                            55              
0000106E  43F9 00001A1F             56  INV_STRT1   LEA     INVSTRTMSG,A1
00001074  103C 000E                 57              MOVE.B  #14,D0
00001078  4E4F                      58              TRAP    #15
0000107A  4EF9 00001080             59              JMP     NXT_CMD     
00001080                            60  
00001080                            61  *-----------------------------------------------------------
00001080                            62  *
00001080                            63  * I/O: Check Start Address
00001080                            64  *
00001080                            65  * Make sure that start address starts after allocated 
00001080                            66  * memory addresses. Else, it will print out a message 
00001080                            67  * saying that requested address is invalid & prompts the
00001080                            68  * user again for the starting address.
00001080                            69  *-----------------------------------------------------------
00001080  43F9 0000184A             70  NXT_CMD     LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001086  103C 000E                 71              MOVE.B  #14,D0
0000108A  4E4F                      72              TRAP    #15
0000108C  43F9 000018CE             73              LEA     CMD_HLD,A1  *Need to change where it can hold the start/end address
00001092  303C 0002                 74              MOVE    #2,D0           *Get start address
00001096                            75              *TRAP   #15
00001096  2811                      76              MOVE.L  (A1),D4
00001098                            77              *JSR        CHECKSTRT1
00001098  0C81 00000008             78  CHECKSTRT1  CMPI.L  #08,D1      *Check if size 
0000109E  6ECE                      79              BGT     INV_STRT1
000010A0  0C81 00000000             80              CMPI.L  #00,D1
000010A6                            81              *BLS        INV_STRT1
000010A6                            82              *RTS            
000010A6                            83  
000010A6                            84  *-----------------------------------------------------------        
000010A6                            85  * Start of Disassembler
000010A6                            86  *-----------------------------------------------------------
000010A6  207C 00007FC0             87          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
000010AC                            88          
000010AC                            89  GRAB_NEXT_OP
000010AC                            90          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
000010AC                            91          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
000010AC                            92          *data that may be associated with the instruction.
000010AC                            93          *Post increment addr, A0 will point to the start of next instruction or will 
000010AC                            94          *point to the start of any immed/abso data with this current instruction
000010AC  4280                      95          CLR.L   D0
000010AE  3018                      96          MOVE.W  (A0)+,D0
000010B0                            97          *Copy the word data we just moved into D0 into D7. We are copying this data
000010B0                            98          *So we always have a copy of the WHOLE instruction somewhere
000010B0  4287                      99          CLR.L   D7
000010B2  3E00                     100          MOVE.W  D0,D7
000010B4                           101          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
000010B4                           102          *four bits of the instruction. Once we have just the first four bits, we can
000010B4                           103          *begin to see which 'bucket'/category this instruction falls into. 
000010B4  E048                     104          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000010B6  E848                     105          LSR.W   #$04,D0
000010B8                           106          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000010B8                           107          *list of buckets until we find which one this instruction falls into.
000010B8                           108  
000010B8                           109  
000010B8                           110  *-----------------------------------------------------------        
000010B8                           111  * Bucket 0000:
000010B8                           112  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
000010B8                           113  *                   BCHG(dynamic) | BCHG (static) | CMPI----
000010B8                           114  *-----------------------------------------------------------
000010B8                           115  BUCKET_0000
000010B8  =00000000                116  BUCKET0000_BITS EQU $0
000010B8  4281                     117          CLR.L   D1
000010BA                           118          *Load the first 4 bits (really a byte) of BUCKET0 into D1
000010BA  123C 0000                119          MOVE.B  #BUCKET0000_BITS,D1
000010BE                           120          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
000010BE                           121          *If equal, continue decoding. If not, branch to next bucket.
000010BE  B200                     122          CMP.B   D0,D1
000010C0  6600 014E                123          BNE     BUCKET_0001
000010C4                           124  
000010C4                           125          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
000010C4                           126          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
000010C4  3007                     127          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
000010C6  0800 0008                128          BTST.L  #$08,D0
000010CA  6600 00DE                129          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
000010CE                           130          
000010CE                           131          *Now we can check bits 11-8 in the instruction and branch to different op-codes
000010CE                           132          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
000010CE  E048                     133          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
000010D0  0880 0004                134          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
000010D4  0880 0005                135          BCLR.L  #$05,D0
000010D8  0880 0006                136          BCLR.L  #$06,D0
000010DC  0880 0007                137          BCLR.L  #$07,D0
000010E0                           138          
000010E0                           139          *Perform compares with these 4 bits to see which specific instruction it is.
000010E0  B03C 0006                140          CMP.B   #$06,D0 *Is this an ADDI?
000010E4  6700 0028                141          BEQ     IS_ADDI
000010E8  B03C 0002                142          CMP.B   #$02,D0 *Is this an ANDI?
000010EC  6700 0084                143          BEQ     IS_ANDI
000010F0  B03C 000A                144          CMP.B   #$0A,D0 *Is this an EORI?
000010F4  6700 0098                145          BEQ     IS_EORI
000010F8  B03C 0008                146          CMP.B   #$08,D0 *Is this a BCHG(static)?
000010FC  6700 00DA                147          BEQ     IS_BCHG_S
00001100  B03C 000C                148          CMP.B   #$0C,D0 *Is this a CMPI?
00001104  6700 00EE                149          BEQ     IS_CMPI
00001108                           150          
00001108                           151          *If we get through all of the compares without finding the specific instruction,
00001108                           152          *then this instruction is either not in our list of OP CODES to decode, or is an
00001108                           153          *invalid instruction/syntax.
00001108  4EF9 000013E0            154          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
0000110E                           155  
0000110E                           156  
0000110E                           157  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
0000110E                           158  IS_ADDI
0000110E                           159          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
0000110E                           160          *Set D0 to the 'size' of the operation located in bits 7 and 6 of the instruction
0000110E  3207                     161          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001110  C27C 00C0                162          AND.W   #$00C0,D1   *Mask out everything but the size bits
00001114  EC09                     163          LSR.B   #$06,D1     *Shift the size bits into LSB
00001116                           164          
00001116  B23C 0003                165          CMP.B   #$03,D1     *Compare the size bits to $3
0000111A  6700 02C4                166          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
0000111E                           167          
0000111E                           168          *Output 'ADDI' to console...
0000111E  43F9 00001932            169          LEA     ADDI,A1  *Loads FNDADDI into address register A1
00001124  103C 000E                170          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001128  4E4F                     171          TRAP    #15         *Displays Message
0000112A                           172          
0000112A                           173          
0000112A                           174          *Should have a valid ADDI op code. Set data up for EA.
0000112A                           175           
0000112A                           176          *Set D1 to the EA mode of the operation located in bits 5-3 of the instruction
0000112A  3407                     177          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
0000112C  C47C 003C                178          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001130  E60A                     179          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001132                           180                  
00001132                           181          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001132  3607                     182          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001134  C67C 0007                183          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001138                           184          
00001138  4EF9 0000113E            185          JMP     EA_ADDI
0000113E                           186  
0000113E                           187  EA_ADDI
0000113E                           188          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
0000113E                           189          *and D3 holds the EA register.
0000113E                           190          
0000113E                           191          *Determine how much data to read in, depending on the size of the operation
0000113E                           192          *output the size of the operation and the immediate data to console
0000113E  4EB9 00001216            193          JSR     WrapperSizeImmediate
00001144                           194          
00001144                           195          *Determine which EA mode and thus Register/Mem Address this instruction used
00001144  B43C 0000                196          CMP.B   #$00,D2
00001148  6700 011E                197          BEQ     DataRegMode *If EA mode is a data register, output that
0000114C                           198          
0000114C  B43C 0002                199          CMP.B   #$02,D2
00001150  6700 011C                200          BEQ     AddrDirectMode  *If EA mode is an addr indirect, output that
00001154                           201          
00001154  B43C 0003                202          CMP.B   #$03,D2
00001158  6700 0154                203          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000115C                           204          
0000115C  B43C 0004                205          CMP.B   #$04,D2
00001160  6700 014C                206          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001164                           207          
00001164  B43C 0007                208          CMP.B   #$07,D2
00001168  6700 0144                209          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000116C                           210          
0000116C                           211          *If the ea mode isn't equal to any of these, it is an invalid EA
0000116C  4EF9 000013F0            212          JMP     BADEACODE                                
00001172                           213  
00001172                           214  
00001172                           215  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
00001172                           216  IS_ANDI
00001172                           217          *TODO:Verify bits
00001172                           218  
00001172                           219          *Output 'ANDI' to console...
00001172  43F9 00001937            220          LEA     ANDI,A1  *Loads FNDANDI into address register A1
00001178  103C 000E                221          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000117C  4E4F                     222          TRAP    #15         *Displays Message
0000117E                           223          
0000117E                           224          *Should have a valid ANDI op code. Set data up for EA.
0000117E                           225          *TODO:
0000117E  163C 000E                226          MOVE.B  #14,D3
00001182  4EF9 00001188            227          JMP     EA_ANDI
00001188                           228  
00001188                           229  EA_ANDI
00001188  4EF9 00001404            230          JMP     THEEND  *For now just end
0000118E                           231  
0000118E                           232  
0000118E                           233  *Now we know this instruction is exactly EORI, lets set everything up for EA.
0000118E                           234  IS_EORI
0000118E                           235          *TODO:Verify bits
0000118E                           236  
0000118E                           237          *Output 'EORI' to console...
0000118E  43F9 0000193C            238          LEA     EORI,A1  *Loads FNDEORI into address register A1
00001194  103C 000E                239          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001198  4E4F                     240          TRAP    #15         *Displays Message
0000119A                           241          
0000119A                           242          *Should have a valid EORI op code. Set data up for EA.
0000119A                           243          *TODO:
0000119A  163C 000E                244          MOVE.B  #14,D3
0000119E  4EF9 000011A4            245          JMP     EA_EORI
000011A4                           246  
000011A4                           247  EA_EORI
000011A4  4EF9 00001404            248          JMP     THEEND  *For now just end
000011AA                           249  
000011AA                           250  
000011AA                           251  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000011AA                           252  * everything up for EA if is a legit instruction. Assuming D0 holds full instruction.
000011AA                           253  IS_BCHG_D
000011AA  3007                     254          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
000011AC                           255          
000011AC                           256          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000011AC                           257          *invalid, branch to BADOPCODE
000011AC  0800 0007                258          BTST.L  #$07,D0
000011B0  6600 022E                259          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000011B4  0800 0006                260          BTST.L  #$06,D0
000011B8  6700 0226                261          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000011BC                           262          
000011BC                           263          *Output 'BCHG(dynamic)' to console...
000011BC  43F9 00001941            264          LEA     BCHG_D,A1    *Loads FNDBCHG_D into address register A1
000011C2  103C 000E                265          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000011C6  4E4F                     266          TRAP    #15             *Displays Message
000011C8                           267                  
000011C8                           268          *Should have a valid BCHG(dynamic) op code. Set data up for EA.
000011C8                           269          *TODO:
000011C8  163C 000E                270          MOVE.B  #14,D3
000011CC  4EF9 000011D2            271          JMP     EA_BCHG_D
000011D2                           272  
000011D2                           273  EA_BCHG_D
000011D2  4EF9 00001404            274          JMP     THEEND  *For now just end
000011D8                           275  
000011D8                           276  
000011D8                           277  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
000011D8                           278  IS_BCHG_S
000011D8                           279          *TODO:Verify bits
000011D8                           280  
000011D8                           281          *Output 'BCHG_S' to console...
000011D8  43F9 0000194F            282          LEA     BCHG_S,A1    *Loads FNDBCHG_S into address register A1
000011DE  103C 000E                283          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000011E2  4E4F                     284          TRAP    #15             *Displays Message
000011E4                           285          
000011E4                           286          *Should have a valid BCHG_S op code. Set data up for EA.
000011E4                           287          *TODO:
000011E4  163C 000E                288          MOVE.B  #14,D3
000011E8  4EF9 000011EE            289          JMP     EA_BCHG_S
000011EE                           290  
000011EE                           291  EA_BCHG_S
000011EE  4EF9 00001404            292          JMP     THEEND  *For now just end
000011F4                           293  
000011F4                           294  
000011F4                           295  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
000011F4                           296  IS_CMPI
000011F4                           297          *TODO:Verify bits
000011F4                           298  
000011F4                           299          *Output 'CMPI' to console...
000011F4  43F9 0000195C            300          LEA     CMPI,A1  *Loads FNDCMPI into address register A1
000011FA  103C 000E                301          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000011FE  4E4F                     302          TRAP    #15         *Displays Message
00001200                           303          
00001200                           304          *Should have a valid CMPI op code. Set data up for EA.
00001200                           305          *TODO:
00001200  163C 000E                306          MOVE.B  #14,D3
00001204  4EF9 0000120A            307          JMP     EA_CMPI
0000120A                           308  
0000120A                           309  EA_CMPI
0000120A  4EF9 00001404            310          JMP     THEEND  *For now just end
00001210                           311  
00001210                           312  
00001210                           313  *STARTS WITH 0001, MOVE.B-----------------------------------
00001210                           314  BUCKET_0001
00001210  =00000001                315  BUCKET0001_BITS EQU $1
00001210                           316          
00001210                           317          *some code...
00001210                           318  
00001210                           319  
00001210                           320  *STARTS WITH 0010, MOVE.L-----------------------------------
00001210                           321  BUCKET_0010
00001210  =00000002                322  BUCKET0010_BITS EQU $2
00001210                           323  
00001210                           324          *some code...
00001210                           325  
00001210                           326  
00001210                           327  *STARTS WITH 0011, MOVE.W-----------------------------------
00001210                           328  BUCKET_0011
00001210  =00000003                329  BUCKET0011_BITS EQU $3
00001210                           330  
00001210                           331          *some code...
00001210                           332  
00001210                           333  
00001210                           334  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
00001210                           335  BUCKET_0100
00001210  =00000004                336  BUCKET0100_BITS EQU $4
00001210                           337  
00001210                           338          *some code...
00001210                           339  
00001210                           340  
00001210                           341  *STARTS WITH 0101, SUBQ-------------------------------------
00001210                           342  BUCKET_0101
00001210  =00000005                343  BUCKET0101_BITS EQU $5
00001210                           344  
00001210                           345          *some code...
00001210                           346  
00001210                           347  
00001210                           348  *STARTS WITH 0110, BCC--------------------------------------
00001210                           349  BUCKET_0110
00001210  =00000006                350  BUCKET0110_BITS EQU $6
00001210                           351  
00001210                           352          *some code...
00001210                           353  
00001210                           354  
00001210                           355  *STARTS WITH 1000, DIVU-------------------------------------
00001210                           356  BUCKET_1000
00001210  =00000008                357  BUCKET1000_BITS EQU $8
00001210                           358  
00001210                           359          *some code...
00001210                           360  
00001210                           361  
00001210                           362  *STARTS WITH 1001, SUBA-------------------------------------
00001210                           363  BUCKET_1001
00001210  =00000009                364  BUCKET1001_BITS EQU $9
00001210                           365  
00001210                           366          *some code...
00001210                           367  
00001210                           368  
00001210                           369  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
00001210                           370  BUCKET_1011
00001210  =0000000B                371  BUCKET1011_BITS EQU $B
00001210                           372  
00001210                           373          *some code...
00001210                           374  
00001210                           375  
00001210                           376  *STARTS WITH 1100, MULS(W) | AND----------------------------
00001210                           377  BUCKET_1100
00001210  =0000000C                378  BUCKET1100_BITS EQU $C
00001210                           379  
00001210                           380          *some code...
00001210                           381  
00001210                           382  
00001210                           383  *STARTS WITH 1101, ADD | ADDA-------------------------------
00001210                           384  BUCKET_1101
00001210  =0000000D                385  BUCKET1101_BITS EQU $D
00001210                           386  
00001210                           387          *some code...
00001210                           388  
00001210                           389  
00001210                           390  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
00001210                           391  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
00001210                           392  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
00001210                           393  BUCKET_1110
00001210  =0000000E                394  BUCKET1110_BITS EQU $E     
00001210                           395  
00001210                           396          *some code...
00001210                           397  
00001210                           398  
00001210                           399  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
00001210                           400  *for this disassembler, jump to BADOPCODE and let I/O take care of it
00001210  4EF9 000013E0            401          JMP     BADOPCODE  
00001216                           402          
00001216                           403  
00001216                           404  *-----------------------------------------------------------        
00001216                           405  * EA operation size decoding functionality
00001216                           406  *-----------------------------------------------------------   
00001216                           407  *'Wrapper' func used for all ea decoding. Used to do the nasty branching for diff sizes
00001216                           408  WrapperSizeImmediate
00001216  4284                     409          CLR.L   D4
00001218  B23C 0000                410          CMP.B   #$00,D1     *If the size of operation is byte, get immediate data/output
0000121C  6700 0014                411          BEQ     ByteSizeImmediate
00001220                           412          
00001220  B23C 0001                413          CMP.B   #$01,D1     *If the size of operation is word, get immediate data/output
00001224  6700 001E                414          BEQ     WordSizeImmediate
00001228                           415  
00001228  B23C 0002                416          CMP.B   #$02,D1     *If the size of operation is long, get immediate data/output
0000122C  6700 0028                417          BEQ     LongSizeImmediate
00001230                           418          
00001230                           419  *Used to get back to what we were doing, after dealing with the specific size
00001230                           420  WrapperSizeImmediateEnd
00001230  4E75                     421          RTS
00001232                           422       
00001232                           423  ByteSizeImmediate
00001232  3818                     424          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
00001234                           425          
00001234                           426          *Output '.B' to console...
00001234  43F9 00001961            427          LEA     ByteSize,A1 *Loads ByteSize into address register A1
0000123A  103C 000E                428          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000123E  4E4F                     429          TRAP    #15         *Displays Message
00001240                           430          
00001240                           431          *HOW TO OUTPUT THE CONTENTS OF A REGISTER (D4)?
00001240                           432          *Output some message, the immediate data is...
00001240                           433          *LEA     FNDADDI,A1  *Loads FNDADDI into address register A1
00001240                           434          *MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001240                           435          *TRAP    #15         *Displays Message
00001240                           436          
00001240  4EF8 1230                437          JMP     WrapperSizeImmediateEnd
00001244                           438                  
00001244                           439  WordSizeImmediate
00001244  3818                     440          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001246                           441          
00001246                           442          *Output '.W' to console...
00001246  43F9 00001968            443          LEA     WordSize,A1 *Loads WordSize into address register A1
0000124C  103C 000E                444          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001250  4E4F                     445          TRAP    #15         *Displays Message
00001252                           446          
00001252                           447          *HOW TO OUTPUT THE CONTENTS OF A REGISTER (D4)?
00001252                           448          *Output some message, the immediate data is...
00001252                           449          *LEA     FNDADDI,A1  *Loads FNDADDI into address register A1
00001252                           450          *MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001252                           451          *TRAP    #15         *Displays Message
00001252                           452          
00001252  4EF8 1230                453          JMP     WrapperSizeImmediateEnd
00001256                           454                  
00001256                           455  LongSizeImmediate
00001256  2818                     456          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
00001258                           457          
00001258                           458          *Output '.L' to console...
00001258  43F9 0000196F            459          LEA     LongSize,A1 *Loads LongSize into address register A1
0000125E  103C 000E                460          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001262  4E4F                     461          TRAP    #15         *Displays Message
00001264                           462          
00001264                           463          *HOW TO OUTPUT THE CONTENTS OF A REGISTER (D4)?
00001264                           464          *Output some message, the immediate data is...
00001264                           465          *LEA     FNDADDI,A1  *Loads FNDADDI into address register A1
00001264                           466          *MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001264                           467          *TRAP    #15         *Displays Message
00001264                           468          
00001264  4EF8 1230                469          JMP     WrapperSizeImmediateEnd
00001268                           470  
00001268                           471  
00001268                           472  *-----------------------------------------------------------        
00001268                           473  * EA Mode/EA Register decoding functionality
00001268                           474  *-----------------------------------------------------------        
00001268                           475  DataRegMode
00001268                           476          *Depending on the EA Register, output a different register number
00001268  4EB9 000012AE            477          JSR     WrapperDataReg
0000126E                           478          
0000126E                           479          *Nothing else to do here, should maybe go straight to next instruction and not back
0000126E                           480          *to the EA_ADDI portion?
0000126E                           481  
0000126E                           482  AddrDirectMode
0000126E                           483          *some code...
0000126E                           484  
0000126E                           485  AddrIndirectMode
0000126E                           486          *Depending on the EA Register, output a different register number
0000126E  B63C 0000                487          CMP.B   #$00,D3
00001272  6700 00FC                488          BEQ     AddrIndReg0
00001276                           489          
00001276  B63C 0001                490          CMP.B   #$01,D3
0000127A  6700 0102                491          BEQ     AddrIndReg1
0000127E                           492          
0000127E  B63C 0002                493          CMP.B   #$02,D3
00001282  6700 0108                494          BEQ     AddrIndReg2
00001286                           495          
00001286  B63C 0003                496          CMP.B   #$03,D3
0000128A  6700 010E                497          BEQ     AddrIndReg3
0000128E                           498          
0000128E  B63C 0004                499          CMP.B   #$04,D3
00001292  6700 0114                500          BEQ     AddrIndReg4
00001296                           501          
00001296  B63C 0005                502          CMP.B   #$05,D3
0000129A  6700 011A                503          BEQ     AddrIndReg5
0000129E                           504          
0000129E  B63C 0006                505          CMP.B   #$06,D3
000012A2  6700 0120                506          BEQ     AddrIndReg6
000012A6                           507          
000012A6  B63C 0007                508          CMP.B   #$07,D3
000012AA  6700 0126                509          BEQ     AddrIndReg7
000012AE                           510                          
000012AE                           511          *Nothing else to do here, should maybe go straight to next instruction and not back
000012AE                           512          *to the EA_ADDI portion?
000012AE                           513  
000012AE                           514  AddrIndirectPostMode
000012AE                           515          *Depending on the EA Register, output a different register number
000012AE                           516          
000012AE                           517  
000012AE                           518          *Nothing else to do here, should maybe go straight to next instruction and not back
000012AE                           519          *to the EA_ADDI portion?
000012AE                           520  
000012AE                           521  AddrIndirectPreMode
000012AE                           522          *Depending on the EA Register, output a different register number
000012AE                           523  
000012AE                           524          *Nothing else to do here, should maybe go straight to next instruction and not back
000012AE                           525          *to the EA_ADDI portion?
000012AE                           526  
000012AE                           527  AddrAbsoluteMode
000012AE                           528          *Depending on the EA Register, output a different register number
000012AE                           529  
000012AE                           530          *READ IN THE NEXT WORD ADDRESS OR LONG ADDRESS, DEPENDING ON EA REGISTER, ALSO OUTPUT
000012AE                           531  
000012AE                           532          *Nothing else to do here, should maybe go straight to next instruction and not back
000012AE                           533          *to the EA_ADDI portion?
000012AE                           534          
000012AE                           535  ImmediateDataMode
000012AE                           536          *some code      
000012AE                           537  
000012AE                           538  
000012AE                           539  *-----------------------------------------------------------        
000012AE                           540  * Output logic for all Data Registers (0-7)
000012AE                           541  *-----------------------------------------------------------     
000012AE                           542  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000012AE                           543  WrapperDataReg
000012AE  B63C 0000                544          CMP.B   #$00,D3
000012B2  6700 003C                545          BEQ     DataReg0
000012B6                           546          
000012B6  B63C 0001                547          CMP.B   #$01,D3
000012BA  6700 0044                548          BEQ     DataReg1
000012BE                           549          
000012BE  B63C 0002                550          CMP.B   #$02,D3
000012C2  6700 004C                551          BEQ     DataReg2
000012C6                           552          
000012C6  B63C 0003                553          CMP.B   #$03,D3
000012CA  6700 0054                554          BEQ     DataReg3
000012CE                           555          
000012CE  B63C 0004                556          CMP.B   #$04,D3
000012D2  6700 005C                557          BEQ     DataReg4
000012D6                           558          
000012D6  B63C 0005                559          CMP.B   #$05,D3
000012DA  6700 0064                560          BEQ     DataReg5
000012DE                           561          
000012DE  B63C 0006                562          CMP.B   #$06,D3
000012E2  6700 006C                563          BEQ     DataReg6
000012E6                           564          
000012E6  B63C 0007                565          CMP.B   #$07,D3
000012EA  6700 0074                566          BEQ     DataReg7        
000012EE                           567  
000012EE                           568  *Used to get back to 'DataRegMode', after dealing with the specific register
000012EE                           569  WrapperDataRegEnd
000012EE  4E75                     570          RTS
000012F0                           571  
000012F0                           572  DataReg0
000012F0                           573          *Output some message, EA mode is data register 0...
000012F0  43F9 00001976            574          LEA     OutDataReg0,A1  *Loads DataReg0 into address register A1
000012F6  103C 000E                575          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000012FA  4E4F                     576          TRAP    #15             *Displays Message   
000012FC                           577          
000012FC  4EF8 12EE                578          JMP     WrapperDataRegEnd
00001300                           579  
00001300                           580  DataReg1
00001300  43F9 0000197C            581          LEA     OutDataReg1,A1
00001306  103C 000E                582          MOVE.B  #14,D0
0000130A  4E4F                     583          TRAP    #15
0000130C                           584          
0000130C  4EF8 12EE                585          JMP     WrapperDataRegEnd
00001310                           586  
00001310                           587  DataReg2
00001310  43F9 00001982            588          LEA     OutDataReg2,A1
00001316  103C 000E                589          MOVE.B  #14,D0
0000131A  4E4F                     590          TRAP    #15
0000131C                           591  
0000131C  4EF8 12EE                592          JMP     WrapperDataRegEnd
00001320                           593      
00001320                           594  DataReg3
00001320  43F9 00001988            595          LEA     OutDataReg3,A1
00001326  103C 000E                596          MOVE.B  #14,D0
0000132A  4E4F                     597          TRAP    #15
0000132C                           598  
0000132C  4EF8 12EE                599          JMP     WrapperDataRegEnd
00001330                           600          
00001330                           601  DataReg4
00001330  43F9 0000198E            602          LEA     OutDataReg4,A1
00001336  103C 000E                603          MOVE.B  #14,D0
0000133A  4E4F                     604          TRAP    #15
0000133C                           605  
0000133C  4EF8 12EE                606          JMP     WrapperDataRegEnd
00001340                           607                 
00001340                           608  DataReg5
00001340  43F9 00001994            609          LEA     OutDataReg5,A1
00001346  103C 000E                610          MOVE.B  #14,D0
0000134A  4E4F                     611          TRAP    #15
0000134C                           612  
0000134C  4EF8 12EE                613          JMP     WrapperDataRegEnd
00001350                           614          
00001350                           615  DataReg6
00001350  43F9 0000199A            616          LEA     OutDataReg6,A1 A1
00001356  103C 000E                617          MOVE.B  #14,D0
0000135A  4E4F                     618          TRAP    #15
0000135C                           619  
0000135C  4EF8 12EE                620          JMP     WrapperDataRegEnd
00001360                           621          
00001360                           622  DataReg7
00001360  43F9 000019A0            623          LEA     OutDataReg7,A1
00001366  103C 000E                624          MOVE.B  #14,D0
0000136A  4E4F                     625          TRAP    #15
0000136C                           626          
0000136C  4EF8 12EE                627          JMP     WrapperDataRegEnd
00001370                           628  
00001370                           629  
00001370                           630  *-----------------------------------------------------------        
00001370                           631  * Output logic for all Address Indirec Registers (0-7)
00001370                           632  *-----------------------------------------------------------     
00001370                           633  AddrIndReg0
00001370                           634          *Output some message, EA mode is address indirect 0...
00001370  43F9 000019A6            635          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
00001376  103C 000E                636          MOVE.B  #14,D0              *Moves the number 14 into data register D0
0000137A  4E4F                     637          TRAP    #15                 *Displays Message        
0000137C                           638          
0000137C  4E75                     639          RTS
0000137E                           640  
0000137E                           641  AddrIndReg1
0000137E  43F9 000019AE            642          LEA     OutAddrIndReg1,A1
00001384  103C 000E                643          MOVE.B  #14,D0
00001388  4E4F                     644          TRAP    #15
0000138A                           645          
0000138A  4E75                     646          RTS
0000138C                           647  
0000138C                           648  AddrIndReg2
0000138C  43F9 000019B6            649          LEA     OutAddrIndReg2,A1
00001392  103C 000E                650          MOVE.B  #14,D0
00001396  4E4F                     651          TRAP    #15
00001398                           652          
00001398  4E75                     653          RTS
0000139A                           654  
0000139A                           655  AddrIndReg3
0000139A  43F9 000019BE            656          LEA     OutAddrIndReg3,A1
000013A0  103C 000E                657          MOVE.B  #14,D0
000013A4  4E4F                     658          TRAP    #15
000013A6                           659          
000013A6  4E75                     660          RTS
000013A8                           661  
000013A8                           662  AddrIndReg4
000013A8  43F9 000019C6            663          LEA     OutAddrIndReg4,A1
000013AE  103C 000E                664          MOVE.B  #14,D0
000013B2  4E4F                     665          TRAP    #15
000013B4                           666          
000013B4  4E75                     667          RTS
000013B6                           668  
000013B6                           669  AddrIndReg5
000013B6  43F9 000019CE            670          LEA     OutAddrIndReg5,A1
000013BC  103C 000E                671          MOVE.B  #14,D0
000013C0  4E4F                     672          TRAP    #15
000013C2                           673          
000013C2  4E75                     674          RTS
000013C4                           675  
000013C4                           676  AddrIndReg6
000013C4  43F9 000019D6            677          LEA     OutAddrIndReg6,A1
000013CA  103C 000E                678          MOVE.B  #14,D0
000013CE  4E4F                     679          TRAP    #15
000013D0                           680          
000013D0  4E75                     681          RTS
000013D2                           682  
000013D2                           683  AddrIndReg7
000013D2  43F9 000019DE            684          LEA     OutAddrIndReg7,A1
000013D8  103C 000E                685          MOVE.B  #14,D0
000013DC  4E4F                     686          TRAP    #15
000013DE                           687          
000013DE  4E75                     688          RTS
000013E0                           689  
000013E0                           690  
000013E0                           691  *-----------------------------------------------------------        
000013E0                           692  * Current handling of bad op/ea codes. Should be revisited.
000013E0                           693  *----------------------------------------------------------- 
000013E0                           694  BADOPCODE
000013E0                           695          *We found a bad op code, output some error to the screen, jump to the 
000013E0                           696          *next instruction in memory.
000013E0                           697          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
000013E0                           698          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
000013E0                           699          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
000013E0                           700          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
000013E0                           701          *i/o and error message code...
000013E0  43F9 000019F6            702          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
000013E6  103C 000E                703          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000013EA  4E4F                     704          TRAP    #15         *Displays Message
000013EC  4EF8 10AC                705          JMP     GRAB_NEXT_OP
000013F0                           706                  
000013F0                           707  BADEACODE
000013F0                           708          *We found a bad ea code, output some error to the screen, jump to the
000013F0                           709          *next instruction in memory.
000013F0                           710          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
000013F0                           711          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
000013F0  43F9 000019E6            712          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
000013F6  103C 000E                713          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000013FA  4E4F                     714          TRAP    #15         *Displays Message
000013FC  4EF8 10AC                715          JMP     GRAB_NEXT_OP
00001400                           716          
00001400                           717          
00001400                           718  *-----------------------------------------------------------        
00001400                           719  * End of Disassembler
00001400                           720  *-----------------------------------------------------------    
00001400                           721  
00001400  4E72 2700                722  DONE    STOP    #$2700  *What does this do? Why was it added?
00001404                           723  
00001404  103C 0009                724  THEEND  MOVE.B  #9,D0
00001408  4E4F                     725          TRAP    #15             Halt Simulator        
0000140A                           726          
0000140A                           727       
0000140A                           728  *-----------------------------------------------------------        
0000140A                           729  * Output stuff
0000140A                           730  *-----------------------------------------------------------     
0000140A  =0000000D                731  CR      EQU     $0D             ASCII code for Carriage Return
0000140A  =0000000A                732  LF      EQU     $0A             ASCII code for Line Feed
0000140A= 2D 2D 2D 2D 2D 2D ...    733  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001449= 7C 7C 20 20 20 20 ...    734              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001488= 2D 2D 2D 2D 2D 2D ...    735              DC.B    '-------------------------------------------------------------',CR,LF
000014C7= 2A 2A 2A 2A 2A 2A ...    736              DC.B    '*************************************************************',CR,LF
00001506= 2A 2A 2A 2A 2A 2A ...    737              DC.B    '*************************************************************',CR,LF
00001545= 2A 2A 2A 2A 2A 2A ...    738              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001584= 2A 2A 2A 2A 2A 2A ...    739              DC.B    '************    ****   ************   *******  **  **********',CR,LF
000015C3= 2A 2A 2A 2A 2A 2A ...    740              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001602= 2A 2A 2A 2A 2A 2A ...    741              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001641= 2A 2A 2A 2A 2A 2A ...    742              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001680= 2A 2A 2A 2A 2A 2A ...    743              DC.B    '*************************************************************',CR,LF
000016BF= 2A 2A 2A 2A 2A 2A ...    744              DC.B    '*************************************************************',CR,LF
000016FE= 2A 20 20 20 20 20 ...    745              DC.B    '*                                                           *',CR,LF
0000173D= 2A 20 41 75 74 68 ...    746              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
0000177C= 2A 20 20 20 20 20 ...    747              DC.B    '*                                                           *',CR,LF
000017BB= 2A 2A 2A 2A 2A 2A ...    748              DC.B    '*************************************************************',CR,LF,CR,LF
000017FC= 53 74 61 72 74 69 ...    749              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001819                           750              
00001819= 57 6F 75 6C 64 20 ...    751  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
0000184A                           752  
0000184A= 20 0D 0A                 753  GETSTRTADDR DC.B    ' ',CR,LF
0000184D= 50 6C 65 61 73 65 ...    754              DC.B    'Please type in your starting address request: ',0
0000187C                           755              
0000187C= 20 0D 0A                 756  GETENDADDR  DC.B    ' ',CR,LF
0000187F= 50 6C 65 61 73 65 ...    757              DC.B    'Please type in your ending address request: ',0
000018AC                           758              
000018AC= 20 0D 0A                 759  QUIT_MSG    DC.B    ' ',CR,LF
000018AF= 57 6F 75 6C 64 20 ...    760              DC.B    'Would you like to quit (Y/N)? ',0
000018CE                           761  
000018CE                           762  *****************************************************
000018CE                           763  * I/O storages - assuming users knows what to do.
000018CE                           764  *****************************************************
000018CE                           765  CMD_HLD     DS.B    30
000018EC                           766  CMD_SZ      DS.B    30
0000190A                           767  STADDR      DS.B    10
00001914                           768  STADDRSZ    DS.B    10
0000191E                           769  ENDADDR     DS.B    10
00001928                           770  ENDADDRSZ   DS.B    10
00001932                           771  *****************************************************
00001932                           772  
00001932                           773  *output for all OPCODEs
00001932= 41 44 44 49 00           774  ADDI    DC.B    'ADDI',0
00001937= 41 4E 44 49 00           775  ANDI    DC.B    'ANDI',0
0000193C= 45 4F 52 49 00           776  EORI    DC.B    'EORI',0
00001941= 42 43 48 47 28 64 ...    777  BCHG_D  DC.B    'BCHG(dynamic)',0
0000194F= 42 43 48 47 28 73 ...    778  BCHG_S  DC.B    'BCHG(static)',0
0000195C= 43 4D 50 49 00           779  CMPI    DC.B    'CMPI',0
00001961                           780  
00001961                           781  *output for the size of the operation
00001961= 2E 42 20 20 20 20 00     782  ByteSize    DC.B    '.B    ',0
00001968= 2E 57 20 20 20 20 00     783  WordSize    DC.B    '.W    ',0
0000196F= 2E 4C 20 20 20 20 00     784  LongSize    DC.B    '.L    ',0
00001976                           785  
00001976                           786  *output for all data registers (0-7)
00001976= 2C 44 30 0D 0A 00        787  OutDataReg0 DC.B    ',D0',CR,LF,0
0000197C= 2C 44 31 0D 0A 00        788  OutDataReg1 DC.B    ',D1',CR,LF,0
00001982= 2C 44 32 0D 0A 00        789  OutDataReg2 DC.B    ',D2',CR,LF,0
00001988= 2C 44 33 0D 0A 00        790  OutDataReg3 DC.B    ',D3',CR,LF,0
0000198E= 2C 44 34 0D 0A 00        791  OutDataReg4 DC.B    ',D4',CR,LF,0
00001994= 2C 44 35 0D 0A 00        792  OutDataReg5 DC.B    ',D5',CR,LF,0
0000199A= 2C 44 36 0D 0A 00        793  OutDataReg6 DC.B    ',D6',CR,LF,0
000019A0= 2C 44 37 0D 0A 00        794  OutDataReg7 DC.B    ',D7',CR,LF,0
000019A6                           795  
000019A6                           796  *output for all address indirect registers (0-7)
000019A6= 2C 28 41 30 29 0D ...    797  OutAddrIndReg0  DC.B    ',(A0)',CR,LF,0
000019AE= 2C 28 41 31 29 0D ...    798  OutAddrIndReg1  DC.B    ',(A1)',CR,LF,0
000019B6= 2C 28 41 32 29 0D ...    799  OutAddrIndReg2  DC.B    ',(A2)',CR,LF,0
000019BE= 2C 28 41 33 29 0D ...    800  OutAddrIndReg3  DC.B    ',(A3)',CR,LF,0
000019C6= 2C 28 41 34 29 0D ...    801  OutAddrIndReg4  DC.B    ',(A4)',CR,LF,0
000019CE= 2C 28 41 35 29 0D ...    802  OutAddrIndReg5  DC.B    ',(A5)',CR,LF,0
000019D6= 2C 28 41 36 29 0D ...    803  OutAddrIndReg6  DC.B    ',(A6)',CR,LF,0
000019DE= 2C 28 41 37 29 0D ...    804  OutAddrIndReg7  DC.B    ',(A7)',CR,LF,0
000019E6                           805  
000019E6                           806  *current output for error messages
000019E6= 42 41 44 20 45 41 ...    807  BADEAMSG    DC.B    'BAD EA, WHY?!',CR,LF,0
000019F6= 42 41 44 20 4F 50 ...    808  BADOPMSG    DC.B    'BAD OP CODE, WHY?!',CR,LF,0
00001A0B= 49 6D 70 72 6F 70 ...    809  INV_MSG     DC.B    'Improper command.',CR,LF,0
00001A1F= 49 6E 76 61 6C 69 ...    810  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
00001A38                           811          
00001A38                           812          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                1932
ADDRABSOLUTEMODE    12AE
ADDRDIRECTMODE      126E
ADDRINDIRECTMODE    126E
ADDRINDIRECTPOSTMODE  12AE
ADDRINDIRECTPREMODE  12AE
ADDRINDREG0         1370
ADDRINDREG1         137E
ADDRINDREG2         138C
ADDRINDREG3         139A
ADDRINDREG4         13A8
ADDRINDREG5         13B6
ADDRINDREG6         13C4
ADDRINDREG7         13D2
ANDI                1937
BADEACODE           13F0
BADEAMSG            19E6
BADOPCODE           13E0
BADOPMSG            19F6
BCHG_D              1941
BCHG_S              194F
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         10B8
BUCKET_0001         1210
BUCKET_0010         1210
BUCKET_0011         1210
BUCKET_0100         1210
BUCKET_0101         1210
BUCKET_0110         1210
BUCKET_1000         1210
BUCKET_1001         1210
BUCKET_1011         1210
BUCKET_1100         1210
BUCKET_1101         1210
BUCKET_1110         1210
BYTESIZE            1961
BYTESIZEIMMEDIATE   1232
CHECKSTRT1          1098
CHECK_LOWN          1052
CHECK_LOWY          103A
CHECK_UPN           1046
CHECK_UPY           102E
CMD_HLD             18CE
CMD_SZ              18EC
CMPI                195C
CR                  D
DATAREG0            12F0
DATAREG1            1300
DATAREG2            1310
DATAREG3            1320
DATAREG4            1330
DATAREG5            1340
DATAREG6            1350
DATAREG7            1360
DATAREGMODE         1268
DONE                1400
EA_ADDI             113E
EA_ANDI             1188
EA_BCHG_D           11D2
EA_BCHG_S           11EE
EA_CMPI             120A
EA_EORI             11A4
ENDADDR             191E
ENDADDRSZ           1928
EORI                193C
GETENDADDR          187C
GETSTRTADDR         184A
GRAB_NEXT_OP        10AC
IMMEDIATEDATAMODE   12AE
INVALID1            105E
INVSTRTMSG          1A1F
INV_MSG             1A0B
INV_STRT1           106E
IS_ADDI             110E
IS_ANDI             1172
IS_BCHG_D           11AA
IS_BCHG_S           11D8
IS_CMPI             11F4
IS_EORI             118E
LF                  A
LONGSIZE            196F
LONGSIZEIMMEDIATE   1256
LOOP_1              1010
MESSAGE             140A
NXT_CMD             1080
OUTADDRINDREG0      19A6
OUTADDRINDREG1      19AE
OUTADDRINDREG2      19B6
OUTADDRINDREG3      19BE
OUTADDRINDREG4      19C6
OUTADDRINDREG5      19CE
OUTADDRINDREG6      19D6
OUTADDRINDREG7      19DE
OUTDATAREG0         1976
OUTDATAREG1         197C
OUTDATAREG2         1982
OUTDATAREG3         1988
OUTDATAREG4         198E
OUTDATAREG5         1994
OUTDATAREG6         199A
OUTDATAREG7         19A0
QUIT_MSG            18AC
STACK               7000
STADDR              190A
STADDRSZ            1914
START               1000
STARTASSEM          1819
ST_ADDR             7FC0
THEEND              1404
WORDSIZE            1968
WORDSIZEIMMEDIATE   1244
WRAPPERDATAREG      12AE
WRAPPERDATAREGEND   12EE
WRAPPERSIZEIMMEDIATE  1216
WRAPPERSIZEIMMEDIATEEND  1230
