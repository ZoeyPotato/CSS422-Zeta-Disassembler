00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.0
Created On: 3/14/2014 3:16:44 AM

00000000                             1  *-------------------------------------------------------------
00000000                             2  * Title      :Team Zeta 68k Disassembler, CSS 422 Winter 2014
00000000                             3  * Written by :Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi
00000000                             4  * Date       :3/11/2014
00000000                             5  * Description:
00000000                             6  * This program disassembles a subset of 68k assembly instructions. 
00000000                             7  * ***visit this later, describe what it does, how to use it, assumptions, etc.
00000000                             8  *-------------------------------------------------------------
00000000  =00007FC6                  9  ST_ADDR     EQU $7FC6   *Starting address of input test file
00000000  =00007000                 10  STACK       EQU $7000   *Stack location
00000000  =0000000F                 11  MAX_LINE    EQU     15      *Maximum number of instructions that can be 
00001000                            12  START       ORG $1000   *Start program at provided location 
00001000  4FF8 7000                 13              LEA stack,SP
00001004  3C3C 000F                 14              MOVE    #MAX_LINE,D6
00001008                            15  
00001008                            16  
00001008                            17  *-----------------------------------------------------------
00001008                            18  * Start of I/O
00001008                            19  *-----------------------------------------------------------            
00001008  43F9 00001B44             20              LEA     MESSAGE,A1  *Loads MESSAGE into address register A1
0000100E  103C 000E                 21              MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001012  4E4F                      22              TRAP    #15         *Displays Message
00001014                            23          
00001014  303C 0000                 24  loop_1      MOVE    #0,D0       
00001018  43F9 00001F53             25              LEA     STARTASSEM,A1   *Fix the bug that takes the input but outputs the input back out.
0000101E  103C 000E                 26              MOVE.B  #14,D0
00001022  4E4F                      27              TRAP    #15    
00001024  303C 0002                 28              MOVE    #2,D0
00001028  43F9 0000202E             29              LEA     CMD_HLD,A1  *Store the command in a buffer
0000102E  4E4F                      30              TRAP    #15
00001030  0C01 0001                 31              CMPI.B  #01,D1
00001034  6600 00FE                 32              BNE     INVALID1
00001038  4EB9 00001110             33              JSR     CHECK_UPY
0000103E                            34  *-----------------------------------------------------------
0000103E                            35  *
0000103E                            36  * I/O: Check Start Address
0000103E                            37  *
0000103E                            38  * Make sure that start address starts after allocated 
0000103E                            39  * memory addresses. Else, it will print out a message 
0000103E                            40  * saying that requested address is invalid & prompts the
0000103E                            41  * user again for the starting address.
0000103E                            42  *-----------------------------------------------------------
0000103E  43F9 00001F84             43  GET_STRT    LEA     GETSTRTADDR,A1  *Ask start address once everything is OK.
00001044  103C 000E                 44              MOVE.B  #14,D0
00001048  4E4F                      45              TRAP    #15
0000104A  43F9 0000206A             46              LEA     STADDR,A1   *Need to change where it can hold the start/end address
00001050  3239 00002074             47              MOVE.W  STADDRSZ,D1 *Store the size in a buffer
00001056  303C 0002                 48              MOVE    #2,D0           *Get start address
0000105A  4E4F                      49              TRAP    #15
0000105C  4EB9 000010E4             50              JSR     CHECKSTRT1
00001062  4287                      51              CLR.L   D7
00001064  4EB9 00001174             52              JSR     ASCIIHEX    *Convert ASCII to Hex if all's ok
0000106A  0C03 0001                 53              CMPI.B  #01,D3      *Check if there was a bad start
0000106E  6700 00DC                 54              BEQ     INV_STRT1   *Prints error message if there was a bad start
00001072  0C87 00007FC6             55              CMPI.L  #ST_ADDR,D7 *Checks the minimum start address for D7
00001078  6D00 00D2                 56              BLT     INV_STRT1   *Asks for another start address if invalid
0000107C  0C87 00FFFFFE             57              CMPI.L  #$00FFFFFE,D7   *Checks if it goes beyond the possible end address
00001082  6C00 00C8                 58              BGE     INV_STRT1
00001086  23C7 0000207E             59              MOVE.L  D7,PROGST
0000108C                            60  
0000108C  43F9 00001FB6             61  GET_END     LEA     GETENDADDR,A1   *Command prompt for end address
00001092  103C 000E                 62              MOVE.B  #14,D0
00001096  4E4F                      63              TRAP    #15
00001098  43F9 00002082             64              LEA     ENDADDR,A1      *Buffer to hold end address
0000109E  3239 0000208C             65              MOVE.W  ENDADDRSZ,D1    *Buffer to hold size of end address
000010A4  303C 0002                 66              MOVE    #2,D0
000010A8  4E4F                      67              TRAP    #15
000010AA  4EB9 000010FA             68              JSR     CHECKEND1
000010B0  4287                      69              CLR.L   D7
000010B2  4EB9 00001174             70              JSR     ASCIIHEX
000010B8  0C03 0001                 71              CMPI.B  #01,D3
000010BC  6700 00A2                 72              BEQ     INV_END1
000010C0  0C87 0000207E             73              CMPI.L  #PROGST,D7
000010C6  6D00 0098                 74              BLT     INV_END1
000010CA  0C87 00FFFFFF             75              CMPI.L  #$00FFFFFF,D7
000010D0  6C00 008E                 76              BGE     INV_END1
000010D4  23C7 00002096             77              MOVE.L  D7,PROGEND
000010DA  2079 0000207E             78              MOVEA.L PROGST,A0
000010E0  6000 028A                 79              BRA     GRAB_NEXT_OP            
000010E4                            80                          
000010E4  0C81 00000008             81  CHECKSTRT1  CMPI.L  #08,D1      *Check if size falls within range
000010EA  6E00 0060                 82              BGT     INV_STRT1
000010EE  0C81 00000000             83              CMPI.L  #00,D1
000010F4  6300 0056                 84              BLS     INV_STRT1
000010F8  4E75                      85              RTS         
000010FA                            86              
000010FA  0C81 00000008             87  CHECKEND1   CMPI.L  #08,D1
00001100  6E00 005E                 88              BGT     INV_END1
00001104  0C81 00000000             89              CMPI.L  #00,D1
0000110A  6300 0054                 90              BLS     INV_END1
0000110E  4E75                      91              RTS
00001110                            92  
00001110                            93  *-----------------------------------------------------------
00001110                            94  * I/O: Input check for Y, y, N, n
00001110                            95  *-----------------------------------------------------------
00001110  0C11 0059                 96  CHECK_UPY   CMPI.B  #$59,(A1)   *Checks for uppercase Y
00001114  6600 0004                 97              BNE     CHECK_LOWY
00001118  4E75                      98              RTS
0000111A  0C11 0079                 99  CHECK_LOWy  CMPI.B  #$79,(A1)   *Checks for lowercase y
0000111E  6600 0004                100              BNE     CHECK_UPN
00001122  4E75                     101              RTS
00001124  0C11 004E                102  CHECK_UPN   CMPI.B  #$4E,(A1)   *Checks for uppercase N
00001128  6700 0A10                103              BEQ     DONE
0000112C                           104              
0000112C  0C11 006E                105  CHECK_LOWn  CMPI.B  #$6E,(A1)   *Checks for lowercase n
00001130  6700 0A08                106              BEQ     DONE
00001134                           107              
00001134  163C 0000                108  INVALID1    MOVE.B  #0,D3       *Reset bad flag
00001138  303C 0000                109              MOVE    #0,D0       *Prints invalid command msg if not found
0000113C  43F9 00002207            110              LEA     INV_MSG,A1
00001142  303C 000E                111              MOVE    #14,D0
00001146  4E4F                     112              TRAP    #15
00001148  6000 FECA                113              BRA     loop_1
0000114C                           114              
0000114C  43F9 0000221B            115  INV_STRT1   LEA     INVSTRTMSG,A1
00001152  103C 000E                116              MOVE.B  #14,D0
00001156  4E4F                     117              TRAP    #15
00001158  163C 0000                118              MOVE.B  #00,D3      *Reset flag
0000115C  6000 FEE0                119              BRA     GET_STRT        
00001160                           120              
00001160  43F9 00002234            121  INV_END1    LEA     INVENDMSG,A1
00001166  103C 000E                122              MOVE.B  #14,D0
0000116A  4E4F                     123              TRAP    #15
0000116C  163C 0000                124              MOVE.B  #00,D3      *Reset flag
00001170  6000 FF1A                125              BRA     GET_END
00001174                           126              
00001174                           127  *-----------------------------------------------------------
00001174                           128  * ASCII to Hex converter
00001174                           129  *
00001174                           130  * Checks and converts the ASCII value to the hex equivalent
00001174                           131  *-----------------------------------------------------------
00001174  48E7 6000                132  ASCIIHEX    MOVEM.L D1/D2,-(SP) *Free up and store the values in the stack
00001178  0C01 0000                133  ASCIIHEX1   CMPI.B  #00,D1      *See if done
0000117C  6700 0062                134              BEQ     exitSub     *Exit subroutine 
00001180  5301                     135              SUBI.B  #01,D1      *Keep track of how many chars we need to go through
00001182  E99F                     136              ROL.L   #4,D7       *Keep shifting to add the next appropriate hex for the full addr
00001184  1419                     137              MOVE.B  (A1)+,D2    *Takes the first char
00001186  0C02 0024                138              CMPI.B  #$24,D2     *See if the first char is $
0000118A  67EC                     139              BEQ     ASCIIHEX1   *Loop through to get the next char if first is $
0000118C  0C02 0030                140              CMPI.B  #$30,D2     *See if the char is less than the hex value for '0'
00001190  6D00 004C                141              BLT     st_bad      *Put error message
00001194  0C02 0039                142              CMPI.B  #$39,D2     *Checks if char value is between 0 and 9's hex value
00001198  6F00 0026                143              BLE     CONV_NUM    *Convert to number, if so
0000119C  0C02 0041                144              CMPI.B  #$41,D2     *Checks if char value is not a number or letter (A-F)
000011A0  6D00 003C                145              BLT     st_bad      *Put error message
000011A4  0C02 0046                146              CMPI.B  #$46,D2     *Checks if char value is an uppercase letter between A and F
000011A8  6F00 0020                147              BLE     CONV_UpL    *Convert to hex
000011AC  0C02 0061                148              CMPI.B  #$61,D2     *Checks for non-valid chars
000011B0  6D00 002C                149              BLT     st_bad
000011B4  0C02 0066                150              CMPI.B  #$66,D2     *Checks for lowercase chars of (a-f)
000011B8  6F00 001A                151              BLE     CONV_LoL    
000011BC  6E00 0020                152              BGT     st_bad      *Puts error message for anything greater than f value
000011C0                           153              
000011C0  0402 0030                154  CONV_NUM    SUBI.B  #$30,D2
000011C4  8E02                     155              OR.B    D2,D7
000011C6  4EF8 1178                156              JMP     ASCIIHEX1
000011CA  0402 0037                157  CONV_UpL    SUBI.B  #$37,D2     *Put it in a range of 10-15
000011CE  8E02                     158              OR.B    D2,D7
000011D0  4EF8 1178                159              JMP     ASCIIHEX1
000011D4  0402 0057                160  CONV_LoL    SUBI.B  #$57,D2
000011D8  8E02                     161              OR.B    D2,D7
000011DA  4EF8 1178                162              JMP     ASCIIHEX1   
000011DE                           163  
000011DE  5203                     164  st_bad      ADDI.B  #01,D3
000011E0  4CDF 0006                165  exitSub     MOVEM.L (SP)+,D1/D2 *Pop back data back to the respective registers
000011E4  4E75                     166              RTS
000011E6                           167              
000011E6                           168  *-----------------------------------------------------------
000011E6                           169  * Hex to ASCII converter
000011E6                           170  *-----------------------------------------------------------
000011E6  48E7 4C00                171  HEXASCII    MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
000011EA  0C01 0000                172  CHECK       CMPI.B  #00,D1          * Check if it's sending a byte, word, or longword
000011EE  6700 002C                173              BEQ     CHNG_SZB        * Set the appropriate size for for-loop
000011F2  B27C 0001                174              CMP.W   #01,D1          
000011F6  6700 003E                175              BEQ     CHNG_SZW
000011FA  6000 0006                176              BRA     CHNG_SZL        
000011FE                           177  
000011FE  48E7 4C00                178  HEXASCIIREG MOVEM.L D1/D4/D5,-(SP)  * Push registers into the stack
00001202  123C 0008                179  CHNG_SZL    MOVE.B  #8,D1           * Set size to 8
00001206  0C01 0000                180  LOOP_L      CMPI.B  #00,D1
0000120A  6700 00CA                181              BEQ     EXIT_CONV
0000120E  5301                     182              SUBI.B  #01,D1
00001210  E99C                     183              ROL.L   #4,D4           * Shift it for next bit
00001212  2A04                     184              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001214  4EB9 00001250            185              JSR     CONV_LOOP
0000121A  60EA                     186              BRA     LOOP_L      
0000121C                           187  
0000121C  123C 0002                188  CHNG_SZB    MOVE.B  #2,D1           * Set size to 2
00001220  0C01 0000                189  LOOP_B      CMPI.B  #00,D1
00001224  6700 00B0                190              BEQ     EXIT_CONV
00001228  5301                     191              SUBI.B  #01,D1
0000122A  E91C                     192              ROL.B   #4,D4           * Shift it for next bit
0000122C  2A04                     193              MOVE.L  D4,D5           * Keep a copy of hex values in D5
0000122E  4EB9 00001250            194              JSR     CONV_LOOP
00001234  60EA                     195              BRA     LOOP_B
00001236                           196              
00001236  123C 0004                197  CHNG_SZW    MOVE.B  #4,D1           * Set size to 4
0000123A  0C01 0000                198  LOOP_W      CMPI.B  #00,D1
0000123E  6700 0096                199              BEQ     EXIT_CONV
00001242  5301                     200              SUBI.B  #01,D1
00001244  E95C                     201              ROL.W   #4,D4           * Shift it for next bit
00001246  2A04                     202              MOVE.L  D4,D5           * Keep a copy of hex values in D5
00001248  4EB9 00001250            203              JSR     CONV_LOOP
0000124E  60EA                     204              BRA     LOOP_W
00001250                           205  
00001250  0285 0000000F            206  CONV_LOOP   ANDI.L  #$0000000F,D5   * Grab only the last bit in D5
00001256  0C05 0000                207              CMPI.B  #$0,D5
0000125A  6700 0088                208              BEQ     NUM_0
0000125E  0C05 0001                209              CMPI.B  #$1,D5
00001262  6700 0088                210              BEQ     NUM_1
00001266  0C05 0002                211              CMPI.B  #$2,D5
0000126A  6700 0088                212              BEQ     NUM_2
0000126E  0C05 0003                213              CMPI.B  #$3,D5
00001272  6700 0088                214              BEQ     NUM_3
00001276  0C05 0004                215              CMPI.B  #$4,D5
0000127A  6700 0088                216              BEQ     NUM_4
0000127E  0C05 0005                217              CMPI.B  #$5,D5
00001282  6700 0088                218              BEQ     NUM_5
00001286  0C05 0006                219              CMPI.B  #$6,D5
0000128A  6700 0088                220              BEQ     NUM_6
0000128E  0C05 0007                221              CMPI.B  #$7,D5
00001292  6700 0088                222              BEQ     NUM_7
00001296  0C05 0008                223              CMPI.B  #$8,D5
0000129A  6700 0088                224              BEQ     NUM_8
0000129E  0C05 0009                225              CMPI.B  #$9,D5
000012A2  6700 0088                226              BEQ     NUM_9
000012A6  0C05 000A                227              CMPI.B  #$A,D5
000012AA  6700 0088                228              BEQ     NUM_A
000012AE  0C05 000B                229              CMPI.B  #$B,D5
000012B2  6700 0088                230              BEQ     NUM_B
000012B6  0C05 000C                231              CMPI.B  #$C,D5
000012BA  6700 0088                232              BEQ     NUM_C
000012BE  0C05 000D                233              CMPI.B  #$D,D5
000012C2  6700 0088                234              BEQ     NUM_D
000012C6  0C05 000E                235              CMPI.B  #$E,D5
000012CA  6700 0088                236              BEQ     NUM_E
000012CE  0C05 000F                237              CMPI.B  #$F,D5
000012D2  6700 0088                238              BEQ     NUM_F
000012D6                           239              
000012D6  4CDF 0032                240  EXIT_CONV   MOVEM.L (SP)+,D1/D4/D5
000012DA  4E75                     241              RTS
000012DC                           242              
000012DC  303C 000E                243  PRINT_NUM   MOVE    #14,D0
000012E0  4E4F                     244              TRAP    #15
000012E2  4E75                     245              RTS
000012E4  43F9 000020B8            246  NUM_0       LEA     PRNT0,A1
000012EA  60F0                     247              BRA     PRINT_NUM
000012EC  43F9 000020BA            248  NUM_1       LEA     PRNT1,A1
000012F2  60E8                     249              BRA     PRINT_NUM
000012F4  43F9 000020BC            250  NUM_2       LEA     PRNT2,A1
000012FA  60E0                     251              BRA     PRINT_NUM
000012FC  43F9 000020BE            252  NUM_3       LEA     PRNT3,A1
00001302  60D8                     253              BRA     PRINT_NUM
00001304  43F9 000020C0            254  NUM_4       LEA     PRNT4,A1
0000130A  60D0                     255              BRA     PRINT_NUM
0000130C  43F9 000020C2            256  NUM_5       LEA     PRNT5,A1
00001312  60C8                     257              BRA     PRINT_NUM
00001314  43F9 000020C4            258  NUM_6       LEA     PRNT6,A1
0000131A  60C0                     259              BRA     PRINT_NUM
0000131C  43F9 000020C6            260  NUM_7       LEA     PRNT7,A1
00001322  60B8                     261              BRA     PRINT_NUM
00001324  43F9 000020C8            262  NUM_8       LEA     PRNT8,A1
0000132A  60B0                     263              BRA     PRINT_NUM
0000132C  43F9 000020CA            264  NUM_9       LEA     PRNT9,A1
00001332  60A8                     265              BRA     PRINT_NUM
00001334  43F9 000020CC            266  NUM_A       LEA     PRNTA,A1
0000133A  60A0                     267              BRA     PRINT_NUM
0000133C  43F9 000020CE            268  NUM_B       LEA     PRNTB,A1
00001342  6098                     269              BRA     PRINT_NUM
00001344  43F9 000020D0            270  NUM_C       LEA     PRNTC,A1
0000134A  6090                     271              BRA     PRINT_NUM
0000134C  43F9 000020D2            272  NUM_D       LEA     PRNTD,A1
00001352  6088                     273              BRA     PRINT_NUM
00001354  43F9 000020D4            274  NUM_E       LEA     PRNTE,A1
0000135A  6080                     275              BRA     PRINT_NUM
0000135C  43F9 000020D6            276  NUM_F       LEA     PRNTF,A1
00001362  6000 FF78                277              BRA     PRINT_NUM
00001366                           278  
00001366                           279  *-----------------------------------------------------------        
00001366                           280  * Start of Disassembler
00001366                           281  *-----------------------------------------------------------
00001366                           282          *FOR DEBUGGING ONLY!!!
00001366  207C 00007FC6            283          MOVEA.L #ST_ADDR,A0 *Load starting location of test input file into A0
0000136C                           284          
0000136C                           285  GRAB_NEXT_OP
0000136C  2E08                     286          MOVE.L  A0,D7       
0000136E  0C87 00002096            287          CMPI.L  #PROGEND,D7  *Check and see if A0 == end of test address. 
00001374  6700 FC9E                288          BEQ     loop_1      * Ask user if they want to do the disassembler again
00001378  0C86 00000000            289          CMPI.L  #00,D6      * Check if max line of instructions output on console is reached
0000137E  6700 002A                290          BEQ     CONT_Q      * Asks user if they want to continue with the disassembler
00001382  5306                     291          SUBI.B  #01,D6      * Keep track of how many lines of instruction has been printed
00001384                           292          *Output the address of this instruction to console...
00001384  2808                     293          MOVE.L  A0,D4
00001386  4EB8 11FE                294          JSR     HEXASCIIREG
0000138A                           295          
0000138A                           296          *Output a tab (4 spaces) to console, just after the address...
0000138A  43F9 000021E6            297          LEA     Tab,A1  *Loads Tab into address register A1
00001390  103C 000E                298          MOVE.B  #14,D0  *Moves the number 14 into data register D0
00001394  4E4F                     299          TRAP    #15     *Displays Message
00001396                           300          
00001396                           301          *Move word data at (A0) into D0. D0 should now hold the entire 16 bits of the
00001396                           302          *next OP CODE instruction to disassemble, EXCLUDING any immediate/absolute 
00001396                           303          *data that may be associated with the instruction.
00001396                           304          *Post increment addr, A0 will point to the start of next instruction or will 
00001396                           305          *point to the start of any immed/abso data with this current instruction
00001396  4280                     306          CLR.L   D0
00001398  3018                     307          MOVE.W  (A0)+,D0
0000139A                           308          *Copy the word data we just moved into D0 into D7. We are copying this data
0000139A                           309          *So we always have a copy of the WHOLE instruction somewhere
0000139A  4287                     310          CLR.L   D7
0000139C  3E00                     311          MOVE.W  D0,D7
0000139E                           312          *Now shift D0 to the right by 12 bit values, so that we can isolate the first
0000139E                           313          *four bits of the instruction. Once we have just the first four bits, we can
0000139E                           314          *begin to see which 'bucket'/category this instruction falls into. 
0000139E  E048                     315          LSR.W   #$08,D0 *The max we can shift at once is 8 bits...
000013A0  E848                     316          LSR.W   #$04,D0
000013A2                           317          *Now try to figure out what OP CODE this is using these 4 bits. Run down the
000013A2                           318          *list of buckets until we find which one this instruction falls into.
000013A2  4EB9 00001410            319          JSR     BUCKET_0000     * Start with 0000
000013A8  60C2                     320          BRA     GRAB_NEXT_OP    * Loop back
000013AA                           321  
000013AA                           322  *-----------------------------------------------------------        
000013AA                           323  * Question Prompts
000013AA                           324  *-----------------------------------------------------------        
000013AA  43F9 00001FE6            325  CONT_Q      LEA     QUES_CONT,A1
000013B0  303C 000E                326              MOVE    #14,D0
000013B4  4E4F                     327              TRAP    #15
000013B6  43F9 0000209A            328              LEA     CONT,A1     *Need to store Y/N
000013BC  303C 0002                329              MOVE    #2,D0
000013C0  4E4F                     330              TRAP    #15
000013C2  0C01 0001                331              CMPI.B  #01,D1
000013C6  6600 FD6C                332              BNE     INVALID1
000013CA  0C39 0059 0000209A       333              CMPI.B  #$59,CONT   *Checks for uppercase Y
000013D2  6600 0008                334              BNE     CHECK_Y
000013D6  3C3C 000F                335              MOVE    #MAX_LINE,D6    *Resets counter
000013DA  4E75                     336              RTS
000013DC  0C11 0079                337  CHECK_Y     CMPI.B  #$79,(A1)   *Checks for lowercase y
000013E0  6600 0008                338              BNE     CHECK_N
000013E4  3C3C 000F                339              MOVE    #MAX_LINE,D6    *Resets counter
000013E8  4E75                     340              RTS
000013EA  0C11 004E                341  CHECK_N     CMPI.B  #$4E,(A1)   *Checks for uppercase N
000013EE  6700 FC24                342              BEQ     loop_1
000013F2  0C11 006E                343              CMPI.B  #$6E,(A1)   *Checks for lowercase n
000013F6  6700 FC1C                344              BEQ     loop_1      
000013FA                           345  
000013FA  163C 0000                346  INV2        MOVE.B  #0,D3       *Reset bad flag
000013FE  303C 0000                347              MOVE    #0,D0       *Prints invalid command msg if not found
00001402  43F9 00002207            348              LEA     INV_MSG,A1
00001408  303C 000E                349              MOVE    #14,D0
0000140C  4E4F                     350              TRAP    #15
0000140E  609A                     351              BRA     CONT_Q
00001410                           352  
00001410                           353  *-----------------------------------------------------------        
00001410                           354  * Bucket 0000:
00001410                           355  * STARTS WITH 0000, ADDI | ANDI | EORI----------------------
00001410                           356  *                   BCHG(dynamic) | BCHG (static) | CMPI----
00001410                           357  *-----------------------------------------------------------
00001410                           358  BUCKET_0000
00001410  =00000000                359  BUCKET0000_BITS EQU $0
00001410  4281                     360          CLR.L   D1
00001412                           361          *Load the first 4 bits (really a byte) of BUCKET0 into D1
00001412  123C 0000                362          MOVE.B  #BUCKET0000_BITS,D1
00001416                           363          *Compare the first 4 bits of the CURRENT instruction with first 4 of BUCKET0. 
00001416                           364          *If equal, continue decoding. If not, branch to next bucket.
00001416  B200                     365          CMP.B   D0,D1
00001418  6600 02CE                366          BNE     BUCKET_0001
0000141C                           367  
0000141C                           368          *Test the 8th bit in this instruction, if it is 1, then it is a BCHG(dynamic) 
0000141C                           369          *The zbit will be 1 if the bit is 0, and 0 if the bit is 1. 
0000141C  3007                     370          MOVE.W  D7,D0   *Move the WHOLE instruction back to D0
0000141E  0800 0008                371          BTST.L  #$08,D0
00001422  6600 01A4                372          BNE     IS_BCHG_D  *If the zbit was 0 (the 8th bit is 1), branch to ISBCHG_D
00001426                           373          
00001426                           374          *Now we can check bits 11-8 in the instruction and branch to different op-codes
00001426                           375          *depending on what the bits equal, without ambiguity due to BCHG(dynamic)
00001426  E048                     376          LSR.W   #$08,D0 *Shift the first 8 bits into LSB position
00001428  0880 0004                377          BCLR.L  #$04,D0 *Set first 4 bits to 0, leaving only bits 11-8 of the instruction
0000142C  0880 0005                378          BCLR.L  #$05,D0
00001430  0880 0006                379          BCLR.L  #$06,D0
00001434  0880 0007                380          BCLR.L  #$07,D0
00001438                           381          
00001438                           382          *Perform compares with these 4 bits to see which specific instruction it is.
00001438  B03C 0006                383          CMP.B   #$06,D0 *Is this an ADDI?
0000143C  6700 0028                384          BEQ     IS_ADDI
00001440  B03C 0002                385          CMP.B   #$02,D0 *Is this an ANDI?
00001444  6700 0096                386          BEQ     IS_ANDI
00001448  B03C 000A                387          CMP.B   #$0A,D0 *Is this an EORI?
0000144C  6700 0104                388          BEQ     IS_EORI
00001450  B03C 0008                389          CMP.B   #$08,D0 *Is this a BCHG(static)?
00001454  6700 0200                390          BEQ     IS_BCHG_S
00001458  B03C 000C                391          CMP.B   #$0C,D0 *Is this a CMPI?
0000145C  6700 0214                392          BEQ     IS_CMPI
00001460                           393          
00001460                           394          *If we get through all of the compares without finding the specific instruction,
00001460                           395          *then this instruction is either not in our list of OP CODES to decode, or is an
00001460                           396          *invalid instruction/syntax.
00001460  4EF9 00001B1A            397          JMP     BADOPCODE   *jump to BADOPCODE, where i/o will take care of it.
00001466                           398          
00001466                           399          
00001466                           400  *Now we know this instruction is exactly ADDI, lets set everything up for EA.
00001466                           401  IS_ADDI
00001466                           402          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001466                           403          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001466  4281                     404          CLR.L   D1
00001468  3207                     405          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
0000146A  C27C 00C0                406          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000146E  EC09                     407          LSR.B   #$06,D1     *Shift the size bits into LSB
00001470                           408          
00001470  B23C 0003                409          CMP.B   #$03,D1     *Compare the size bits to $3
00001474  6700 06A4                410          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001478                           411          
00001478                           412          *Output 'ADDI' to console...
00001478  43F9 000020D8            413          LEA     ADDI,A1     *Loads ADDI into address register A1
0000147E  103C 000E                414          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001482  4E4F                     415          TRAP    #15         *Displays Message
00001484                           416          
00001484                           417          
00001484                           418          *Should have a valid ADDI op code. Set data up for EA.
00001484                           419          
00001484                           420          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001484  4282                     421          CLR.L   D2
00001486  3407                     422          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001488  C47C 003C                423          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
0000148C  E60A                     424          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000148E                           425                  
0000148E                           426          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000148E  4283                     427          CLR.L   D3
00001490  3607                     428          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001492  C67C 0007                429          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001496                           430          
00001496  4EF9 0000149C            431          JMP     EA_ADDI
0000149C                           432  
0000149C                           433  EA_ADDI
0000149C                           434          *Decode the ea bits of ADDI. Assuming D1 holds the size, D2 holds the EA mode,
0000149C                           435          *and D3 holds the EA register.
0000149C                           436          
0000149C                           437          *Determine how much data to read in, depending on the size of the operation
0000149C                           438          *output the size of the operation and the immediate data to console
0000149C  4EB9 000016EE            439          JSR     WrapperSizeImmediate
000014A2                           440          
000014A2                           441          *manually output a comma here...
000014A2  43F9 000021EB            442          LEA     Comma,A1        *Loads Comma into address register A1
000014A8  103C 000E                443          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000014AC  4E4F                     444          TRAP    #15             *Displays Message        
000014AE                           445          
000014AE                           446          *Determine which EA mode and thus Register/Mem Address this instruction used
000014AE  B43C 0000                447          CMP.B   #$00,D2
000014B2  6700 02BC                448          BEQ     DataRegMode *If EA mode is a data register, output that
000014B6                           449          
000014B6  B43C 0002                450          CMP.B   #$02,D2
000014BA  6700 02C4                451          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000014BE                           452          
000014BE  B43C 0003                453          CMP.B   #$03,D2
000014C2  6700 02CC                454          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000014C6                           455          
000014C6  B43C 0004                456          CMP.B   #$04,D2
000014CA  6700 02CE                457          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000014CE                           458          
000014CE  B43C 0007                459          CMP.B   #$07,D2
000014D2  6700 02D0                460          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000014D6                           461          
000014D6                           462          *If the ea mode isn't equal to any of these, it is an invalid EA
000014D6  4EF9 00001B2A            463          JMP     BADEACODE                               
000014DC                           464          
000014DC                           465  
000014DC                           466  *Now we know this instruction is exactly ANDI, lets set everything up for EA.
000014DC                           467  IS_ANDI
000014DC                           468          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
000014DC                           469          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
000014DC  4281                     470          CLR.L   D1
000014DE  3207                     471          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000014E0  C27C 00C0                472          AND.W   #$00C0,D1   *Mask out everything but the size bits
000014E4  EC09                     473          LSR.B   #$06,D1     *Shift the size bits into LSB
000014E6                           474          
000014E6  B23C 0003                475          CMP.B   #$03,D1     *Compare the size bits to $3
000014EA  6700 062E                476          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
000014EE                           477          
000014EE                           478          *Output 'ANDI' to console...
000014EE  43F9 000020DD            479          LEA     ANDI,A1     *Loads ANDI into address register A1
000014F4  103C 000E                480          MOVE.B  #14,D0      *Moves the number 14 into data register D0
000014F8  4E4F                     481          TRAP    #15         *Displays Message
000014FA                           482          
000014FA                           483          
000014FA                           484          *Should have a valid ANDI op code. Set data up for EA.
000014FA                           485          
000014FA                           486          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000014FA  4282                     487          CLR.L   D2
000014FC  3407                     488          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000014FE  C47C 003C                489          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001502  E60A                     490          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
00001504                           491                  
00001504                           492          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
00001504  4283                     493          CLR.L   D3
00001506  3607                     494          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001508  C67C 0007                495          AND.W   #$0007,D3   *Mask out everything but the EA register bits
0000150C                           496          
0000150C  4EF9 00001512            497          JMP     EA_ANDI
00001512                           498  
00001512                           499  EA_ANDI
00001512                           500          *Decode the ea bits of ANDI. Assuming D1 holds the size, D2 holds the EA mode,
00001512                           501          *and D3 holds the EA register.
00001512                           502          
00001512                           503          *Determine how much data to read in, depending on the size of the operation
00001512                           504          *output the size of the operation and the immediate data to console
00001512  4EB9 000016EE            505          JSR     WrapperSizeImmediate
00001518                           506          
00001518                           507          *manually output a comma here...
00001518  43F9 000021EB            508          LEA     Comma,A1        *Loads Comma into address register A1
0000151E  103C 000E                509          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001522  4E4F                     510          TRAP    #15             *Displays Message        
00001524                           511          
00001524                           512          *Determine which EA mode and thus Register/Mem Address this instruction used
00001524  B43C 0000                513          CMP.B   #$00,D2
00001528  6700 0246                514          BEQ     DataRegMode *If EA mode is a data register, output that
0000152C                           515          
0000152C  B43C 0002                516          CMP.B   #$02,D2
00001530  6700 024E                517          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001534                           518          
00001534  B43C 0003                519          CMP.B   #$03,D2
00001538  6700 0256                520          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
0000153C                           521          
0000153C  B43C 0004                522          CMP.B   #$04,D2
00001540  6700 0258                523          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001544                           524          
00001544  B43C 0007                525          CMP.B   #$07,D2
00001548  6700 025A                526          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
0000154C                           527          
0000154C                           528          *If the ea mode isn't equal to any of these, it is an invalid EA
0000154C  4EF9 00001B2A            529          JMP     BADEACODE
00001552                           530          
00001552                           531  
00001552                           532  *Now we know this instruction is exactly EORI, lets set everything up for EA.
00001552                           533  IS_EORI
00001552                           534          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001552                           535          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001552  4281                     536          CLR.L   D1
00001554  3207                     537          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001556  C27C 00C0                538          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000155A  EC09                     539          LSR.B   #$06,D1     *Shift the size bits into LSB
0000155C                           540          
0000155C  B23C 0003                541          CMP.B   #$03,D1     *Compare the size bits to $3
00001560  6700 05B8                542          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001564                           543          
00001564                           544          *Output 'EORI' to console...
00001564  43F9 000020E2            545          LEA     EORI,A1     *Loads EORI into address register A1
0000156A  103C 000E                546          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000156E  4E4F                     547          TRAP    #15         *Displays Message
00001570                           548          
00001570                           549          
00001570                           550          *Should have a valid EORI op code. Set data up for EA.
00001570                           551          
00001570                           552          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001570  4282                     553          CLR.L   D2
00001572  3407                     554          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001574  C47C 003C                555          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001578  E60A                     556          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000157A                           557                  
0000157A                           558          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000157A  4283                     559          CLR.L   D3
0000157C  3607                     560          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000157E  C67C 0007                561          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001582                           562          
00001582  4EF9 00001588            563          JMP     EA_EORI
00001588                           564  
00001588                           565  EA_EORI
00001588                           566          *Decode the ea bits of EORI. Assuming D1 holds the size, D2 holds the EA mode,
00001588                           567          *and D3 holds the EA register.
00001588                           568          
00001588                           569          *Determine how much data to read in, depending on the size of the operation
00001588                           570          *output the size of the operation and the immediate data to console
00001588  4EB9 000016EE            571          JSR     WrapperSizeImmediate
0000158E                           572          
0000158E                           573          *manually output a comma here...
0000158E  43F9 000021EB            574          LEA     Comma,A1        *Loads Comma into address register A1
00001594  103C 000E                575          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001598  4E4F                     576          TRAP    #15             *Displays Message        
0000159A                           577          
0000159A                           578          *Determine which EA mode and thus Register/Mem Address this instruction used
0000159A  B43C 0000                579          CMP.B   #$00,D2
0000159E  6700 01D0                580          BEQ     DataRegMode *If EA mode is a data register, output that
000015A2                           581          
000015A2  B43C 0002                582          CMP.B   #$02,D2
000015A6  6700 01D8                583          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000015AA                           584          
000015AA  B43C 0003                585          CMP.B   #$03,D2
000015AE  6700 01E0                586          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000015B2                           587          
000015B2  B43C 0004                588          CMP.B   #$04,D2
000015B6  6700 01E2                589          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000015BA                           590          
000015BA  B43C 0007                591          CMP.B   #$07,D2
000015BE  6700 01E4                592          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000015C2                           593          
000015C2                           594          *If the ea mode isn't equal to any of these, it is an invalid EA
000015C2  4EF9 00001B2A            595          JMP     BADEACODE
000015C8                           596  
000015C8                           597  
000015C8                           598  *Found a possible BCHG(dynamic) instruction. Verify its bit integrity and then set
000015C8                           599  * everything up for EA if is a legit instruction.
000015C8                           600  IS_BCHG_D
000015C8                           601          *Check bits 7 and 6, these should be 0 and 1. If not, this instruction is
000015C8                           602          *invalid, branch to BADOPCODE
000015C8  3007                     603          MOVE.W  D7,D0      *Move the WHOLE instruction back to D0
000015CA  0800 0007                604          BTST.L  #$07,D0
000015CE  6600 054A                605          BNE     BADOPCODE  *If the zbit was 0 (the 7th bit is 1), branch to BADOPCODE
000015D2  0800 0006                606          BTST.L  #$06,D0
000015D6  6700 0542                607          BEQ     BADOPCODE  *If the zbit was 1 (the 6th bit is 0), branch to BADOPCODE
000015DA                           608          
000015DA                           609          *Output 'BCHG' to console...
000015DA  43F9 000020E7            610          LEA     BCHG,A1         *Loads BCHG into address register A1
000015E0  103C 000E                611          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000015E4  4E4F                     612          TRAP    #15             *Displays Message
000015E6                           613                  
000015E6                           614                  
000015E6                           615          *Should have a valid BCHG op code. Set data up for EA.
000015E6                           616  
000015E6                           617          *Set D1 to the EA source register located in bits 11-9 of the instruction
000015E6  4281                     618          CLR.L   D1
000015E8  3207                     619          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
000015EA  C27C 0E00                620          AND.W   #$0E00,D1   *Mask out everything but the EA source register bits
000015EE  E009                     621          LSR.B   #$08,D1     *Shift the EA source register bits into LSB
000015F0  E209                     622          LSR.B   #$01,D1
000015F2                           623  
000015F2                           624          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
000015F2  4282                     625          CLR.L   D2
000015F4  3407                     626          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
000015F6  C47C 003C                627          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
000015FA  E60A                     628          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
000015FC                           629                  
000015FC                           630          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
000015FC  4283                     631          CLR.L   D3
000015FE  3607                     632          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
00001600  C67C 0007                633          AND.W   #$0007,D3   *Mask out everything but the EA register bits
00001604                           634  
00001604  4EF9 0000160A            635          JMP     EA_BCHG_D
0000160A                           636  
0000160A                           637  EA_BCHG_D
0000160A                           638          *Decode the ea bits of BCHG(dynamic). Assuming D1 holds the source register, 
0000160A                           639          *D2 holds the EA mode, and D3 holds the EA register.
0000160A                           640          
0000160A                           641          *output the source register to console, flag D6 with a 1 so we come back...
0000160A  48E7 0200                642          MOVEM.L  D6,-(SP)   *Push current contents of D6 into stack (line counter)
0000160E  1C3C 0001                643          MOVE.B  #$01,D6
00001612  4EB9 00001770            644          JSR     DataRegMode
00001618  4CDF 0040                645          MOVEM.L (SP)+,D6    *Pull current contents of stack back into D6
0000161C                           646          
0000161C                           647          *manually output a comma here...
0000161C  43F9 000021EB            648          LEA     Comma,A1        *Loads Comma into address register A1
00001622  103C 000E                649          MOVE.B  #14,D0          *Moves the number 14 into data register D0
00001626  4E4F                     650          TRAP    #15             *Displays Message
00001628                           651          
00001628                           652          *Determine which EA mode and thus Register/Mem Address this instruction used
00001628  B43C 0000                653          CMP.B   #$00,D2
0000162C  6700 0142                654          BEQ     DataRegMode *If EA mode is a data register, output that
00001630                           655          
00001630  B43C 0002                656          CMP.B   #$02,D2
00001634  6700 014A                657          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
00001638                           658          
00001638  B43C 0003                659          CMP.B   #$03,D2
0000163C  6700 0152                660          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
00001640                           661          
00001640  B43C 0004                662          CMP.B   #$04,D2
00001644  6700 0154                663          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
00001648                           664          
00001648  B43C 0007                665          CMP.B   #$07,D2
0000164C  6700 0156                666          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
00001650                           667          
00001650                           668          *If the ea mode isn't equal to any of these, it is an invalid EA
00001650  4EF9 00001B2A            669          JMP     BADEACODE
00001656                           670  
00001656                           671  
00001656                           672  *Now we know this instruction is exactly BCHG(static), lets set everything up for EA.
00001656                           673  IS_BCHG_S
00001656                           674          *TODO:Verify bits
00001656                           675  
00001656                           676          *Output 'BCHG' to console...
00001656  43F9 000020E7            677          LEA     BCHG,A1 *Loads FNDBCHG_S into address register A1
0000165C  103C 000E                678          MOVE.B  #14,D0  *Moves the number 14 into data register D0
00001660  4E4F                     679          TRAP    #15     *Displays Message
00001662                           680          
00001662                           681          *Should have a valid BCHG_S op code. Set data up for EA.
00001662                           682          *TODO:
00001662  163C 000E                683          MOVE.B  #14,D3
00001666  4EF9 0000166C            684          JMP     EA_BCHG_S
0000166C                           685  
0000166C                           686  EA_BCHG_S
0000166C  4EF9 00001B3E            687          JMP     THEEND  *For now just end
00001672                           688  
00001672                           689  
00001672                           690  *Now we know this instruction is exactly CMPI, lets set everything up for EA.
00001672                           691  IS_CMPI
00001672                           692          *Verify the size of this operation. If incorrect size (%11), then bad opcode!
00001672                           693          *Set D1 to the 'size' of the operation located in bits 7 and 6 of the instruction
00001672  4281                     694          CLR.L   D1
00001674  3207                     695          MOVE.W  D7,D1       *Move the WHOLE instruction to D1
00001676  C27C 00C0                696          AND.W   #$00C0,D1   *Mask out everything but the size bits
0000167A  EC09                     697          LSR.B   #$06,D1     *Shift the size bits into LSB
0000167C                           698          
0000167C  B23C 0003                699          CMP.B   #$03,D1     *Compare the size bits to $3
00001680  6700 0498                700          BEQ     BADOPCODE   *if equal, bad op code, size shouldn't be (%11)
00001684                           701          
00001684                           702          *Output 'CMPI' to console...
00001684  43F9 000020EC            703          LEA     CMPI,A1     *Loads CMPI into address register A1
0000168A  103C 000E                704          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000168E  4E4F                     705          TRAP    #15         *Displays Message
00001690                           706          
00001690                           707          
00001690                           708          *Should have a valid CMPI op code. Set data up for EA.
00001690                           709          
00001690                           710          *Set D2 to the EA mode of the operation located in bits 5-3 of the instruction
00001690  4282                     711          CLR.L   D2
00001692  3407                     712          MOVE.W  D7,D2       *Move the WHOLE instruction to D2
00001694  C47C 003C                713          AND.W   #$003C,D2   *Mask out everything but the EA mode bits
00001698  E60A                     714          LSR.B   #$03,D2     *Shift the EA mode bits into LSB
0000169A                           715                  
0000169A                           716          *Set D3 to the EA register of the operation located in bits 2-0 of the instruction
0000169A  4283                     717          CLR.L   D3
0000169C  3607                     718          MOVE.W  D7,D3       *Move the WHOLE instruction to D3
0000169E  C67C 0007                719          AND.W   #$0007,D3   *Mask out everything but the EA register bits
000016A2                           720          
000016A2  4EF9 000016A8            721          JMP     EA_CMPI
000016A8                           722  
000016A8                           723  EA_CMPI
000016A8                           724          *Decode the ea bits of CMPI. Assuming D1 holds the size, D2 holds the EA mode,
000016A8                           725          *and D3 holds the EA register.
000016A8                           726          
000016A8                           727          *Determine how much data to read in, depending on the size of the operation
000016A8                           728          *output the size of the operation and the immediate data to console
000016A8  4EB9 000016EE            729          JSR     WrapperSizeImmediate
000016AE                           730          
000016AE                           731          *manually output a comma here...
000016AE  43F9 000021EB            732          LEA     Comma,A1        *Loads Comma into address register A1
000016B4  103C 000E                733          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000016B8  4E4F                     734          TRAP    #15             *Displays Message
000016BA                           735          
000016BA                           736          *Determine which EA mode and thus Register/Mem Address this instruction used
000016BA  B43C 0000                737          CMP.B   #$00,D2
000016BE  6700 00B0                738          BEQ     DataRegMode *If EA mode is a data register, output that
000016C2                           739          
000016C2  B43C 0002                740          CMP.B   #$02,D2
000016C6  6700 00B8                741          BEQ     AddrIndirectMode  *If EA mode is an addr indirect, output that
000016CA                           742          
000016CA  B43C 0003                743          CMP.B   #$03,D2
000016CE  6700 00C0                744          BEQ     AddrIndirectPostMode    *If EA mode is an addr indirect postinc, output that
000016D2                           745          
000016D2  B43C 0004                746          CMP.B   #$04,D2
000016D6  6700 00C2                747          BEQ     AddrIndirectPreMode    *If EA mode is an addr indirect predec, output that
000016DA                           748          
000016DA  B43C 0007                749          CMP.B   #$07,D2
000016DE  6700 00C4                750          BEQ     AddrAbsoluteMode    *If EA mode is an addr absolute word/long, output that
000016E2                           751          
000016E2                           752          *If the ea mode isn't equal to any of these, it is an invalid EA
000016E2  4EF9 00001B2A            753          JMP     BADEACODE
000016E8                           754  
000016E8                           755          
000016E8                           756  *STARTS WITH 0001, MOVE.B-----------------------------------
000016E8                           757  BUCKET_0001
000016E8  =00000001                758  BUCKET0001_BITS EQU $1
000016E8                           759          
000016E8                           760          *some code...
000016E8                           761  
000016E8                           762  
000016E8                           763  *STARTS WITH 0010, MOVE.L-----------------------------------
000016E8                           764  BUCKET_0010
000016E8  =00000002                765  BUCKET0010_BITS EQU $2
000016E8                           766  
000016E8                           767          *some code...
000016E8                           768  
000016E8                           769  
000016E8                           770  *STARTS WITH 0011, MOVE.W-----------------------------------
000016E8                           771  BUCKET_0011
000016E8  =00000003                772  BUCKET0011_BITS EQU $3
000016E8                           773  
000016E8                           774          *some code...
000016E8                           775  
000016E8                           776  
000016E8                           777  *STARTS WITH 0100, MOVEM | MULS(L) | LEA | CLR | JSR | RTS--
000016E8                           778  BUCKET_0100
000016E8  =00000004                779  BUCKET0100_BITS EQU $4
000016E8                           780  
000016E8                           781          *some code...
000016E8                           782  
000016E8                           783  
000016E8                           784  *STARTS WITH 0101, SUBQ-------------------------------------
000016E8                           785  BUCKET_0101
000016E8  =00000005                786  BUCKET0101_BITS EQU $5
000016E8                           787  
000016E8                           788          *some code...
000016E8                           789  
000016E8                           790  
000016E8                           791  *STARTS WITH 0110, BCC--------------------------------------
000016E8                           792  BUCKET_0110
000016E8  =00000006                793  BUCKET0110_BITS EQU $6
000016E8                           794  
000016E8                           795          *some code...
000016E8                           796  
000016E8                           797  
000016E8                           798  *STARTS WITH 1000, DIVU-------------------------------------
000016E8                           799  BUCKET_1000
000016E8  =00000008                800  BUCKET1000_BITS EQU $8
000016E8                           801  
000016E8                           802          *some code...
000016E8                           803  
000016E8                           804  
000016E8                           805  *STARTS WITH 1001, SUBA-------------------------------------
000016E8                           806  BUCKET_1001
000016E8  =00000009                807  BUCKET1001_BITS EQU $9
000016E8                           808  
000016E8                           809          *some code...
000016E8                           810  
000016E8                           811  
000016E8                           812  *STARTS WITH 1011, EOR | CMP | CMPA-------------------------
000016E8                           813  BUCKET_1011
000016E8  =0000000B                814  BUCKET1011_BITS EQU $B
000016E8                           815  
000016E8                           816          *some code...
000016E8                           817  
000016E8                           818  
000016E8                           819  *STARTS WITH 1100, MULS(W) | AND----------------------------
000016E8                           820  BUCKET_1100
000016E8  =0000000C                821  BUCKET1100_BITS EQU $C
000016E8                           822  
000016E8                           823          *some code...
000016E8                           824  
000016E8                           825  
000016E8                           826  *STARTS WITH 1101, ADD | ADDA-------------------------------
000016E8                           827  BUCKET_1101
000016E8  =0000000D                828  BUCKET1101_BITS EQU $D
000016E8                           829  
000016E8                           830          *some code...
000016E8                           831  
000016E8                           832  
000016E8                           833  *STARTS WITH 1110, ASR(REGSHIFT) | ASR(MEMSHIFT)------------
000016E8                           834  *                  LSL(REGSHIFT) | LSL(MEMSHIFT)------------
000016E8                           835  *                  ROL/ROR(REGROTATE) | ROLS/ROR(MEMROTATE)-
000016E8                           836  BUCKET_1110
000016E8  =0000000E                837  BUCKET1110_BITS EQU $E     
000016E8                           838  
000016E8                           839          *some code...
000016E8                           840  
000016E8                           841  
000016E8                           842  *The given OP CODE doesn't fall into any buckets, this is an invalid opcode
000016E8                           843  *for this disassembler, jump to BADOPCODE and let I/O take care of it
000016E8  4EF9 00001B1A            844          JMP     BADOPCODE  
000016EE                           845          
000016EE                           846  
000016EE                           847  *-----------------------------------------------------------        
000016EE                           848  * EA operation size decoding functionality
000016EE                           849  *-----------------------------------------------------------   
000016EE                           850  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
000016EE                           851  WrapperSizeImmediate
000016EE  4284                     852          CLR.L   D4
000016F0                           853          *Depending on the EA Register, choose which size to decode
000016F0  B23C 0000                854          CMP.B   #$00,D1
000016F4  6700 0014                855          BEQ     ByteSizeImmediate
000016F8                           856          
000016F8  B23C 0001                857          CMP.B   #$01,D1
000016FC  6700 002E                858          BEQ     WordSizeImmediate
00001700                           859  
00001700  B23C 0002                860          CMP.B   #$02,D1
00001704  6700 0048                861          BEQ     LongSizeImmediate
00001708                           862          
00001708                           863  *Used to get back to what we were doing, after dealing with the specific size
00001708                           864  WrapperSizeImmediateEnd
00001708  4E75                     865          RTS
0000170A                           866          
0000170A                           867  ByteSizeImmediate
0000170A  3818                     868          MOVE.W  (A0)+,D4    *read in the next word, data is the last 2 chars of word
0000170C                           869          
0000170C                           870          *Output '.B' to console...
0000170C  43F9 000020F1            871          LEA     ByteSize,A1 *Loads ByteSize into address register A1
00001712  103C 000E                872          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001716  4E4F                     873          TRAP    #15         *Displays Message
00001718                           874          
00001718                           875          *Output '#$' just before the immediate data
00001718  43F9 000021F0            876          LEA     ShaBang,A1
0000171E  103C 000E                877          MOVE.B  #14,D0
00001722  4E4F                     878          TRAP    #15  
00001724                           879          
00001724                           880          *output the immediate data to console with the hex-ascii converter
00001724  4EB8 11E6                881          JSR     HEXASCII
00001728                           882                  
00001728  4EF8 1708                883          JMP     WrapperSizeImmediateEnd
0000172C                           884                  
0000172C                           885  WordSizeImmediate
0000172C  3818                     886          MOVE.W  (A0)+,D4    *read in next word, data is that word
0000172E                           887          
0000172E                           888          *Output '.W' to console...
0000172E  43F9 000020F8            889          LEA     WordSize,A1 *Loads WordSize into address register A1
00001734  103C 000E                890          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001738  4E4F                     891          TRAP    #15         *Displays Message
0000173A                           892          
0000173A                           893          *Output '#$' just before the immediate data
0000173A  43F9 000021F0            894          LEA     ShaBang,A1
00001740  103C 000E                895          MOVE.B  #14,D0
00001744  4E4F                     896          TRAP    #15  
00001746                           897          
00001746                           898          *output the immediate data to console with the hex-ascii converter
00001746  4EB8 11E6                899          JSR     HEXASCII
0000174A                           900          
0000174A  4EF8 1708                901          JMP     WrapperSizeImmediateEnd
0000174E                           902                  
0000174E                           903  LongSizeImmediate
0000174E  2818                     904          MOVE.L  (A0)+,D4    *read in next two words, data is those two words
00001750                           905          
00001750                           906          *Output '.L' to console...
00001750  43F9 000020FF            907          LEA     LongSize,A1 *Loads LongSize into address register A1
00001756  103C 000E                908          MOVE.B  #14,D0      *Moves the number 14 into data register D0
0000175A  4E4F                     909          TRAP    #15         *Displays Message
0000175C                           910          
0000175C                           911          *Output '#$' just before the immediate data
0000175C  43F9 000021F0            912          LEA     ShaBang,A1
00001762  103C 000E                913          MOVE.B  #14,D0
00001766  4E4F                     914          TRAP    #15  
00001768                           915          
00001768                           916          *output the immediate data to console with the hex-ascii converter
00001768  4EB8 11E6                917          JSR     HEXASCII
0000176C                           918          
0000176C  4EF8 1708                919          JMP     WrapperSizeImmediateEnd
00001770                           920  
00001770                           921  
00001770                           922  *-----------------------------------------------------------        
00001770                           923  * EA Mode/EA Register decoding functionality
00001770                           924  *-----------------------------------------------------------        
00001770                           925  DataRegMode
00001770                           926          *Depending on the EA Register, output a different register number
00001770  4EB9 000017AE            927          JSR     WrapperDataReg        
00001776                           928          
00001776                           929          *if this was called for a destination decoding then we are done decoding this        
00001776                           930          *instruction, go get the next instruction
00001776  BC3C 0001                931          CMP.B   #$01,D6
0000177A  6600 FBF0                932          BNE     GRAB_NEXT_OP
0000177E                           933          
0000177E                           934          *else this was a source decoding, rts back to we can keep decoding
0000177E  4E75                     935          RTS
00001780                           936  
00001780                           937  AddrDirectMode
00001780                           938          *some code...
00001780                           939  
00001780                           940  AddrIndirectMode
00001780                           941          *Depending on the EA Register, output a different register number
00001780  4EB9 00001870            942          JSR     WrapperAddrIndirect
00001786                           943                          
00001786                           944          *if this was called for a destination decoding then we are done decoding this        
00001786                           945          *instruction, go get the next instruction
00001786  BC3C 0001                946          CMP.B   #$01,D6
0000178A  6600 FBE0                947          BNE     GRAB_NEXT_OP
0000178E                           948          
0000178E                           949          *else this was a source decoding, rts back to we can keep decoding
0000178E  4E75                     950          RTS
00001790                           951  
00001790                           952  AddrIndirectPostMode
00001790                           953          *Depending on the EA Register, output a different register number
00001790  4EB9 00001932            954          JSR     WrapperAddrIndirectPost
00001796                           955  
00001796                           956          *need to read some flag, if this was called from a source EA decoding then jmp to 
00001796                           957          *some wrapper (i'll define later)
00001796                           958          
00001796                           959          *else this was a destination EA decoding, we can just go get the next instruction
00001796                           960          *since there is no more decoding to do for the current instruction
00001796  4EF8 136C                961          JMP     GRAB_NEXT_OP
0000179A                           962  
0000179A                           963  AddrIndirectPreMode
0000179A                           964          *Depending on the EA Register, output a different register number
0000179A  4EB9 000019F4            965          JSR     WrapperAddrIndirectPre
000017A0                           966  
000017A0                           967          *need to read some flag, if this was called from a source EA decoding then jmp to 
000017A0                           968          *some wrapper (i'll define later)
000017A0                           969          
000017A0                           970          *else this was a destination EA decoding, we can just go get the next instruction
000017A0                           971          *since there is no more decoding to do for the current instruction
000017A0  4EF8 136C                972          JMP     GRAB_NEXT_OP
000017A4                           973  
000017A4                           974  AddrAbsoluteMode
000017A4                           975          *Depending on the EA Register, output a different register number
000017A4  4EB9 00001AB6            976          JSR     WrapperAddrAbsolute        
000017AA                           977  
000017AA                           978          *need to read some flag, if this was called from a source EA decoding then jmp to 
000017AA                           979          *some wrapper (i'll define later)
000017AA                           980          
000017AA                           981          *else this was a destination EA decoding, we can just go get the next instruction
000017AA                           982          *since there is no more decoding to do for the current instruction
000017AA  4EF8 136C                983          JMP     GRAB_NEXT_OP
000017AE                           984          
000017AE                           985  ImmediateDataMode
000017AE                           986          *some code        
000017AE                           987          
000017AE                           988          
000017AE                           989  *-----------------------------------------------------------        
000017AE                           990  * Output logic for all Data Registers (0-7)
000017AE                           991  *-----------------------------------------------------------
000017AE                           992  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000017AE                           993  WrapperDataReg
000017AE                           994          *Depending on the EA destination register, output a different register number
000017AE  B63C 0000                995          CMP.B   #$00,D3
000017B2  6700 003C                996          BEQ     DataReg0
000017B6                           997          
000017B6  B63C 0001                998          CMP.B   #$01,D3
000017BA  6700 0044                999          BEQ     DataReg1
000017BE                          1000          
000017BE  B63C 0002               1001          CMP.B   #$02,D3
000017C2  6700 004C               1002          BEQ     DataReg2
000017C6                          1003          
000017C6  B63C 0003               1004          CMP.B   #$03,D3
000017CA  6700 0054               1005          BEQ     DataReg3
000017CE                          1006          
000017CE  B63C 0004               1007          CMP.B   #$04,D3
000017D2  6700 005C               1008          BEQ     DataReg4
000017D6                          1009          
000017D6  B63C 0005               1010          CMP.B   #$05,D3
000017DA  6700 0064               1011          BEQ     DataReg5
000017DE                          1012          
000017DE  B63C 0006               1013          CMP.B   #$06,D3
000017E2  6700 006C               1014          BEQ     DataReg6
000017E6                          1015          
000017E6  B63C 0007               1016          CMP.B   #$07,D3
000017EA  6700 0074               1017          BEQ     DataReg7        
000017EE                          1018  
000017EE                          1019  *Used to get back to 'DataRegMode', after dealing with the specific register
000017EE                          1020  WrapperDataRegEnd
000017EE  4E75                    1021          RTS
000017F0                          1022  
000017F0                          1023  DataReg0
000017F0                          1024          *Output the specific data register...
000017F0  43F9 00002106           1025          LEA     OutDataReg0,A1  *Loads OutDataReg0 into address register A1
000017F6  103C 000E               1026          MOVE.B  #14,D0          *Moves the number 14 into data register D0
000017FA  4E4F                    1027          TRAP    #15             *Displays Message   
000017FC                          1028          
000017FC  4EF8 17EE               1029          JMP     WrapperDataRegEnd
00001800                          1030  
00001800                          1031  DataReg1
00001800  43F9 0000210B           1032          LEA     OutDataReg1,A1
00001806  103C 000E               1033          MOVE.B  #14,D0
0000180A  4E4F                    1034          TRAP    #15
0000180C                          1035          
0000180C  4EF8 17EE               1036          JMP     WrapperDataRegEnd
00001810                          1037  
00001810                          1038  DataReg2
00001810  43F9 00002110           1039          LEA     OutDataReg2,A1
00001816  103C 000E               1040          MOVE.B  #14,D0
0000181A  4E4F                    1041          TRAP    #15
0000181C                          1042  
0000181C  4EF8 17EE               1043          JMP     WrapperDataRegEnd
00001820                          1044      
00001820                          1045  DataReg3
00001820  43F9 00002115           1046          LEA     OutDataReg3,A1
00001826  103C 000E               1047          MOVE.B  #14,D0
0000182A  4E4F                    1048          TRAP    #15
0000182C                          1049  
0000182C  4EF8 17EE               1050          JMP     WrapperDataRegEnd
00001830                          1051          
00001830                          1052  DataReg4
00001830  43F9 0000211A           1053          LEA     OutDataReg4,A1
00001836  103C 000E               1054          MOVE.B  #14,D0
0000183A  4E4F                    1055          TRAP    #15
0000183C                          1056  
0000183C  4EF8 17EE               1057          JMP     WrapperDataRegEnd
00001840                          1058                 
00001840                          1059  DataReg5
00001840  43F9 0000211F           1060          LEA     OutDataReg5,A1
00001846  103C 000E               1061          MOVE.B  #14,D0
0000184A  4E4F                    1062          TRAP    #15
0000184C                          1063  
0000184C  4EF8 17EE               1064          JMP     WrapperDataRegEnd
00001850                          1065          
00001850                          1066  DataReg6
00001850  43F9 00002124           1067          LEA     OutDataReg6,A1 A1
00001856  103C 000E               1068          MOVE.B  #14,D0
0000185A  4E4F                    1069          TRAP    #15
0000185C                          1070  
0000185C  4EF8 17EE               1071          JMP     WrapperDataRegEnd
00001860                          1072          
00001860                          1073  DataReg7
00001860  43F9 00002129           1074          LEA     OutDataReg7,A1
00001866  103C 000E               1075          MOVE.B  #14,D0
0000186A  4E4F                    1076          TRAP    #15
0000186C                          1077          
0000186C  4EF8 17EE               1078          JMP     WrapperDataRegEnd
00001870                          1079  
00001870                          1080  
00001870                          1081  *-----------------------------------------------------------        
00001870                          1082  * Output logic for all Address Indirect Registers (0-7)
00001870                          1083  *-----------------------------------------------------------     
00001870                          1084  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001870                          1085  WrapperAddrIndirect
00001870                          1086          *Depending on the EA Register, output a different register number
00001870  B63C 0000               1087          CMP.B   #$00,D3
00001874  6700 003C               1088          BEQ     AddrIndReg0
00001878                          1089          
00001878  B63C 0001               1090          CMP.B   #$01,D3
0000187C  6700 0044               1091          BEQ     AddrIndReg1
00001880                          1092          
00001880  B63C 0002               1093          CMP.B   #$02,D3
00001884  6700 004C               1094          BEQ     AddrIndReg2
00001888                          1095          
00001888  B63C 0003               1096          CMP.B   #$03,D3
0000188C  6700 0054               1097          BEQ     AddrIndReg3
00001890                          1098          
00001890  B63C 0004               1099          CMP.B   #$04,D3
00001894  6700 005C               1100          BEQ     AddrIndReg4
00001898                          1101          
00001898  B63C 0005               1102          CMP.B   #$05,D3
0000189C  6700 0064               1103          BEQ     AddrIndReg5
000018A0                          1104          
000018A0  B63C 0006               1105          CMP.B   #$06,D3
000018A4  6700 006C               1106          BEQ     AddrIndReg6
000018A8                          1107          
000018A8  B63C 0007               1108          CMP.B   #$07,D3
000018AC  6700 0074               1109          BEQ     AddrIndReg7
000018B0                          1110  
000018B0                          1111  *Used to get back to 'AddrIndirectMode', after dealing with the specific register
000018B0                          1112  WrapperAddrIndirectEnd
000018B0  4E75                    1113          RTS        
000018B2                          1114  
000018B2                          1115  AddrIndReg0
000018B2                          1116          *Output the specific address indirect register...
000018B2  43F9 0000212E           1117          LEA     OutAddrIndReg0,A1   *Loads AddrIndReg0 into address register A1
000018B8  103C 000E               1118          MOVE.B  #14,D0              *Moves the number 14 into data register D0
000018BC  4E4F                    1119          TRAP    #15                 *Displays Message        
000018BE                          1120          
000018BE  4EF8 18B0               1121          JMP     WrapperAddrIndirectEnd
000018C2                          1122  
000018C2                          1123  AddrIndReg1
000018C2  43F9 00002135           1124          LEA     OutAddrIndReg1,A1
000018C8  103C 000E               1125          MOVE.B  #14,D0
000018CC  4E4F                    1126          TRAP    #15
000018CE                          1127          
000018CE  4EF8 18B0               1128          JMP     WrapperAddrIndirectEnd
000018D2                          1129  
000018D2                          1130  AddrIndReg2
000018D2  43F9 0000213C           1131          LEA     OutAddrIndReg2,A1
000018D8  103C 000E               1132          MOVE.B  #14,D0
000018DC  4E4F                    1133          TRAP    #15
000018DE                          1134          
000018DE  4EF8 18B0               1135          JMP     WrapperAddrIndirectEnd
000018E2                          1136  
000018E2                          1137  AddrIndReg3
000018E2  43F9 00002143           1138          LEA     OutAddrIndReg3,A1
000018E8  103C 000E               1139          MOVE.B  #14,D0
000018EC  4E4F                    1140          TRAP    #15
000018EE                          1141          
000018EE  4EF8 18B0               1142          JMP     WrapperAddrIndirectEnd
000018F2                          1143  
000018F2                          1144  AddrIndReg4
000018F2  43F9 0000214A           1145          LEA     OutAddrIndReg4,A1
000018F8  103C 000E               1146          MOVE.B  #14,D0
000018FC  4E4F                    1147          TRAP    #15
000018FE                          1148          
000018FE  4EF8 18B0               1149          JMP     WrapperAddrIndirectEnd
00001902                          1150  
00001902                          1151  AddrIndReg5
00001902  43F9 00002151           1152          LEA     OutAddrIndReg5,A1
00001908  103C 000E               1153          MOVE.B  #14,D0
0000190C  4E4F                    1154          TRAP    #15
0000190E                          1155          
0000190E  4EF8 18B0               1156          JMP     WrapperAddrIndirectEnd
00001912                          1157  
00001912                          1158  AddrIndReg6
00001912  43F9 00002158           1159          LEA     OutAddrIndReg6,A1
00001918  103C 000E               1160          MOVE.B  #14,D0
0000191C  4E4F                    1161          TRAP    #15
0000191E                          1162          
0000191E  4EF8 18B0               1163          JMP     WrapperAddrIndirectEnd
00001922                          1164  
00001922                          1165  AddrIndReg7
00001922  43F9 0000215F           1166          LEA     OutAddrIndReg7,A1
00001928  103C 000E               1167          MOVE.B  #14,D0
0000192C  4E4F                    1168          TRAP    #15
0000192E                          1169          
0000192E  4EF8 18B0               1170          JMP     WrapperAddrIndirectEnd
00001932                          1171          
00001932                          1172          
00001932                          1173  *-----------------------------------------------------------        
00001932                          1174  * Output logic for all Address Indirect Post Increment Registers (0-7)
00001932                          1175  *-----------------------------------------------------------     
00001932                          1176  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
00001932                          1177  WrapperAddrIndirectPost
00001932                          1178          *Depending on the EA Register, output a different register number
00001932  B63C 0000               1179          CMP.B   #$00,D3
00001936  6700 003C               1180          BEQ     AddrIndPoReg0
0000193A                          1181          
0000193A  B63C 0001               1182          CMP.B   #$01,D3
0000193E  6700 0044               1183          BEQ     AddrIndPoReg1
00001942                          1184          
00001942  B63C 0002               1185          CMP.B   #$02,D3
00001946  6700 004C               1186          BEQ     AddrIndPoReg2
0000194A                          1187          
0000194A  B63C 0003               1188          CMP.B   #$03,D3
0000194E  6700 0054               1189          BEQ     AddrIndPoReg3
00001952                          1190          
00001952  B63C 0004               1191          CMP.B   #$04,D3
00001956  6700 005C               1192          BEQ     AddrIndPoReg4
0000195A                          1193          
0000195A  B63C 0005               1194          CMP.B   #$05,D3
0000195E  6700 0064               1195          BEQ     AddrIndPoReg5
00001962                          1196          
00001962  B63C 0006               1197          CMP.B   #$06,D3
00001966  6700 006C               1198          BEQ     AddrIndPoReg6
0000196A                          1199          
0000196A  B63C 0007               1200          CMP.B   #$07,D3
0000196E  6700 0074               1201          BEQ     AddrIndPoReg7
00001972                          1202  
00001972                          1203  *Used to get back to 'AddrIndirectPostMode', after dealing with the specific register
00001972                          1204  WrapperAddrIndirectPostEnd
00001972  4E75                    1205          RTS        
00001974                          1206  
00001974                          1207  AddrIndPoReg0
00001974                          1208          *Output the specific address indirect post register...
00001974  43F9 00002166           1209          LEA     OutAddrIndPoReg0,A1 *Loads AddrIndPoReg0 into address register A1
0000197A  103C 000E               1210          MOVE.B  #14,D0              *Moves the number 14 into data register D0
0000197E  4E4F                    1211          TRAP    #15                 *Displays Message        
00001980                          1212          
00001980  4EF8 1972               1213          JMP     WrapperAddrIndirectPostEnd
00001984                          1214  
00001984                          1215  AddrIndPoReg1
00001984  43F9 0000216E           1216          LEA     OutAddrIndPoReg1,A1
0000198A  103C 000E               1217          MOVE.B  #14,D0
0000198E  4E4F                    1218          TRAP    #15
00001990                          1219          
00001990  4EF8 1972               1220          JMP     WrapperAddrIndirectPostEnd
00001994                          1221  
00001994                          1222  AddrIndPoReg2
00001994  43F9 00002176           1223          LEA     OutAddrIndPoReg2,A1
0000199A  103C 000E               1224          MOVE.B  #14,D0
0000199E  4E4F                    1225          TRAP    #15
000019A0                          1226          
000019A0  4EF8 1972               1227          JMP     WrapperAddrIndirectPostEnd
000019A4                          1228  
000019A4                          1229  AddrIndPoReg3
000019A4  43F9 0000217E           1230          LEA     OutAddrIndPoReg3,A1
000019AA  103C 000E               1231          MOVE.B  #14,D0
000019AE  4E4F                    1232          TRAP    #15
000019B0                          1233          
000019B0  4EF8 1972               1234          JMP     WrapperAddrIndirectPostEnd
000019B4                          1235  
000019B4                          1236  AddrIndPoReg4
000019B4  43F9 00002186           1237          LEA     OutAddrIndPoReg4,A1
000019BA  103C 000E               1238          MOVE.B  #14,D0
000019BE  4E4F                    1239          TRAP    #15
000019C0                          1240          
000019C0  4EF8 1972               1241          JMP     WrapperAddrIndirectPostEnd
000019C4                          1242  
000019C4                          1243  AddrIndPoReg5
000019C4  43F9 0000218E           1244          LEA     OutAddrIndPoReg5,A1
000019CA  103C 000E               1245          MOVE.B  #14,D0
000019CE  4E4F                    1246          TRAP    #15
000019D0                          1247          
000019D0  4EF8 1972               1248          JMP     WrapperAddrIndirectPostEnd
000019D4                          1249  
000019D4                          1250  AddrIndPoReg6
000019D4  43F9 00002196           1251          LEA     OutAddrIndPoReg6,A1
000019DA  103C 000E               1252          MOVE.B  #14,D0
000019DE  4E4F                    1253          TRAP    #15
000019E0                          1254          
000019E0  4EF8 1972               1255          JMP     WrapperAddrIndirectPostEnd
000019E4                          1256  
000019E4                          1257  AddrIndPoReg7
000019E4  43F9 0000219E           1258          LEA     OutAddrIndPoReg7,A1
000019EA  103C 000E               1259          MOVE.B  #14,D0
000019EE  4E4F                    1260          TRAP    #15
000019F0                          1261          
000019F0  4EF8 1972               1262          JMP     WrapperAddrIndirectPostEnd
000019F4                          1263  
000019F4                          1264  
000019F4                          1265  *-----------------------------------------------------------        
000019F4                          1266  * Output logic for all Address Indirect Pre Decrement Registers (0-7)
000019F4                          1267  *-----------------------------------------------------------     
000019F4                          1268  *'Wrapper' func used for outputing the correct register. Used to do the nasty branching
000019F4                          1269  WrapperAddrIndirectPre
000019F4                          1270          *Depending on the EA Register, output a different register number
000019F4  B63C 0000               1271          CMP.B   #$00,D3
000019F8  6700 003C               1272          BEQ     AddrIndPrReg0
000019FC                          1273          
000019FC  B63C 0001               1274          CMP.B   #$01,D3
00001A00  6700 0044               1275          BEQ     AddrIndPrReg1
00001A04                          1276          
00001A04  B63C 0002               1277          CMP.B   #$02,D3
00001A08  6700 004C               1278          BEQ     AddrIndPrReg2
00001A0C                          1279          
00001A0C  B63C 0003               1280          CMP.B   #$03,D3
00001A10  6700 0054               1281          BEQ     AddrIndPrReg3
00001A14                          1282          
00001A14  B63C 0004               1283          CMP.B   #$04,D3
00001A18  6700 005C               1284          BEQ     AddrIndPrReg4
00001A1C                          1285          
00001A1C  B63C 0005               1286          CMP.B   #$05,D3
00001A20  6700 0064               1287          BEQ     AddrIndPrReg5
00001A24                          1288          
00001A24  B63C 0006               1289          CMP.B   #$06,D3
00001A28  6700 006C               1290          BEQ     AddrIndPrReg6
00001A2C                          1291          
00001A2C  B63C 0007               1292          CMP.B   #$07,D3
00001A30  6700 0074               1293          BEQ     AddrIndPrReg7
00001A34                          1294  
00001A34                          1295  *Used to get back to 'AddrIndirectPreMode', after dealing with the specific register
00001A34                          1296  WrapperAddrIndirectPreEnd
00001A34  4E75                    1297          RTS        
00001A36                          1298  
00001A36                          1299  AddrIndPrReg0
00001A36                          1300          *Output the specific address indirect post register...
00001A36  43F9 000021A6           1301          LEA     OutAddrIndPrReg0,A1 *Loads AddrIndPrReg0 into address register A1
00001A3C  103C 000E               1302          MOVE.B  #14,D0              *Moves the number 14 into data register D0
00001A40  4E4F                    1303          TRAP    #15                 *Displays Message        
00001A42                          1304          
00001A42  4EF8 1A34               1305          JMP     WrapperAddrIndirectPreEnd
00001A46                          1306  
00001A46                          1307  AddrIndPrReg1
00001A46  43F9 000021AE           1308          LEA     OutAddrIndPrReg1,A1
00001A4C  103C 000E               1309          MOVE.B  #14,D0
00001A50  4E4F                    1310          TRAP    #15
00001A52                          1311          
00001A52  4EF8 1A34               1312          JMP     WrapperAddrIndirectPreEnd
00001A56                          1313  
00001A56                          1314  AddrIndPrReg2
00001A56  43F9 000021B6           1315          LEA     OutAddrIndPrReg2,A1
00001A5C  103C 000E               1316          MOVE.B  #14,D0
00001A60  4E4F                    1317          TRAP    #15
00001A62                          1318          
00001A62  4EF8 1A34               1319          JMP     WrapperAddrIndirectPreEnd
00001A66                          1320  
00001A66                          1321  AddrIndPrReg3
00001A66  43F9 000021BE           1322          LEA     OutAddrIndPrReg3,A1
00001A6C  103C 000E               1323          MOVE.B  #14,D0
00001A70  4E4F                    1324          TRAP    #15
00001A72                          1325          
00001A72  4EF8 1A34               1326          JMP     WrapperAddrIndirectPreEnd
00001A76                          1327  
00001A76                          1328  AddrIndPrReg4
00001A76  43F9 000021C6           1329          LEA     OutAddrIndPrReg4,A1
00001A7C  103C 000E               1330          MOVE.B  #14,D0
00001A80  4E4F                    1331          TRAP    #15
00001A82                          1332          
00001A82  4EF8 1A34               1333          JMP     WrapperAddrIndirectPreEnd
00001A86                          1334  
00001A86                          1335  AddrIndPrReg5
00001A86  43F9 000021CE           1336          LEA     OutAddrIndPrReg5,A1
00001A8C  103C 000E               1337          MOVE.B  #14,D0
00001A90  4E4F                    1338          TRAP    #15
00001A92                          1339          
00001A92  4EF8 1A34               1340          JMP     WrapperAddrIndirectPreEnd
00001A96                          1341  
00001A96                          1342  AddrIndPrReg6
00001A96  43F9 000021D6           1343          LEA     OutAddrIndPrReg6,A1
00001A9C  103C 000E               1344          MOVE.B  #14,D0
00001AA0  4E4F                    1345          TRAP    #15
00001AA2                          1346          
00001AA2  4EF8 1A34               1347          JMP     WrapperAddrIndirectPreEnd
00001AA6                          1348  
00001AA6                          1349  AddrIndPrReg7
00001AA6  43F9 000021DE           1350          LEA     OutAddrIndPrReg7,A1
00001AAC  103C 000E               1351          MOVE.B  #14,D0
00001AB0  4E4F                    1352          TRAP    #15
00001AB2                          1353          
00001AB2  4EF8 1A34               1354          JMP     WrapperAddrIndirectPreEnd
00001AB6                          1355  
00001AB6                          1356  
00001AB6                          1357  *-----------------------------------------------------------        
00001AB6                          1358  * Output logic for absolute memory addressing (0-7)
00001AB6                          1359  *-----------------------------------------------------------     
00001AB6                          1360  *'Wrapper' func used for all size decoding. Used to do the nasty branching for diff sizes
00001AB6                          1361  WrapperAddrAbsolute
00001AB6  4284                    1362          CLR.L   D4
00001AB8                          1363          *Depending on the EA Register, choose which size to decode
00001AB8  B63C 0000               1364          CMP.B   #$00,D3
00001ABC  6700 000C               1365          BEQ     WordSizeAbsolute
00001AC0                          1366  
00001AC0  B63C 0001               1367          CMP.B   #$01,D3
00001AC4  6700 002C               1368          BEQ     LongSizeAbsolute
00001AC8                          1369          
00001AC8                          1370  *Used to get back to 'AddrAbsoluteMode', after dealing with the specific register
00001AC8                          1371  WrapperAddrAbsoluteEnd
00001AC8  4E75                    1372          RTS
00001ACA                          1373  
00001ACA                          1374  WordSizeAbsolute        
00001ACA  3818                    1375          MOVE.W  (A0)+,D4    *read in next word, data is that word
00001ACC                          1376          
00001ACC                          1377          *Move #$01 into D1 to specify this as a word, used for hextoascii conversion...
00001ACC  4281                    1378          CLR.L   D1
00001ACE  123C 0001               1379          MOVE.B  #$01,D1     
00001AD2                          1380              
00001AD2                          1381          *Output ',$' just after source operand
00001AD2  43F9 000021F3           1382          LEA     Bang,A1
00001AD8  103C 000E               1383          MOVE.B  #14,D0
00001ADC  4E4F                    1384          TRAP    #15
00001ADE                          1385              
00001ADE                          1386          *output the absolute mem address to console with the hex-ascii converter
00001ADE  4EB8 11E6               1387          JSR     HEXASCII
00001AE2                          1388          
00001AE2                          1389          *Print a new line, since this should be the last piece of data for an instruction
00001AE2  43F9 000021ED           1390          LEA     NewLine,A1
00001AE8  103C 000E               1391          MOVE.B  #14,D0
00001AEC  4E4F                    1392          TRAP    #15
00001AEE                          1393          
00001AEE  4EF8 1AC8               1394          JMP     WrapperAddrAbsoluteEnd
00001AF2                          1395  
00001AF2                          1396  LongSizeAbsolute
00001AF2  2818                    1397          MOVE.L  (A0)+,D4    *read in next long, data is that long
00001AF4                          1398                  
00001AF4                          1399          *Move #$10 into D1 to specify this as a long, used for hextoascii conversion...
00001AF4  4281                    1400          CLR.L   D1
00001AF6  123C 0010               1401          MOVE.B  #$10,D1
00001AFA                          1402                  
00001AFA                          1403          *Output ',$' just after source operand
00001AFA  43F9 000021F3           1404          LEA     Bang,A1
00001B00  103C 000E               1405          MOVE.B  #14,D0
00001B04  4E4F                    1406          TRAP    #15  
00001B06                          1407          
00001B06                          1408          *output the absolute mem address to console with the hex-ascii converter
00001B06  4EB8 11E6               1409          JSR     HEXASCII
00001B0A                          1410          
00001B0A                          1411          *Print a new line, since this should be the last piece of data for an instruction
00001B0A  43F9 000021ED           1412          LEA     NewLine,A1
00001B10  103C 000E               1413          MOVE.B  #14,D0
00001B14  4E4F                    1414          TRAP    #15
00001B16                          1415  
00001B16  4EF8 1AC8               1416          JMP     WrapperAddrAbsoluteEnd
00001B1A                          1417          
00001B1A                          1418  
00001B1A                          1419  *-----------------------------------------------------------        
00001B1A                          1420  * Current handling of bad op/ea codes. Should be revisited.
00001B1A                          1421  *----------------------------------------------------------- 
00001B1A                          1422  BADOPCODE
00001B1A                          1423          *We found a bad op code, output some error to the screen, jump to the 
00001B1A                          1424          *next instruction in memory.
00001B1A                          1425          *NOTE: IF THIS INSTRUCTION HAD IMMEDIATE OR ABSOLUTE DATA ATTACHED TO IT,
00001B1A                          1426          *THEN WE WILL NEED SOME WAY TO FIGURE THAT OUT AND READ THROUGH THAT DATA.
00001B1A                          1427          *OTHERWISE, THE NEXT OP WILL TRY TO TREAT THAT IMMEDIATE/ABSOULTE DATA AS
00001B1A                          1428          *A LEGIT INSTRUCTION, NOT GARBAGE!!!
00001B1A                          1429          *i/o and error message code...
00001B1A  43F9 000021FE           1430          LEA     BADOPMSG,A1 *Loads BADOPMSG into address register A1        
00001B20  103C 000E               1431          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001B24  4E4F                    1432          TRAP    #15         *Displays Message
00001B26  4EF8 136C               1433          JMP     GRAB_NEXT_OP
00001B2A                          1434                  
00001B2A                          1435  BADEACODE
00001B2A                          1436          *We found a bad ea code, output some error to the screen, jump to the
00001B2A                          1437          *next instruction in memory.
00001B2A                          1438          *NOTE: WE SHOULDN'T HAVE TO WORRY ABOUT GARBAGE IMMEDAIATE/ABSOLUTE DATA
00001B2A                          1439          *HERE, EACH EA FUNC SHOULD HAVE TAKEN CARE OF THAT BEFORE JUMPIN TO THIS FUNC        
00001B2A  43F9 000021F5           1440          LEA     BADEAMSG,A1 *Loads BADEAMSG into address register A1        
00001B30  103C 000E               1441          MOVE.B  #14,D0      *Moves the number 14 into data register D0
00001B34  4E4F                    1442          TRAP    #15         *Displays Message
00001B36  4EF8 136C               1443          JMP     GRAB_NEXT_OP
00001B3A                          1444          
00001B3A                          1445          
00001B3A                          1446  *-----------------------------------------------------------        
00001B3A                          1447  * End of Disassembler
00001B3A                          1448  *-----------------------------------------------------------    
00001B3A                          1449  
00001B3A  4E72 2700               1450  DONE    STOP    #$2700  *What does this do? Why was it added?
00001B3E                          1451  
00001B3E  103C 0009               1452  THEEND  MOVE.B  #9,D0
00001B42  4E4F                    1453          TRAP    #15             Halt Simulator        
00001B44                          1454          
00001B44                          1455       
00001B44                          1456  *-----------------------------------------------------------        
00001B44                          1457  * Output stuff
00001B44                          1458  *-----------------------------------------------------------     
00001B44  =0000000D               1459  CR      EQU     $0D             ASCII code for Carriage Return
00001B44  =0000000A               1460  LF      EQU     $0A             ASCII code for Line Feed
00001B44= 2D 2D 2D 2D 2D 2D ...   1461  MESSAGE     DC.B    '-------------------------------------------------------------',CR,LF
00001B83= 7C 7C 20 20 20 20 ...   1462              DC.B    '||               Welcome to ZETA Disassembler              ||',CR,LF
00001BC2= 2D 2D 2D 2D 2D 2D ...   1463              DC.B    '-------------------------------------------------------------',CR,LF
00001C01= 2A 2A 2A 2A 2A 2A ...   1464              DC.B    '*************************************************************',CR,LF
00001C40= 2A 2A 2A 2A 2A 2A ...   1465              DC.B    '*************************************************************',CR,LF
00001C7F= 2A 2A 2A 2A 2A 2A ...   1466              DC.B    '******           ***        ***           ****    ***********',CR,LF
00001CBE= 2A 2A 2A 2A 2A 2A ...   1467              DC.B    '************    ****   ************   *******  **  **********',CR,LF
00001CFD= 2A 2A 2A 2A 2A 2A ...   1468              DC.B    '**********    ******        *******   ******        *********',CR,LF
00001D3C= 2A 2A 2A 2A 2A 2A ...   1469              DC.B    '********    ********   ************   *****   ****   ********',CR,LF
00001D7B= 2A 2A 2A 2A 2A 2A ...   1470              DC.B    '******           ***        *******   ****   ******   *******',CR,LF
00001DBA= 2A 2A 2A 2A 2A 2A ...   1471              DC.B    '*************************************************************',CR,LF
00001DF9= 2A 2A 2A 2A 2A 2A ...   1472              DC.B    '*************************************************************',CR,LF
00001E38= 2A 20 20 20 20 20 ...   1473              DC.B    '*                                                           *',CR,LF
00001E77= 2A 20 41 75 74 68 ...   1474              DC.B    '* Authors: Brandon Roth, Dwayne Honeycutt, Teresia Djunaedi *',CR,LF
00001EB6= 2A 20 20 20 20 20 ...   1475              DC.B    '*                                                           *',CR,LF
00001EF5= 2A 2A 2A 2A 2A 2A ...   1476              DC.B    '*************************************************************',CR,LF,CR,LF
00001F36= 53 74 61 72 74 69 ...   1477              DC.B    'Starting disassembler...',CR,LF,CR,LF,0
00001F53                          1478              
00001F53= 57 6F 75 6C 64 20 ...   1479  STARTASSEM  DC.B    'Would you like to start disassembling the test? ',0
00001F84                          1480  
00001F84= 20 0D 0A                1481  GETSTRTADDR DC.B    ' ',CR,LF
00001F87= 50 6C 65 61 73 65 ...   1482              DC.B    'Please type in your starting address request: ',0
00001FB6                          1483              
00001FB6= 20 0D 0A                1484  GETENDADDR  DC.B    ' ',CR,LF
00001FB9= 50 6C 65 61 73 65 ...   1485              DC.B    'Please type in your ending address request: ',0
00001FE6                          1486              
00001FE6= 20 0D 0A                1487  QUES_CONT   DC.B    ' ',CR,LF
00001FE9= 57 6F 75 6C 64 20 ...   1488              DC.B    'Would you like to continue (Y/N)? ',0
0000200C                          1489              
0000200C= 20 0D 0A                1490  QUIT_MSG    DC.B    ' ',CR,LF
0000200F= 57 6F 75 6C 64 20 ...   1491              DC.B    'Would you like to quit (Y/N)? ',0
0000202E                          1492  
0000202E                          1493  *****************************************************
0000202E                          1494  * I/O storages - assuming users knows what to do.
0000202E                          1495  *****************************************************
0000202E                          1496  CMD_HLD     DS.B    30
0000204C                          1497  CMD_SZ      DS.B    30
0000206A                          1498  STADDR      DS.B    10
00002074                          1499  STADDRSZ    DS.B    10
0000207E                          1500  PROGST      DS.L    1
00002082                          1501  ENDADDR     DS.B    10
0000208C                          1502  ENDADDRSZ   DS.B    10
00002096                          1503  PROGEND     DS.L    1
0000209A                          1504  CONT        DS.B    30
000020B8                          1505  *****************************************************
000020B8                          1506  
000020B8                          1507  *Table for 0-9 && A-F
000020B8= 30 00                   1508  PRNT0   DC.B    '0',0
000020BA= 31 00                   1509  PRNT1   DC.B    '1',0
000020BC= 32 00                   1510  PRNT2   DC.B    '2',0
000020BE= 33 00                   1511  PRNT3   DC.B    '3',0
000020C0= 34 00                   1512  PRNT4   DC.B    '4',0
000020C2= 35 00                   1513  PRNT5   DC.B    '5',0
000020C4= 36 00                   1514  PRNT6   DC.B    '6',0
000020C6= 37 00                   1515  PRNT7   DC.B    '7',0
000020C8= 38 00                   1516  PRNT8   DC.B    '8',0
000020CA= 39 00                   1517  PRNT9   DC.B    '9',0
000020CC= 41 00                   1518  PRNTA   DC.B    'A',0
000020CE= 42 00                   1519  PRNTB   DC.B    'B',0
000020D0= 43 00                   1520  PRNTC   DC.B    'C',0
000020D2= 44 00                   1521  PRNTD   DC.B    'D',0
000020D4= 45 00                   1522  PRNTE   DC.B    'E',0
000020D6= 46 00                   1523  PRNTF   DC.B    'F',0
000020D8                          1524  
000020D8                          1525  *output for all OPCODEs
000020D8= 41 44 44 49 00          1526  ADDI    DC.B    'ADDI',0
000020DD= 41 4E 44 49 00          1527  ANDI    DC.B    'ANDI',0
000020E2= 45 4F 52 49 00          1528  EORI    DC.B    'EORI',0
000020E7= 42 43 48 47 00          1529  BCHG    DC.B    'BCHG',0
000020EC= 43 4D 50 49 00          1530  CMPI    DC.B    'CMPI',0
000020F1                          1531  
000020F1                          1532  *output for the size of the operation
000020F1= 2E 42 20 20 20 20 00    1533  ByteSize    DC.B    '.B    ',0
000020F8= 2E 57 20 20 20 20 00    1534  WordSize    DC.B    '.W    ',0
000020FF= 2E 4C 20 20 20 20 00    1535  LongSize    DC.B    '.L    ',0
00002106                          1536  
00002106                          1537  *output for all destination data registers (0-7)
00002106= 44 30 0D 0A 00          1538  OutDataReg0 DC.B    'D0',CR,LF,0
0000210B= 44 31 0D 0A 00          1539  OutDataReg1 DC.B    'D1',CR,LF,0
00002110= 44 32 0D 0A 00          1540  OutDataReg2 DC.B    'D2',CR,LF,0
00002115= 44 33 0D 0A 00          1541  OutDataReg3 DC.B    'D3',CR,LF,0
0000211A= 44 34 0D 0A 00          1542  OutDataReg4 DC.B    'D4',CR,LF,0
0000211F= 44 35 0D 0A 00          1543  OutDataReg5 DC.B    'D5',CR,LF,0
00002124= 44 36 0D 0A 00          1544  OutDataReg6 DC.B    'D6',CR,LF,0
00002129= 44 37 0D 0A 00          1545  OutDataReg7 DC.B    'D7',CR,LF,0
0000212E                          1546  
0000212E                          1547  *output for all address indirect registers (0-7)
0000212E= 28 41 30 29 0D 0A 00    1548  OutAddrIndReg0  DC.B    '(A0)',CR,LF,0
00002135= 28 41 31 29 0D 0A 00    1549  OutAddrIndReg1  DC.B    '(A1)',CR,LF,0
0000213C= 28 41 32 29 0D 0A 00    1550  OutAddrIndReg2  DC.B    '(A2)',CR,LF,0
00002143= 28 41 33 29 0D 0A 00    1551  OutAddrIndReg3  DC.B    '(A3)',CR,LF,0
0000214A= 28 41 34 29 0D 0A 00    1552  OutAddrIndReg4  DC.B    '(A4)',CR,LF,0
00002151= 28 41 35 29 0D 0A 00    1553  OutAddrIndReg5  DC.B    '(A5)',CR,LF,0
00002158= 28 41 36 29 0D 0A 00    1554  OutAddrIndReg6  DC.B    '(A6)',CR,LF,0
0000215F= 28 41 37 29 0D 0A 00    1555  OutAddrIndReg7  DC.B    '(A7)',CR,LF,0
00002166                          1556  
00002166                          1557  *output for all address indirect post registers (0-7)
00002166= 28 41 30 29 2B 0D ...   1558  OutAddrIndPoReg0    DC.B    '(A0)+',CR,LF,0
0000216E= 28 41 31 29 2B 0D ...   1559  OutAddrIndPoReg1    DC.B    '(A1)+',CR,LF,0
00002176= 28 41 32 29 2B 0D ...   1560  OutAddrIndPoReg2    DC.B    '(A2)+',CR,LF,0
0000217E= 28 41 33 29 2B 0D ...   1561  OutAddrIndPoReg3    DC.B    '(A3)+',CR,LF,0
00002186= 28 41 34 29 2B 0D ...   1562  OutAddrIndPoReg4    DC.B    '(A4)+',CR,LF,0
0000218E= 28 41 35 29 2B 0D ...   1563  OutAddrIndPoReg5    DC.B    '(A5)+',CR,LF,0
00002196= 28 41 36 29 2B 0D ...   1564  OutAddrIndPoReg6    DC.B    '(A6)+',CR,LF,0
0000219E= 28 41 37 29 2B 0D ...   1565  OutAddrIndPoReg7    DC.B    '(A7)+',CR,LF,0
000021A6                          1566  
000021A6                          1567  *output for all address indirect pre registers (0-7)
000021A6= 2D 28 41 30 29 0D ...   1568  OutAddrIndPrReg0    DC.B    '-(A0)',CR,LF,0
000021AE= 2D 28 41 31 29 0D ...   1569  OutAddrIndPrReg1    DC.B    '-(A1)',CR,LF,0
000021B6= 2D 28 41 32 29 0D ...   1570  OutAddrIndPrReg2    DC.B    '-(A2)',CR,LF,0
000021BE= 2D 28 41 33 29 0D ...   1571  OutAddrIndPrReg3    DC.B    '-(A3)',CR,LF,0
000021C6= 2D 28 41 34 29 0D ...   1572  OutAddrIndPrReg4    DC.B    '-(A4)',CR,LF,0
000021CE= 2D 28 41 35 29 0D ...   1573  OutAddrIndPrReg5    DC.B    '-(A5)',CR,LF,0
000021D6= 2D 28 41 36 29 0D ...   1574  OutAddrIndPrReg6    DC.B    '-(A6)',CR,LF,0
000021DE= 2D 28 41 37 29 0D ...   1575  OutAddrIndPrReg7    DC.B    '-(A7)',CR,LF,0
000021E6                          1576  
000021E6                          1577  *output for a tab only (4 spaces)
000021E6= 20 20 20 20 00          1578  Tab DC.B    '    ',0
000021EB                          1579  
000021EB                          1580  *output for a comma only
000021EB= 2C 00                   1581  Comma   DC.B    ',',0
000021ED                          1582  
000021ED                          1583  *output for a new line only
000021ED= 0D 0A 00                1584  NewLine DC.B    CR,LF,0
000021F0                          1585  
000021F0                          1586  *output for a '#$' and '$' only
000021F0= 23 24 00                1587  ShaBang DC.B    '#$',0
000021F3= 24 00                   1588  Bang    DC.B    '$',0
000021F5                          1589  
000021F5                          1590  *current output for error messages
000021F5= 42 41 44 20 45 41 ...   1591  BADEAMSG    DC.B    'BAD EA',CR,LF,0
000021FE= 42 41 44 20 4F 50 ...   1592  BADOPMSG    DC.B    'BAD OP',CR,LF,0
00002207= 49 6D 70 72 6F 70 ...   1593  INV_MSG     DC.B    'Improper command.',CR,LF,0
0000221B= 49 6E 76 61 6C 69 ...   1594  INVSTRTMSG  DC.B    'Invalid start address.',CR,LF,0
00002234= 49 6E 76 61 6C 69 ...   1595  INVENDMSG   DC.B    'Invalid end address.',CR,LF,0
0000224B                          1596  
0000224B                          1597          
0000224B                          1598          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI                20D8
ADDRABSOLUTEMODE    17A4
ADDRDIRECTMODE      1780
ADDRINDIRECTMODE    1780
ADDRINDIRECTPOSTMODE  1790
ADDRINDIRECTPREMODE  179A
ADDRINDPOREG0       1974
ADDRINDPOREG1       1984
ADDRINDPOREG2       1994
ADDRINDPOREG3       19A4
ADDRINDPOREG4       19B4
ADDRINDPOREG5       19C4
ADDRINDPOREG6       19D4
ADDRINDPOREG7       19E4
ADDRINDPRREG0       1A36
ADDRINDPRREG1       1A46
ADDRINDPRREG2       1A56
ADDRINDPRREG3       1A66
ADDRINDPRREG4       1A76
ADDRINDPRREG5       1A86
ADDRINDPRREG6       1A96
ADDRINDPRREG7       1AA6
ADDRINDREG0         18B2
ADDRINDREG1         18C2
ADDRINDREG2         18D2
ADDRINDREG3         18E2
ADDRINDREG4         18F2
ADDRINDREG5         1902
ADDRINDREG6         1912
ADDRINDREG7         1922
ANDI                20DD
ASCIIHEX            1174
ASCIIHEX1           1178
BADEACODE           1B2A
BADEAMSG            21F5
BADOPCODE           1B1A
BADOPMSG            21FE
BANG                21F3
BCHG                20E7
BUCKET0000_BITS     0
BUCKET0001_BITS     1
BUCKET0010_BITS     2
BUCKET0011_BITS     3
BUCKET0100_BITS     4
BUCKET0101_BITS     5
BUCKET0110_BITS     6
BUCKET1000_BITS     8
BUCKET1001_BITS     9
BUCKET1011_BITS     B
BUCKET1100_BITS     C
BUCKET1101_BITS     D
BUCKET1110_BITS     E
BUCKET_0000         1410
BUCKET_0001         16E8
BUCKET_0010         16E8
BUCKET_0011         16E8
BUCKET_0100         16E8
BUCKET_0101         16E8
BUCKET_0110         16E8
BUCKET_1000         16E8
BUCKET_1001         16E8
BUCKET_1011         16E8
BUCKET_1100         16E8
BUCKET_1101         16E8
BUCKET_1110         16E8
BYTESIZE            20F1
BYTESIZEIMMEDIATE   170A
CHECK               11EA
CHECKEND1           10FA
CHECKSTRT1          10E4
CHECK_LOWN          112C
CHECK_LOWY          111A
CHECK_N             13EA
CHECK_UPN           1124
CHECK_UPY           1110
CHECK_Y             13DC
CHNG_SZB            121C
CHNG_SZL            1202
CHNG_SZW            1236
CMD_HLD             202E
CMD_SZ              204C
CMPI                20EC
COMMA               21EB
CONT                209A
CONT_Q              13AA
CONV_LOL            11D4
CONV_LOOP           1250
CONV_NUM            11C0
CONV_UPL            11CA
CR                  D
DATAREG0            17F0
DATAREG1            1800
DATAREG2            1810
DATAREG3            1820
DATAREG4            1830
DATAREG5            1840
DATAREG6            1850
DATAREG7            1860
DATAREGMODE         1770
DONE                1B3A
EA_ADDI             149C
EA_ANDI             1512
EA_BCHG_D           160A
EA_BCHG_S           166C
EA_CMPI             16A8
EA_EORI             1588
ENDADDR             2082
ENDADDRSZ           208C
EORI                20E2
EXITSUB             11E0
EXIT_CONV           12D6
GETENDADDR          1FB6
GETSTRTADDR         1F84
GET_END             108C
GET_STRT            103E
GRAB_NEXT_OP        136C
HEXASCII            11E6
HEXASCIIREG         11FE
IMMEDIATEDATAMODE   17AE
INV2                13FA
INVALID1            1134
INVENDMSG           2234
INVSTRTMSG          221B
INV_END1            1160
INV_MSG             2207
INV_STRT1           114C
IS_ADDI             1466
IS_ANDI             14DC
IS_BCHG_D           15C8
IS_BCHG_S           1656
IS_CMPI             1672
IS_EORI             1552
LF                  A
LONGSIZE            20FF
LONGSIZEABSOLUTE    1AF2
LONGSIZEIMMEDIATE   174E
LOOP_1              1014
LOOP_B              1220
LOOP_L              1206
LOOP_W              123A
MAX_LINE            F
MESSAGE             1B44
NEWLINE             21ED
NUM_0               12E4
NUM_1               12EC
NUM_2               12F4
NUM_3               12FC
NUM_4               1304
NUM_5               130C
NUM_6               1314
NUM_7               131C
NUM_8               1324
NUM_9               132C
NUM_A               1334
NUM_B               133C
NUM_C               1344
NUM_D               134C
NUM_E               1354
NUM_F               135C
OUTADDRINDPOREG0    2166
OUTADDRINDPOREG1    216E
OUTADDRINDPOREG2    2176
OUTADDRINDPOREG3    217E
OUTADDRINDPOREG4    2186
OUTADDRINDPOREG5    218E
OUTADDRINDPOREG6    2196
OUTADDRINDPOREG7    219E
OUTADDRINDPRREG0    21A6
OUTADDRINDPRREG1    21AE
OUTADDRINDPRREG2    21B6
OUTADDRINDPRREG3    21BE
OUTADDRINDPRREG4    21C6
OUTADDRINDPRREG5    21CE
OUTADDRINDPRREG6    21D6
OUTADDRINDPRREG7    21DE
OUTADDRINDREG0      212E
OUTADDRINDREG1      2135
OUTADDRINDREG2      213C
OUTADDRINDREG3      2143
OUTADDRINDREG4      214A
OUTADDRINDREG5      2151
OUTADDRINDREG6      2158
OUTADDRINDREG7      215F
OUTDATAREG0         2106
OUTDATAREG1         210B
OUTDATAREG2         2110
OUTDATAREG3         2115
OUTDATAREG4         211A
OUTDATAREG5         211F
OUTDATAREG6         2124
OUTDATAREG7         2129
PRINT_NUM           12DC
PRNT0               20B8
PRNT1               20BA
PRNT2               20BC
PRNT3               20BE
PRNT4               20C0
PRNT5               20C2
PRNT6               20C4
PRNT7               20C6
PRNT8               20C8
PRNT9               20CA
PRNTA               20CC
PRNTB               20CE
PRNTC               20D0
PRNTD               20D2
PRNTE               20D4
PRNTF               20D6
PROGEND             2096
PROGST              207E
QUES_CONT           1FE6
QUIT_MSG            200C
SHABANG             21F0
STACK               7000
STADDR              206A
STADDRSZ            2074
START               1000
STARTASSEM          1F53
ST_ADDR             7FC6
ST_BAD              11DE
TAB                 21E6
THEEND              1B3E
WORDSIZE            20F8
WORDSIZEABSOLUTE    1ACA
WORDSIZEIMMEDIATE   172C
WRAPPERADDRABSOLUTE  1AB6
WRAPPERADDRABSOLUTEEND  1AC8
WRAPPERADDRINDIRECT  1870
WRAPPERADDRINDIRECTEND  18B0
WRAPPERADDRINDIRECTPOST  1932
WRAPPERADDRINDIRECTPOSTEND  1972
WRAPPERADDRINDIRECTPRE  19F4
WRAPPERADDRINDIRECTPREEND  1A34
WRAPPERDATAREG      17AE
WRAPPERDATAREGEND   17EE
WRAPPERSIZEIMMEDIATE  16EE
WRAPPERSIZEIMMEDIATEEND  1708
